{"name":"css-CSS 盒子模型","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 盒子模型\nCSS 盒子模型(Box Model)\n所有HTML元素可以看作盒子，在CSS中，\"box model\"这一术语是用来设计和布局时使用。\n\nCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。\n\n盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。\n\n下面的图片说明了盒子模型(Box Model)：\n\n\nCSS box-model\n不同部分的说明：\n\nMargin(外边距) - 清除边框外的区域，外边距是透明的。\nBorder(边框) - 围绕在内边距和内容外的边框。\nPadding(内边距) - 清除内容周围的区域，内边距是透明的。\nContent(内容) - 盒子的内容，显示文本和图像。\n为了正确设置元素在所有浏览器中的宽度和高度，你需要知道的盒模型是如何工作的。\n\n元素的宽度和高度\nRemark重要: 当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完整大小的元素，你还必须添加内边距，边框和边距。\n\n下面的例子中的元素的总宽度为300px：\n\n实例\ndiv {\n    width: 300px;\n    border: 25px solid green;\n    padding: 25px;\n    margin: 25px;\n}\n\n尝试一下 »\n让我们自己算算：\n300px (宽)\n+ 50px (左 + 右填充)\n+ 50px (左 + 右边框)\n+ 50px (左 + 右边距)\n= 450px\n\n试想一下，你只有250像素的空间。让我们设置总宽度为250像素的元素:\n\n实例\ndiv {\n    width: 220px;\n    padding: 10px;\n    border: 5px solid gray;\n    margin: 0; \n}\n\n尝试一下 »\n最终元素的总宽度计算公式是这样的：\n\n总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距\n\n元素的总高度最终计算公式是这样的：\n\n总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距\n\n浏览器的兼容性问题\n一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。\n\n虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。\n\nIE8 及更早IE版本不支持设置填充的宽度和边框的宽度属性。\n\n解决IE8及更早版本不兼容问题可以在HTML页面声明 <!DOCTYPE html>即可。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888552133},"updatedAt":{"$$date":1598888958008},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0Drq4HlC24YLXV98"}
{"name":"HTML5 Geolocation（地理定位）","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\nHTML5 Geolocation（地理定位）\nHTML5 Geolocation（地理定位）用于定位用户的位置。\n\n定位用户的位置\nHTML5 Geolocation API 用于获得用户的地理位置。\n\n鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。\n\n浏览器支持\nInternet ExplorerFirefoxOperaGoogle ChromeSafari\n\nInternet Explorer 9+, Firefox, Chrome, Safari 和 Opera 支持Geolocation（地理定位）.\n\n注意: Geolocation（地理定位）对于拥有 GPS 的设备，比如 iPhone，地理定位更加精确。\n\nHTML5 - 使用地理定位\n请使用 getCurrentPosition() 方法来获得用户的位置。\n\n下例是一个简单的地理定位实例，可返回用户位置的经度和纬度:\n\n实例\nvar x=document.getElementById(\"demo\");\nfunction getLocation()\n{\n    if (navigator.geolocation)\n    {\n        navigator.geolocation.getCurrentPosition(showPosition);\n    }\n    else\n    {\n        x.innerHTML=\"该浏览器不支持获取地理位置。\";\n    }\n}\n \nfunction showPosition(position)\n{\n    x.innerHTML=\"纬度: \" + position.coords.latitude + \n    \"<br>经度: \" + position.coords.longitude;    \n}\n\n尝试一下 »\n实例解析:\n\n检测是否支持地理定位\n如果支持，则运行 getCurrentPosition() 方法。如果不支持，则向用户显示一段消息。\n如果 getCurrentPosition() 运行成功，则向参数showPosition中规定的函数返回一个 coordinates 对象\nshowPosition() 函数获得并显示经度和纬度\n上面的例子是一个非常基础的地理定位脚本，不含错误处理。\n\n处理错误和拒绝\ngetCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数：\n\n实例\nfunction showError(error)\n{\n    switch(error.code) \n    {\n        case error.PERMISSION_DENIED:\n            x.innerHTML=\"用户拒绝对获取地理位置的请求。\"\n            break;\n        case error.POSITION_UNAVAILABLE:\n            x.innerHTML=\"位置信息是不可用的。\"\n            break;\n        case error.TIMEOUT:\n            x.innerHTML=\"请求用户地理位置超时。\"\n            break;\n        case error.UNKNOWN_ERROR:\n            x.innerHTML=\"未知错误。\"\n            break;\n    }\n}\n\n尝试一下 »\n错误代码：\n\nPermission denied - 用户不允许地理定位\nPosition unavailable - 无法获取当前位置\nTimeout - 操作超时\n在地图中显示结果\n如需在地图中显示结果，您需要访问可使用经纬度的地图服务，比如谷歌地图或百度地图：\n\n实例\nfunction showPosition(position)\n{\n    var latlon=position.coords.latitude+\",\"+position.coords.longitude;\n \n    var img_url=\"http://maps.googleapis.com/maps/api/staticmap?center=\"\n    +latlon+\"&zoom=14&size=400x300&sensor=false\";\n    document.getElementById(\"mapholder\").innerHTML=\"<img src='\"+img_url+\"'>\";\n}\n\n尝试一下 »\n在上例中，我们使用返回的经纬度数据在谷歌地图中显示位置（使用静态图像）。\n\nGoogle地图脚本\n上面的链接向您演示如何使用脚本来显示带有标记、缩放和拖曳选项的交互式地图。\n\n给定位置的信息\n本页演示的是如何在地图上显示用户的位置。不过，地理定位对于给定位置的信息同样很有用处。\n\n实例:\n\n更新本地信息\n显示用户周围的兴趣点\n交互式车载导航系统 (GPS)\ngetCurrentPosition() 方法 - 返回数据\nT若成功，则 getCurrentPosition() 方法返回对象。始终会返回 latitude、longitude 以及 accuracy 属性。如果可用，则会返回其他下面的属性。\n\n属性\t描述\ncoords.latitude\t十进制数的纬度\ncoords.longitude\t十进制数的经度\ncoords.accuracy\t位置精度\ncoords.altitude\t海拔，海平面以上以米计\ncoords.altitudeAccuracy\t位置的海拔精度\ncoords.heading\t方向，从正北开始以度计\ncoords.speed\t速度，以米/每秒计\ntimestamp\t响应的日期/时间\n\nGeolocation 对象 - 其他有趣的方法\nwatchPosition() - 返回用户的当前位置，并继续返回用户移动时的更新位置（就像汽车上的 GPS）。\n\nclearWatch() - 停止 watchPosition() 方法\n\n下面的例子展示 watchPosition() 方法。您需要一台精确的 GPS 设备来测试该例（比如 iPhone）：\n\n实例\nvar x=document.getElementById(\"demo\");\nfunction getLocation()\n{\n    if (navigator.geolocation)\n    {\n        navigator.geolocation.watchPosition(showPosition);\n    }\n    else\n    {\n        x.innerHTML=\"该浏览器不支持获取地理位置。\";\n    }\n}\nfunction showPosition(position)\n{\n    x.innerHTML=\"纬度: \" + position.coords.latitude + \n    \"<br>经度: \" + position.coords.longitude; \n}\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886963484},"updatedAt":{"$$date":1598887616638},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0K1oUHwjd606Oj72"}
{"name":"kotlin-相等性 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/equality.html\n相等性 - Kotlin 语言中文站\n3-4 minutes\n改进翻译\nKotlin 中有两种类型的相等性：\n\n结构相等（用 equals() 检测）；\n引用相等（两个引用指向同一对象）。\n结构相等由 ==（以及其否定形式 !=）操作判断。按照惯例，像 a == b 这样的表达式会翻译成：\n\na?.equals(b) ?: (b === null)\n也就是说如果 a 不是 null 则调用 equals(Any?) 函数，否则（即 a 是 null）检测 b 是否与 null 引用相等。\n\n请注意，当与 null 显式比较时完全没必要优化你的代码：a == null 会被自动转换为 a === null。\n\n如需提供自定义的相等检测实现，请覆盖 equals(other: Any?): Boolean 函数。名称相同但签名不同的函数，如 equals(other: Foo) 并不会影响操作符 == 与 != 的相等性检测。\n\n结构相等与 Comparable<……> 接口定义的比较无关，因此只有自定义的 equals(Any?) 实现可能会影响该操作符的行为。\n\n当相等性检测的两个操作数都是静态已知的（可空或非空的）Float 或 Double 类型时，该检测遵循 IEEE 754 浮点数运算标准。\n\n否则会使用不符合该标准的结构相等性检测，这会导致 NaN 等于其自身，而 -0.0 不等于 0.0。\n\n参见：浮点数比较。\n\n引用相等由 ===（以及其否定形式 !==）操作判断。a === b 当且仅当 a 与 b 指向同一个对象时求值为 true。对于运行时表示为原生类型的值 （例如 Int），=== 相等检测等价于 == 检测。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386572806},"updatedAt":{"$$date":1597396877128},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0LJsCj3dSGGPzqxZ"}
{"name":"kotlin-kotlin 委托 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-delegated.html\nkotlin 委托 | 菜鸟教程\n7-8 minutes\n委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。\n\nKotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。\n\n类委托\n类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。\n\n以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。\n\n// 创建接口\ninterface Base {   \n    fun print()\n}\n\n// 实现此接口的被委托的类\nclass BaseImpl(val x: Int) : Base {\n    override fun print() { print(x) }\n}\n\n// 通过关键字 by 建立委托类\nclass Derived(b: Base) : Base by b\n\nfun main(args: Array<String>) {\n    val b = BaseImpl(10)\n    Derived(b).print() // 输出 10\n}\n在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。\n\n属性委托\n属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。\n\n属性委托语法格式：\n\nval/var <属性名>: <类型> by <表达式>\nvar/val：属性类型(可变/只读)\n属性名：属性名称\n类型：属性的数据类型\n表达式：委托代理类\nby 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。\n\n定义一个被委托的类\n该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，prop 为进行委托的属性的对象。\n\nimport kotlin.reflect.KProperty\n// 定义包含属性委托的类\nclass Example {\n    var p: String by Delegate()\n}\n\n// 委托的类\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, 这里委托了 ${property.name} 属性\"\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$thisRef 的 ${property.name} 属性赋值为 $value\")\n    }\n}\nfun main(args: Array<String>) {\n    val e = Example()\n    println(e.p)     // 访问该属性，调用 getValue() 函数\n\n    e.p = \"Runoob\"   // 调用 setValue() 函数\n    println(e.p)\n}\n输出结果为：\n\nExample@433c675d, 这里委托了 p 属性\nExample@433c675d 的 p 属性赋值为 Runoob\nExample@433c675d, 这里委托了 p 属性\n标准委托\nKotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。\n\n延迟属性 Lazy\nlazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy <T> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。\n\nval lazyValue: String by lazy {\n    println(\"computed!\")     // 第一次调用输出，第二次调用不执行\n    \"Hello\"\n}\n\nfun main(args: Array<String>) {\n    println(lazyValue)   // 第一次执行，执行两次输出表达式\n    println(lazyValue)   // 第二次执行，只输出返回值\n}\n执行输出结果：\n\ncomputed!\nHello\nHello\n可观察属性 Observable\nobservable 可以用于实现观察者模式。\n\nDelegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。\n\n在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值：\n\nimport kotlin.properties.Delegates\n\nclass User {\n    var name: String by Delegates.observable(\"初始值\") {\n        prop, old, new ->\n        println(\"旧值：$old -> 新值：$new\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val user = User()\n    user.name = \"第一次赋值\"\n    user.name = \"第二次赋值\"\n}\n执行输出结果：\n\n旧值：初始值 -> 新值：第一次赋值\n旧值：第一次赋值 -> 新值：第二次赋值\n把属性储存在映射中\n一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他\"动态\"事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。\n\nclass Site(val map: Map<String, Any?>) {\n    val name: String by map\n    val url: String  by map\n}\n\nfun main(args: Array<String>) {\n    // 构造函数接受一个映射参数\n    val site = Site(mapOf(\n        \"name\" to \"菜鸟教程\",\n        \"url\"  to \"www.runoob.com\"\n    ))\n    \n    // 读取映射值\n    println(site.name)\n    println(site.url)\n}\n执行输出结果：\n\n菜鸟教程\nwww.runoob.com\n如果使用 var 属性，需要把 Map 换成 MutableMap：\n\nclass Site(val map: MutableMap<String, Any?>) {\n    val name: String by map\n    val url: String by map\n}\n\nfun main(args: Array<String>) {\n\n    var map:MutableMap<String, Any?> = mutableMapOf(\n            \"name\" to \"菜鸟教程\",\n            \"url\" to \"www.runoob.com\"\n    )\n\n    val site = Site(map)\n\n    println(site.name)\n    println(site.url)\n\n    println(\"--------------\")\n    map.put(\"name\", \"Google\")\n    map.put(\"url\", \"www.google.com\")\n\n    println(site.name)\n    println(site.url)\n\n}\n执行输出结果：\n\n菜鸟教程\nwww.runoob.com\n--------------\nGoogle\nwww.google.com\nNot Null\nnotNull 适用于那些无法在初始化阶段就确定属性值的场合。\n\nclass Foo {\n    var notNullBar: String by Delegates.notNull<String>()\n}\n\nfoo.notNullBar = \"bar\"\nprintln(foo.notNullBar)\n需要注意，如果属性在赋值前就被访问的话则会抛出异常。\n\n局部委托属性\n你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：\n\nfun example(computeFoo: () -> Foo) {\n    val memoizedFoo by lazy(computeFoo)\n\n    if (someCondition && memoizedFoo.isValid()) {\n        memoizedFoo.doSomething()\n    }\n}\nmemoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。\n\n属性委托要求\n对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数：\n\nthisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型\nproperty —— 必须是类型 KProperty<*> 或其超类型\n这个函数必须返回与属性相同的类型（或其子类型）。\n\n对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数:\n\nproperty —— 必须是类型 KProperty<*> 或其超类型\nnew value —— 必须和属性同类型或者是它的超类型。\n翻译规则\n在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性：\n\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// 这段是由编译器生成的相应代码：\nclass C {\n    private val prop$delegate = MyDelegate()\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\nKotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。\n\n提供委托\n通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。\n\nprovideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。\n\n例如，如果要在绑定之前检查属性名称，可以这样写：\n\nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(\n            thisRef: MyUI,\n            prop: KProperty<*>\n    ): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        // 创建委托\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { …… }\n}\n\nfun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { …… }\n\nclass MyUI {\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\nprovideDelegate 的参数与 getValue 相同：\n\nthisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型\nproperty —— 必须是类型 KProperty<*> 或其超类型。\n在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。\n\n如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：\n\n// 检查属性名称而不使用“provideDelegate”功能\nclass MyUI {\n    val image by bindResource(ResourceID.image_id, \"image\")\n    val text by bindResource(ResourceID.text_id, \"text\")\n}\n\nfun <T> MyUI.bindResource(\n        id: ResourceID<T>,\n        propertyName: String\n): ReadOnlyProperty<MyUI, T> {\n   checkProperty(this, propertyName)\n   // 创建委托\n}\n在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：\n\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// 这段代码是当“provideDelegate”功能可用时\n// 由编译器生成的代码：\nclass C {\n    // 调用“provideDelegate”来创建额外的“delegate”属性\n    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)\n    val prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n}\n请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304152917},"updatedAt":{"$$date":1597305135650},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0SBq9za4zC6ZmCKB"}
{"name":"HTML5 Web SQL 数据库","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\nHTML5 Web SQL 数据库\nWeb SQL 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。\n\n如果你是一个 Web 后端程序员，应该很容易理解 SQL 的操作。\n\n你也可以参考我们的 SQL 教程，了解更多数据库操作知识。\n\nWeb SQL 数据库可以在最新版的 Safari, Chrome 和 Opera 浏览器中工作。\n\n核心方法\n以下是规范中定义的三个核心方法：\n\nopenDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。\ntransaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。\nexecuteSql：这个方法用于执行实际的 SQL 查询。\n打开数据库\n我们可以使用 openDatabase() 方法来打开已存在的数据库，如果数据库不存在，则会创建一个新的数据库，使用代码如下：\n\nvar db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);\nopenDatabase() 方法对应的五个参数说明：\n\n数据库名称\n版本号\n描述文本\n数据库大小\n创建回调\n第五个参数，创建回调会在创建数据库后被调用。\n\n执行查询操作\n执行操作使用 database.transaction() 函数：\n\nvar db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);\ndb.transaction(function (tx) {  \n   tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');\n});\n上面的语句执行后会在 'mydb' 数据库中创建一个名为 LOGS 的表。\n\n插入数据\n在执行上面的创建表语句后，我们可以插入一些数据：\n\nvar db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);\ndb.transaction(function (tx) {\n   tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');\n   tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")');\n   tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');\n});\n我们也可以使用动态值来插入数据：\n\nvar db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);\ndb.transaction(function (tx) {  \n  tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');\n  tx.executeSql('INSERT INTO LOGS (id,log) VALUES (?, ?)', [e_id, e_log]);\n});\n实例中的 e_id 和 e_log 是外部变量，executeSql 会映射数组参数中的每个条目给 \"?\"。\n\n读取数据\n以下实例演示了如何读取数据库中已经存在的数据：\n\nvar db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);\n \ndb.transaction(function (tx) {\n   tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');\n   tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")');\n   tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');\n});\n \ndb.transaction(function (tx) {\n   tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) {\n      var len = results.rows.length, i;\n      msg = \"<p>查询记录条数: \" + len + \"</p>\";\n      document.querySelector('#status').innerHTML +=  msg;\n    \n      for (i = 0; i < len; i++){\n         alert(results.rows.item(i).log );\n      }\n    \n   }, null);\n});\n完整实例\n实例\nvar db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);\nvar msg;\n \ndb.transaction(function (tx) {\n    tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');\n    tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")');\n    tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');\n    msg = '<p>数据表已创建，且插入了两条数据。</p>';\n    document.querySelector('#status').innerHTML =  msg;\n});\n \ndb.transaction(function (tx) {\ntx.executeSql('SELECT * FROM LOGS', [], function (tx, results) {\n    var len = results.rows.length, i;\n    msg = \"<p>查询记录条数: \" + len + \"</p>\";\n    document.querySelector('#status').innerHTML +=  msg;\n \n    for (i = 0; i < len; i++){\n        msg = \"<p><b>\" + results.rows.item(i).log + \"</b></p>\";\n        document.querySelector('#status').innerHTML +=  msg;\n    }\n}, null);\n});\n\n尝试一下 »\n以上实例运行结果如下图所示：\n\n\n\n删除记录\n删除记录使用的格式如下：\n\ndb.transaction(function (tx) {\n    tx.executeSql('DELETE FROM LOGS  WHERE id=1');\n});\n删除指定的数据id也可以是动态的：\n\ndb.transaction(function(tx) {\n    tx.executeSql('DELETE FROM LOGS WHERE id=?', [id]);\n});\n更新记录\n更新记录使用的格式如下：\n\ndb.transaction(function (tx) {\n    tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=2');\n});\n更新指定的数据id也可以是动态的：\n\ndb.transaction(function(tx) {\n    tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=?', [id]);\n});\n完整实例\n实例\nvar db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);\nvar msg;\n \n db.transaction(function (tx) {\n    tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');\n    tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")');\n    tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")');\n    msg = '<p>数据表已创建，且插入了两条数据。</p>';\n    document.querySelector('#status').innerHTML =  msg;\n });\n \n db.transaction(function (tx) {\n      tx.executeSql('DELETE FROM LOGS  WHERE id=1');\n      msg = '<p>删除 id 为 1 的记录。</p>';\n      document.querySelector('#status').innerHTML =  msg;\n });\n \n db.transaction(function (tx) {\n     tx.executeSql('UPDATE LOGS SET log=\\'www.w3cschool.cc\\' WHERE id=2');\n      msg = '<p>更新 id 为 2 的记录。</p>';\n      document.querySelector('#status').innerHTML =  msg;\n });\n \n db.transaction(function (tx) {\n    tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) {\n       var len = results.rows.length, i;\n       msg = \"<p>查询记录条数: \" + len + \"</p>\";\n       document.querySelector('#status').innerHTML +=  msg;\n       \n       for (i = 0; i < len; i++){\n          msg = \"<p><b>\" + results.rows.item(i).log + \"</b></p>\";\n          document.querySelector('#status').innerHTML +=  msg;\n       }\n    }, null);\n });\n\n尝试一下 »\n以上实例运行结果如下图所示：\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887693885},"updatedAt":{"$$date":1598887987095},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0Trchoz34LbDT6pS"}
{"name":"qk-","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598586251481},"updatedAt":{"$$date":1598586251481},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0bR22bXVymkQKDcd"}
{"name":"html-HTML <div> 和<span>","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n HTML 元素被定义为块级元素或内联元素。\n\n块级元素在浏览器显示时，通常会以新行来开始（和结束）。\n\n实例: <h1>, <p>, <ul>, <table>\n\nHTML 内联元素\n内联元素在显示时通常不会以新行开始。\n\n实例: <b>, <td>, <a>, <img>\n\nHTML <div> 元素\nHTML <div> 元素是块级元素，它可用于组合其他 HTML 元素的容器。\n\n<div> 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。\n\n如果与 CSS 一同使用，<div> 元素可用于对大的内容块设置样式属性。\n\n<div> 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 <table> 元素进行文档布局不是表格的正确用法。<table> 元素的作用是显示表格化的数据。\n\nHTML <span> 元素\nHTML <span> 元素是内联元素，可用作文本的容器\n\n<span> 元素也没有特定的含义。\n\n当与 CSS 一同使用时，<span> 元素可用于为部分文本设置样式属性。\n\nHTML 分组标签\n标签\t描述\n<div>\t定义了文档的区域，块级 (block-level)\n<span>\t用来组合文档中的行内元素， 内联元素(inline)\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886129999},"updatedAt":{"$$date":1598886571679},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0zY53jwk214yKG1y"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598521311654},"updatedAt":{"$$date":1598521311654},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"13cRTDN4zZnuZK9p"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598974377101},"updatedAt":{"$$date":1598974377101},"_id":"17QoLRRdJkcC6Cjc"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975698315},"updatedAt":{"$$date":1598975698315},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"1AcUmNKNbooGHGCK"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977488664},"updatedAt":{"$$date":1594977488664},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"1Dr1XzINvSxOuA6u"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975686606},"updatedAt":{"$$date":1598975686606},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"1ErCMM4Rj642dxIl"}
{"name":"CSS2 多媒体类型","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 多媒体查询\nCSS2 多媒体类型\n@media 规则在 CSS2 中有介绍，针对不同媒体类型可以定制不同的样式规则。\n\n例如：你可以针对不同的媒体类型(包括显示器、便携设备、电视机，等等)设置不同的样式规则。\n\n但是这些多媒体类型在很多设备上支持还不够友好。\n\nCSS3 多媒体查询\nCSS3 的多媒体查询继承了 CSS2 多媒体类型的所有思想： 取代了查找设备的类型，CSS3 根据设置自适应显示。\n\n媒体查询可用于检测很多事情，例如：\n\nviewport(视窗) 的宽度与高度\n设备的宽度与高度\n朝向 (智能手机横屏，竖屏) 。\n分辨率\n目前很多针对苹果手机，Android 手机，平板等设备都会使用到多媒体查询。\n\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器的版本号。\n\n属性\t\t\t\t\t\n@media\t21.0\t9.0\t3.5\t4.0\t9.0\n多媒体查询语法\n多媒体查询由多种媒体组成，可以包含一个或多个表达式，表达式根据条件是否成立返回 true 或 false。\n\n@media not|only mediatype and (expressions) {\n    CSS 代码...;\n}\n如果指定的多媒体类型匹配设备类型则查询结果返回 true，文档会在匹配的设备上显示指定样式效果。\n\n除非你使用了 not 或 only 操作符，否则所有的样式会适应在所有设备上显示效果。\n\nnot: not是用来排除掉某些特定的设备的，比如 @media not print（非打印设备）。\n\nonly: 用来定某种特别的媒体类型。对于支持Media Queries的移动设备来说，如果存在only关键字，移动设备的Web浏览器会忽略only关键字并直接根据后面的表达式应用样式文件。对于不支持Media Queries的设备但能够读取Media Type类型的Web浏览器，遇到only关键字时会忽略这个样式文件。\n\nall: 所有设备，这个应该经常看到。\n\n你也可以在不同的媒体上使用不同的样式文件：\n\n<link rel=\"stylesheet\" media=\"mediatype and|not|only (expressions)\" href=\"print.css\">\nCSS3 多媒体类型\n值\t描述\nall\t用于所有多媒体类型设备\nprint\t用于打印机\nscreen\t用于电脑屏幕，平板，智能手机等。\nspeech\t用于屏幕阅读器\n多媒体查询简单实例\n使用多媒体查询可以在指定的设备上使用对应的样式替代原有的样式。\n\n以下实例中在屏幕可视窗口尺寸小于 480 像素的设备上修改背景颜色:\n\n实例\n@media screen and (max-width: 480px) {\n    body {\n        background-color: lightgreen;\n    }\n}\n\n尝试一下 »\n以下实例在屏幕可视窗口尺寸大于 480 像素时将菜单浮动到页面左侧：\n\n实例\n@media screen and (min-width: 480px) {\n    #leftsidebar {width: 200px; float: left;}\n    #main {margin-left:216px;}\n}\n\n尝试一下 »\n以下实例在屏幕可视窗口尺寸小于 600 像素时将 div 元素隐藏：\n\n实例\n@media screen and (max-width: 600px) {\n  div.example {\n    display: none;\n  }\n}\n\n尝试一下 »\nCSS3 @media 参考\n更多多媒体查询内容可以参考 @media 规则\n\n\n\n\n\n\nCSS3 多媒体查询实例\n本章节我们将为大家演示一些多媒体查询实例。\n\n开始之前我们先制作一个电子邮箱的链接列表。HTML 代码如下：\n\n实例 1\n<!DOCTYPE html>\n<html>\n<head>\n<style>\nul {\n    list-style-type: none;\n}\n\nul li a {\n    color: green;\n    text-decoration: none;\n    padding: 3px;\n    display: block;\n}\n</style>\n</head>\n<body>\n\n<ul>\n  <li><a data-email=\"johndoe@example.com\" href=\"mailto:johndoe@example.com\">John Doe</a></li>\n  <li><a data-email=\"marymoe@example.com\" href=\"mailto:marymoe@example.com\">Mary Moe</a></li>\n  <li><a data-email=\"amandapanda@example.com\" href=\"mailto:amandapanda@example.com\">Amanda Panda</a></li>\n</ul>\n\n</body>\n</html>\n\n尝试一下 »\n注意 data-email 属性。在 HTML 中我们可以使用带 data- 前缀的属性来存储信息。\n\n520 到 699px 宽度 - 添加邮箱图标\n当浏览器的宽度在 520 到 699px, 邮箱链接前添加邮件图标：\n\n实例 2\n@media screen and (max-width: 699px) and (min-width: 520px) {\n    ul li a {\n        padding-left: 30px;\n        background: url(email-icon.png) left center no-repeat;\n    }\n}\n\n尝试一下 »\n700 到 1000px - 添加文本前缀信息\n当浏览器的宽度在 700 到 1000px, 会在邮箱链接前添加 \"Email: \":\n\n实例 3\n@media screen and (max-width: 1000px) and (min-width: 700px) {\n    ul li a:before {\n        content: \"Email: \";\n        font-style: italic;\n        color: #666666;\n    }\n}\n\n尝试一下 »\n大于 1001px 宽度 - 添加邮件地址\n当浏览器的宽度大于 1001px 时，会在链接后添加邮件地址接。\n\n我们会使用 data- 属性来为每个人名后添加邮件地址：\n\n实例 4\n@media screen and (min-width: 1001px) {\n    ul li a:after {\n        content: \" (\" attr(data-email) \")\";\n        font-size: 12px;\n        font-style: italic;\n        color: #666666;\n    }\n}\n\n尝试一下 »\n大于 1151px 宽度 - 添加图标\n当浏览器的宽度大于 1001px 时，会在人名前添加图标。\n\n实例中，我们没有编写额外的查询块，我们可以在已有的查询媒体后使用逗号分隔来添加其他媒体查询 (类似 OR 操作符):\n\n实例 5\n@media screen and (max-width: 699px) and (min-width: 520px), (min-width: 1151px) {\n    ul li a {\n        padding-left: 30px;\n        background: url(email-icon.png) left center no-repeat;\n    }\n}\n\n尝试一下 »\n实例\n更多实例\n在一个网页的侧栏上使用邮件列表链接\n该实例在网页的左侧栏添加了邮件链接列表。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975683284},"updatedAt":{"$$date":1598975805355},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"1NhZulDYoKiI5Z04"}
{"name":"ad- View.post()","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n更新 UI 操作\n\n获取 View 的实际宽高\n\n\n\n在 Activity 中，View 绘制流程的开始时机是在 ActivityThread 的 handleResumeActivity 方法，\n在该方法首先完成 Activity 生命周期 onResume 方法回调，然后开始 View 绘制任务。\n\n\n\n\n\n\n\n\n\n注意这里不考虑使用 ViewTreeObserver 或更长延迟的 postDelayed()。\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594980139005},"updatedAt":{"$$date":1594980202597},"_id":"1a1lrWW2FLFJKnPY","folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-ksmp3recorder","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\n//apply plugin: 'com.github.dcendents.android-maven'\n//apply plugin: 'com.jfrog.bintray'\nversion = \"1.0.4\"\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    \n    resourcePrefix \"AndroidMP3RecorderLibrary_\"\t//这个随便填\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n\n\n//        externalNativeBuild {\n//            cmake {\n//                cppFlags \"-fexceptions\"\n//                cFlags \"-DSTDC_HEADERS\"\n//                arguments \"-DANDROID_ARM_NEON=TRUE\"\n//            }\n//        }\n\n\n        ndk {\n            abiFilters 'armeabi-v7a'\n        }\n    }\n\n//    sourceSets.main {\n//        jni.srcDirs = [] // This prevents the auto generation of Android.mk\n//        jniLibs.srcDir 'src/main/libs' // This is not necessary unless you have precompiled libraries in your project.\n//    }\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n            java {\n                srcDirs += []\n            }\n        }\n    }\n    splits {//删除64位的so库\n        abi {\n            enable true\n            reset()\n            include 'armeabi-v7a'\n            universalApk false\n        }\n    }\n\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'\n        }\n    }\n}\n\ndependencies {\n    compileOnly deps.androidx.support_v4\n    compileOnly project(':ksutils')\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\narmeabi-v7a\n    libksmp3lame.so\n\n\n\nLameUtil\nDataEncodeThread\nMP3Recorder\nPCMFormat\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class MP3Recorder {\n\n\tstatic {\n\t\tSystem.loadLibrary(\"ksmp3lame\");\n\t}\n\n\t//=======================AudioRecord Default Settings=======================\n\tprivate static final int DEFAULT_AUDIO_SOURCE = MediaRecorder.AudioSource.MIC;\n\t/**\n\t * 以下三项为默认配置参数。Google Android文档明确表明只有以下3个参数是可以在所有设备上保证支持的。\n\t *\n\t * 单词跟读音频评分，修改参数，原参数441000\n\t */\n\tprivate static final int DEFAULT_SAMPLING_RATE = 16000;//模拟器仅支持从麦克风输入8kHz采样率\n\tprivate static final int DEFAULT_CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO;\n\t/**\n\t * 下面是对此的封装\n\t * private static final int DEFAULT_AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT;\n\t */\n\tprivate static final PCMFormat DEFAULT_AUDIO_FORMAT = PCMFormat.PCM_16BIT;\n\t\n\t//======================Lame Default Settings=====================\n\tprivate static final int DEFAULT_LAME_MP3_QUALITY = 7;\n\t/**\n\t * 与DEFAULT_CHANNEL_CONFIG相关，因为是mono单声，所以是1\n\t */\n\tprivate static final int DEFAULT_LAME_IN_CHANNEL = 1;\n\t/**\n\t *  Encoded bit rate. MP3 file will be encoded with bit rate 32kbps\n\t *  单词跟读音频评分，修改参数，原参数32\n\t */ \n\tprivate static final int DEFAULT_LAME_MP3_BIT_RATE = 16;\n\t\n\t//==================================================================\n\t\n\t/**\n\t * 自定义 每160帧作为一个周期，通知一下需要进行编码\n\t */\n\tprivate static final int FRAME_COUNT = 160;\n\tprivate AudioRecord mAudioRecord = null;\n\tprivate int mBufferSize;\n\tprivate short[] mPCMBuffer;\n\tprivate DataEncodeThread mEncodeThread;\n\tprivate boolean mIsRecording = false;\n\tprivate File mRecordFile;\n\t/**\n\t * Default constructor. Setup recorder with default sampling rate 1 channel,\n\t * 16 bits pcm\n\t * @param recordFile target file\n\t */\n\tpublic MP3Recorder(File recordFile) {\n\t\tmRecordFile = recordFile;\n\t}\n\n\t/**\n\t * Start recording. Create an encoding thread. Start record from this\n\t * thread.\n\t * \n\t * @throws IOException  initAudioRecorder throws\n\t */\n\tpublic void start() throws IOException {\n\t\tif (mIsRecording) {\n\t\t\treturn;\n\t\t}\n\t\tmIsRecording = true; // 提早，防止init或startRecording被多次调用\n\t    initAudioRecorder();\n\t\tmAudioRecord.startRecording();\n\t\tnew Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t//设置线程权限\n\t\t\t\tProcess.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO);\n\t\t\t\twhile (mIsRecording) {\n\t\t\t\t\tint readSize = mAudioRecord.read(mPCMBuffer, 0, mBufferSize);\n\t\t\t\t\tif (readSize > 0) {\n\t\t\t\t\t\tmEncodeThread.addTask(mPCMBuffer, readSize);\n\t\t\t\t\t\tcalculateRealVolume(mPCMBuffer, readSize);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mAudioRecord != null) {\n\t\t\t\t\tLog.d(\"MP3Recorder\", \"run:  auto finish record.\");\n\t\t\t\t\t// release and finalize audioRecord\n\t\t\t\t\tmAudioRecord.stop();\n\t\t\t\t\tmAudioRecord.release();\n\t\t\t\t\tmAudioRecord = null;\n\t\t\t\t\t// stop the encoding thread and try to wait\n\t\t\t\t\t// until the thread finishes its job\n\t\t\t\t\tif (mEncodeThread != null) {\n\t\t\t\t\t\tmEncodeThread.sendStopMessage();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n\t\t\t * 此计算方法来自samsung开发范例\n\t\t\t * \n\t\t\t * @param buffer buffer\n\t\t\t * @param readSize readSize\n\t\t\t */\n\t\t\tprivate void calculateRealVolume(short[] buffer, int readSize) {\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int i = 0; i < readSize; i++) {  \n\t\t\t\t    // 这里没有做运算的优化，为了更加清晰的展示代码  \n\t\t\t\t    sum += buffer[i] * buffer[i]; \n\t\t\t\t} \n\t\t\t\tif (readSize > 0) {\n\t\t\t\t\tdouble amplitude = sum / readSize;\n\t\t\t\t\tmVolume = (int) Math.sqrt(amplitude);\n\t\t\t\t}\n\t\t\t}\n\t\t}.start();\n\t}\n\n\tpublic void release() {\n//\t\tif (mAudioRecord != null) {\n//\t\t\tLog.d(\"MP3Recorder\", \"release audio record.\");\n//\t\t\tmAudioRecord.stop();\n//\t\t\tmAudioRecord.release();\n//\t\t\tmAudioRecord = null;\n//\t\t\t// stop the encoding thread and try to wait\n//\t\t\t// until the thread finishes its job\n//\t\t\tif (mEncodeThread != null) {\n//\t\t\t\tmEncodeThread.sendStopMessage();\n//\t\t\t}\n//\t\t}\n\t}\n\n\tprivate int mVolume;\n\n\t/**\n\t * 获取真实的音量。 [算法来自三星]\n\t * @return 真实音量\n     */\n\tpublic int getRealVolume() {\n\t\treturn mVolume;\n\t}\n\n\t/**\n\t * 获取相对音量。 超过最大值时取最大值。\n\t * @return 音量\n     */\n\tpublic int getVolume(){\n\t\tif (mVolume >= MAX_VOLUME) {\n\t\t\treturn MAX_VOLUME;\n\t\t}\n\t\treturn mVolume;\n\t}\n\tprivate static final int MAX_VOLUME = 2000;\n\n\t/**\n\t * 根据资料假定的最大值。 实测时有时超过此值。\n\t * @return 最大音量值。\n     */\n\tpublic int getMaxVolume(){\n\t\treturn MAX_VOLUME;\n\t}\n\tpublic void stop(){\n\t\tmIsRecording = false;\n\t}\n\tpublic boolean isRecording() {\n\t\treturn mIsRecording;\n\t}\n\t/**\n\t * Initialize audio recorder\n\t */\n\tprivate void initAudioRecorder() throws IOException {\n\t\tmBufferSize = AudioRecord.getMinBufferSize(DEFAULT_SAMPLING_RATE,\n\t\t\t\tDEFAULT_CHANNEL_CONFIG, DEFAULT_AUDIO_FORMAT.getAudioFormat());\n\t\t\n\t\tint bytesPerFrame = DEFAULT_AUDIO_FORMAT.getBytesPerFrame();\n\t\t/* Get number of samples. Calculate the buffer size \n\t\t * (round up to the factor of given frame size) \n\t\t * 使能被整除，方便下面的周期性通知\n\t\t * */\n\t\tint frameSize = mBufferSize / bytesPerFrame;\n\t\tif (frameSize % FRAME_COUNT != 0) {\n\t\t\tframeSize += (FRAME_COUNT - frameSize % FRAME_COUNT);\n\t\t\tmBufferSize = frameSize * bytesPerFrame;\n\t\t}\n\t\t\n\t\t/* Setup audio recorder */\n\t\tmAudioRecord = new AudioRecord(DEFAULT_AUDIO_SOURCE,\n\t\t\t\tDEFAULT_SAMPLING_RATE, DEFAULT_CHANNEL_CONFIG, DEFAULT_AUDIO_FORMAT.getAudioFormat(),\n\t\t\t\tmBufferSize);\n\t\t\n\t\tmPCMBuffer = new short[mBufferSize];\n\t\t/*\n\t\t * Initialize lame buffer\n\t\t * mp3 sampling rate is the same as the recorded pcm sampling rate \n\t\t * The bit rate is 32kbps\n\t\t * \n\t\t */\n\t\tLameUtil.init(DEFAULT_SAMPLING_RATE, DEFAULT_LAME_IN_CHANNEL, DEFAULT_SAMPLING_RATE, DEFAULT_LAME_MP3_BIT_RATE, DEFAULT_LAME_MP3_QUALITY);\n\t\t// Create and run thread used to encode data\n\t\t// The thread will \n\t\tmEncodeThread = new DataEncodeThread(mRecordFile, mBufferSize);\n//\t\tmEncodeThread.start();\n\t\tmAudioRecord.setRecordPositionUpdateListener(mEncodeThread, mEncodeThread.getHandler());\n\t\tmAudioRecord.setPositionNotificationPeriod(FRAME_COUNT);\n\t}\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598519927833},"updatedAt":{"$$date":1598521477682},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"1lRGzxtiv1RjkkUB"}
{"name":"ad-ksframe项目","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\nREADME.md\t\tgradle\t\t\tks_frame_ijkplayer\tks_imageload_glide\napp\t\t\tgradle.properties\tks_frame_net\t\tks_imageload_picasso\nbuild.gradle\t\tgradlew\t\t\tks_frame_ui\t\tscript\nbuildSrc\t\tgradlew.bat\t\tks_imageload_core\tsettings.gradle\nframe_log\t\tks_frame_bsdiffpatcher\tks_imageload_fresco\n\n\n\n\n\ngit clone ssh://yanglichuan@10.0.20.167:29418/KsFrame && scp -p -P 29418 yanglichuan@10.0.20.167:hooks/commit-msg KsFrame/.git/hooks/\n\n\n\nhttp://10.0.20.167/#/admin/projects/KsFrame\n\n\n\nsource ~/.bash_profile \n\n\nadb connect 127.0.0.1:5555\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241223941},"updatedAt":{"$$date":1598515767339},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"1yqbZQiCzl7mkFgZ"}
{"name":"css-CSS Position(定位)","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS Position(定位)\nposition 属性指定了元素的定位类型。\n\nposition 属性的五个值：\n\nstatic\nrelative\nfixed\nabsolute\nsticky\n元素可以使用的顶部，底部，左侧和右侧属性定位。然而，这些属性无法工作，除非是先设定position属性。他们也有不同的工作方式，这取决于定位方法。\n\nstatic 定位\nHTML 元素的默认值，即没有定位，遵循正常的文档流对象。\n\n静态定位的元素不会受到 top, bottom, left, right影响。\n\n实例\ndiv.static {\n    position: static;\n    border: 3px solid #73AD21;\n}\n\n尝试一下 »\nfixed 定位\n元素的位置相对于浏览器窗口是固定位置。\n\n即使窗口是滚动的它也不会移动：\n\n实例\np.pos_fixed\n{\n    position:fixed;\n    top:30px;\n    right:5px;\n}\n\n尝试一下 »\n注意： Fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才能支持。\n\nFixed定位使元素的位置与文档流无关，因此不占据空间。\n\nFixed定位的元素和其他元素重叠。\n\nrelative 定位\n相对定位元素的定位是相对其正常位置。\n\n实例\nh2.pos_left\n{\n    position:relative;\n    left:-20px;\n}\nh2.pos_right\n{\n    position:relative;\n    left:20px;\n}\n\n尝试一下 »\n移动相对定位元素，但它原本所占的空间不会改变。\n\n实例\nh2.pos_top\n{\n    position:relative;\n    top:-50px;\n}\n\n尝试一下 »\n相对定位元素经常被用来作为绝对定位元素的容器块。\n\nabsolute 定位\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>:\n\n实例\nh2\n{\n    position:absolute;\n    left:100px;\n    top:150px;\n}\n\n尝试一下 »\nabsolute 定位使元素的位置与文档流无关，因此不占据空间。\n\nabsolute 定位的元素和其他元素重叠。\n\nsticky 定位\nsticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。\n\nposition: sticky; 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。\n\n它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。\n\n元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n注意: Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。\n\n实例\ndiv.sticky {\n    position: -webkit-sticky; /* Safari */\n    position: sticky;\n    top: 0;\n    background-color: green;\n    border: 2px solid #4CAF50;\n}\n\n尝试一下 »\n重叠的元素\n元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素\n\nz-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）\n\n一个元素可以有正数或负数的堆叠顺序：\n\n实例\nimg\n{\n    position:absolute;\n    left:0px;\n    top:0px;\n    z-index:-1;\n}\n\n尝试一下 »\n具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。\n\n注意： 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面。\n\nExamples\n更多实例\n裁剪元素的外形\n\n此示例演示如何设置元素的外形。该元素被剪裁成这种形状，并显示出来。\n\n如何使用滚动条来显示元素内溢出的内容\n\n这个例子演示了overflow属性创建一个滚动条，当一个元素的内容在指定的区域过大时如何设置以适应。\n\n如何设置浏览器自动溢出处理\n\n这个例子演示了如何设置浏览器来自动处理溢出。\n\n更改光标\n\n这个例子演示了如何改变光标。\n\n所有的CSS定位属性\n\"CSS\" 列中的数字表示哪个CSS(CSS1 或者CSS2)版本定义了该属性。\n\n属性\t说明\t值\tCSS\nbottom\t定义了定位元素下外边距边界与其包含块下边界之间的偏移。\tauto\nlength\n%\ninherit\t2\nclip\t剪辑一个绝对定位的元素\tshape\nauto\ninherit\t2\ncursor\t显示光标移动到指定的类型\turl\nauto\ncrosshair\ndefault\npointer\nmove\ne-resize\nne-resize\nnw-resize\nn-resize\nse-resize\nsw-resize\ns-resize\nw-resize\ntext\nwait\nhelp\t2\nleft\t定义了定位元素左外边距边界与其包含块左边界之间的偏移。\tauto\nlength\n%\ninherit\t2\noverflow\n设置当元素的内容溢出其区域时发生的事情。\tauto\nhidden\nscroll\nvisible\ninherit\t2\noverflow-y\n指定如何处理顶部/底部边缘的内容溢出元素的内容区域\tauto\nhidden\nscroll\nvisible\nno-display\nno-content\t2\noverflow-x\n指定如何处理右边/左边边缘的内容溢出元素的内容区域\tauto\nhidden\nscroll\nvisible\nno-display\nno-content\t2\nposition\t指定元素的定位类型\tabsolute\nfixed\nrelative\nstatic\ninherit\t2\nright\t定义了定位元素右外边距边界与其包含块右边界之间的偏移。\tauto\nlength\n%\ninherit\t2\ntop\t定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。\tauto\nlength\n%\ninherit\t2\nz-index\t设置元素的堆叠顺序\tnumber\nauto\ninherit\t2"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598889115425},"updatedAt":{"$$date":1598973636526},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"23cDvHshtCQzaoYw"}
{"name":"ad-ksinit","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.app_compat\n    implementation deps.kotlin.kotlin_stdlib_jdk\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\nsort\nGraph\nTaskSortUtil\nstat\nTaskStat\nTaskStatBean\ntask\nDispatchRunnable\nITask\nMainTask\nTask\nTaskCallBack\nutils\nDispatcherExecutor\nDispatcherLog\nUtils\nDelayInitDispatcher\nTaskDispatcher\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521315552},"updatedAt":{"$$date":1598522492539},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2Fd9N8CKIjlf9kpP"}
{"name":"css-CSS Id 和 Class","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS Id 和 Class\nid 和 class 选择器\n如果你要在HTML元素中设置CSS样式，你需要在元素中设置\"id\" 和 \"class\"选择器。\n\nid 选择器\nid 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。\n\nHTML元素以id属性来设置id选择器,CSS 中 id 选择器以 \"#\" 来定义。\n\n以下的样式规则应用于元素属性 id=\"para1\":\n\n实例\n#para1\n{\n    text-align:center;\n    color:red;\n}\n\n尝试一下 »\nRemark ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用。\n\nclass 选择器\nclass 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。\n\nclass 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点\".\"号显示：\n\n在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。\n\n实例\n.center {text-align:center;}\n\n尝试一下 »\n你也可以指定特定的HTML元素使用class。\n\n在以下实例中, 所有的 p 元素使用 class=\"center\" 让该元素的文本居中:\n\n实例\np.center {text-align:center;}\n\n尝试一下 »\nRemark 类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888542592},"updatedAt":{"$$date":1598888631293},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2LVL9YdqR38sdapx"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241210789},"updatedAt":{"$$date":1597241210789},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2Ld6PvrG6BGuinmT"}
{"name":"kotlin-Android 上的 Kotlin 协程  |  Android 开发者  |  Android Developers","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /kotlin/coroutines\nAndroid 上的 Kotlin 协程  |  Android 开发者  |  Android Developers\n6-7 minutes\n协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。协程是在版本 1.3 中添加到 Kotlin 的，它基于来自其他语言的既定概念。\n\n在 Android 上，协程有助于管理长时间运行的任务，如果管理不当，这些任务可能会阻塞主线程并导致应用无响应。本主题介绍如何使用 Kotlin 协程解决这些问题，从而让您能够编写出更清晰、更简洁的应用代码。\n\n功能\n协程是我们在 Android 上进行异步编程的推荐解决方案。值得关注的功能包括：\n\n轻量：您可以在单个线程上运行多个协程，因为协程支持挂起，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。\n内存泄露更少：使用结构化并发机制在一个作用域内执行多个操作。\n内置取消支持：取消功能会自动通过正在运行的协程层次结构传播。\nJetpack 集成：许多 Jetpack 库都包含提供全面协程支持的扩展。某些库还提供自己的协程作用域，可供您用于结构化并发。\n示例概览\n根据应用架构指南，本主题中的示例会发出网络请求并将结果返回到主线程，然后应用可以在主线程上向用户显示结果。\n\n具体而言，ViewModel 架构组件会在主线程上调用代码库层，以触发网络请求。本指南介绍了多种使用协程确保主线程畅通的解决方案。\n\nViewModel 包含一组可直接与协程配合使用的 KTX 扩展。这些扩展是 lifecycle-viewmodel-ktx 库，在本指南中有用到。\n\n在后台线程中执行\n如果在主线程上发出网络请求，则主线程会处于等待或阻塞状态，直到收到响应。由于线程处于阻塞状态，因此操作系统无法调用 onDraw()，这会导致应用冻结，并有可能导致弹出“应用无响应”(ANR) 对话框。为了提供更好的用户体验，我们在后台线程上执行此操作。\n\n首先，我们来了解一下 Repository 类，看看它是如何发出网络请求的：\n\nsealed class Result<out R> {\n    data class Success<out T>(val data: T) : Result<T>()\n    data class Error(val exception: Exception) : Result<Nothing>()\n}\n\nclass LoginRepository(private val responseParser: LoginResponseParser) {\n    private const val loginUrl = \"https://example.com/login\"// Function that makes the network request, blocking the current thread\n    fun makeLoginRequest(\n        jsonBody: String\n    ): Result<LoginResponse> {\n        val url = URL(loginUrl)\n        (url.openConnection() as? HttpURLConnection)?.run {\n            requestMethod = \"POST\"\n            setRequestProperty(\"Content-Type\", \"application/json; utf-8\")\n            setRequestProperty(\"Accept\", \"application/json\")\n            doOutput = true\n            outputStream.write(jsonBody.toByteArray())\n            return Result.Success(responseParser.parse(inputStream))\n        }\n        return Result.Error(Exception(\"Cannot open HttpURLConnection\"))\n    }\n}\nmakeLoginRequest 是同步的，并且会阻塞发起调用的线程。为了对网络请求的响应建模，我们创建了自己的 Result 类。\n\nViewModel 会在用户点击（例如，点击按钮）时触发网络请求：\n\nclass LoginViewModel(\n    private val loginRepository: LoginRepository\n): ViewModel() {fun login(username: String, token: String) {\n        val jsonBody = \"{ username: \\\"$username\\\", token: \\\"$token\\\"}\"\n        loginRepository.makeLoginRequest(jsonBody)\n    }\n}\n使用上述代码，LoginViewModel 会在网络请求发出时阻塞界面线程。如需将执行操作移出主线程，最简单的方法是创建一个新的协程，然后在 I/O 线程上执行网络请求：\n\nclass LoginViewModel(\n    private val loginRepository: LoginRepository\n): ViewModel() {fun login(username: String, token: String) {\n        // Create a new coroutine to move the execution off the UI thread\n        viewModelScope.launch(Dispatchers.IO) {\n            val jsonBody = \"{ username: \\\"$username\\\", token: \\\"$token\\\"}\"\n            loginRepository.makeLoginRequest(jsonBody)\n        }\n    }\n}\n下面我们仔细分析一下 login 函数中的协程代码：\n\nviewModelScope 是预定义的 CoroutineScope，包含在 ViewModel KTX 扩展中。请注意，所有协程都必须在一个作用域内运行。一个 CoroutineScope 管理一个或多个相关的协程。\nlaunch 是一个函数，用于创建协程并将其函数主体的执行分派给相应的调度程序。\nDispatchers.IO 指示此协程应在为 I/O 操作预留的线程上执行。\nlogin 函数按以下方式执行：\n\n应用从主线程上的 View 层调用 login 函数。\nlaunch 会创建一个新的协程，并且网络请求在为 I/O 操作预留的线程上独立发出。\n在该协程运行时，login 函数会继续执行，并可能在网络请求完成前返回。请注意，为简单起见，我们暂时忽略掉网络响应。\n由于此协程通过 viewModelScope 启动，因此在 ViewModel 的作用域内执行。如果 ViewModel 因用户离开屏幕而被销毁，则 viewModelScope 会自动取消，且所有运行的协程也会被取消。\n\n前面的示例存在的一个问题是，调用 makeLoginRequest 的任何项都需要记得将执行操作显式移出主线程。下面我们来看看如何修改 Repository 以解决这一问题。\n\n使用协程确保主线程安全\n如果函数不会在主线程上阻止界面更新，我们即将其视为是主线程安全的。makeLoginRequest 函数不是主线程安全的，因为从主线程调用 makeLoginRequest 确实会阻塞界面。可以使用协程库中的 withContext() 函数将协程的执行操作移至其他线程：\n\nclass LoginRepository(...) {\n    ...\n    suspend fun makeLoginRequest(\n        jsonBody: String\n    ): Result<LoginResponse> {// Move the execution of the coroutine to the I/O dispatcher\n        return withContext(Dispatchers.IO) {\n            // Blocking network request code\n        }\n    }\n}\nwithContext(Dispatchers.IO) 将协程的执行操作移至一个 I/O 线程，这样一来，我们的调用函数便是主线程安全的，并且支持根据需要更新界面。\n\nmakeLoginRequest 还会用 suspend 关键字进行标记。Kotlin 利用此关键字强制从协程内调用函数。\n\n在以下示例中，协程是在 LoginViewModel 中创建的。由于 makeLoginRequest 将执行操作移出主线程，login 函数中的协程现在可以在主线程中执行：\n\nclass LoginViewModel(\n    private val loginRepository: LoginRepository\n): ViewModel() {fun login(username: String, token: String) {// Create a new coroutine on the UI thread\n        viewModelScope.launch {\n            val jsonBody = \"{ username: \\\"$username\\\", token: \\\"$token\\\"}\"// Make the network call and suspend execution until it finishes\n            val result = loginRepository.makeLoginRequest(jsonBody)// Display result of the network request to the user\n            when (result) {\n                is Result.Success<LoginResponse> -> // Happy path\n                else -> // Show error in UI\n            }\n        }\n    }\n}\n请注意，此处仍需要协程，因为 makeLoginRequest 是一个 suspend 函数，而所有 suspend 函数都必须在协程中执行。\n\n此代码与前面的 login 示例的不同之处体现在以下几个方面：\n\nlaunch 不接受 Dispatchers.IO 参数。如果您未将 Dispatcher 传递至 launch，则从 viewModelScope 启动的所有协程都会在主线程中运行。\n系统现在会处理网络请求的结果，以显示成功或失败界面。\nlogin 函数现在按以下方式执行：\n\n应用从主线程上的 View 层调用 login() 函数。\nlaunch 创建一个新的协程，以在主线程上发出网络请求，然后该协程开始执行。\n在协程内，调用 loginRepository.makeLoginRequest() 现在会挂起协程的进一步执行操作，直至 makeLoginRequest() 中的 withContext 块结束运行。\nwithContext 块结束运行后，login() 中的协程在主线程上恢复执行操作，并返回网络请求的结果。\n处理异常\n为了处理 Repository 层可能抛出的异常，请使用 Kotlin 对异常的内置支持。在以下示例中，我们使用的是 try-catch 块：\n\nclass LoginViewModel(\n    private val loginRepository: LoginRepository\n): ViewModel() {fun makeLoginRequest(username: String, token: String) {\n        viewModelScope.launch {\n            val jsonBody = \"{ username: \\\"$username\\\", token: \\\"$token\\\"}\"\n            val result = try {\n                loginRepository.makeLoginRequest(jsonBody)\n            } catch(e: Exception) {\n                Result.Error(Exception(\"Network request failed\"))\n            }\n            when (result) {\n                is Result.Success<LoginResponse> -> // Happy path\n                else -> // Show error in UI\n            }\n        }\n    }\n}\n在此示例中，makeLoginRequest() 调用抛出的任何意外异常都会处理为界面错误。\n\n其他协程资源\n如需详细了解 Android 上的协程，请参阅利用 Kotlin 协程提升应用性能。\n\n如需获取更多协程资源，请访问以下链接：\n\n协程概览 (JetBrains)\n您的首个 Kotlin 协程"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397424777},"updatedAt":{"$$date":1597403407118},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2bWo07KhHcTshtTT"}
{"name":"kotlin-构造集合 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/constructing-collections.html\n构造集合 - Kotlin 语言中文站\n11-14 minutes\n改进翻译\n创建集合的最常用方法是使用标准库函数 listOf<T>()、setOf<T>()、mutableListOf<T>()、mutableSetOf<T>()。 如果以逗号分隔的集合元素列表作为参数，编译器会自动检测元素类型。创建空集合时，须明确指定类型。\n\n同样的，Map 也有这样的函数 mapOf() 与 mutableMapOf()。映射的键和值作为 Pair 对象传递（通常使用中缀函数 to 创建）。\n\nval numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n注意，to 符号创建了一个短时存活的 Pair 对象，因此建议仅在性能不重要时才使用它。 为避免过多的内存使用，请使用其他方法。例如，可以创建可写 Map 并使用写入操作填充它。 apply() 函数可以帮助保持初始化流畅。\n\nval numbersMap = mutableMapOf<String, String>().apply { this[\"one\"] = \"1\"; this[\"two\"] = \"2\" }\n还有用于创建没有任何元素的集合的函数：emptyList()、emptySet() 与 emptyMap()。 创建空集合时，应指定集合将包含的元素类型。\n\nval empty = emptyList<String>()\n对于 List，有一个接受 List 的大小与初始化函数的构造函数，该初始化函数根据索引定义元素的值。\n\nfun main() {\n//sampleStart\n    val doubled = List(3, { it * 2 })  // 如果你想操作这个集合，应使用 MutableList\n    println(doubled)\n//sampleEnd\n}\n要创建具体类型的集合，例如 ArrayList 或 LinkedList，可以使用这些类型的构造函数。 类似的构造函数对于 Set 与 Map 的各实现中均有提供。\n\nval linkedList = LinkedList<String>(listOf(\"one\", \"two\", \"three\"))\nval presizedSet = HashSet<Int>(32)\n要创建与现有集合具有相同元素的集合，可以使用复制操作。标准库中的集合复制操作创建了具有相同元素引用的 浅 复制集合。 因此，对集合元素所做的更改会反映在其所有副本中。\n\n在特定时刻通过集合复制函数，例如toList()、toMutableList()、toSet() 等等。创建了集合的快照。 结果是创建了一个具有相同元素的新集合 如果在源集合中添加或删除元素，则不会影响副本。副本也可以独立于源集合进行更改。\n\nfun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val copyList = sourceList.toMutableList()\n    val readOnlyCopyList = sourceList.toList()\n    sourceList.add(4)\n    println(\"Copy size: ${copyList.size}\")   \n    \n    //readOnlyCopyList.add(4)             // 编译异常\n    println(\"Read-only copy size: ${readOnlyCopyList.size}\")\n//sampleEnd\n}\n这些函数还可用于将集合转换为其他类型，例如根据 List 构建 Set，反之亦然。\n\nfun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)    \n    val copySet = sourceList.toMutableSet()\n    copySet.add(3)\n    copySet.add(4)    \n    println(copySet)\n//sampleEnd\n}\n或者，可以创建对同一集合实例的新引用。使用现有集合初始化集合变量时，将创建新引用。 因此，当通过引用更改集合实例时，更改将反映在其所有引用中。\n\nfun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList = sourceList\n    referenceList.add(4)\n    println(\"Source size: ${sourceList.size}\")\n//sampleEnd\n}\n集合的初始化可用于限制其可变性。例如，如果构建了一个 MutableList 的 List 引用，当你试图通过此引用修改集合的时候，编译器会抛出错误。\n\nfun main() {\n//sampleStart \n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList: List<Int> = sourceList\n    //referenceList.add(4)            // 编译错误\n    sourceList.add(4)\n    println(referenceList) // 显示 sourceList 当前状态\n//sampleEnd\n}\n可以通过其他集合各种操作的结果来创建集合。例如，过滤列表会创建与过滤器匹配的新元素列表：\n\nfun main() {\n//sampleStart \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n//sampleEnd\n}\n映射生成转换结果列表：\n\nfun main() {\n//sampleStart \n    val numbers = setOf(1, 2, 3)\n    println(numbers.map { it * 3 })\n    println(numbers.mapIndexed { idx, value -> value * idx })\n//sampleEnd\n}\n关联生成 Map:\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n有关 Kotlin 中集合操作的更多信息，参见集合操作概述."}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308429761},"updatedAt":{"$$date":1597313895931},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2d5vRVNfdNs5MyyU"}
{"name":"qk-ks_lib_address_selector","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 110\n        versionName \"110\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'proguard-rules.pro'\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.appcompat\n    implementation 'androidx.viewpager:viewpager:1.0.0'\n    implementation deps.google_gson\n}\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598584069404},"updatedAt":{"$$date":1598584759904},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2fzh5g29hjuXHbzi"}
{"name":"HTML 字符实体","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\nHTML 字符实体\nHTML 中的预留字符必须被替换为字符实体。\n\n一些在键盘上找不到的字符也可以使用字符实体来替换。\n\nHTML 实体\n在 HTML 中，某些字符是预留的。\n\n在 HTML 中不能使用小于号（<）和大于号（>），这是因为浏览器会误认为它们是标签。\n\n如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 字符实体类似这样：\n\n&entity_name;\n或\n\n&#entity_number;\n如需显示小于号，我们必须这样写：&lt; 或 &#60; 或 &#060;\n\nRemark提示： 使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。\n\n不间断空格(Non-breaking Space)\nHTML 中的常用字符实体是不间断空格(&nbsp;)。\n\n浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 &nbsp; 字符实体。\n\n结合音标符\n发音符号是加到字母上的一个\"glyph(字形)\"。\n\n一些变音符号, 如 尖音符 (  ̀) 和 抑音符 (  ́) 。\n\n变音符号可以出现字母的上面和下面，或者字母里面，或者两个字母间。\n\n变音符号可以与字母、数字字符的组合来使用。\n\n以下是一些实例:\n\n音标符\t字符\tConstruct\t输出结果\n  ̀\ta\ta&#768;\tà\n  ́\ta\ta&#769;\tá\n̂\ta\ta&#770;\tâ\n  ̃\ta\ta&#771;\tã\n  ̀\tO\tO&#768;\tÒ\n  ́\tO\tO&#769;\tÓ\n̂\tO\tO&#770;\tÔ\n  ̃\tO\tO&#771;\tÕ\n\nHTML字符实体\nNote\t\n 实体名称对大小写敏感！\n\n\n显示结果\t描述\t实体名称\t实体编号\n \t空格\t&nbsp;\t&#160;\n<\t小于号\t&lt;\t&#60;\n>\t大于号\t&gt;\t&#62;\n&\t和号\t&amp;\t&#38;\n\"\t引号\t&quot;\t&#34;\n'\t撇号 \t&apos; (IE不支持)\t&#39;\n￠\t分\t&cent;\t&#162;\n£\t镑\t&pound;\t&#163;\n¥\t人民币/日元\t&yen;\t&#165;\n€\t欧元\t&euro;\t&#8364;\n§\t小节\t&sect;\t&#167;\n©\t版权\t&copy;\t&#169;\n®\t注册商标\t&reg;\t&#174;\n™\t商标\t&trade;\t&#8482;\n×\t乘号\t&times;\t&#215;\n÷\t除号\t&divide;\t&#247;\n虽然 html 不区分大小写，但实体字符对大小写敏感。\n\n查看本站完整的HTML实体：请点击 HTML 实体参考手册。\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886141499},"updatedAt":{"$$date":1598886932608},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2gsG2b2tzYaQF6EZ"}
{"name":"kotlin-Kotlin 协程基础课 04.协程原理小探——从包装异步请求为同步说起","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nlilei.pro /2020/03/16/kotlin-coroutines-04/\nKotlin 协程基础课 04.协程原理小探——从包装异步请求为同步说起\n3-4 minutes\n2020-03-16\n\n这是《Kotlin 协程基础课》的第4篇，也是最后一篇文章。\n\n我不在意十年后的自己是什么样子，我在意的是，十年后的我怎么看现在的自己。\n\n协程是强大的工具，通过前面三篇文章我们介绍了什么是协程、如何使用协程、协程里的CoroutineContext到底是个什么玩意儿。本文是《Kotlin协程基础课》系列的最后一篇文章，将从原理上进行简要的介绍。\n\n对Java开发者而言，“回调”是再常见不过的概念了。从各种SDK到我们自己开发的代码，处处充满了回调。某个任务需要长时间执行，同时我们希望能在任务完成时得到通知，在函数参数里加上一个回调对象，用以收取结果，是十分常见的解决方案。\n\n一个回调Demo\n我们假设有个耗时计算任务，sleep指定时间然后返回数值，代码如下。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nfun calcSlowly(inp: Int, callback: CalcTaskCallback<Int>) {\n    try {\n        println(\"calcSlowly inp=$inp in thread: ${Thread.currentThread().name}\")\n        val result = inp * 1000L\n        Thread.sleep(result)\n        callback.onSuccess(result.toInt())\n    } catch (e: Exception) {\n        println(\"Fail to calc\")\n        callback.onFailure(-1, \"Fail\")\n    }\n}\n为了获取计算的结果，我们传入了callback参数，用以接收计算结果，或者异常信息。\n\n调用它的代码样例如下，用一个匿名内部对象接收回调：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nfun execCalcTaskAsync() {\n    Thread(Runnable {\n        calcSlowly(3, object : CalcTaskCallback<Int> {\n            override fun onSuccess(result: Int) {\n                println(\"onSuccess, result=$result, in thread: ${Thread.currentThread().name}\")\n            }\n\n            override fun onFailure(code: Int, msg: String) {\n                println(\"onFailure, code=$code, msg=$msg, in thread: ${Thread.currentThread().name}\")\n            }\n        })\n    }).start()\n}\n这种回调写法在Java中再常见不过了。但是它却有着不小的隐患：\n\n嵌套太多，成为“回调地狱”；\n传入的callback如果是Activity会引起泄露；\n代码阅读起来不直观。\n这几个隐患不详述了，接下来看看在Kotlin中如何将异步回调转换为同步请求。\n\n将异步转化为同步\n通过协程的suspendCoroutine关键字，可以将异步回调转换为同步调用，上例改写方法如下，\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\nsuspend fun calcSlowlySync(inp: Int): Int =\n    suspendCoroutine { cont ->\n        calcSlowly(inp, object: CalcTaskCallback<Int> {\n            override fun onSuccess(result: Int) {\n                cont.resume(result)\n            }\n\n            override fun onFailure(code: Int, msg: String) {\n                cont.resumeWithException(Exception(\"code=$code, msg=$msg\"))\n            }\n        })\n    }\n改写之后，就可以在协程内部愉快地使用这个同步方法进行耗时计算了。\n\n1\n2\n3\n4\nlaunch(Dispatchers.DEFAULT) {\n    val result = calcSlowlySync(100)\n    println(\"result=$result\")\n}\ntodo\n\n原始代码MainCoroutine.kt\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nfun main(args: Array<String>) {\n    runBlocking {\n        val job = GlobalScope.launch {\n            val result = calcSlowly(123)\n            println(\"result = $result\")\n        }\n        job.join()\n    }\n    print(\"FINISH\")\n}\n\n\nprivate suspend fun calcSlowly(inp: Int): Int = withContext(Dispatchers.Default) {\n    delay(1000L)\n    inp * 10\n}\n反编译后生成4个文件\n\nMainCoroutineKt.class，\nMainCoroutineKt$main$1.class\nMainCoroutineKt$main$1$job$1.class\nMainCoroutineKt$calcSlowly$2.class\n异步接口\n转换同步\nsuspendCoroutine\ntodo\n最后更新时间：2020-03-16 23:15:56\n本文系作者原创，如转载请注明出处。欢迎留言讨论，或通过邮件进行沟通～"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597400503790},"updatedAt":{"$$date":1597403194630},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2qwdyRjmJeY3C9ns"}
{"name":"py-数据类型检查可以用内置函数isinstance()实现：","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：\n\ndef my_abs(x):\n    if not isinstance(x, (int, float)):\n        raise TypeError('bad operand type')\n    if x >= 0:\n        return x\n    else:\n        return -x\n添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：\n\n>>> my_abs('A')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 3, in my_abs\nTypeError: bad operand type\n错误和异常处理将在后续讲到。\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973948153},"updatedAt":{"$$date":1594977429216},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"30Dx01Ahdu4KWYBs"}
{"name":"kotlin-使用 withContext 获取耗时任务结果","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n使用 withContext 获取耗时任务结果：定义2个耗时任务，一个2000ms后返回结果，另一个1000ms后返回结果\n\nbtn.setOnClickListener {\n    CoroutineScope(Dispatchers.Main).launch {\n        val time1 = System.currentTimeMillis()\n \n        val task1 = withContext(Dispatchers.IO) {\n            delay(2000)\n            Log.e(\"TAG\", \"1.执行task1.... [当前线程为：${Thread.currentThread().name}]\")\n            \"one\"  //返回结果赋值给task1\n        }\n                \n        val task2 = withContext(Dispatchers.IO) {\n            delay(1000)\n            Log.e(\"TAG\", \"2.执行task2.... [当前线程为：${Thread.currentThread().name}]\")\n            \"two\"  //返回结果赋值给task2\n        }\n \n        Log.e(\"TAG\", \"task1 = $task1  , task2 = $task2 , 耗时 ${System.currentTimeMillis()-time1} ms  [当前线程为：${Thread.currentThread().name}]\")\n    }\n}\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597400504831},"updatedAt":{"$$date":1597403513042},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"31v73tUOUZp2v6uV"}
{"name":"Mac安装软件时提示已损坏的解决方法","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"最新Catalina报错问题汇总\n提示程序含有恶意代码或者已经打开所有来源还是提示扔到垃圾桶\n在终端输入 xattr -r -d com.apple.quarantine 加上程序的App绝对路径，App建议直接拖放到终端，会自动填写路径\n\n如这样：xattr -r -d com.apple.quarantine /Applications/QQ.app\n\n常规报错解决方案一\n2019年7月10号开始，很多TNT破解软件大面积报错，原因不多说，讲一下具体的解决方案\n\n步骤一：\n\n安装xcode，这个在商店里面有，不想安装的，按步骤二来。\n\n步骤二：\n\n安装Command Line Tool 工具\n\n打开终端输入以下命令\n\nxcode-select --install （install前面为两个短横线）\n\n步骤三：\n\n终端继续输入以下命令\n\ncodesign --force --deep --sign - （force、deep、sign前面为两个短横线）\n\n然后拖入需要签名的软件，最后类似于这样\n\ncodesign --force --deep --sign - /Applications/name.app （/Applications前面有一个空格）\n\n回车搞定\n\n常规报错解决方案二\n不想知道原理和偷懒的，安装软件，直接给报错程序签名。\n\n 免费下载 免费下载\n\n常规报错解决方案三\n从本站下载的Sketch、Principle等设计软件，以及输入法等常用软件，安装时总是提示“已损坏，移至废纸篓”这类信息，根本无法打开。如下图：\n\nMac安装软件时提示已损坏的解决方法-麦氪派(WaitsUn.com | 爱情守望者)\n\n其实，这是新系统（macOS Sierra 10.12.X）惹的祸。新系统加强了安全机制，默认不允许用户自行下载安装应用程序，只能从Mac App Store里安装应用。\n\n解决方法\n\n步骤一：打开终端\n\nMac安装软件时提示已损坏的解决方法-麦氪派(WaitsUn.com | 爱情守望者)\n\n步骤二：输入代码：sudo spctl --master-disable（master前面为两个短横线，看下面的截图）\n\nMac安装软件时提示已损坏的解决方法-麦氪派(WaitsUn.com | 爱情守望者)\n\n注意红框处应有空格\n步骤三：按回车输入自己电脑密码，再次回车（密码不会显示出来，放心输就好）\n\nMac安装软件时提示已损坏的解决方法-麦氪派(WaitsUn.com | 爱情守望者)\n\n不显示密码，输完按回车\n\n步骤四：打开系统偏好设置 » 安全性与隐私，若显示任何来源，大功告成；若没有此选项，一定是你前面的步骤不对\n\nMac安装软件时提示已损坏的解决方法-麦氪派(WaitsUn.com | 爱情守望者)\n回到桌面双击安装文件，发现都可以打开啦，尽情享受Mac带给你的乐趣吧！\n\n常规报错解决方案四\n32位程序不兼容，报类似以下的错误\n\nMac安装软件时提示已损坏的解决方法-麦氪派(WaitsUn.com | 爱情守望者)\n\n终端输入\n\ndefaults write -g CSUIDisable32BitWarning -boolean TRUE"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598545366416},"updatedAt":{"$$date":1598545423864},"_id":"37oPQHfmhgxkXtUY","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Untitled snippet","folderId":null,"content":[{"label":"Fragment 1","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594709014765},"updatedAt":{"$$date":1594709014765},"_id":"3BzA1TGqEP2PBtcZ"}
{"name":"ad-ksurirouter","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.app_compat\n    implementation deps.kotlin.kotlin_stdlib_jdk\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class KsUriRouter {\n\n    @SuppressLint(\"StaticFieldLeak\")\n    private static RootUriHandler ROOT_HANDLER;\n\n    private static KsPageDelegate pageDelegate;\n\n    /**\n     * 此初始化方法必须在主线程调用。\n     */\n    public static void init(@NonNull RootUriHandler rootUriHandler, @NonNull KsPageDelegate delegate) {\n        if (!Debugger.isLogSetting()) {\n            Log.w(Debugger.LOG_TAG, \"!!当前未设置Logger,建议通过 Debugger.setLogger()方法设置Logger\");\n            Log.w(Debugger.LOG_TAG, \"!!并在测试环境通过 Debugger.EnableLog(true)方法开启日志\");\n            Log.w(Debugger.LOG_TAG, \"!!通过Debugger.setEnableDebug(true)方法在测试环境及时抛出严重类型异常\");\n        }\n\n        if (Looper.myLooper() != Looper.getMainLooper()) {\n            Debugger.fatal(\"初始化方法init应该在主线程调用\");\n        }\n        if (ROOT_HANDLER == null) {\n            ROOT_HANDLER = rootUriHandler;\n        } else {\n            Debugger.fatal(\"请勿重复初始化UriRouter\");\n        }\n\n        if (pageDelegate == null) {\n            pageDelegate = delegate;\n        } else {\n            Debugger.fatal(\"请勿重复初始化pageDelegate\");\n        }\n    }\n\n    public static KsPageDelegate getPageDelegate() {\n        if (pageDelegate == null) {\n            throw new RuntimeException(\"请先调用init初始化pageDelegate\");\n        }\n        return pageDelegate;\n    }\n\n    public static RootUriHandler getRootHandler() {\n        if (ROOT_HANDLER == null) {\n            throw new RuntimeException(\"请先调用init初始化UriRouter\");\n        }\n        return ROOT_HANDLER;\n    }\n\n    public static void startUri(UriRequest request) {\n        getRootHandler().startUri(request);\n    }\n\n    public static void startUri(Context context, String uri) {\n        getRootHandler().startUri(new UriRequest(context, uri));\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic interface KsPageDelegate {\n    void handlePage(Context context, String page, String params);\n}\n\n\n\n\n\n\n\n\n\n\n\n\npublic class RootUriHandler extends ChainedHandler {\n\n    private final Context mContext;\n    private OnCompleteListener mGlobalOnCompleteListener;\n\n    public RootUriHandler(Context context) {\n        mContext = context.getApplicationContext();\n    }\n\n    public Context getContext() {\n        return mContext;\n    }\n\n    /**\n     * 全局 {@link OnCompleteListener}\n     */\n    public void setGlobalOnCompleteListener(OnCompleteListener listener) {\n        mGlobalOnCompleteListener = listener;\n    }\n\n    /**\n     * 全局 {@link OnCompleteListener}\n     */\n    public OnCompleteListener getGlobalOnCompleteListener() {\n        return mGlobalOnCompleteListener;\n    }\n\n    @Override\n    public RootUriHandler addChildHandler(@NonNull UriHandler handler, int priority) {\n        return (RootUriHandler) super.addChildHandler(handler, priority);\n    }\n\n    @Override\n    public RootUriHandler addChildHandler(@NonNull UriHandler handler) {\n        return addChildHandler(handler, 0);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T extends UriHandler> T findChildHandlerByClass(Class<T> clazz) {\n        for (UriHandler handler : getHandlers()) {\n            if (clazz.isInstance(handler)) {\n                return (T) handler;\n            }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    public void startUri(@NonNull UriRequest request) {\n        if (request == null) {\n\n            String msg = \"UriRequest为空\";\n            Debugger.fatal(msg);\n            UriRequest req = new UriRequest(mContext, Uri.EMPTY).setErrorMessage(msg);\n            onError(req, UriResult.CODE_BAD_REQUEST);\n\n        } else if (request.getContext() == null) {\n\n            String msg = \"UriRequest.Context为空\";\n            Debugger.fatal(msg);\n            UriRequest req = new UriRequest(mContext, request.getUri(), request.getFields())\n                    .setErrorMessage(msg);\n            onError(req, UriResult.CODE_BAD_REQUEST);\n\n        } else if (request.isUriEmpty()) {\n\n            String msg = \"跳转链接为空\";\n            Debugger.e(msg);\n            request.setErrorMessage(msg);\n            onError(request, UriResult.CODE_BAD_REQUEST);\n\n        } else {\n\n            if (Debugger.isEnableLog()) {\n                Debugger.i(\"\");\n                Debugger.i(\"---> receive request: %s\", request.toFullString());\n            }\n            handle(request, new RootUriCallback(request));\n        }\n    }\n\n    private void onSuccess(@NonNull UriRequest request) {\n        OnCompleteListener globalListener = mGlobalOnCompleteListener;\n        if (globalListener != null) {\n            globalListener.onSuccess(request);\n        }\n        final OnCompleteListener listener = request.getOnCompleteListener();\n        if (listener != null) {\n            listener.onSuccess(request);\n        }\n    }\n\n    private void onError(@NonNull UriRequest request, int resultCode) {\n        OnCompleteListener globalListener = mGlobalOnCompleteListener;\n        if (globalListener != null) {\n            globalListener.onError(request, resultCode);\n        }\n        final OnCompleteListener listener = request.getOnCompleteListener();\n        if (listener != null) {\n            listener.onError(request, resultCode);\n        }\n    }\n\n    protected class RootUriCallback implements UriCallback {\n\n        private final UriRequest mRequest;\n\n        public RootUriCallback(UriRequest request) {\n            mRequest = request;\n        }\n\n        @Override\n        public void onNext() {\n            onComplete(CODE_NOT_FOUND);\n        }\n\n        @Override\n        public void onComplete(int resultCode) {\n            switch (resultCode) {\n\n                case CODE_REDIRECT:\n                    // 重定向，重新跳转\n                    Debugger.i(\"<--- redirect, result code = %s\", resultCode);\n                    startUri(mRequest);\n                    break;\n\n                case CODE_SUCCESS:\n                    // 跳转成功\n                    mRequest.putField(UriRequest.FIELD_RESULT_CODE, resultCode);\n                    onSuccess(mRequest);\n                    Debugger.i(\"<--- success, result code = %s\", resultCode);\n                    break;\n\n                default:\n                    // 跳转失败\n                    mRequest.putField(UriRequest.FIELD_RESULT_CODE, resultCode);\n                    onError(mRequest, resultCode);\n                    Debugger.i(\"<--- error, result code = %s\", resultCode);\n                    break;\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class DefaultRootUriHandler extends RootUriHandler {\n\n    public DefaultRootUriHandler(Context context) {\n        this(context, null, null);\n    }\n\n    public DefaultRootUriHandler(Context context, @Nullable String defaultScheme, @Nullable String defaultHost) {\n        super(context);\n        // 按优先级排序，数字越大越先执行\n        // NatvieHandler\n        addChildHandler(new NativeUriHandler(), 300);\n        // RNUriHandler\n        addChildHandler(new RNUriHandler(), 200);\n        // H5UriHandler\n        addChildHandler(new H5UriHandler(), 100);\n        // 添加其他用户自定义Handler...\n\n        // 都没有处理，则尝试使用默认的StartUriHandler直接启动Uri\n        addChildHandler(new StartUriHandler(), -100);\n        // 全局OnCompleteListener，用于输出跳转失败提示信息\n        setGlobalOnCompleteListener(DefaultOnCompleteListener.INSTANCE);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class RNUriHandler extends UriHandler {\n\n    @Override\n    protected boolean shouldHandle(@NonNull UriRequest request) {\n        return request.getUri().getScheme().equals(\"rn\");\n    }\n\n    @Override\n    protected void handleInternal(@NonNull UriRequest request, @NonNull UriCallback callback) {\n        String page = request.getUri().getQueryParameter(\"page\");\n        String pageParams = request.getUri().getQueryParameter(\"pageParams\");\n//        try {\n//            pageParams = URLDecoder.decode(pageParams, \"UTF-8\");\n//        } catch (Exception tE) {\n//            tE.printStackTrace();\n//        }\n        String params = \"\";\n        try {\n            params = new String(Base64InRouter.decode(pageParams));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        if (!TextUtils.isEmpty(page)) {\n            // 默认处理方式，可以抛给业务层自己实现也可以\n            KsUriRouter.getPageDelegate().handlePage(request.getContext(), page, params);\n        } else {\n            callback.onNext();\n        }\n    }\n\n    /**\n     * 跳转Activity后的行为，可以继承覆盖。\n     * 默认行为：跳转成功后结束分发，跳转失败后继续分发给其他Handler。\n     */\n    protected void handleResult(@NonNull UriCallback callback, int resultCode) {\n        if (resultCode == UriResult.CODE_SUCCESS) {\n            callback.onComplete(resultCode);\n        } else {\n            callback.onNext();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"RNUriHandler\";\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class NativeUriHandler extends UriHandler {\n\n    @Override\n    protected boolean shouldHandle(@NonNull UriRequest request) {\n        return request.getUri().getScheme().equals(\"native\");\n    }\n\n    @Override\n    protected void handleInternal(@NonNull UriRequest request, @NonNull UriCallback callback) {\n        String page = request.getUri().getQueryParameter(\"page\");\n        String pageParams = request.getUri().getQueryParameter(\"pageParams\");\n//        try {\n//            pageParams = URLDecoder.decode(pageParams, \"UTF-8\");\n//        } catch (Exception tE) {\n//            tE.printStackTrace();\n//        }\n        String params = \"\";\n        try {\n            params = new String(Base64InRouter.decode(pageParams));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        if (!TextUtils.isEmpty(page)) {\n            // 默认处理方式，可以抛给业务层自己实现也可以\n            KsUriRouter.getPageDelegate().handlePage(request.getContext(), page, params);\n        } else {\n            callback.onNext();\n        }\n    }\n\n    /**\n     * 跳转Activity后的行为，可以继承覆盖。\n     * 默认行为：跳转成功后结束分发，跳转失败后继续分发给其他Handler。\n     */\n    protected void handleResult(@NonNull UriCallback callback, int resultCode) {\n        if (resultCode == UriResult.CODE_SUCCESS) {\n            callback.onComplete(resultCode);\n        } else {\n            callback.onNext();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"NativeUriHandler\";\n    }\n}\n\n\n\n\n\n\n\n\n\npublic class H5UriHandler extends UriHandler {\n\n    @Override\n    protected boolean shouldHandle(@NonNull UriRequest request) {\n        return request.getUri().getScheme().equals(\"h5\");\n    }\n\n    @Override\n    protected void handleInternal(@NonNull UriRequest request, @NonNull UriCallback callback) {\n        String page = request.getUri().getQueryParameter(\"page\");\n        String pageParams = request.getUri().getQueryParameter(\"pageParams\");\n//        try {\n////            pageParams = URLDecoder.decode(pageParams, \"UTF-8\");\n////        } catch (Exception tE) {\n////            tE.printStackTrace();\n////        }\n        String params = \"\";\n        try {\n            params = new String(Base64InRouter.decode(pageParams));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        if (!TextUtils.isEmpty(page)) {\n            // 默认处理方式，可以抛给业务层自己实现也可以\n            KsUriRouter.getPageDelegate().handlePage(request.getContext(), page, params);\n        } else {\n            callback.onNext();\n        }\n    }\n\n    /**\n     * 跳转Activity后的行为，可以继承覆盖。\n     * 默认行为：跳转成功后结束分发，跳转失败后继续分发给其他Handler。\n     */\n    protected void handleResult(@NonNull UriCallback callback, int resultCode) {\n        if (resultCode == UriResult.CODE_SUCCESS) {\n            callback.onComplete(resultCode);\n        } else {\n            callback.onNext();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"H5UriHandler\";\n    }\n}\n\n\n\n\n\n\n\n\n流程：\n\n\nKsUriRouter\n public static void startUri(UriRequest request) {\n        getRootHandler().startUri(request);\n    }\n\n\npublic class DefaultRootUriHandler extends RootUriHandler \n\n    @SuppressWarnings(\"ConstantConditions\")\n    public void startUri(@NonNull UriRequest request) {\n        if (request == null) {\n\n            String msg = \"UriRequest为空\";\n            Debugger.fatal(msg);\n            UriRequest req = new UriRequest(mContext, Uri.EMPTY).setErrorMessage(msg);\n            onError(req, UriResult.CODE_BAD_REQUEST);\n\n        } else if (request.getContext() == null) {\n\n            String msg = \"UriRequest.Context为空\";\n            Debugger.fatal(msg);\n            UriRequest req = new UriRequest(mContext, request.getUri(), request.getFields())\n                    .setErrorMessage(msg);\n            onError(req, UriResult.CODE_BAD_REQUEST);\n\n        } else if (request.isUriEmpty()) {\n\n            String msg = \"跳转链接为空\";\n            Debugger.e(msg);\n            request.setErrorMessage(msg);\n            onError(request, UriResult.CODE_BAD_REQUEST);\n\n        } else {\n\n            if (Debugger.isEnableLog()) {\n                Debugger.i(\"\");\n                Debugger.i(\"---> receive request: %s\", request.toFullString());\n            }\n            handle(request, new RootUriCallback(request));\n        }\n    }\n\n\n\n\n\n\n\n    public void handle(@NonNull final UriRequest request, @NonNull final UriCallback callback) {\n        if (shouldHandle(request)) {\n            Debugger.i(\"%s: handle request %s\", this, request);\n            if (mInterceptor != null && !request.isSkipInterceptors()) {\n                mInterceptor.intercept(request, new UriCallback() {\n                    @Override\n                    public void onNext() {\n                        handleInternal(request, callback);\n                    }\n\n                    @Override\n                    public void onComplete(int result) {\n                        callback.onComplete(result);\n                    }\n                });\n            } else {\n                handleInternal(request, callback);\n            }\n        } else {\n            Debugger.i(\"%s: ignore request %s\", this, request);\n            callback.onNext();\n        }\n    }\n\n\n\n\n\n    protected abstract void handleInternal(@NonNull UriRequest request, @NonNull UriCallback callback);\n\n\n\n\n  @Override\n    protected void handleInternal(@NonNull final UriRequest request, @NonNull final UriCallback callback) {\n        next(mHandlers.iterator(), request, callback);\n    }\n\n    private void next(@NonNull final Iterator<UriHandler> iterator, @NonNull final UriRequest request,\n                      @NonNull final UriCallback callback) {\n        if (iterator.hasNext()) {\n            UriHandler t = iterator.next();\n            t.handle(request, new UriCallback() {\n                @Override\n                public void onNext() {\n                    next(iterator, request, callback);\n                }\n\n                @Override\n                public void onComplete(int resultCode) {\n                    callback.onComplete(resultCode);\n                }\n            });\n        } else {\n            callback.onNext();\n        }\n    }\n\n\n\n\n\n\n\n遍历 看哪个 handler 可以处理 \n if (iterator.hasNext()) {\n            UriHandler t = iterator.next();\n            t.handle(request, new UriCallback() {\n\n\n\b\n\n\n\n这里加入了三个 handler \n\n public DefaultRootUriHandler(Context context, @Nullable String defaultScheme, @Nullable String defaultHost) {\n        super(context);\n        // 按优先级排序，数字越大越先执行\n        // NatvieHandler\n        addChildHandler(new NativeUriHandler(), 300);\n        // RNUriHandler\n        addChildHandler(new RNUriHandler(), 200);\n        // H5UriHandler\n        addChildHandler(new H5UriHandler(), 100);\n        // 添加其他用户自定义Handler...\n\n        // 都没有处理，则尝试使用默认的StartUriHandler直接启动Uri\n        addChildHandler(new StartUriHandler(), -100);\n        // 全局OnCompleteListener，用于输出跳转失败提示信息\n        setGlobalOnCompleteListener(DefaultOnCompleteListener.INSTANCE);\n    }\n\n\n\n\n\n最后得以处理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598519921194},"updatedAt":{"$$date":1598520920340},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"3ePxoJcwZJ7423tZ"}
{"name":"ad-kstoast","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    api fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.app_compat\n\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\nActivityToast\nDovaTN\nDovaToast\nDPriorityQueue\nIToast\nSafelyHandlerWrapper\nSystemTN\nSystemToast\nDToast\nDUtil\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598519922490},"updatedAt":{"$$date":1598521073334},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"3mpjVXmK2gsa0bfb"}
{"name":"ad-ksui-gradle","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    api fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.app_compat\n    implementation deps.androidx.recyclerview_v7\n    compileOnly (deps.androidx.palette) {\n        force = true\n    }\n    implementation deps.kotlin.kotlin_stdlib_jdk\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515783064},"updatedAt":{"$$date":1598517413041},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"3ugU6y5ZGS2g2L5C"}
{"name":"Map 集合的默认值","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"dart","value":"val map = mapOf(\n        \"java\" to 1,\n        \"kotlin\" to 2,\n        \"python\" to 3\n).withDefault { \"?\" }\n\nprintln(map.getValue(\"java\")) // 1\nprintln(map.getValue(\"kotlin\")) // 2\nprintln(map.getValue(\"c++\")) // ?\n\n作者：HiDhl\n链接：https://juejin.im/post/5edfd7c9e51d45789a7f206d\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}],"tags":["aZ7LswF9qbcVtQZT"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594728228648},"updatedAt":{"$$date":1594728387772},"_id":"3xW0ORj8fA0dYEDm","folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"kotlin","_id":"aZ7LswF9qbcVtQZT","text":"kotlin"}]}
{"name":"ad-settings.gradle","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\ninclude ':logintest'\ninclude ':ks_new_player_page'\ninclude ':ks_main_center'//主工程\n\n//业务组件\ninclude ':ks_home_center',              /*儿内*/\n        ':ks_course_center',            /*儿教*/\n        ':ks_mine_center',              /*个人*/\n        ':ks_game_center',              /*游戏*/\n        //':ks_shopping_center',          /*有赞*/\n        ':ks_storymachine_center',      /*故事机*/\n        ':ks_selfbuildecommerce_center',/*实物电商*/\n        ':ks_member_center',            /*会员*/\n        ':ks_live_video_center'         /*直播*/\n\n\n//公共组件\ninclude ':lib_base',               /*网络库*/\n        ':libmedia',              /*播放器*/\n        ':common_res',            /*公共资源*/\n        ':ks_base',               /*公共*/\n        ':ks_provide_center',     /*路由*/\n        ':ks_login_center',       /*登录*/\n        ':ks_message_center',     /*消息*/\n        ':ks_payment_center',     /*支付*/\n        ':ks_permissionrx',\n        ':ks_base_res',\n        ':ks_image_select',\n        ':ks_point_upload'\n\n//依赖\ninclude ':sobotsdk'\ninclude ':ks_lib_down_course'\ninclude ':ks_audio_player'\ninclude ':ks_new_player_page'"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515775698},"updatedAt":{"$$date":1598516776848},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"4NUeM35XGfRf6gQ2"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975693534},"updatedAt":{"$$date":1598975693534},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"4UCMDh5O5jqTYpwO"}
{"name":"html-HTML 颜色名","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\nHTML 颜色名\n目前所有浏览器都支持以下颜色名。\n141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。下表列出了所有颜色的值，包括十六进制值。\n\nRemark 提示: 17标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。点击其中一个颜色名称（或一个十六进制值）就可以查看与不同文字颜色搭配的背景颜色。\n\n按颜色名排序\n按十六进制的值排序\n\n单击一个颜色名或者 16 进制值，就可以查看与不同文字颜色搭配的背景颜色。\n\n颜色名\tHEX\tColor\nAliceBlue \t#F0F8FF\t \nAntiqueWhite \t#FAEBD7\t \nAqua \t#00FFFF\t \nAquamarine \t#7FFFD4\t \nAzure \t#F0FFFF\t \nBeige \t#F5F5DC\t \nBisque \t#FFE4C4\t \nBlack \t#000000\t \nBlanchedAlmond \t#FFEBCD\t \nBlue \t#0000FF\t \nBlueViolet \t#8A2BE2\t \nBrown \t#A52A2A\t \nBurlyWood \t#DEB887\t \nCadetBlue \t#5F9EA0\t \nChartreuse \t#7FFF00\t \nChocolate \t#D2691E\t \nCoral \t#FF7F50\t \nCornflowerBlue \t#6495ED\t \nCornsilk \t#FFF8DC\t \nCrimson \t#DC143C\t \nCyan \t#00FFFF\t \nDarkBlue \t#00008B\t \nDarkCyan \t#008B8B\t \nDarkGoldenRod \t#B8860B\t \nDarkGray \t#A9A9A9\t \nDarkGreen \t#006400\t \nDarkKhaki \t#BDB76B\t \nDarkMagenta \t#8B008B\t \nDarkOliveGreen \t#556B2F\t \nDarkOrange \t#FF8C00\t \nDarkOrchid \t#9932CC\t \nDarkRed \t#8B0000\t \nDarkSalmon \t#E9967A\t \nDarkSeaGreen \t#8FBC8F\t \nDarkSlateBlue \t#483D8B\t \nDarkSlateGray \t#2F4F4F\t \nDarkTurquoise \t#00CED1\t \nDarkViolet \t#9400D3\t \nDeepPink \t#FF1493\t \nDeepSkyBlue \t#00BFFF\t \nDimGray \t#696969\t \nDodgerBlue \t#1E90FF\t \nFireBrick \t#B22222\t \nFloralWhite \t#FFFAF0\t \nForestGreen \t#228B22\t \nFuchsia \t#FF00FF\t \nGainsboro \t#DCDCDC\t \nGhostWhite \t#F8F8FF\t \nGold \t#FFD700\t \nGoldenRod \t#DAA520\t \nGray \t#808080\t \nGreen \t#008000\t \nGreenYellow \t#ADFF2F\t \nHoneyDew \t#F0FFF0\t \nHotPink \t#FF69B4\t \nIndianRed  \t#CD5C5C\t \nIndigo  \t#4B0082\t \nIvory \t#FFFFF0\t \nKhaki \t#F0E68C\t \nLavender \t#E6E6FA\t \nLavenderBlush \t#FFF0F5\t \nLawnGreen \t#7CFC00\t \nLemonChiffon \t#FFFACD\t \nLightBlue \t#ADD8E6\t \nLightCoral \t#F08080\t \nLightCyan \t#E0FFFF\t \nLightGoldenRodYellow \t#FAFAD2\t \nLightGray \t#D3D3D3\t \nLightGreen \t#90EE90\t \nLightPink \t#FFB6C1\t \nLightSalmon \t#FFA07A\t \nLightSeaGreen \t#20B2AA\t \nLightSkyBlue \t#87CEFA\t \nLightSlateGray \t#778899\t \nLightSteelBlue \t#B0C4DE\t \nLightYellow \t#FFFFE0\t \nLime \t#00FF00\t \nLimeGreen \t#32CD32\t \nLinen \t#FAF0E6\t \nMagenta \t#FF00FF\t \nMaroon \t#800000\t \nMediumAquaMarine \t#66CDAA\t \nMediumBlue \t#0000CD\t \nMediumOrchid \t#BA55D3\t \nMediumPurple \t#9370DB\t \nMediumSeaGreen \t#3CB371\t \nMediumSlateBlue \t#7B68EE\t \nMediumSpringGreen \t#00FA9A\t \nMediumTurquoise \t#48D1CC\t \nMediumVioletRed \t#C71585\t \nMidnightBlue \t#191970\t \nMintCream \t#F5FFFA\t \nMistyRose \t#FFE4E1\t \nMoccasin \t#FFE4B5\t \nNavajoWhite \t#FFDEAD\t \nNavy \t#000080\t \nOldLace \t#FDF5E6\t \nOlive \t#808000\t \nOliveDrab \t#6B8E23\t \nOrange \t#FFA500\t \nOrangeRed \t#FF4500\t \nOrchid \t#DA70D6\t \nPaleGoldenRod \t#EEE8AA\t \nPaleGreen \t#98FB98\t \nPaleTurquoise \t#AFEEEE\t \nPaleVioletRed \t#DB7093\t \nPapayaWhip \t#FFEFD5\t \nPeachPuff \t#FFDAB9\t \nPeru \t#CD853F\t \nPink \t#FFC0CB\t \nPlum \t#DDA0DD\t \nPowderBlue \t#B0E0E6\t \nPurple \t#800080\t \nRed \t#FF0000\t \nRosyBrown \t#BC8F8F\t \nRoyalBlue \t#4169E1\t \nSaddleBrown \t#8B4513\t \nSalmon \t#FA8072\t \nSandyBrown \t#F4A460\t \nSeaGreen \t#2E8B57\t \nSeaShell \t#FFF5EE\t \nSienna \t#A0522D\t \nSilver \t#C0C0C0\t \nSkyBlue \t#87CEEB\t \nSlateBlue \t#6A5ACD\t \nSlateGray \t#708090\t \nSnow \t#FFFAFA\t \nSpringGreen \t#00FF7F\t \nSteelBlue \t#4682B4\t \nTan \t#D2B48C\t \nTeal \t#008080\t \nThistle \t#D8BFD8\t \nTomato \t#FF6347\t \nTurquoise \t#40E0D0\t \nViolet \t#EE82EE\t \nWheat \t#F5DEB3\t \nWhite \t#FFFFFF\t \nWhiteSmoke \t#F5F5F5\t \nYellow \t#FFFF00\t \nYellowGreen \t#9ACD32\t \n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886138815},"updatedAt":{"$$date":1598886834966},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"4nGB5wQjuKIvAhZN"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403214082},"updatedAt":{"$$date":1597403214082},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"4wLoISp2H358eaPj"}
{"name":"py-默认参数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：\n\n>>> power(5)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: power() missing 1 required positional argument: 'n'\nPython的错误信息很明确：调用函数power()缺少了一个位置参数n。\n\n这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：\n\ndef power(x, n=2):\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n这样，当我们调用power(5)时，相当于调用power(5, 2)：\n\n>>> power(5)\n25\n>>> power(5, 2)\n25\n而对于n > 2的其他情况，就必须明确地传入n，比如power(5, 3)。\n\n从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：\n\n一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；\n\n二是如何设置默认参数。\n\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n\n使用默认参数有什么好处？最大的好处是能降低调用函数的难度。\n\n举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：\n\ndef enroll(name, gender):\n    print('name:', name)\n    print('gender:', gender)\n这样，调用enroll()函数只需要传入两个参数：\n\n>>> enroll('Sarah', 'F')\nname: Sarah\ngender: F\n如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。\n\n我们可以把年龄和城市设为默认参数：\n\ndef enroll(name, gender, age=6, city='Beijing'):\n    print('name:', name)\n    print('gender:', gender)\n    print('age:', age)\n    print('city:', city)\n这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：\n\n>>> enroll('Sarah', 'F')\nname: Sarah\ngender: F\nage: 6\ncity: Beijing\n只有与默认参数不符的学生才需要提供额外的信息：\n\nenroll('Bob', 'M', 7)\nenroll('Adam', 'M', city='Tianjin')\n可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。\n\n有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。\n\n也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。\n\n默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：\n\n先定义一个函数，传入一个list，添加一个END再返回：\n\ndef add_end(L=[]):\n    L.append('END')\n    return L\n当你正常调用时，结果似乎不错：\n\n>>> add_end([1, 2, 3])\n[1, 2, 3, 'END']\n>>> add_end(['x', 'y', 'z'])\n['x', 'y', 'z', 'END']\n当你使用默认参数调用时，一开始结果也是对的：\n\n>>> add_end()\n['END']\n但是，再次调用add_end()时，结果就不对了：\n\n>>> add_end()\n['END', 'END']\n>>> add_end()\n['END', 'END', 'END']\n很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。\n\n原因解释如下：\n\nPython函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。\n\n 定义默认参数要牢记一点：默认参数必须指向不变对象！\n要修改上面的例子，我们可以用None这个不变对象来实现：\n\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n现在，无论调用多少次，都不会有问题：\n\n>>> add_end()\n['END']\n>>> add_end()\n['END']\n为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973950809},"updatedAt":{"$$date":1594977537350},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"58crdKwfbpxQQPeD"}
{"name":"ad-ks_media_picker","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n    implementation deps.androidx.app_compat\n    implementation deps.androidx.recyclerview_v7\n    implementation deps.androidx.constraint_layout\n    if(rootProject.ext.isUseMediaModle) {\n        implementation project(':ks_media_core')\n    }else {\n        implementation ks.mediacore\n    }\n\n}\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522805153},"updatedAt":{"$$date":1598525682200},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5BDMMfJOSXjTM6ZN"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977493221},"updatedAt":{"$$date":1594977493221},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5BMyTbMqsTXyvdAl"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973274642},"updatedAt":{"$$date":1594973274642},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5C70cNT3wii5VvPv"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973280314},"updatedAt":{"$$date":1594973280314},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5EWJzywYU0NXERDq"}
{"name":"kotlin-使用 Kotlin 进行 Android 开发","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"www.kotlincn.net /docs/reference/android-overview.html\nKotlin 用于 Android 开发 - Kotlin 语言中文站\n4-4 minutes\n改进翻译\n自 2019 年 Google I/O 以来，Kotlin 就成为了 Android 移动开发的首选。\n\n使用 Kotlin 进行 Android 开发，可以受益于：\n\n代码更少、可读性更强。花更少的时间来编写代码与理解他人的代码。\n成熟的语言与环境。自 2011 年创建以来，Kotlin 不仅通过语言而且通过强大的工具在整个生态系统中不断发展。 现在，它已无缝集成到 Android Studio 中， 并被许多公司积极用于开发 Android 应用程序。\nAndroid Jetpack 与其他库中的 Kotlin 支持。KTX 扩展 为现有的 Android 库添加了 Kotlin 语言特性，如协程、扩展函数、lambdas 与命名参数。\n与 Java 的互操作性。可以在应用程序中将 Kotlin 与 Java 编程语言一起使用， 而无需将所有代码迁移到 Kotlin。\n支持多平台开发。不仅可以使用 Kotlin 开发 Android，还可以开发 iOS、后端与 Web 应用程序。 享受在平台之间共享公共代码的好处。\n代码安全。更少的代码与更好的可读性导致更少的错误。Kotlin 编译器检测这些剩余的错误，从而使代码安全。\n易学易用。Kotlin 非常易于学习，尤其是对于 Java 开发人员而言。\n大社区。Kotlin 得到了社区的大力支持与许多贡献，该社区在全世界范围内都在增长。 根据 Google 的说法，Play 商店前 1000 个应用中有 60％ 以上使用 Kotlin。\n许多初创公司与财富 500 强公司已经使用 Kotlin 开发了 Android 应用程序——详情请见面向 Kotlin 开发者的谷歌网站。\n\n如果想开始使用 Kotlin 进行 Android 开发，请参阅在 Android 开发中开始使用 Kotlin。\n\n如果是 Android 的新手，并且想学习使用 Kotlin 创建应用程序，请查看这门 Udacity 课程。\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304156407},"updatedAt":{"$$date":1597305702236},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5GQuwtnCFQFHlbnw"}
{"name":"html-HTML 表格","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"HTML 表格\nHTML 表格实例:\nFirst Name\tLast Name\tPoints\nJill\tSmith\t50\nEve\tJackson\t94\nJohn\tDoe\t80\nAdam\tJohnson\t67\n\nExamples\n在线实例\n表格\n这个例子演示如何在 HTML 文档中创建表格。\n\n（可以在本页底端找到更多实例。）\n\nHTML 表格\n表格由 <table> 标签来定义。每个表格均有若干行（由 <tr> 标签定义），每行被分割为若干单元格（由 <td> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。\n\n表格实例\n实例\n<table border=\"1\">\n    <tr>\n        <td>row 1, cell 1</td>\n        <td>row 1, cell 2</td>\n    </tr>\n    <tr>\n        <td>row 2, cell 1</td>\n        <td>row 2, cell 2</td>\n    </tr>\n</table>\n在浏览器显示如下：:\n\n\n\nHTML 表格和边框属性\n如果不定义边框属性，表格将不显示边框。有时这很有用，但是大多数时候，我们希望显示边框。\n\n使用边框属性来显示一个带有边框的表格：\n\n实例\n<table border=\"1\">\n    <tr>\n        <td>Row 1, cell 1</td>\n        <td>Row 1, cell 2</td>\n    </tr>\n</table>\nHTML 表格表头\n表格的表头使用 <th> 标签进行定义。\n\n大多数浏览器会把表头显示为粗体居中的文本：\n\n实例\n<table border=\"1\">\n    <tr>\n        <th>Header 1</th>\n        <th>Header 2</th>\n    </tr>\n    <tr>\n        <td>row 1, cell 1</td>\n        <td>row 1, cell 2</td>\n    </tr>\n    <tr>\n        <td>row 2, cell 1</td>\n        <td>row 2, cell 2</td>\n    </tr>\n</table>\n在浏览器显示如下：\n\n\n\n\nExamples\n更多实例\n没有边框的表格\n本例演示一个没有边框的表格。\n\n表格中的表头(Heading)\n本例演示如何显示表格表头。\n\n带有标题的表格\n本例演示一个带标题 (caption) 的表格\n\n跨行或跨列的表格单元格\n本例演示如何定义跨行或跨列的表格单元格。\n\n表格内的标签\n本例演示如何在不同的元素内显示元素。\n\n单元格边距(Cell padding)\n本例演示如何使用 Cell padding 来创建单元格内容与其边框之间的空白。\n\n单元格间距(Cell spacing)\n本例演示如何使用 Cell spacing 增加单元格之间的距离。\n\n漂亮的表格\n\nHTML 表格标签\n标签\t描述\n<table>\t定义表格\n<th>\t定义表格的表头\n<tr>\t定义表格的行\n<td>\t定义表格单元\n<caption>\t定义表格标题\n<colgroup>\t定义表格列的组\n<col>\t定义用于表格列的属性\n<thead>\t定义表格的页眉\n<tbody>\t定义表格的主体\n<tfoot>\t定义表格的页脚\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886124910},"updatedAt":{"$$date":1598886461765},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5bgYDcrzYfukthGp"}
{"name":"App各环境域名","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"凯叔讲故事\n开发\n测试\nGama\n正式\n故事通用\nhttps://dapi.kaishustory.com\nhttps://tapi.kaishustory.com\nhttps://gapi.kaishustory.com\nhttps://api.kaishustory.com\n电商通用\nhttps://dmapi.kaishustory.com/mall\nhttps://tmapi.kaishustory.com/mall\nhttps://gmapi.kaishustory.com/mall\nhttps://mapi.kaishustory.com/mall\n大数据上报\nhttps://dbdplog.kaishustory.com\nhttps://tbdplog.kaishustory.com\nhttps://gbdplog.kaishustory.com\nhttps://bdplog.kaishustory.com\n短域名\nhttps://t.ksjgs.com/t/\nhttps://g.ksjgs.com/g\nhttps://ksjgs.com/\ncdn域名：\n1. tcdn.kaishustory.com  dev+test\n2. cdn.kaishuhezi.com   gamma+prod\n凯叔语文\n开发\n测试\nGama\n正式\n语文通用\nhttps://dyuwen.kaishustory.com\nhttps://tyuwen.kaishustory.com\nhttps://gyuwen.kaishustory.com\nhttps://yuwen.kaishustory.com\n大数据上报\nhttps://ddyw-bdplog.kaishustory.com\nhttps://tdyw-bdplog.kaishustory.com\nhttps://gdyw-bdplog.kaishustory.com\nhttps://dyw-bdplog.kaishustory.com\n通用接口\nhttps://dapi.kaishustory.com\nhttps://tapi.kaishustory.com\nhttps://gapi.kaishustory.com\nhttps://api.kaishustory.com\n短域名\nhttps://t.ksjgs.com/t\nhttps://g.ksjgs.com/g\nhttps://ksjgs.com\ncdn域名：\n1. tyuwencdn.kaishustory.com  dev+test\n2. yuwencdn.kaishustory.com   gamma+prod\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598545443957},"updatedAt":{"$$date":1598545727273},"_id":"5bo5WEvO6sdXc3dk","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Nexus Docker","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"Nexus Docker 的搭建步骤 和 注意事项\n//  创建持久化目录，备份nexus\nmkdir /usr/local/nexus3 && chown -R 200 /usr/local/nexus3\n//  启动对应容器+ 备份目录+ 配置内存\ndocker run -d\n-p 8081:8081\n--name nexus\n-v /usr/local/nexus3:/nexus-data\n-e INSTALL4J_ADD_VM_PARAMS=\"-Xms1g -Xmx1g -XX:MaxDirectMemorySize=3g\" \\\nsonatype/nexus3:3.12.0\n//注意,第一次启动,不能人为的去停止,如果停止了,需要清空 <持久数据存储目录>; 如果没有报错的话,那么恭喜你,在重新启动一下就成功了\ndocker restart nexus\n创建对应目录，,Mac 模拟 部署服务器\n// Docker 创建目录(推荐方式)\n$ docker volume create --name nexus-data\n// 开机启动+镜像挂载+版本指定+容器命名\n$ docker run -d -p 8081:8081 --name nexus --restart=always -v nexus-data:/nexus-data sonatype/nexus3:3.12.0\n// 自己创建目录\n$ mkdir /some/dir/nexus-data && chown -R 200 /some/dir/nexus-data\n$ docker run -d -p 8081:8081 --name nexus -v /some/dir/nexus-data:/nexus-data sonatype/nexus3\n内网部署 Docker 私有库\n安全备份测试：\n✅ 重启Docker 后是否容器自动重启（—restart 是否重启）\n✅删除容器后 docker 的数据是否还能正常使用\nDocker 的基本使用\nDocker 主要分为 镜像和容器的概念：\n// 查看镜像\ndocker images\n// 查看容器\ndocker ps \n// 查看所有容器\ndocker ps -a\n// 拉取镜像\ndocke pull xxx"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598544163016},"updatedAt":{"$$date":1598544465947},"_id":"5sSm0FNuZ60Ln3hM","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-ksrclayout","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion  build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n}\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\nRCAttrs\nRCHelper\nRCImageView\nRCRelativeLayout\n\n\n\n\n\n\n\npublic class RCHelper {\n    public float[] radii = new float[8];   // top-left, top-right, bottom-right, bottom-left\n    public Path mClipPath;                 // 剪裁区域路径\n    public Paint mPaint;                   // 画笔\n    public boolean mRoundAsCircle = false; // 圆形\n    public int mDefaultStrokeColor;        // 默认描边颜色\n    public int mStrokeColor;               // 描边颜色\n    public ColorStateList mStrokeColorStateList;// 描边颜色的状态\n    public int mStrokeWidth;               // 描边半径\n    public boolean mClipBackground;        // 是否剪裁背景\n    public Region mAreaRegion;             // 内容区域\n    public int mEdgeFix = 10;              // 边缘修复\n    public RectF mLayer;                   // 画布图层大小\n\n    public void initAttrs(Context context, AttributeSet attrs) {\n        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.RCAttrs);\n        mRoundAsCircle = ta.getBoolean(R.styleable.RCAttrs_round_as_circle, false);\n        mStrokeColorStateList = ta.getColorStateList(R.styleable.RCAttrs_stroke_color);\n        if (null != mStrokeColorStateList) {\n            mStrokeColor = mStrokeColorStateList.getDefaultColor();\n            mDefaultStrokeColor = mStrokeColorStateList.getDefaultColor();\n        } else {\n            mStrokeColor = Color.WHITE;\n            mDefaultStrokeColor = Color.WHITE;\n        }\n        mStrokeWidth = ta.getDimensionPixelSize(R.styleable.RCAttrs_stroke_width, 0);\n        mClipBackground = ta.getBoolean(R.styleable.RCAttrs_clip_background, false);\n        int roundCorner = ta.getDimensionPixelSize(R.styleable.RCAttrs_round_corner, 0);\n        int roundCornerTopLeft = ta.getDimensionPixelSize(\n                R.styleable.RCAttrs_round_corner_top_left, roundCorner);\n        int roundCornerTopRight = ta.getDimensionPixelSize(\n                R.styleable.RCAttrs_round_corner_top_right, roundCorner);\n        int roundCornerBottomLeft = ta.getDimensionPixelSize(\n                R.styleable.RCAttrs_round_corner_bottom_left, roundCorner);\n        int roundCornerBottomRight = ta.getDimensionPixelSize(\n                R.styleable.RCAttrs_round_corner_bottom_right, roundCorner);\n        ta.recycle();\n\n        radii[0] = roundCornerTopLeft;\n        radii[1] = roundCornerTopLeft;\n\n        radii[2] = roundCornerTopRight;\n        radii[3] = roundCornerTopRight;\n\n        radii[4] = roundCornerBottomRight;\n        radii[5] = roundCornerBottomRight;\n\n        radii[6] = roundCornerBottomLeft;\n        radii[7] = roundCornerBottomLeft;\n\n        mLayer = new RectF();\n        mClipPath = new Path();\n        mAreaRegion = new Region();\n        mPaint = new Paint();\n        mPaint.setColor(Color.WHITE);\n        mPaint.setAntiAlias(true);\n    }\n\n    public void onSizeChanged(View view, int w, int h) {\n        mLayer.set(0, 0, w, h);\n        refreshRegion(view);\n    }\n\n    public void refreshRegion(View view) {\n        int w = (int) mLayer.width();\n        int h = (int) mLayer.height();\n        RectF areas = new RectF();\n        areas.left = view.getPaddingLeft();\n        areas.top = view.getPaddingTop();\n        areas.right = w - view.getPaddingRight();\n        areas.bottom = h - view.getPaddingBottom();\n        mClipPath.reset();\n        if (mRoundAsCircle) {\n            float d = areas.width() >= areas.height() ? areas.height() : areas.width();\n            float r = d / 2;\n            PointF center = new PointF(w / 2, h / 2);\n            mClipPath.addCircle(center.x, center.y, r, Path.Direction.CW);\n        } else {\n            mClipPath.addRoundRect(areas, radii, Path.Direction.CW);\n        }\n        mClipPath.moveTo(-mEdgeFix, -mEdgeFix);  // 通过空操作让Path区域占满画布\n        mClipPath.moveTo(w + mEdgeFix, h + mEdgeFix);\n        Region clip = new Region((int) areas.left, (int) areas.top,\n                (int) areas.right, (int) areas.bottom);\n        mAreaRegion.setPath(mClipPath, clip);\n    }\n\n    public void onClipDraw(Canvas canvas) {\n        if (mStrokeWidth > 0) {\n            // 支持半透明描边，将与描边区域重叠的内容裁剪掉\n            mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));\n            mPaint.setColor(Color.WHITE);\n            mPaint.setStrokeWidth(mStrokeWidth * 2);\n            mPaint.setStyle(Paint.Style.STROKE);\n            canvas.drawPath(mClipPath, mPaint);\n            // 绘制描边\n            mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER));\n            mPaint.setColor(mStrokeColor);\n            mPaint.setStyle(Paint.Style.STROKE);\n            canvas.drawPath(mClipPath, mPaint);\n        }\n        mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n        mPaint.setColor(Color.WHITE);\n        mPaint.setStyle(Paint.Style.FILL);\n        canvas.drawPath(mClipPath, mPaint);\n    }\n\n\n    //--- Selector 支持 ----------------------------------------------------------------------------\n\n    public boolean mChecked;              // 是否是 check 状态\n    public OnCheckedChangeListener mOnCheckedChangeListener;\n\n    public void drawableStateChanged(View view) {\n        if (view instanceof RCAttrs) {\n            ArrayList<Integer> stateListArray = new ArrayList<>();\n            if (view instanceof Checkable) {\n                stateListArray.add(android.R.attr.state_checkable);\n                if (((Checkable) view).isChecked())\n                    stateListArray.add(android.R.attr.state_checked);\n            }\n            if (view.isEnabled()) stateListArray.add(android.R.attr.state_enabled);\n            if (view.isFocused()) stateListArray.add(android.R.attr.state_focused);\n            if (view.isPressed()) stateListArray.add(android.R.attr.state_pressed);\n            if (view.isHovered()) stateListArray.add(android.R.attr.state_hovered);\n            if (view.isSelected()) stateListArray.add(android.R.attr.state_selected);\n            if (view.isActivated()) stateListArray.add(android.R.attr.state_activated);\n            if (view.hasWindowFocus()) stateListArray.add(android.R.attr.state_window_focused);\n\n            if (mStrokeColorStateList != null && mStrokeColorStateList.isStateful()) {\n                int[] stateList = new int[stateListArray.size()];\n                for (int i = 0; i < stateListArray.size(); i++) {\n                    stateList[i] = stateListArray.get(i);\n                }\n                int stateColor = mStrokeColorStateList.getColorForState(stateList, mDefaultStrokeColor);\n                ((RCAttrs) view).setStrokeColor(stateColor);\n            }\n        }\n    }\n\n    public interface OnCheckedChangeListener {\n        void onCheckedChanged(View view, boolean isChecked);\n    }\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598519925664},"updatedAt":{"$$date":1598521239968},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5vrT00EH1zlKOdxe"}
{"name":"CSS3 边框","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 边框\nCSS3 边框\n用 CSS3，你可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序，如 Photoshop。\n\n在本章中，您将了解以下的边框属性：\n\nborder-radius\nbox-shadow\nborder-image\nCSS3 圆角\n在 CSS2 中添加圆角棘手。我们不得不在每个角落使用不同的图像。\n\n在 CSS3 中，很容易创建圆角。\n\n在 CSS3 中 border-radius 属性被用于创建圆角：\n\n这是圆角边框！\n\n实例\n在div中添加圆角元素：\n\ndiv\n{\nborder:2px solid;\nborder-radius:25px;\n}\n\n尝试一下 »\n\nCSS3 盒阴影\nCSS3 中的 box-shadow 属性被用来添加阴影:\n\n\n实例\n在div中添加box-shadow属性\n\ndiv\n{\nbox-shadow: 10px 10px 5px #888888;\n}\n\n尝试一下 »\n\nCSS3 边界图片\n有了 CSS3 的 border-image 属性，你可以使用图像创建一个边框：\n\nborder-image 属性允许你指定一个图片作为边框！ 用于创建上文边框的原始图像：\n在 div 中使用图片创建边框:\n\nBorder\n\n实例\n在 div 中使用图片创建边框\n\ndiv\n{\nborder-image:url(border.png) 30 30 round;\n-webkit-border-image:url(border.png) 30 30 round; /* Safari 5 and older */\n-o-border-image:url(border.png) 30 30 round; /* Opera */\n}\n\n尝试一下 »\n\n新边框属性\n属性\t说明\tCSS\nborder-image\t设置所有边框图像的速记属性。\t3\nborder-radius\t一个用于设置所有四个边框- *-半径属性的速记属性\t3\nbox-shadow\t附加一个或多个下拉框的阴影\t"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974608002},"updatedAt":{"$$date":1598974692769},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"68ahpXUelwaepE0T"}
{"name":"java-使用StampedLock","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"前面介绍的ReadWriteLock可以解决多线程同时读，但只有一个线程能写的问题。\n\n如果我们深入分析ReadWriteLock，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。\n\n要进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。\n\nStampedLock和ReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。\n\n乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。\n\n我们来看例子：\n\npublic class Point {\n    private final StampedLock stampedLock = new StampedLock();\n\n    private double x;\n    private double y;\n\n    public void move(double deltaX, double deltaY) {\n        long stamp = stampedLock.writeLock(); // 获取写锁\n        try {\n            x += deltaX;\n            y += deltaY;\n        } finally {\n            stampedLock.unlockWrite(stamp); // 释放写锁\n        }\n    }\n\n    public double distanceFromOrigin() {\n        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁\n        // 注意下面两行代码不是原子操作\n        // 假设x,y = (100,200)\n        double currentX = x;\n        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)\n        double currentY = y;\n        // 此处已读取到y，如果没有写入，读取是正确的(100,200)\n        // 如果有写入，读取是错误的(100,400)\n        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生\n            stamp = stampedLock.readLock(); // 获取一个悲观读锁\n            try {\n                currentX = x;\n                currentY = y;\n            } finally {\n                stampedLock.unlockRead(stamp); // 释放悲观读锁\n            }\n        }\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}\n和ReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过tryOptimisticRead()获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过validate()去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。\n\n可见，StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。\n\nStampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。\n\n小结\nStampedLock提供了乐观读锁，可取代ReadWriteLock以进一步提升并发性能；\n\nStampedLock是不可重入锁。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826927346},"updatedAt":{"$$date":1594967852779},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"6G7ILb19mwcKVpuR"}
{"name":"js-","folderId":"WKqaKGQVd","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973740085},"updatedAt":{"$$date":1594973761483},"_id":"6RF35DpChYyIO0ti","folder":{"id":"WKqaKGQVd","name":"javascript","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"HTML5 简介","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\nHTML5 简介\nHTML\nHTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。\n\nHTML5的设计目的是为了在移动设备上支持多媒体。\n\nHTML5 简单易学。\n\n什么是 HTML5?\nHTML5 是下一代 HTML 标准。\n\nHTML , HTML 4.01的上一个版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。\n\nHTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持。\n\nHTML5 是如何起步的？\nHTML5 是 W3C 与 WHATWG 合作的结果,WHATWG 指 Web Hypertext Application Technology Working Group。\n\nWHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。\n\nHTML5 中的一些有趣的新特性：\n\n用于绘画的 canvas 元素\n用于媒介回放的 video 和 audio 元素\n对本地离线存储的更好的支持\n新的特殊内容元素，比如 article、footer、header、nav、section\n新的表单控件，比如 calendar、date、time、email、url、search\nHTML5 <!DOCTYPE>\n<!doctype> 声明必须位于 HTML5 文档中的第一行,使用非常简单:\n\n<!DOCTYPE html>\n最小的HTML5文档\n下面是一个简单的HTML5文档：\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>文档标题</title>\n</head>\n \n<body>\n文档内容......\n</body>\n \n</html>\n注意：对于中文网页需要使用 <meta charset=\"utf-8\"> 声明编码，否则会出现乱码。\n\nHTML5 的改进\n新元素\n新属性\n完全支持 CSS3\nVideo 和 Audio\n2D/3D 制图\n本地存储\n本地 SQL 数据\nWeb 应用\nHTML5 多媒体\n使用 HTML5 你可以简单的在网页中播放 视频(video)与音频 (audio) 。\n\nHTML5 <video>\nHTML5 <audio>\nHTML5 应用\n使用 HTML5 你可以简单地开发应用\n\n本地数据存储\n访问本地文件\n本地 SQL 数据\n缓存引用\nJavascript 工作者\nXHTMLHttpRequest 2\nHTML5 图形\n使用 HTML5 你可以简单的绘制图形:\n\n使用 <canvas> 元素。\n使用内联 SVG。\n使用 CSS3 2D 转换、CSS3 3D 转换。\nHTML5 使用 CSS3\n新选择器\n新属性\n动画\n2D/3D 转换\n圆角\n阴影效果\n可下载的字体\n了解更多CSS3知识请查看本站的 CSS3 教程。\n\n语义元素\nHTML5 添加了很多语义元素如下所示：\n\n标签\t描述\n<article>\t定义页面独立的内容区域。\n<aside>\t定义页面的侧边栏内容。\n<bdi>\t允许您设置一段文本，使其脱离其父元素的文本方向设置。\n<command>\t定义命令按钮，比如单选按钮、复选框或按钮\n<details>\t用于描述文档或文档某个部分的细节\n<dialog>\t定义对话框，比如提示框\n<summary>\t标签包含 details 元素的标题\n<figure>\t规定独立的流内容（图像、图表、照片、代码等等）。\n<figcaption>\t定义 <figure> 元素的标题\n<footer>\t定义 section 或 document 的页脚。\n<header>\t定义了文档的头部区域\n<mark>\t定义带有记号的文本。\n<meter>\t定义度量衡。仅用于已知最大和最小值的度量。\n<nav>\t定义导航链接的部分。\n<progress>\t定义任何类型的任务的进度。\n<ruby>\t定义 ruby 注释（中文注音或字符）。\n<rt>\t定义字符（中文注音或字符）的解释或发音。\n<rp>\t在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。\n<section>\t定义文档中的节（section、区段）。\n<time>\t定义日期或时间。\n<wbr>\t规定在文本中的何处适合添加换行符。\nHTML5 表单\n新表单元素, 新属性，新输入类型，自动验证。\n\n已移除元素\n以下的 HTML 4.01 元素在HTML5中已经被删除:\n\n<acronym>\n<applet>\n<basefont>\n<big>\n<center>\n<dir>\n<font>\n<frame>\n<frameset>\n<noframes>\n<strike>\n每一章中的实例\n通过我们的 HTML 编辑器，您能够编辑 HTML，然后点击按钮来查看结果。\n\n实例\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta charset=\"utf-8\"> \n<title>菜鸟教程(runoob.com)</title> \n</head>\n<body>\n \n<video width=\"320\" height=\"240\" controls>\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  <source src=\"movie.ogg\" type=\"video/ogg\">\n  你的浏览器不支持 video 标签。\n</video>\n \n</body>\n</html>\n\n尝试一下 »\n点击 \"尝试一下\" 按钮查看在线运行结果。\n\nHTML5 浏览器支持\n最新版本的 Safari、Chrome、Firefox 以及 Opera 支持某些 HTML5 特性。Internet Explorer 9 将支持某些 HTML5 特性。\n\n\n\nIE9 以下版本浏览器兼容HTML5的方法，使用本站的静态资源的html5shiv包：\n\n<!--[if lt IE 9]>\n    <script src=\"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\"></script>\n<![endif]-->\n载入后，初始化新标签的CSS：\n\n/*html5*/\narticle,aside,dialog,footer,header,section,nav,figure,menu{display:block}\n\nHTML5 参考手册\n在本站中你可以找到关于HTML5 的标签及属性描述，详细请点击 HTML5参考手册。\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886144120},"updatedAt":{"$$date":1598887160191},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"6ZNhhpBk2es3ub1W"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975700293},"updatedAt":{"$$date":1598975700293},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"6aymvZlKsPO1JRYy"}
{"name":"ad-imageload_glide","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n    implementation project(path: ':frame_imageload')\n\n    //glide\n    api 'com.github.bumptech.glide:glide:4.11.0'\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'\n    api \"com.github.bumptech.glide:okhttp3-integration:4.11.0\"\n\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598525720258},"updatedAt":{"$$date":1598537207790},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"6e1SUctx1108xtiz"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975874691},"updatedAt":{"$$date":1598975874691},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"6g1AdpfutxbromWl"}
{"name":"HTML 简介","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>菜鸟教程(runoob.com)</title>\n</head>\n<body>\n \n<h1>我的第一个标题</h1>\n \n<p>我的第一个段落。</p>\n \n</body>\n</html>\n\n尝试一下 »\n实例解析\n<!DOCTYPE html> 声明为 HTML5 文档\n<html> 元素是 HTML 页面的根元素\n<head> 元素包含了文档的元（meta）数据，如 <meta charset=\"utf-8\"> 定义网页编码格式为 utf-8。\n<title> 元素描述了文档的标题\n<body> 元素包含了可见的页面内容\n<h1> 元素定义一个大标题\n<p> 元素定义一个段落\n注：在浏览器的页面上使用键盘上的 F12 按键开启调试模式，就可以看到组成标签。\n\n\n什么是HTML?\nHTML 是用来描述网页的一种语言。\n\nHTML 指的是超文本标记语言: HyperText Markup Language\nHTML 不是一种编程语言，而是一种标记语言\n标记语言是一套标记标签 (markup tag)\nHTML 使用标记标签来描述网页\nHTML 文档包含了HTML 标签及文本内容\nHTML文档也叫做 web 页面\nHTML 标签\nHTML 标记标签通常被称为 HTML 标签 (HTML tag)。\n\nHTML 标签是由尖括号包围的关键词，比如 <html>\nHTML 标签通常是成对出现的，比如 <b> 和 </b>\n标签对中的第一个标签是开始标签，第二个标签是结束标签\n开始和结束标签也被称为开放标签和闭合标签\n<标签>内容</标签>\n\nHTML 元素\n\"HTML 标签\" 和 \"HTML 元素\" 通常都是描述同样的意思.\n\n但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例:\n\nHTML 元素:\n\n<p>这是一个段落。</p>\n\nWeb 浏览器\nWeb浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。\n\n浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户：\n\n\n\nHTML 网页结构\n下面是一个可视化的HTML页面结构：\n\n<html>\n<head>\n<title>页面标题</title>\n</head>\n<body>\n<h1>这是一个标题</h1>\n<p>这是一个段落。</p>\n<p>这是另外一个段落。</p>\n</body>\n</html>\n\nNote\t只有 <body> \b区域 (\b白色部分) \b才会在浏览器中显示。\n\nHTML版本\n从初期的网络诞生后，已经出现了许多HTML版本:\n\n版本\t发布时间\nHTML\t1991\nHTML+\t1993\nHTML 2.0\t1995\nHTML 3.2\t1997\nHTML 4.01\t1999\nXHTML 1.0\t2000\nHTML5\t2012\nXHTML5\t2013\n\n<!DOCTYPE> 声明\n<!DOCTYPE>声明有助于浏览器中正确显示网页。\n\n网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。\n\ndoctype 声明是不区分大小写的，以下方式均可：\n\n<!DOCTYPE html>\n\n<!DOCTYPE HTML>\n\n<!doctype html>\n\n<!Doctype Html>\n通用声明\nHTML5\n<!DOCTYPE html>\nHTML 4.01\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\nXHTML 1.0\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n查看完整网页声明类型 DOCTYPE 参考手册。\n\n中文编码\n目前在大部分浏览器中，直接\b输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。\n\nHTML 实例\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>\n页面标题</title>\n</head>\n<body>\n \n<h1>我的第一个标题</h1>\n \n<p>我的第一个段落。</p>\n \n</body>\n</html>\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885690682},"updatedAt":{"$$date":1598885807525},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"6jxhz9IpEeP84iJ0"}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244757625},"updatedAt":{"$$date":1597244757625},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"6nqJ2gwgo3hlt6tI"}
{"name":"LeakCanary2.4分析内存泄漏手册","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"LeakCanary2.4分析内存泄漏手册\n1、打包阶段检查LeakCanary是否开启\n非命令打包\n手动开启gradle.properties下的isAnalysis=true配置\n命令打包\n./gradlew installKsDebug --stacktrace -PisAnalysis=true\n2、打开LeakCanary\nLeaks是泄漏列表\nHeapDumps是堆泄漏列表\nAbout是LeakCanary介绍\n3、点击HeapDumps下Dump Heap Now，可以抓去当前状态下APP的堆信息\n第一张图可以看到hprof堆信息文件目录\n第二张图可以看到ShoppingHomePageActivity在onDestroy方法执行后还有为释放资源，看引用关系应该是ReactInstanceManager还有ShoppingHomePageActivity对象的引用。\n4、可以通过AS的Device File Explorer找到hprof文件进行深度分析\n双击hprof文件会导入文件到AS到Profiler中\n选中Activity/Fragment Leaks 就能筛选出结果\n5、hprof还以通过MAT来分析看个人对工具对熟悉程度自由选择"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598547503943},"updatedAt":{"$$date":1598547504897},"_id":"6vF93QHDwtogrhpr","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-空安全 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/null-safety.html\n空安全 - Kotlin 语言中文站\n12-15 minutes\n改进翻译\nKotlin 的类型系统旨在消除来自代码空引用的危险，也称为《十亿美元的错误》。\n\n许多编程语言（包括 Java）中最常见的陷阱之一，就是访问空引用的成员会导致空引用异常。在 Java 中，这等同于 NullPointerException 或简称 NPE。\n\nKotlin 的类型系统旨在从我们的代码中消除 NullPointerException。NPE 的唯一可能的原因可能是：\n\n显式调用 throw NullPointerException()；\n使用了下文描述的 !! 操作符；\n有些数据在初始化时不一致，例如当：\n传递一个在构造函数中出现的未初始化的 this 并用于其他地方（“泄漏 this”）；\n超类的构造函数调用一个开放成员，该成员在派生中类的实现使用了未初始化的状态；\nJava 互操作：\n企图访问平台类型的 null 引用的成员；\n用于具有错误可空性的 Java 互操作的泛型类型，例如一段 Java 代码可能会向 Kotlin 的 MutableList<String> 中加入 null，这意味着应该使用 MutableList<String?> 来处理它；\n由外部 Java 代码引发的其他问题。\n在 Kotlin 中，类型系统区分一个引用可以容纳 null （可空引用）还是不能容纳（非空引用）。 例如，String 类型的常规变量不能容纳 null：\n\nfun main() {\n//sampleStart\n    var a: String = \"abc\" // 默认情况下，常规初始化意味着非空\n    a = null // 编译错误\n//sampleEnd\n}\n如果要允许为空，我们可以声明一个变量为可空字符串，写作 String?：\n\nfun main() {\n//sampleStart\n    var b: String? = \"abc\" // 可以设置为空\n    b = null // ok\n    print(b)\n//sampleEnd\n}\n现在，如果你调用 a 的方法或者访问它的属性，它保证不会导致 NPE，这样你就可以放心地使用：\n\n但是如果你想访问 b 的同一个属性，那么这是不安全的，并且编译器会报告一个错误：\n\nval l = b.length // 错误：变量“b”可能为空\n但是我们还是需要访问该属性，对吧？有几种方式可以做到。\n\n首先，你可以显式检测 b 是否为 null，并分别处理两种可能：\n\nval l = if (b != null) b.length else -1\n编译器会跟踪所执行检测的信息，并允许你在 if 内部调用 length。 同时，也支持更复杂（更智能）的条件：\n\nfun main() {\n//sampleStart\n    val b: String? = \"Kotlin\"\n    if (b != null && b.length > 0) {\n        print(\"String of length ${b.length}\")\n    } else {\n        print(\"Empty string\")\n    }\n//sampleEnd\n}\n\n请注意，这只适用于 b 是不可变的情况（即在检测和使用之间没有修改过的局部变量 ，或者不可覆盖并且有幕后字段的 val 成员），因为否则可能会发生在检测之后 b 又变为 null 的情况。\n\n你的第二个选择是安全调用操作符，写作 ?.：\n\nfun main() {\n//sampleStart\n    val a = \"Kotlin\"\n    val b: String? = null\n    println(b?.length)\n    println(a?.length) // 无需安全调用\n//sampleEnd\n}\n如果 b 非空，就返回 b.length，否则返回 null，这个表达式的类型是 Int?。\n\n安全调用在链式调用中很有用。例如，如果一个员工 Bob 可能会（或者不会）分配给一个部门， 并且可能有另外一个员工是该部门的负责人，那么获取 Bob 所在部门负责人（如果有的话）的名字，我们写作：\n\nbob?.department?.head?.name\n如果任意一个属性（环节）为空，这个链式调用就会返回 null。\n\n如果要只对非空值执行某个操作，安全调用操作符可以与 let 一起使用：\n\nfun main() {\n//sampleStart\n    val listWithNulls: List<String?> = listOf(\"Kotlin\", null)\n    for (item in listWithNulls) {\n         item?.let { println(it) } // 输出 Kotlin 并忽略 null\n    }\n//sampleEnd\n}\n安全调用也可以出现在赋值的左侧。这样，如果调用链中的任何一个接收者为空都会跳过赋值，而右侧的表达式根本不会求值：\n\n// 如果 `person` 或者 `person.department` 其中之一为空，都不会调用该函数：\nperson?.department?.head = managersPool.getManager()\n当我们有一个可空的引用 b 时，我们可以说“如果 b 非空，我使用它；否则使用某个非空的值”：\n\nval l: Int = if (b != null) b.length else -1\n除了完整的 if-表达式，这还可以通过 Elvis 操作符表达，写作 ?:：\n\n如果 ?: 左侧表达式非空，elvis 操作符就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。\n\n请注意，因为 throw 和 return 在 Kotlin 中都是表达式，所以它们也可以用在 elvis 操作符右侧。这可能会非常方便，例如，检测函数参数：\n\nfun foo(node: Node): String? {\n    val parent = node.getParent() ?: return null\n    val name = node.getName() ?: throw IllegalArgumentException(\"name expected\")\n    // ……\n}\n第三种选择是为 NPE 爱好者准备的：非空断言运算符（!!）将任何值转换为非空类型，若该值为空则抛出异常。我们可以写 b!! ，这会返回一个非空的 b 值 （例如：在我们例子中的 String）或者如果 b 为空，就会抛出一个 NPE 异常：\n\n因此，如果你想要一个 NPE，你可以得到它，但是你必须显式要求它，否则它不会不期而至。\n\n如果对象不是目标类型，那么常规类型转换可能会导致 ClassCastException。 另一个选择是使用安全的类型转换，如果尝试转换不成功则返回 null：\n\nval aInt: Int? = a as? Int\n如果你有一个可空类型元素的集合，并且想要过滤非空元素，你可以使用 filterNotNull 来实现：\n\nval nullableList: List<Int?> = listOf(1, 2, null, 4)\nval intList: List<Int> = nullableList.filterNotNull()"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386574905},"updatedAt":{"$$date":1597397058678},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"777IdC3ljwasjxGS"}
{"name":"kqapp-build.gradle","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\napply plugin: 'com.alibaba.arouter'\nbuildscript {\n    repositories {\n//        apply from: 'dependencies.gradle'\n//        apply from: '../kt-base-lib/ks_kotlin_lib_versions.gradle'\n        google()\n        jcenter()\n        maven {\n            url \"http://10.0.20.167:8081/repository/ks_kt_lib_public/\"\n            allowInsecureProtocol true\n\n        }\n        maven {\n            url \"http://10.0.20.167:8081/repository/ks_plugin_lib_public/\"\n            allowInsecureProtocol true\n        }\n//        maven { url \"http://nexus2.tingyun.com/nexus/content/repositories/snapshots/\" }\n    }\n    dependencies {\n        classpath ProjectPlugin.gradle_plugin\n        classpath ProjectPlugin.kotlin_plugin\n        classpath ProjectPlugin.arouter_plugin\n        classpath ProjectPlugin.packer_np_plugin\n//        classpath(ks.lib_appmerge_plugin) { changing = true \n        classpath ProjectPlugin.tingyun_plugin\n        classpath 'com.didichuxing.doraemonkit:doraemonkit-plugin:3.1.8'\n        //该插件提供了将library以及它依赖的module一起打包成一个完整aar的解决方案，支持gradle plugin 3.0.1及以上。（目前测试的版本范围是gradle plugin 3.0.1 - 4.0.0，gradle 4.6 - 6.1.1）\n        //https://github.com/kezong/fat-aar-android/blob/master/README_CN.md\n//        classpath 'com.kezong:fat-aar:1.2.15'\n\n//        classpath project_plugin.booster_plugin\n//        github relinker,全局替换 System.loadLibrary(String)\n//        classpath ks_plugin.transform_relinker\n        //多线程优化\n//        classpath \"com.didiglobal.booster:booster-transform-thread:$booster_version\"\n//        //        WebView 预加载\n//        classpath \"com.didiglobal.booster:booster-transform-webview:$booster_version\"\n//        //        SharedPreferences 优化\n//        classpath \"com.didiglobal.booster:booster-transform-shared-preferences:$booster_version\"\n\n    }\n\n}\n\n\nallprojects {\n\n    configurations.all {\n        // 采用动态版本声明的依赖缓存10分钟\n        resolutionStrategy.cacheDynamicVersionsFor(5, 'minutes')\n        // 每隔24小时检查远程依赖是否存在更新\n        resolutionStrategy.cacheChangingModulesFor(0, 'seconds')\n    }\n\n//    configurations.all {\n//        resolutionStrategy.force \"com.facebook.fresco:fresco:1.11.0\"\n//        resolutionStrategy.force \"com.facebook.fresco:imagepipeline-okhttp3:1.11.0\"\n//        resolutionStrategy.force \"com.google.code.findbugs:jsr305:3.0.2\"\n//        resolutionStrategy.force \"com.squareup.okhttp3:okhttp:3.12.0\"\n//    }\n\n    repositories {\n        google()\n        jcenter()\n//        maven { url \"https://www.jitpack.io\" }\n//        maven { url 'https://dl.bintray.com/umsdk/release' }\n        flatDir {\n            dirs 'libs'\n        }\n\n//        maven { url 'https://dl.bintray.com/kaishustory/maven' }\n        maven {\n            url \"http://10.0.20.167:8081/repository/ks_kt_lib_public/\"\n            allowInsecureProtocol true\n        }\n        maven {\n            url \"http://10.0.20.167:8081/repository/ks_plugin_lib_public/\"\n            allowInsecureProtocol true\n        }\n        maven {\n            url \"http://10.0.20.167:8081/repository/KsLightLearn/\"\n            allowInsecureProtocol true\n        }\n//        maven { url \"http://nexus2.tingyun.com/nexus/content/repositories/snapshots/\" }\n    }\n\n    group = GROUP\n}\n\n//这几个忽略，不加 上传aar task\ndef ignoreList = [\"lightlearn_module_main\", \"lightlearn_module_base\", \"ks_component_ui\"]\n\nsubprojects { Project project ->\n    if (useModuleSource.toBoolean()) {\n        return\n    }\n    def ignore = false\n    ignoreList.forEach { name ->\n        if (project.name == name) {\n            ignore = true\n        }\n    }\n    if (ignore) {\n        return\n    }\n\n\n\n    apply from: rootProject.file(\"./gradle/upload.gradle\")\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593249677},"updatedAt":{"$$date":1598593450122},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"7KpjiLx7IXUNcpZ7"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975866469},"updatedAt":{"$$date":1598975866469},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"7P5WDgZtlHV6BkIU"}
{"name":"ad-项目","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\nbuildscript {\n    apply from: './script/dependencies.gradle'\n    ext {\n        kotlin_version = '1.3.72'\n        // 是否是发布模式 true 为库发布模式，false 编译模式\n        isPublishMode =  true\n\n    }\n\n\n    repositories {\n        google()\n        jcenter()\n        maven {\n            url \"http://10.0.20.167:8081/repository/ks_kt_lib_public/\"\n            allowInsecureProtocol true\n\n        }\n        maven {\n            url \"http://10.0.20.167:8081/repository/ks_plugin_lib_public/\"\n            allowInsecureProtocol true\n        }\n        maven { url 'https://dl.bintray.com/kaishustory/maven' }\n        maven { url \"http://10.0.20.167:8081/repository/ks_kt_lib_public/\" }\n    }\n    dependencies {\n        classpath ProjectPlugin.gradle_plugin\n        classpath ProjectPlugin.kotlin_plugin\n        classpath ProjectPlugin.hilt_plugin\n        // jcenter 上传\n        classpath 'com.github.dcendents:android-maven-gradle-plugin:2.1'\n        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.4'\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n\n        maven { url 'http://10.0.20.167:8081/repository/ksandroidx/' }\n        maven { url 'http://10.0.20.167:8081/repository/ksandroidx-snapshot/' }\n        maven {\n            url \"http://10.0.20.167:8081/repository/ks_kt_lib_public/\"\n            allowInsecureProtocol true\n        }\n        maven {\n            url \"http://10.0.20.167:8081/repository/ks_plugin_lib_public/\"\n            allowInsecureProtocol true\n        }\n        maven {\n            url \"http://10.0.20.167:8081/repository/KsLightLearn/\"\n            allowInsecureProtocol true\n        }\n\n    }\n}\n\nconfigurations.all {\n    resolutionStrategy.cacheDynamicVersionsFor 0, 'seconds' // 动态版本 x.x.+\n    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'//  变化版本 x.x.x\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539518127},"updatedAt":{"$$date":1598539606281},"_id":"7S4zVuahbIgxFvJ2","folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}]}
{"name":"kotlin-Inline classes - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/inline-classes.html\nInline classes - Kotlin 语言中文站\n14-17 minutes\n改进翻译\n内联类仅在 Kotlin 1.3 之后版本可用，目前还是实验性的。关于详情请参见下文\n\n有时候，业务逻辑需要围绕某种类型创建包装器。然而，由于额外的堆内存分配问题，它会引入运行时的性能开销。此外，如果被包装的类型是原生类型，性能的损失是很糟糕的，因为原生类型通常在运行时就进行了大量优化，然而他们的包装器却没有得到任何特殊的处理。\n\n为了解决这类问题，Kotlin 引入了一种被称为 内联类 的特殊类，它通过在类的前面定义一个 inline 修饰符来声明：\n\n内联类必须含有唯一的一个属性在主构造函数中初始化。在运行时，将使用这个唯一属性来表示内联类的实例（关于运行时的内部表达请参阅下文）：\n\n// 不存在 'Password' 类的真实实例对象\n// 在运行时，'securePassword' 仅仅包含 'String'\nval securePassword = Password(\"Don't try this in production\") \n这就是内联类的主要特性，它灵感来源于 “inline” 这个名称：类的数据被 “内联”到该类使用的地方（类似于内联函数中的代码被内联到该函数调用的地方）。\n\n内联类支持普通类中的一些功能。特别是，内联类可以声明属性与函数：\n\ninline class Name(val s: String) {\n    val length: Int\n        get() = s.length\n\n    fun greet() {\n        println(\"Hello, $s\")\n    }\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    name.greet() // `greet` 方法会作为一个静态方法被调用\n    println(name.length) // 属性的 get 方法会作为一个静态方法被调用\n}\n然而，内联类的成员也有一些限制：\n\n内联类不能含有 init 代码块\n内联类不能含有幕后字段\n因此，内联类只能含有简单的计算属性（不能含有延迟初始化/委托属性）\n内联类允许去继承接口\n\ninterface Printable {\n    fun prettyPrint(): String\n}\n\ninline class Name(val s: String) : Printable {\n    override fun prettyPrint(): String = \"Let's $s!\"\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    println(name.prettyPrint()) // 仍然会作为一个静态方法被调用\n}\n禁止内联类参与到类的继承关系结构中。这就意味着内联类不能继承其他的类而且必须是 final。\n\n在生成的代码中，Kotlin 编译器为每个内联类保留一个包装器。内联类的实例可以在运行时表示为包装器或者基础类型。这就类似于 Int 可以表示为原生类型 int 或者包装器 Integer。\n\n为了生成性能最优的代码，Kotlin 编译更倾向于使用基础类型而不是包装器。 然而，有时候使用包装器是必要的。一般来说，只要将内联类用作另一种类型，它们就会被装箱。\n\ninterface I\n\ninline class Foo(val i: Int) : I\n\nfun asInline(f: Foo) {}\nfun <T> asGeneric(x: T) {}\nfun asInterface(i: I) {}\nfun asNullable(i: Foo?) {}\n\nfun <T> id(x: T): T = x\n\nfun main() {\n    val f = Foo(42) \n    \n    asInline(f)    // 拆箱操作: 用作 Foo 本身\n    asGeneric(f)   // 装箱操作: 用作泛型类型 T\n    asInterface(f) // 装箱操作: 用作类型 I\n    asNullable(f)  // 装箱操作: 用作不同于 Foo 的可空类型 Foo?\n    \n    // 在下面这里例子中，'f' 首先会被装箱（当它作为参数传递给 'id' 函数时）然后又被拆箱（当它从'id'函数中被返回时）\n    // 最后， 'c' 中就包含了被拆箱后的内部表达(也就是 '42')， 和 'f' 一样\n    val c = id(f)  \n}\n因为内联类既可以表示为基础类型有可以表示为包装器，引用相等对于内联类而言毫无意义，因此这也是被禁止的。\n\n由于内联类被编译为其基础类型，因此可能会导致各种模糊的错误，例如意想不到的平台签名冲突：\n\ninline class UInt(val x: Int)\n\n// 在 JVM 平台上被表示为'public final void compute(int x)'\nfun compute(x: Int) { }\n\n// 同理，在 JVM 平台上也被表示为'public final void compute(int x)'！\nfun compute(x: UInt) { }\n为了缓解这种问题，一般会通过在函数名后面拼接一些稳定的哈希码来重命名函数。 因此，fun compute(x: UInt) 将会被表示为 public final void compute-<hashcode>(int x)，以此来解决冲突的问题。\n\n请注意在 Java 中 - 是一个 无效的 符号，也就是说在 Java 中不能调用使用内联类作为形参的函数。\n\n初看起来，内联类似乎与类型别名非常相似。实际上，两者似乎都引入了一种新的类型，并且都在运行时表示为基础类型。\n\n然而，关键的区别在于类型别名与其基础类型(以及具有相同基础类型的其他类型别名)是 赋值兼容 的，而内联类却不是这样。\n\n换句话说，内联类引入了一个真实的新类型，与类型别名正好相反，类型别名仅仅是为现有的类型取了个新的替代名称(别名)：\n\ntypealias NameTypeAlias = String\ninline class NameInlineClass(val s: String)\n\nfun acceptString(s: String) {}\nfun acceptNameTypeAlias(n: NameTypeAlias) {}\nfun acceptNameInlineClass(p: NameInlineClass) {}\n\nfun main() {\n    val nameAlias: NameTypeAlias = \"\"\n    val nameInlineClass: NameInlineClass = NameInlineClass(\"\")\n    val string: String = \"\"\n\n    acceptString(nameAlias) // 正确: 传递别名类型的实参替代函数中基础类型的形参\n    acceptString(nameInlineClass) // 错误: 不能传递内联类的实参替代函数中基础类型的形参\n\n    // And vice versa:\n    acceptNameTypeAlias(string) // 正确: 传递基础类型的实参替代函数中别名类型的形参\n    acceptNameInlineClass(string) // 错误: 不能传递基础类型的实参替代函数中内联类类型的形参\n}\n内联类的设计目前是实验性的，这就是说此特性是正在 快速变化的，并且不保证其兼容性。在 Kotlin 1.3+ 中使用内联类时，将会得到一个警告，来表明此特性还是实验性的。\n\n如需移除警告，必须通过指定编译器参数 -Xinline-classes 来选择使用这项实验性的特性。\n\nGroovyKotlin\n\ncompileKotlin {\n    kotlinOptions.freeCompilerArgs += [\"-Xinline-classes\"]\n}\ntasks.withType<KotlinCompile> {\n    kotlinOptions.freeCompilerArgs += \"-Xinline-classes\"\n}\n关于详细信息，请参见编译器选项。关于多平台项目的设置，请参见使用 Gradle 构建多平台项目章节。\n\n<configuration>\n    <args>\n        <arg>-Xinline-classes</arg> \n    </args>\n</configuration>\n关于详细信息，请参见指定编译器选项。\n\n关于其他技术详细信息和讨论，请参见内联类的语言提议"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307929968},"updatedAt":{"$$date":1597308315206},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"7STj5TYmD3hk5nEw"}
{"name":"html-","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887699600},"updatedAt":{"$$date":1598887699600},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"7aQu5RgR1kfyPX6J"}
{"name":"HTML5 内联 SVG","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\nHTML5 内联 SVG\nHTML5 支持内联 SVG。\n\n什么是SVG？\nSVG 指可伸缩矢量图形 (Scalable Vector Graphics)\nSVG 用于定义用于网络的基于矢量的图形\nSVG 使用 XML 格式定义图形\nSVG 图像在放大或改变尺寸的情况下其图形质量不会有损失\nSVG 是万维网联盟的标准\nSVG优势\n与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：\n\nSVG 图像可通过文本编辑器来创建和修改\nSVG 图像可被搜索、索引、脚本化或压缩\nSVG 是可伸缩的\nSVG 图像可在任何的分辨率下被高质量地打印\nSVG 可在图像质量不下降的情况下被放大\n浏览器支持\nInternet ExplorerFirefoxOperaGoogle ChromeSafari\n\nInternet Explorer 9+, Firefox, Opera, Chrome, 和 Safari 支持内联SVG。\n\n把 SVG 直接嵌入 HTML 页面\n在 HTML5 中，您能够将 SVG 元素直接嵌入 HTML 页面中：\n\n实例\n<!DOCTYPE html>\n<html>\n<body>\n \n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" height=\"190\">\n  <polygon points=\"100,10 40,180 190,60 10,60 160,180\"\n  style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\">\n</svg>\n \n</body>\n</html>\n\n尝试一下 »\n结果：\n\n抱歉, 你的浏览器不支持内联SVG.\n学习更多关于 SVG 教程, 请访问 SVG 教程.\n\nSVG 与 Canvas两者间的区别\nSVG 是一种使用 XML 描述 2D 图形的语言。\n\nCanvas 通过 JavaScript 来绘制 2D 图形。\n\nSVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。\n\n在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\n\nCanvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。\n\nCanvas 与 SVG 的比较\n下表列出了 canvas 与 SVG 之间的一些不同之处。\n\nCanvas\tSVG\n依赖分辨率\n不支持事件处理器\n弱的文本渲染能力\n能够以 .png 或 .jpg 格式保存结果图像\n最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n不依赖分辨率\n支持事件处理器\n最适合带有大型渲染区域的应用程序（比如谷歌地图）\n复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n不适合游戏应用\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886958389},"updatedAt":{"$$date":1598887420455},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"7hz4h95J2bPkJDGv"}
{"name":"HTML5 Video(视频)","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\nHTML5 Video(视频)\n很多站点都会使用到视频. HTML5 提供了展示视频的标准。\n\n检测您的浏览器是否支持 HTML5 视频：\n检测\n\nWeb站点上的视频\n直到现在，仍然不存在一项旨在网页上显示视频的标准。\n\n今天，大多数视频是通过插件（比如 Flash）来显示的。然而，并非所有浏览器都拥有同样的插件。\n\nHTML5 规定了一种通过 video 元素来包含视频的标准方法。\n\n浏览器支持\nInternet ExplorerFirefoxOperaGoogle ChromeSafari\n\nInternet Explorer 9+, Firefox, Opera, Chrome, 和 Safari 支持 <video> 元素.\n\n注意: Internet Explorer 8 或者更早的IE版本不支持 <video> 元素。\n\nHTML5 (视频)- 如何工作\n如需在 HTML5 中显示视频，您所有需要的是：\n\n实例\n<video width=\"320\" height=\"240\" controls>\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  <source src=\"movie.ogg\" type=\"video/ogg\">\n您的浏览器不支持Video标签。\n</video>\n\n尝试一下 »\n<video> 元素提供了 播放、暂停和音量控件来控制视频。\n\n同时 <video> 元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。\n\n<video> 与</video> 标签之间插入的内容是提供给不支持 video 元素的浏览器显示的。\n\n<video> 元素支持多个 <source> 元素. <source> 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式：\n\n视频格式与浏览器的支持\n当前， <video> 元素支持三种视频格式： MP4, WebM, 和 Ogg:\n\n浏览器\tMP4\tWebM\tOgg\nInternet Explorer\tYES\tNO\tNO\nChrome\tYES\tYES\tYES\nFirefox\tYES\tYES\tYES\nSafari\tYES\tNO\tNO\nOpera\tYES (从 Opera 25 起)\tYES\tYES\nMP4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件\nWebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件\nOgg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件\n视频格式\n格式\tMIME-type\nMP4\tvideo/mp4\nWebM\tvideo/webm\nOgg\tvideo/ogg\n\nHTML5 <video> - 使用 DOM 进行控制\nHTML5 <video> 和 <audio> 元素同样拥有方法、属性和事件。\n\n<video> 和 <audio>元素的方法、属性和事件可以使用JavaScript进行控制.\n\n其中的方法用于播放、暂停以及加载等。其中的属性（比如时长、音量等）可以被读取或设置。其中的 DOM 事件能够通知您，比方说，<video> 元素开始播放、已暂停，已停止，等等。\n\n例中简单的方法，向我们演示了如何使用 <video> 元素，读取并设置属性，以及如何调用方法。\n\n实例 1\n为视频创建简单的播放/暂停以及调整尺寸控件：\n\n\n播放/暂停 放大 缩小 普通\n\n上面的例子调用了两个方法：play() 和 pause()。它同时使用了两个属性：paused 和 width。\n\n尝试一下 »\n更多参考请查看 HTML5 Audio/Video DOM 参考手册。\n\nHTML5 Video 标签\n标签\t描述\n<video>\t定义一个视频\n<source>\t定义多种媒体资源,比如 <video> 和<audio>\n<track>\t定义在媒体播放器文本轨迹\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886965670},"updatedAt":{"$$date":1598887702921},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"7oElr2hG4k9sjRzt"}
{"name":"css-CSS margin(外边距)","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS margin(外边距)\nCSS margin(外边距)属性定义元素周围的空间。\n\nmargin\nmargin 清除周围的（外边框）元素区域。margin 没有背景颜色，是完全透明的。\n\nmargin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性。\n\n\n\n可能的值\n值\t说明\nauto\t设置浏览器边距。\n这样做的结果会依赖于浏览器\nlength\t定义一个固定的margin（使用像素，pt，em等）\n%\t定义一个使用百分比的边距\nRemark Margin可以使用负值，重叠的内容。\n\nMargin - 单边外边距属性\n在CSS中，它可以指定不同的侧面不同的边距：\n\n实例\nmargin-top:100px;\nmargin-bottom:100px;\nmargin-right:50px;\nmargin-left:50px;\n\n尝试一下 »\n\nMargin - 简写属性\n为了缩短代码，有可能使用一个属性中margin指定的所有边距属性。这就是所谓的简写属性。\n\n所有边距属性的简写属性是 margin :\n\n实例\nmargin:100px 50px;\n\n尝试一下 »\nmargin属性可以有一到四个值。\n\nmargin:25px 50px 75px 100px;\n上边距为25px\n右边距为50px\n下边距为75px\n左边距为100px\n\nmargin:25px 50px 75px;\n上边距为25px\n左右边距为50px\n下边距为75px\n\nmargin:25px 50px;\n上下边距为25px\n左右边距为50px\n\nmargin:25px;\n所有的4个边距都是25px\nExamples\n更多实例\n文本的上边距设置使用厘米值\n这个例子演示了如何设置一个使用厘米值的文本的顶部margin。\n\nSet 使用百分比值设置文本的下边距\n这个例子演示了如何设置使用百分比值的下边距，相对于包含的元素的宽度。\n\n所有的CSS边距属性\n属性\t描述\nmargin\t简写属性。在一个声明中设置所有外边距属性。\nmargin-bottom\t设置元素的下外边距。\nmargin-left\t设置元素的左外边距。\nmargin-right\t设置元素的右外边距。\nmargin-top\t设置元素的上外边距。\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888555556},"updatedAt":{"$$date":1598889050261},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"7p6D8c42ww2GmN2i"}
{"name":"html-HTML 列表","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\nHTML 列表\nHTML 支持有序、无序和定义列表:\n\nHTML 列表\n有序列表\n第一个列表项\n第二个列表项\n第三个列表项\n无序列表\n列表项\n列表项\n列表项\n实例\t\n在线实例\n无序列表\n本例演示无序列表。\n\n有序列表\n本例演示有序列表。\n\n（可以在本页底端找到更多实例。）\n\nHTML无序列表\n无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。\n\n无序列表使用 <ul> 标签\n\n<ul>\n<li>Coffee</li>\n<li>Milk</li>\n</ul>\n浏览器显示如下：\n\nCoffee\nMilk\nHTML 有序列表\n同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 <ol> 标签。每个列表项始于 <li> 标签。\n\n列表项使用数字来标记。\n\n<ol>\n<li>Coffee</li>\n<li>Milk</li>\n</ol>\n浏览器中显示如下：\n\nCoffee\nMilk\nHTML 自定义列表\n自定义列表不仅仅是一列项目，而是项目及其注释的组合。\n\n自定义列表以 <dl> 标签开始。每个自定义列表项以 <dt> 开始。每个自定义列表项的定义以 <dd> 开始。\n\n<dl>\n<dt>Coffee</dt>\n<dd>- black hot drink</dd>\n<dt>Milk</dt>\n<dd>- white cold drink</dd>\n</dl>\n浏览器显示如下：\n\nCoffee\n- black hot drink\nMilk\n- white cold drink\n注意事项 - 有用提示\n提示: 列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。\n\nExamples\n更多实例\n不同类型的有序列表\n本例演示不同类型的有序列表。\n\n不同类型的无序列表\n本例演示不同类型的无序列表。\n\n嵌套列表\n本例演示如何嵌套列表。\n\n嵌套列表 2\n本例演示更复杂的嵌套列表。\n\n自定义列表\n本例演示一个定义列表。\n\nHTML 列表标签\n标签\t描述\n<ol>\t定义有序列表\n<ul>\t定义无序列表\n<li>\t定义列表项\n<dl>\t定义列表\n<dt>\t自定义列表项目\n<dd>\t定义自定列表项的描述\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886128224},"updatedAt":{"$$date":1598886517380},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"86Lno4qKWSXYQ0n6"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977485771},"updatedAt":{"$$date":1594977485771},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"89ltA1CzbcuyjwQi"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403215382},"updatedAt":{"$$date":1597403215382},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"8ELTXbiOLiPpZJbY"}
{"name":"ad-kscityselector","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation deps.androidx.app_compat\n    implementation deps.fastjson\n    implementation deps.kotlin.kotlin_stdlib_jdk\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class DeviceUtil {\n\n    private DeviceUtil() {\n        /* cannot be instantiated */\n        throw new UnsupportedOperationException(\"cannot be instantiated\");\n    }\n\n    /**\n     * dp转px\n     *\n     * @param context\n     * @param dpVal\n     * @return\n     */\n    public static int dp2px(Context context, float dpVal) {\n        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,\n                dpVal, context.getResources().getDisplayMetrics());\n    }\n\n    /**\n     * sp转px\n     *\n     * @param context\n     * @param spVal\n     * @return\n     */\n    public static int sp2px(Context context, float spVal) {\n        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,\n                spVal, context.getResources().getDisplayMetrics());\n    }\n\n    /**\n     * px转dp\n     *\n     * @param context\n     * @param pxVal\n     * @return\n     */\n    public static float px2dp(Context context, float pxVal) {\n        final float scale = context.getResources().getDisplayMetrics().density;\n        return (pxVal / scale);\n    }\n\n    /**\n     * px转sp\n     *\n     * @param pxVal\n     * @return\n     */\n    public static float px2sp(Context context, float pxVal) {\n        return (pxVal / context.getResources().getDisplayMetrics().scaledDensity);\n    }\n}\n\n\n\n\n\n\n\n\nassets\n      city_data.json\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522793606},"updatedAt":{"$$date":1598523415809},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"8L5smwy2Crso8OZ5"}
{"name":"andr-请求应用权限","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/permissions/requesting\n请求应用权限  |  Android 开发者  |  Android Developers\n10-13 minutes\n每款 Android 应用都在访问受限的沙盒中运行。如果应用需要使用自己的沙盒外的资源或信息，就必须请求相应权限。您可以通过以下方式声明应用需要某项权限：在应用清单中列出该权限，然后在运行时请求用户批准每项权限（适用于 Android 6.0 及更高版本）。\n\n\n\n基本原则如下：\n\n视情况在用户开始与需要相关权限的功能进行互动时请求权限。\n不要阻止用户使用应用。始终提供选项供用户取消与权限相关的指导界面流程。\n如果用户拒绝或撤消某项功能所需的权限，请适当降级您的应用以便让用户可以继续使用您的应用（可能通过停用需要该权限的功能来实现）。\n不要假设任何系统行为。\n本页面详细介绍向应用添加权限以及在运行时根据需要请求这些权限的分步流程。\n\n向清单添加权限\n对于所有 Android 版本，如需声明应用需要某项权限，请在应用清单中添加 <uses-permission> 元素，作为顶级 <manifest> 元素的子级。\n\n例如，需要访问互联网的应用会在清单中添加以下代码行：\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        package=\"com.example.snazzyapp\"><uses-permission android:name=\"android.permission.INTERNET\"/>\n    <!-- other permissions go here --><application ...>\n        ...\n    </application>\n</manifest>\n系统在您声明权限之后的行为取决于权限的敏感程度。有些权限被视为“普通”权限，因此系统会在安装应用后立即授予这些权限。还有些权限则被视为“危险”权限，因此必须由用户向应用明确授予相应访问权限。如需详细了解不同类型的权限，请参阅保护级别。\n\n检查权限\n如果应用需要一项危险权限，那么每次执行需要该权限的操作时，您都必须检查是否具有该权限。在 Android 6.0（API 级别 23）及更高版本中，用户可以随时从任何应用撤消危险权限。\n\n确定应用是否已获得权限\n如需检查用户是否已向您的应用授予特定权限，请将该权限传入 ContextCompat.checkSelfPermission() 方法。根据您的应用是否具有相应权限，此方法会返回 PERMISSION_GRANTED 或 PERMISSION_DENIED。\n\n说明您的应用为何需要获取权限\n如果 ContextCompat.checkSelfPermission() 方法返回 PERMISSION_DENIED，请调用 shouldShowRequestPermissionRationale()。如果此方法返回 true，请向用户显示指导界面。请在此界面中说明用户希望启用的功能为何需要特定权限。\n\n请求权限\n用户查看指导界面后或者 shouldShowRequestPermissionRationale() 的返回值表明您这次不需要显示指导界面后，您可以请求权限。用户会看到系统权限对话框，并可在其中选择是否向您的应用授予特定权限。\n\n按照历来的做法，您可以在权限请求过程中自行管理请求代码，并将此请求代码包含在您的权限回调逻辑中。另一种选择是使用 AndroidX 库中包含的 RequestPermission 协定类，您可在其中允许系统代为管理权限请求代码。由于使用 RequestPermission 协定类可简化逻辑，因此，建议您尽可能使用该方法。\n\n允许系统管理权限请求代码\n如需允许系统管理与权限请求相关联的请求代码，请在您模块的 build.gradle 文件中添加 androidx.activity 库的依赖项。请使用该库的 1.2.0 版或更高版本。\n\n然后，您可以使用以下某个类：\n\n如需请求一项权限，请使用 RequestPermission。\n如需同时请求多项权限，请使用 RequestMultiplePermissions。\n以下步骤显示了如何使用 RequestPermission 协定类。使用 RequestMultiplePermissions 协定类的流程几乎与此相同。\n\n在 Activity 或 Fragment 的初始化逻辑中，将 ActivityResultCallback 的实现传入对 registerForActivityResult() 的调用。ActivityResultCallback 定义应用如何处理用户对权限请求的响应。\n\n保留对 registerForActivityResult()（类型为 ActivityResultLauncher）的返回值的引用。\n\n如需在必要时显示系统权限对话框，请对您在上一步中保存的 ActivityResultLauncher 实例调用 launch() 方法。\n\n调用 launch() 之后，系统会显示系统权限对话框。当用户做出选择后，系统会异步调用您在上一步中定义的 ActivityResultCallback 实现。\n\n注意：应用无法自定义调用 launch() 时显示的对话框。如需为用户提供更多信息或上下文，请更改应用的界面，以便让用户更容易了解应用中的功能为何需要特定权限。例如，您可以更改用于启用该功能的按钮中的文本。\n\n此外，系统权限对话框中的文本会提及与您请求的权限关联的权限组。此权限分组是为了让系统易于使用，您的应用不应依赖于特定权限组之内或之外的权限。\n\n以下代码段展示了如何处理权限响应：\n\n// Register the permissions callback, which handles the user's response to the\n// system permissions dialog. Save the return value, an instance of\n// ActivityResultLauncher. You can use either a val, as shown in this snippet,\n// or a lateinit var in your onAttach() or onCreate() method.\nval requestPermissionLauncher =\n    registerForActivityResult(RequestPermission()\n    ) { isGranted: Boolean ->\n        if (isGranted) {\n            // Permission is granted. Continue the action or workflow in your\n            // app.\n        } else {\n            // Explain to the user that the feature is unavailable because the\n            // features requires a permission that the user has denied. At the\n            // same time, respect the user's decision. Don't link to system\n            // settings in an effort to convince the user to change their\n            // decision.\n        }\n    }\n// Register the permissions callback, which handles the user's response to the\n// system permissions dialog. Save the return value, an instance of\n// ActivityResultLauncher, as an instance variable.\nprivate ActivityResultLauncher<String> requestPermissionLauncher =\n    registerForActivityResult(new RequestPermission(), isGranted -> {\n        if (isGranted) {\n            // Permission is granted. Continue the action or workflow in your\n            // app.\n        } else {\n            // Explain to the user that the feature is unavailable because the\n            // features requires a permission that the user has denied. At the\n            // same time, respect the user's decision. Don't link to system\n            // settings in an effort to convince the user to change their\n            // decision.\n        }\n    });\n以下代码段演示了检查权限并根据需要向用户请求权限的建议流程：\n\nwhen {\n    ContextCompat.checkSelfPermission(\n            CONTEXT,\n            Manifest.permission.REQUESTED_PERMISSION\n            ) == PackageManager.PERMISSION_GRANTED -> {\n        // You can use the API that requires the permission.\n    }\n    shouldShowRequestPermissionRationale(...) -> {\n        // In an educational UI, explain to the user why your app requires this\n        // permission for a specific feature to behave as expected. In this UI,\n        // include a \"cancel\" or \"no thanks\" button that allows the user to\n        // continue using your app without granting the permission.\n        showInContextUI(...)\n    }\n    else -> {\n        // You can directly ask for the permission.\n        // The registered ActivityResultCallback gets the result of this request.\n        requestPermissionLauncher.launch(\n                Manifest.permission.REQUESTED_PERMISSION)\n    }\n}\nif (ContextCompat.checkSelfPermission(\n        CONTEXT, Manifest.permission.REQUESTED_PERMISSION) ==\n        PackageManager.PERMISSION_GRANTED) {\n    // You can use the API that requires the permission.\n    performAction(...);\n} else if (shouldShowRequestPermissionRationale(...)) {\n    // In an educational UI, explain to the user why your app requires this\n    // permission for a specific feature to behave as expected. In this UI,\n    // include a \"cancel\" or \"no thanks\" button that allows the user to\n    // continue using your app without granting the permission.\n    showInContextUI(...);\n} else {\n    // You can directly ask for the permission.\n    // The registered ActivityResultCallback gets the result of this request.\n    requestPermissionLauncher.launch(\n            Manifest.permission.REQUESTED_PERMISSION);\n}\n自行管理权限请求代码\n作为允许系统管理权限请求代码的替代方法，您可以自行管理权限请求代码。为此，请在对 requestPermissions() 的调用中添加请求代码。\n\n以下代码段演示了如何使用请求代码来请求权限：\n\nwhen {\n    ContextCompat.checkSelfPermission(\n            CONTEXT,\n            Manifest.permission.REQUESTED_PERMISSION\n            ) == PackageManager.PERMISSION_GRANTED -> {\n        // You can use the API that requires the permission.\n        performAction(...)\n    }\n    shouldShowRequestPermissionRationale(...) -> {\n        // In an educational UI, explain to the user why your app requires this\n        // permission for a specific feature to behave as expected. In this UI,\n        // include a \"cancel\" or \"no thanks\" button that allows the user to\n        // continue using your app without granting the permission.\n        showInContextUI(...)\n    }\n    else -> {\n        // You can directly ask for the permission.\n        requestPermissions(CONTEXT,\n                arrayOf(Manifest.permission.REQUESTED_PERMISSION),\n                REQUEST_CODE)\n    }\n}\nif (ContextCompat.checkSelfPermission(\n        CONTEXT, Manifest.permission.REQUESTED_PERMISSION) ==\n        PackageManager.PERMISSION_GRANTED) {\n    // You can use the API that requires the permission.\n    performAction(...);\n} else if (shouldShowRequestPermissionRationale(...)) {\n    // In an educational UI, explain to the user why your app requires this\n    // permission for a specific feature to behave as expected. In this UI,\n    // include a \"cancel\" or \"no thanks\" button that allows the user to\n    // continue using your app without granting the permission.\n    showInContextUI(...);\n} else {\n    // You can directly ask for the permission.\n    requestPermissions(CONTEXT,\n            new String[] { Manifest.permission.REQUESTED_PERMISSION },\n            REQUEST_CODE);\n}\n当用户响应系统权限对话框后，系统就会调用应用的 onRequestPermissionsResult() 实现。系统会传入用户对权限对话框的响应以及您定义的请求代码，如以下代码段所示：\n\noverride fun onRequestPermissionsResult(requestCode: Int,\n        permissions: Array<String>, grantResults: IntArray) {\n    when (requestCode) {\n        PERMISSION_REQUEST_CODE -> {\n            // If request is cancelled, the result arrays are empty.\n            if ((grantResults.isNotEmpty() &&\n                    grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n                // Permission is granted. Continue the action or workflow\n                // in your app.\n            } else {\n                // Explain to the user that the feature is unavailable because\n                // the features requires a permission that the user has denied.\n                // At the same time, respect the user's decision. Don't link to\n                // system settings in an effort to convince the user to change\n                // their decision.\n            }\n            return\n        }// Add other 'when' lines to check for other\n        // permissions this app might request.\n        else -> {\n            // Ignore all other requests.\n        }\n    }\n}\n@Override\npublic void onRequestPermissionsResults(int requestCode, String[] permissions,\n        int[] grantResults) {\n    switch (requestCode) {\n        case PERMISSION_REQUEST_CODE:\n            // If request is cancelled, the result arrays are empty.\n            if (grantResults.length > 0 &&\n                    grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                // Permission is granted. Continue the action or workflow\n                // in your app.\n            }  else {\n                // Explain to the user that the feature is unavailable because\n                // the features requires a permission that the user has denied.\n                // At the same time, respect the user's decision. Don't link to\n                // system settings in an effort to convince the user to change\n                // their decision.\n            }\n            return;\n        }\n        // Other 'case' lines to check for other\n        // permissions this app might request.\n    }\n}\n处理权限请求遭拒情况\n如果用户拒绝了权限请求，应用应该帮助用户了解拒绝授予权限的影响。具体而言，应用应该让用户知道因缺少权限而无法使用的功能。在处理这种情况时，请牢记以下最佳做法：\n\n引导用户的注意力。在应用界面中突出显示因为应用没有必要的权限而受限的功能所在的具体部分。以下列举了几个例子说明您可以采取的做法：\n\n在该功能的结果或数据会出现的位置显示一条消息。\n显示一个包含错误图标并带有相应错误颜色的不同按钮。\n内容要具体。显示的消息不要空泛；而要指出因为应用没有必要的权限而无法使用的具体功能。\n\n不要阻止界面显示。换言之，不要显示全屏警告消息，让用户根本无法继续使用您的应用。\n\n在某些情况下，系统可能会自动拒绝权限，而无需用户执行任何操作。（同样，系统也可能会自动授予权限。）请千万不要对系统的自动行为做出任何假设。每当应用需要使用的功能需要权限时，您都应该检查应用是否仍被授予该权限。\n\n如需在请求应用权限时提供最佳用户体验，另请参阅应用权限最佳做法。\n\n在必要时请求成为默认处理程序\n有些应用依赖于访问与通话记录和短信有关的敏感用户信息。如果您想请求特定于通话记录和短信的权限，并将应用发布到 Play 商店，您必须在请求这些运行时权限之前，提示用户将应用设置为核心系统功能的默认处理程序。\n\n如需详细了解默认处理程序，包括有关如何向用户显示默认处理程序提示的指南，请参阅有关仅在默认处理程序中使用的权限的指南。\n\n按 API 级别声明权限\n如需仅在支持运行时权限的设备（即，搭载 Android 6.0（API 级别 23）或更高版本的设备）上声明某项权限，请添加 uses-permission-sdk-23 标记，而不是 uses-permission 标记。\n\n使用这些标记中的任意一个时，您都可以设置 maxSdkVersion 属性，用于指定在搭载更高版本的设备上不需要特定权限。\n\n其他资源\n如需详细了解权限，请阅读以下文章：\n\n权限概览\n应用权限最佳做法\n如需详细了解如何请求权限，请下载以下示例应用：\n\nAndroid RuntimePermissionsBasic 示例 Java | Kotlin"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242656436},"updatedAt":{"$$date":1597243254146},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"8Rd8aj5LdsFbd3ap"}
{"name":"andr-样式","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/style-resource\n样式资源  |  Android 开发者  |  Android Developers\n2-3 minutes\n样式资源定义界面的格式和外观。样式可应用于单个 View（从布局文件中）或应用于整个 Activity 或应用（从清单文件中）。\n\n如需详细了解如何创建和应用样式，请参阅样式和主题。\n\n注意：样式是使用 name 属性中提供的值（不是 XML 文件的名称）引用的简单资源。因此，您可以在一个 XML 文件中将样式资源与其他简单资源合并到一个 <resources> 元素下。\n\n文件位置：\nres/values/filename.xml\n该文件名可以任意设置。元素的 name 将用作资源 ID。\n资源引用：\n在 XML 中：@[package:]style/style_name\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <resources>\n        <style\n            name=\"style_name\"\n            parent=\"@[package:]style/style_to_inherit\">\n            <item\n                name=\"[package:]style_property_name\"\n                >style_value</item>\n        </style>\n    </resources>\n    \n元素：\n<resources>\n必需。该元素必须是根节点。\n没有属性。\n\n<style>\n定义单个样式。包含 <item> 元素。\n属性：\n\nname\n字符串。必需。样式的名称，用作将样式应用于 View、Activity 或应用的资源 ID。\nparent\n样式资源。对此样式应从中继承样式属性的样式的引用。\n<item>\n定义样式的单个属性。必须是 <style> 元素的子元素。\n属性：\n\nname\n属性资源。必需。要定义的样式属性的名称，必要时带有包前缀（例如 android:textColor）。\n示例：\n样式的 XML 文件（保存在 res/values/ 中）：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <resources>\n        <style name=\"CustomText\" parent=\"@style/Text\">\n            <item name=\"android:textSize\">20sp</item>\n            <item name=\"android:textColor\">#008</item>\n        </style>\n    </resources>\n    \n将样式应用于 TextView 的 XML 文件（保存在 res/layout/ 中）：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <EditText\n        style=\"@style/CustomText\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello, World!\" />\n    "}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242644630},"updatedAt":{"$$date":1597242925167},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"8RduqLTGpTlb7MoN"}
{"name":"py-dict","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\nPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n\n举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：\n\nnames = ['Michael', 'Bob', 'Tracy']\nscores = [95, 75, 85]\n给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。\n\n如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：\n\n>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\n>>> d['Michael']\n95\n为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。\n\n第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。\n\ndict就是第二种实现方式，给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。\n\n你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。\n\n把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：\n\n>>> d['Adam'] = 67\n>>> d['Adam']\n67\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\n\n>>> d['Jack'] = 90\n>>> d['Jack']\n90\n>>> d['Jack'] = 88\n>>> d['Jack']\n88\n如果key不存在，dict就会报错：\n\n>>> d['Thomas']\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'Thomas'\n要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：\n\n>>> 'Thomas' in d\nFalse\n二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：\n\n>>> d.get('Thomas')\n>>> d.get('Thomas', -1)\n-1\n注意：返回None的时候Python的交互环境不显示结果。\n\n要删除一个key，用pop(key)方法，对应的value也会从dict中删除：\n\n>>> d.pop('Bob')\n75\n>>> d\n{'Michael': 95, 'Tracy': 85}\n请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。\n\n和list比较，dict有以下几个特点：\n\n查找和插入的速度极快，不会随着key的增加而变慢；\n需要占用大量的内存，内存浪费多。\n而list相反：\n\n查找和插入的时间随着元素的增加而增加；\n占用空间小，浪费内存很少。\n所以，dict是用空间来换取时间的一种方法。\n\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n\n这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：\n\n>>> key = [1, 2, 3]\n>>> d[key] = 'a list'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unhashable type: 'list'"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973940470},"updatedAt":{"$$date":1594977047548},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"8SUnHPRXFtkBs512"}
{"name":"Robust","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"Android 热修复\n热补丁：让应用能够在无需重新安装的情况实现更新，帮助应用快速建立动态修复能力。\n热修复框架选型\n继插件化后，热补丁技术在2015年开始爆发，目前已经是非常热门的Android开发技术。其中比较著名的有淘宝的Dexposed、支付宝的AndFix以及QZone的超级热补丁方案。我们经过研究与尝试现有的各个方案，我们发现它们都有着自身的一些局限性，现如今大浪淘沙，我们最终选择适合的一种热修复方案 Robust。\nRobust 的优点 \n• 支持Android2.3-9.x版本（10.0 也支持）\n• 高兼容性、高稳定性，修复成功率高达99.9%\n• 补丁实时生效，不需要重新启动\n• 支持方法级别的修复，包括静态方法\n• 支持增加方法和类\n• 支持ProGuard的混淆、内联、优化等操作\nRobust 是否得到持续的技术支持？是否是KPI 项目？\n截止 2020年 3月29 日，美团一直在维护这个热修复框架，可以得到持续的支持，我们在此基础上进行优化，可以达到 BugFix 的效果。\nRobust 热修复原理\n打基础包时，Robust 为每个类新增了一个类型为 ChangeQuickRedirect 的静态变量，并且在每个方法前，增加判断该变量是否为空的逻辑，如果不为空，走打基础包时插桩的逻辑，否则走正常逻辑。我们反编译出基础包中的代码如下：\n//SecondActivity\npublic static ChangeQuickRedirect u;\nprotected void onCreate(Bundle bundle) {\n        if (u != null) {\n            if (PatchProxy.isSupport(new Object[]{bundle}, this, u, false, 78)) {\n                PatchProxy.accessDispatchVoid(new Object[]{bundle}, this, u, false, 78);\n                return;\n            }\n        }\n        super.onCreate(bundle);\n        ...\n    }\n热修复平台搭建\n运维依赖：\n1. 单独的oss 存储 patch 包\n2. 单独域名来存储 开发接口+https 配置\n补丁管理页面：\n• APK 版本 与补丁的对应\n• 可以支持多个补丁修复\n• 支持全量下发；条件下发；灰度下发\n后端接口：\n1. 上传patch 包接口\n2. 补丁列表接口\n3. 上报补丁修复成功率接口\n4. 针对用户发送主动发送推送接口\n5. 用户查询是否需要补丁修复接口\n测试资源：\n1. 系统版本兼容测试（4.x-10.0)版本\n2. 机型兼容测试 （vivo,oppo,华为等机型）\n3. 整理流程测试\n补丁成功率上报数据上报："}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598543897789},"updatedAt":{"$$date":1598544155853},"_id":"95JiqBT0uq2vDAiV","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"andr-颜色状态列表资源","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/color-list-resource\n颜色状态列表资源  |  Android 开发者  |  Android Developers\n4-4 minutes\nColorStateList 是一个您可以在 XML 中定义的对象，您可以将其作为颜色来应用，但它实际上会更改颜色，具体取决于其应用到的 View 对象的状态。例如，Button 微件可以处于多种不同状态中的一种（按下、聚焦或既不按下也不聚焦），而使用颜色状态列表，您可以为每种状态提供不同的颜色。\n\n您可以在 XML 文件中描述状态列表。每种颜色都在单个 <selector> 元素内的 <item> 元素中定义。每个 <item> 使用不同的属性描述其应在什么状态下使用。\n\n在每次状态更改期间，系统将从上到下遍历状态列表，并且将使用与当前状态匹配的第一项。系统的选择并非基于“最佳匹配”，而仅仅是基于符合状态的最低标准的第一项。\n\n注意：如果要提供静态颜色资源，请使用简单的颜色值。\n\n文件位置：\nres/color/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 ColorStateList 的资源指针。\n资源引用：\n在 Java 中：R.color.filename\n在 XML 中：@[package:]color/filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <selector xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n        <item\n            android:color=\"hex_color\"\n            android:state_pressed=[\"true\" | \"false\"]\n            android:state_focused=[\"true\" | \"false\"]\n            android:state_selected=[\"true\" | \"false\"]\n            android:state_checkable=[\"true\" | \"false\"]\n            android:state_checked=[\"true\" | \"false\"]\n            android:state_enabled=[\"true\" | \"false\"]\n            android:state_window_focused=[\"true\" | \"false\"] />\n    </selector>\n    \n元素：\n<selector>\n必需。该元素必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必需。定义 XML 命名空间，该命名空间必须为 \"http://schemas.android.com/apk/res/android\"。\n<item>\n定义在某些状态下使用的颜色，状态通过其属性来描述。必须是 <selector> 元素的子元素。\n属性：\n\nandroid:color\n十六进制颜色。必需。颜色通过 RGB 值和可选的 Alpha 通道指定。\n该值始终以井号 (#) 字符开头，后跟以下某种格式的“透明度、红、绿、蓝”(Alpha-Red-Green-Blue) 信息：\n\n#RGB\n#ARGB\n#RRGGBB\n#AARRGGBB\nandroid:state_pressed\n布尔值。如果此项应在按下对象时（例如轻触/点按了按钮时）使用，则为“true”；如果此项应在默认的非按下状态下使用，则为“false”。\nandroid:state_focused\n布尔值。如果此项应在聚焦对象时（例如使用轨迹球/方向键突出显示按钮时）使用，则为“true”；如果此项应在默认的非聚焦状态下使用，则为“false”。\nandroid:state_selected\n布尔值。如果此项应在选择对象时（例如打开标签页时）使用，则为“true”；如果此项应在未选择对象时使用，则为“false”。\nandroid:state_checkable\n布尔值。如果此项应在对象可勾选时使用，则为“true”；如果此项应在对象不可勾选时使用，则为“false”。（仅适用于对象可在可勾选和不可勾选的微件之间转换的情况。）\nandroid:state_checked\n布尔值。如果此项应在勾选对象时使用，则为“true”；如果应在取消勾选对象时使用，则为“false”。\nandroid:state_enabled\n布尔值。如果此项应在启用对象（能够接收轻触/点按事件）时使用，则为“true”；如果应在停用对象时使用，则为“false”。\nandroid:state_window_focused\n布尔值。如果此项应在应用窗口具有焦点（应用位于前台）时使用，则为“true”；如果此项应在应用窗口没有焦点时（例如通知栏下拉或出现一个对话框时）使用，则为“false”。\n注意：请注意，系统将应用状态列表中与对象的当前状态匹配的第一项。因此，如果列表中的第一项不包含上述任何状态属性，则每次都会应用该项，因此默认值应始终为最后一项，如以下示例所示。\n\n示例：\n保存于 res/color/button_text.xml 的 XML 文件：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n        <item android:state_pressed=\"true\"\n              android:color=\"#ffff0000\"/> <!-- pressed -->\n        <item android:state_focused=\"true\"\n              android:color=\"#ff0000ff\"/> <!-- focused -->\n        <item android:color=\"#ff000000\"/> <!-- default -->\n    </selector>\n    \n此布局 XML 会将颜色列表应用到 View：\n\n    <Button\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"@string/button_text\"\n        android:textColor=\"@color/button_text\" />\n    \n另请参阅：\n颜色（简单值）\nColorStateList\n状态列表可绘制对象"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242356080},"updatedAt":{"$$date":1597242563574},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9CcNS7Ui55ziBJzu"}
{"name":"css-CSS Display(显示) 与 Visibility（可见性）","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS Display(显示) 与 Visibility（可见性）\ndisplay属性设置一个元素应如何显示，visibility属性指定一个元素应可见还是隐藏。\n\nBox 1\n\nBox 2\nBox 3\n\n隐藏元素 - display:none或visibility:hidden\n隐藏一个元素可以通过把display属性设置为\"none\"，或把visibility属性设置为\"hidden\"。但是请注意，这两种方法会产生不同的结果。\n\nvisibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。\n\n实例\nh1.hidden {visibility:hidden;}\n\n尝试一下 »\ndisplay:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。\n\n实例\nh1.hidden {display:none;}\n\n尝试一下 »\n\nCSS Display - 块和内联元素\n块元素是一个元素，占用了全部宽度，在前后都是换行符。\n\n块元素的例子：\n\n<h1>\n<p>\n<div>\n内联元素只需要必要的宽度，不强制换行。\n\n内联元素的例子：\n\n<span>\n<a>\n如何改变一个元素显示\n可以更改内联元素和块元素，反之亦然，可以使页面看起来是以一种特定的方式组合，并仍然遵循web标准。\n\n下面的示例把列表项显示为内联元素：\n\n实例\nli {display:inline;}\n\n尝试一下 »\n下面的示例把span元素作为块元素：\n\n实例\nspan {display:block;}\n\n尝试一下 »\n注意：变更元素的显示类型看该元素是如何显示，它是什么样的元素。例如：一个内联元素设置为display:block是不允许有它内部的嵌套块元素。\n\nExamples\n更多实例\n如何显示元素的内联元素。\n\n这个例子演示了如何显示一个元素的内联元素。\n\n如何显示元素的块元素。\n\n这个例子演示了如何显示一个元素的块元素。\n\n如何使用一个表的collapse属性。\n\n这个例子演示了如何使用表的collapse属性。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888560619},"updatedAt":{"$$date":1598973579227},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9D8lAtLgOwt2ANbo"}
{"name":"Android支付业务场景和方式","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"安卓几大联运支付规则\n渠道\n支付\nks/其余\n支付宝+微信+招行支付\n华为\n支付宝+微信+华为支付\noppo\n支付宝+微信+oppo支付\n小米分包\n支付宝+微信+小米支付\n业务场景和支付方式\n业务场景\n支付方式\nKb充值\n微信，支付宝，华为，oppo，招商，小米\n礼品卡\nKb,华为，微信，支付宝，oppo，招商，小米\n会员礼品卡\nKb,华为，微信，支付宝，oppo，招商\n会员礼品卡（给H5提供）\nKb,华为，微信，支付宝，oppo，招商\n会员卡\nKb,华为，微信，支付宝，oppo，招商，小米\n会员卡（给H5提供）\nKb,华为，微信，支付宝，oppo，招商，小米\n会员前置\nKb，华为，微信，支付宝，oppo，招商，小米\n购买故事商品\nKb,华为，微信，支付宝，oppo，招商，小米\n购买故事商品（给H5提供）\nKb,华为，微信，支付宝，oppo，招商，小米\n电商商品购买\n微信，支付宝"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598547685889},"updatedAt":{"$$date":1598548085180},"_id":"9EPBnFTNMBRYz51y","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-Kotlin 泛型 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-generics.html\nKotlin 泛型 | 菜鸟教程\n4-4 minutes\n泛型，即 \"参数化类型\"，将类型参数化，可以用在类，接口，方法上。\n\n与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。\n\n声明一个泛型类:\n\nclass Box<T>(t: T) {\n    var value = t\n}\n创建类的实例时我们需要指定类型参数:\n\nval box: Box<Int> = Box<Int>(1)\n// 或者\nval box = Box(1) // 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box<Int>。\n以下实例向泛型类 Box 传入整型数据和字符串：\n\nclass Box<T>(t : T) {\n    var value = t\n}\n\nfun main(args: Array<String>) {\n    var boxInt = Box<Int>(10)\n    var boxString = Box<String>(\"Runoob\")\n\n    println(boxInt.value)\n    println(boxString.value)\n}\n输出结果为：\n\n10\nRunoob\n定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。\n\nKotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：\n\nfun <T> boxIn(value: T) = Box(value)\n\n// 以下都是合法语句\nval box4 = boxIn<Int>(1)\nval box5 = boxIn(1)     // 编译器会进行类型推断\n在调用泛型函数时，如果可以推断出类型参数，可以省略泛型参数。\n\n以下实例创建了泛型函数 doPrintln，函数根据传入的不同类型做相应处理：\n\nfun main(args: Array<String>) {\n    val age = 23\n    val name = \"runoob\"\n    val bool = true\n\n    doPrintln(age)    // 整型\n    doPrintln(name)   // 字符串\n    doPrintln(bool)   // 布尔型\n}\n\nfun <T> doPrintln(content: T) {\n\n    when (content) {\n        is Int -> println(\"整型数字为 $content\")\n        is String -> println(\"字符串转换为大写：${content.toUpperCase()}\")\n        else -> println(\"T 不是整型，也不是字符串\")\n    }\n}\n输出结果为：\n\n整型数字为 23\n字符串转换为大写：RUNOOB\nT 不是整型，也不是字符串\n泛型约束\n我们可以使用泛型约束来设定一个给定参数允许使用的类型。\n\nKotlin 中使用 : 对泛型的类型上限进行约束。\n\n最常见的约束是上界(upper bound)：\n\nfun <T : Comparable<T>> sort(list: List<T>) {\n    // ……\n}\nComparable 的子类型可以替代 T。 例如:\n\nsort(listOf(1, 2, 3)) // OK。Int 是 Comparable<Int> 的子类型\nsort(listOf(HashMap<Int, String>())) // 错误：HashMap<Int, String> 不是 Comparable<HashMap<Int, String>> 的子类型\n默认的上界是 Any?。\n\n对于多个上界约束条件，可以用 where 子句：\n\nfun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>\n    where T : CharSequence,\n          T : Comparable<T> {\n    return list.filter { it > threshold }.map { it.toString() }\n}\n型变\nKotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。\n\n声明处型变\n声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。\n\n使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：\n\n// 定义一个支持协变的类\nclass Runoob<out A>(val a: A) {\n    fun foo(): A {\n        return a\n    }\n}\n\nfun main(args: Array<String>) {\n    var strCo: Runoob<String> = Runoob(\"a\")\n    var anyCo: Runoob<Any> = Runoob<Any>(\"b\")\n    anyCo = strCo\n    println(anyCo.foo())   // 输出 a\n}\nin 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：\n\n// 定义一个支持逆变的类\nclass Runoob<in A>(a: A) {\n    fun foo(a: A) {\n    }\n}\n\nfun main(args: Array<String>) {\n    var strDCo = Runoob(\"a\")\n    var anyDCo = Runoob<Any>(\"b\")\n    strDCo = anyDCo\n}\n星号投射\n有些时候, 你可能想表示你并不知道类型参数的任何信息, 但是仍然希望能够安全地使用它. 这里所谓\"安全地使用\"是指, 对泛型类型定义一个类型投射, 要求这个泛型类型的所有的实体实例, 都是这个投射的子类型。\n\n对于这个问题, Kotlin 提供了一种语法, 称为 星号投射(star-projection):\n\n假如类型定义为 Foo<out T> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper ,Foo<> 等价于 Foo<out TUpper> . 它表示, 当 T 未知时, 你可以安全地从 Foo<> 中 读取TUpper 类型的值.\n假如类型定义为 Foo<in T> , 其中 T 是一个反向协变的类型参数, Foo<> 等价于 Foo<inNothing> . 它表示, 当 T 未知时, 你不能安全地向 Foo<> 写入 任何东西.\n假如类型定义为 Foo<T> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper , 对于读取值的场合, Foo<*> 等价于 Foo<out TUpper> , 对于写入值的场合, 等价于 Foo<in Nothing> .\n如果一个泛型类型中存在多个类型参数, 那么每个类型参数都可以单独的投射. 比如, 如果类型定义为interface Function<in T, out U> , 那么可以出现以下几种星号投射:\n\nFunction<*, String> , 代表 Function<in Nothing, String> ;\nFunction<Int, *> , 代表 Function<Int, out Any?> ;\nFunction<, > , 代表 Function<in Nothing, out Any?> .\n注意: 星号投射与 Java 的原生类型(raw type)非常类似, 但可以安全使用"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304148711},"updatedAt":{"$$date":1597304297171},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9MZXOe8JlHPA5715"}
{"name":"ad-kscocos2dx","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        ndk {\n            abiFilters 'armeabi-v7a'\n        }\n    }\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n            java {\n                srcDirs += []\n            }\n        }\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n    splits {//删除64位的so库\n        abi {\n            enable true\n            reset()\n            include 'armeabi-v7a'\n            universalApk false\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\narmeabi-v7a\n   android-async-http-1.4.9.jar\n   com.android.vending.expansion.zipfile.jar\n   httpclient-4.4.1.1.jar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522792643},"updatedAt":{"$$date":1598523335083},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9RfzpAVaqWAo2Mqf"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598974375702},"updatedAt":{"$$date":1598974375702},"_id":"9e6A0NHTZvaVfrU8"}
{"name":"ad-dependencies.gradle","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\ndef versions = [\n        // gradle_plugin\n        gradle_plugin       : \"4.0.0\",\n        kotlin_version      : \"1.3.61\",\n        androidx            : \"1.2.0-alpha03\",\n        support             : \"1.1.0\",\n        junit               : \"4.12\",\n        fresco              : \"1.11.0\",\n        kotlin_coroutines   : '1.3.3',\n        roomVersion         : '2.2.1',\n        archLifecycleVersion: '2.2.0-rc03',\n        coroutines          : '1.3.2',\n        constraint_layout   : \"1.1.3\",\n\n\n        retrofit            : \"2.7.1\",\n        okhttp3             : \"4.2.0\",\n        multidex            : \"1.0.3\",\n\n\n]\n\n\next {\n    app_id = \"com.ks.frame\"\n    useLibrary = \"org.apache.http.legacy\"   //兼容httpclient\n\n    testInstrumentationRunner = \"android.support.test.runner.AndroidJUnitRunner\"\n\n    signConfig = [\n            storeFile    : \"../../config/kaishustory.jks\",\n            storePassword: \"kaishu2099\",\n            keyAlias     : \"kaishustory\",\n            keyPassword  : \"kaishu2099\",\n    ]\n\n    signAloneConfig = [\n            storeFile    : \"../../../config/kaishustory.jks\",\n            storePassword: \"kaishu2099\",\n            keyAlias     : \"kaishustory\",\n            keyPassword  : \"kaishu2099\",\n    ]\n\n    build_versions = [\n            compile_sdk : 28,\n            min_sdk     : 17,\n            target_sdk  : 28,\n            tool_version: \"28.0.3\",\n\n            versionCode : 100,\n            versionName : \"1.0.0\",\n    ]\n\n    project_plugin = [\n            gradle_plugin   : \"com.android.tools.build:gradle:${versions.gradle_plugin}\",\n            kotlin_plugin   : \"org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin_version}\",\n            arouter_plugin  : \"com.alibaba:arouter-register:${versions.arouter_register}\",\n            packer_np_plugin: \"com.mcxiaoke.packer-ng:plugin:${versions.packer_np_plugin}\",\n    ]\n\n    deps = [\n            //support 系统库\n            androidx     : [\n                    core                    : \"androidx.core:core-ktx:1.1.0\",\n                    app_compat              : \"androidx.appcompat:appcompat:${versions.androidx}\",\n                    design                  : \"com.google.android.material:material:${versions.support}\",\n                    constraint_layout       : \"androidx.constraintlayout:constraintlayout:${versions.constraint_layout}\",\n                    cardview                : \"androidx.cardview:cardview:1.0.0\",\n                    multidex                : \"androidx.multidex:multidex:${versions.multidex}\",\n                    support_v4              : \"androidx.legacy:legacy-support-v4:${versions.support}\",\n                    fragment                : \"androidx.fragment:fragment:${versions.support}\",\n                    palette                 : \"androidx.palette:palette:${versions.support}\",\n                    recyclerview_v7         : \"androidx.recyclerview:recyclerview:${versions.support}\",\n                    annotations_experimental: \"androidx.annotation:annotation-experimental:${versions.support}\",\n                    annotations             : \"androidx.annotation:annotation:${versions.support}\",\n            ],\n\n            test         : [\n                    junit       : \"junit:junit:${versions.junit}\",\n                    test_runner : \"androidx.test:runner:1.2.0\",\n                    spresso_core: \"androidx.test.espresso:espresso-core:3.2.0\",\n                    ext_junit   : \"androidx.test.ext:junit:1.1.1\"\n\n            ],\n\n            //kotlin\n            kotlin       : [\n                    kotlin_stdlib_jdk : \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:${versions.kotlin_version}\",\n                    kotlin_reflect    : \"org.jetbrains.kotlin:kotlin-reflect:${versions.kotlin_version}\",\n\n                    coroutines_core   : \"org.jetbrains.kotlinx:kotlinx-coroutines-core:${versions.kotlin_coroutines}\",\n                    coroutines_android: \"org.jetbrains.kotlinx:kotlinx-coroutines-android:${versions.kotlin_coroutines}\"\n            ],\n\n            archLifecycle: [\n                    lifecycle_viewmodel_ktx: \"androidx.lifecycle:lifecycle-viewmodel-ktx:${versions.archLifecycleVersion}\",\n                    lifecycle_livedata_ktx : \"androidx.lifecycle:lifecycle-livedata-ktx:${versions.archLifecycleVersion}\",\n                    lifecycle_compiler     : \"androidx.lifecycle:lifecycle-compiler:${versions.archLifecycleVersion}\",\n                    lifecycle_extensions   : \"androidx.lifecycle:lifecycle-extensions:${versions.archLifecycleVersion}\"\n            ],\n\n            room         : [\n\n                    room_runtime : \"androidx.room:room-runtime:${versions.roomVersion}\",\n                    room_ktx     : \"androidx.room:room-ktx:${versions.roomVersion}\",\n                    room_compiler: \"androidx.room:room-compiler:${versions.roomVersion}\"\n            ],\n\n            //retrofit相关依赖--网络请求封装\n            retrofit     : [\n                    retrofit      : \"com.squareup.retrofit2:retrofit:${versions.retrofit}\",\n                    converter_gson: \"com.squareup.retrofit2:converter-gson:${versions.retrofit}\",\n            ],\n\n            //okhttp相关依赖--网络请求\n            okhttp3      : [\n                    okhttp             : \"com.squareup.okhttp3:okhttp:${versions.okhttp3}\",\n                    logging_interceptor: \"com.squareup.okhttp3:logging-interceptor:${versions.okhttp3}\"\n            ],\n\n            //fresco相关依赖--图片显示\n            fresco       : [\n                    fresco              : \"com.facebook.fresco:fresco:${versions.fresco}\",\n                    imagepipeline_okhttp: \"com.facebook.fresco:imagepipeline-okhttp3:${versions.fresco}\",\n                    animated_gif        : \"com.facebook.fresco:animated-gif:${versions.fresco}\",\n            ],\n\n\n            //多线程通讯\n            eventbus     : \"org.greenrobot:eventbus:3.1.1\",\n            google_gson  : \"com.google.code.gson:gson:2.8.5\",\n            tecentX5     : \"com.tencent.tbs.tbssdk:sdk:43903\",\n    ]\n\n\n}\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539538718},"updatedAt":{"$$date":1598539707695},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"9l1SDRUB4RZYSEPJ"}
{"name":"py-max","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n而max函数max()可以接收任意多个参数，并返回最大的那个：\n\n>>> max(1, 2)\n2\n>>> max(2, 3, 1, -5)\n3\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973942744},"updatedAt":{"$$date":1594977252280},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9xJkNCQNKsPvdW6g"}
{"name":"kotlin-基础 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/coroutines/basics.html\n基础 - Kotlin 语言中文站\n19-24 minutes\n改进翻译\n目录\n\n协程基础\n第一个协程程序\n桥接阻塞与非阻塞的世界\n等待一个作业\n结构化的并发\n作用域构建器\n提取函数重构\n协程很轻量\n全局协程像守护线程\n这一部分包括基础的协程概念。\n\n运行以下代码：\n\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // 在后台启动一个新的协程并继续\n        delay(1000L) // 非阻塞的等待 1 秒钟（默认时间单位是毫秒）\n        println(\"World!\") // 在延迟后打印输出\n    }\n    println(\"Hello,\") // 协程已在等待时主线程还在继续\n    Thread.sleep(2000L) // 阻塞主线程 2 秒钟来保证 JVM 存活\n}\n可以在这里获取完整代码。\n\n代码运行的结果：\n\nHello,\nWorld!\n本质上，协程是轻量级的线程。 它们在某些 CoroutineScope 上下文中与 launch 协程构建器 一起启动。 这里我们在 GlobalScope 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制。\n\n可以将 GlobalScope.launch { …… } 替换为 thread { …… }，并将 delay(……) 替换为 Thread.sleep(……) 达到同样目的。 试试看（不要忘记导入 kotlin.concurrent.thread）。\n\n如果你首先将 GlobalScope.launch 替换为 thread，编译器会报以下错误：\n\nError: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function\n这是因为 delay 是一个特殊的 挂起函数 ，它不会造成线程阻塞，但是会 挂起 协程，并且只能在协程中使用。\n\n第一个示例在同一段代码中混用了 非阻塞的 delay(……) 与 阻塞的 Thread.sleep(……)。 这容易让我们记混哪个是阻塞的、哪个是非阻塞的。 让我们显式使用 runBlocking 协程构建器来阻塞：\n\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // 在后台启动一个新的协程并继续\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // 主线程中的代码会立即执行\n    runBlocking {     // 但是这个表达式阻塞了主线程\n        delay(2000L)  // ……我们延迟 2 秒来保证 JVM 的存活\n    } \n}\n可以在这里获取完整代码。\n\n结果是相似的，但是这些代码只使用了非阻塞的函数 delay。 调用了 runBlocking 的主线程会一直 阻塞 直到 runBlocking 内部的协程执行完毕。\n\n这个示例可以使用更合乎惯用法的方式重写，使用 runBlocking 来包装 main 函数的执行：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // 开始执行主协程\n    GlobalScope.launch { // 在后台启动一个新的协程并继续\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // 主协程在这里会立即执行\n    delay(2000L)      // 延迟 2 秒来保证 JVM 存活\n}\n可以在这里获取完整代码。\n\n这里的 runBlocking<Unit> { …… } 作为用来启动顶层主协程的适配器。 我们显式指定了其返回类型 Unit，因为在 Kotlin 中 main 函数必须返回 Unit 类型。\n\n这也是为挂起函数编写单元测试的一种方式：\n\nclass MyTest {\n    @Test\n    fun testMySuspendingFunction() = runBlocking<Unit> {\n        // 这里我们可以使用任何喜欢的断言风格来使用挂起函数\n    }\n}\n延迟一段时间来等待另一个协程运行并不是一个好的选择。让我们显式（以非阻塞方式）等待所启动的后台 Job 执行结束：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = GlobalScope.launch { // 启动一个新协程并保持对这个作业的引用\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    job.join() // 等待直到子协程执行结束\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n现在，结果仍然相同，但是主协程与后台作业的持续时间没有任何关系了。好多了。\n\n协程的实际使用还有一些需要改进的地方。 当我们使用 GlobalScope.launch 时，我们会创建一个顶层协程。虽然它很轻量，但它运行时仍会消耗一些内存资源。如果我们忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样（例如，我们错误地延迟了太长时间），如果我们启动了太多的协程并导致内存不足会怎么样？ 必须手动保持对所有已启动协程的引用并 join 之很容易出错。\n\n有一个更好的解决办法。我们可以在代码中使用结构化并发。 我们可以在执行操作所在的指定作用域内启动协程， 而不是像通常使用线程（线程总是全局的）那样在 GlobalScope 中启动。\n\n在我们的示例中，我们使用 runBlocking 协程构建器将 main 函数转换为协程。 包括 runBlocking 在内的每个协程构建器都将 CoroutineScope 的实例添加到其代码块所在的作用域中。 我们可以在这个作用域中启动协程而无需显式 join 之，因为外部协程（示例中的 runBlocking）直到在其作用域中启动的所有协程都执行完毕后才会结束。因此，可以将我们的示例简化为：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { // 在 runBlocking 作用域中启动一个新协程\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n}\n可以在这里获取完整代码。\n\n除了由不同的构建器提供协程作用域之外，还可以使用 coroutineScope 构建器声明自己的作用域。它会创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束。\n\nrunBlocking 与 coroutineScope 可能看起来很类似，因为它们都会等待其协程体以及所有子协程结束。 主要区别在于，runBlocking 方法会阻塞当前线程来等待， 而 coroutineScope 只是挂起，会释放底层线程用于其他用途。 由于存在这点差异，runBlocking 是常规函数，而 coroutineScope 是挂起函数。\n\n可以通过以下示例来演示：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { \n        delay(200L)\n        println(\"Task from runBlocking\")\n    }\n    \n    coroutineScope { // 创建一个协程作用域\n        launch {\n            delay(500L) \n            println(\"Task from nested launch\")\n        }\n    \n        delay(100L)\n        println(\"Task from coroutine scope\") // 这一行会在内嵌 launch 之前输出\n    }\n    \n    println(\"Coroutine scope is over\") // 这一行在内嵌 launch 执行完毕后才输出\n}\n可以在这里获取完整代码。\n\n请注意，（当等待内嵌 launch 时）紧挨“Task from coroutine scope”消息之后， 就会执行并输出“Task from runBlocking”——尽管 coroutineScope 尚未结束。\n\n我们来将 launch { …… } 内部的代码块提取到独立的函数中。当你对这段代码执行“提取函数”重构时，你会得到一个带有 suspend 修饰符的新函数。 这是你的第一个挂起函数。在协程内部可以像普通函数一样使用挂起函数， 不过其额外特性是，同样可以使用其他挂起函数（如本例中的 delay）来挂起协程的执行。\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    launch { doWorld() }\n    println(\"Hello,\")\n}\n\n// 这是你的第一个挂起函数\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"World!\")\n}\n可以在这里获取完整代码。\n\n但是如果提取出的函数包含一个在当前作用域中调用的协程构建器的话，该怎么办？ 在这种情况下，所提取函数上只有 suspend 修饰符是不够的。为 CoroutineScope 写一个 doWorld 扩展方法是其中一种解决方案，但这可能并非总是适用，因为它并没有使 API 更加清晰。 惯用的解决方案是要么显式将 CoroutineScope 作为包含该函数的类的一个字段， 要么当外部类实现了 CoroutineScope 时隐式取得。 作为最后的手段，可以使用 CoroutineScope(coroutineContext)，不过这种方法结构上不安全， 因为你不能再控制该方法执行的作用域。只有私有 API 才能使用这个构建器。\n\n运行以下代码：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    repeat(100_000) { // 启动大量的协程\n        launch {\n            delay(5000L)\n            print(\".\")\n        }\n    }\n}\n可以在这里获取完整代码。\n\n它启动了 10 万个协程，并且在 5 秒钟后，每个协程都输出一个点。\n\n现在，尝试使用线程来实现。会发生什么？（很可能你的代码会产生某种内存不足的错误）\n\n以下代码在 GlobalScope 中启动了一个长期运行的协程，该协程每秒输出“I'm sleeping”两次，之后在主函数中延迟一段时间后返回。\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    GlobalScope.launch {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // 在延迟后退出\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n你可以运行这个程序并看到它输出了以下三行后终止：\n\nI'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\n在 GlobalScope 中启动的活动协程并不会使进程保活。它们就像守护线程。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382140847},"updatedAt":{"$$date":1597386554165},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9zC8KjRNRbTjr529"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598525726884},"updatedAt":{"$$date":1598538114486},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9zLXbRYACo5QOVny"}
{"name":"css-CSS Position(定位)","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS Position(定位)\nposition 属性指定了元素的定位类型。\n\nposition 属性的五个值：\n\nstatic\nrelative\nfixed\nabsolute\nsticky\n元素可以使用的顶部，底部，左侧和右侧属性定位。然而，这些属性无法工作，除非是先设定position属性。他们也有不同的工作方式，这取决于定位方法。\n\nstatic 定位\nHTML 元素的默认值，即没有定位，遵循正常的文档流对象。\n\n静态定位的元素不会受到 top, bottom, left, right影响。\n\n实例\ndiv.static {\n    position: static;\n    border: 3px solid #73AD21;\n}\n\n尝试一下 »\nfixed 定位\n元素的位置相对于浏览器窗口是固定位置。\n\n即使窗口是滚动的它也不会移动：\n\n实例\np.pos_fixed\n{\n    position:fixed;\n    top:30px;\n    right:5px;\n}\n\n尝试一下 »\n注意： Fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才能支持。\n\nFixed定位使元素的位置与文档流无关，因此不占据空间。\n\nFixed定位的元素和其他元素重叠。\n\nrelative 定位\n相对定位元素的定位是相对其正常位置。\n\n实例\nh2.pos_left\n{\n    position:relative;\n    left:-20px;\n}\nh2.pos_right\n{\n    position:relative;\n    left:20px;\n}\n\n尝试一下 »\n移动相对定位元素，但它原本所占的空间不会改变。\n\n实例\nh2.pos_top\n{\n    position:relative;\n    top:-50px;\n}\n\n尝试一下 »\n相对定位元素经常被用来作为绝对定位元素的容器块。\n\nabsolute 定位\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>:\n\n实例\nh2\n{\n    position:absolute;\n    left:100px;\n    top:150px;\n}\n\n尝试一下 »\nabsolute 定位使元素的位置与文档流无关，因此不占据空间。\n\nabsolute 定位的元素和其他元素重叠。\n\nsticky 定位\nsticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。\n\nposition: sticky; 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。\n\n它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。\n\n元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n注意: Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。\n\n实例\ndiv.sticky {\n    position: -webkit-sticky; /* Safari */\n    position: sticky;\n    top: 0;\n    background-color: green;\n    border: 2px solid #4CAF50;\n}\n\n尝试一下 »\n重叠的元素\n元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素\n\nz-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）\n\n一个元素可以有正数或负数的堆叠顺序：\n\n实例\nimg\n{\n    position:absolute;\n    left:0px;\n    top:0px;\n    z-index:-1;\n}\n\n尝试一下 »\n具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。\n\n注意： 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面。\n\nExamples\n更多实例\n裁剪元素的外形\n\n此示例演示如何设置元素的外形。该元素被剪裁成这种形状，并显示出来。\n\n如何使用滚动条来显示元素内溢出的内容\n\n这个例子演示了overflow属性创建一个滚动条，当一个元素的内容在指定的区域过大时如何设置以适应。\n\n如何设置浏览器自动溢出处理\n\n这个例子演示了如何设置浏览器来自动处理溢出。\n\n更改光标\n\n这个例子演示了如何改变光标。\n\n所有的CSS定位属性\n\"CSS\" 列中的数字表示哪个CSS(CSS1 或者CSS2)版本定义了该属性。\n\n属性\t说明\t值\tCSS\nbottom\t定义了定位元素下外边距边界与其包含块下边界之间的偏移。\tauto\nlength\n%\ninherit\t2\nclip\t剪辑一个绝对定位的元素\tshape\nauto\ninherit\t2\ncursor\t显示光标移动到指定的类型\turl\nauto\ncrosshair\ndefault\npointer\nmove\ne-resize\nne-resize\nnw-resize\nn-resize\nse-resize\nsw-resize\ns-resize\nw-resize\ntext\nwait\nhelp\t2\nleft\t定义了定位元素左外边距边界与其包含块左边界之间的偏移。\tauto\nlength\n%\ninherit\t2\noverflow\n设置当元素的内容溢出其区域时发生的事情。\tauto\nhidden\nscroll\nvisible\ninherit\t2\noverflow-y\n指定如何处理顶部/底部边缘的内容溢出元素的内容区域\tauto\nhidden\nscroll\nvisible\nno-display\nno-content\t2\noverflow-x\n指定如何处理右边/左边边缘的内容溢出元素的内容区域\tauto\nhidden\nscroll\nvisible\nno-display\nno-content\t2\nposition\t指定元素的定位类型\tabsolute\nfixed\nrelative\nstatic\ninherit\t2\nright\t定义了定位元素右外边距边界与其包含块右边界之间的偏移。\tauto\nlength\n%\ninherit\t2\ntop\t定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。\tauto\nlength\n%\ninherit\t2\nz-index\t设置元素的堆叠顺序\tnumber\nauto\ninherit\t2\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598889297398},"updatedAt":{"$$date":1598973671571},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"A7Z4EynUxuQ9WzXF"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973282995},"updatedAt":{"$$date":1594973282995},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"A9c3Q3zNiJikoHg3"}
{"name":"qk-ks_lib_persistence","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    packagingOptions {\n        exclude 'META-INF/atomicfu.kotlin_module'\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    api deps.kotlin.stdlib_jdk\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n\n    //room\n    api deps.room.room_runtime\n    api deps.room.room_ktx\n    kapt deps.room.room_compiler\n\n    // Lifecycle components\n    implementation deps.archLifecycle.lifecycle_extensions\n    kapt deps.archLifecycle.lifecycle_compiler\n\n    // ViewModel Kotlin support\n    implementation deps.archLifecycle.lifecycle_viewmodel_ktx\n\n\n    // Coroutines\n    api deps.kotlin.coroutines_android\n}\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n@Entity(tableName = \"cache\")\ndata class Cache(@PrimaryKey @ColumnInfo(name = \"key\") var key: String, @ColumnInfo(name = \"_data\") var data: ByteArray?) {\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (javaClass != other?.javaClass) return false\n\n        other as Cache\n\n        if (key != other.key) return false\n        if (data != null) {\n            if (other.data == null) return false\n            if (!data!!.contentEquals(other.data!!)) return false\n        } else if (other.data != null) return false\n\n        return true\n    }\n\n    override fun hashCode(): Int {\n        var result = key.hashCode()\n        result = 31 * result + (data?.contentHashCode() ?: 0)\n        return result\n    }\n}\n\n\n\n\n@Database(entities = [Cache::class], version = 1, exportSchema = false)\nabstract class CacheRoomDatabase : RoomDatabase() {\n    abstract fun cacheDao(): CacheDao\n\n    companion object {\n        @Volatile\n        private var INSTANCE: CacheRoomDatabase? = null\n\n        fun getDatabase(context: Context, scope: CoroutineScope): CacheRoomDatabase {\n            val tempInstance = INSTANCE\n            if (tempInstance != null) {\n                return tempInstance\n            }\n            synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    CacheRoomDatabase::class.java,\n                    \"ks_cache_database\"\n                )\n                    .addCallback(\n                        WordDatabaseCallback(scope)\n                    )\n                    .build()\n\n                INSTANCE = instance\n                return instance\n            }\n        }\n    }\n\n    private class WordDatabaseCallback(private val scope: CoroutineScope\n    ) : RoomDatabase.Callback() {\n\n        override fun onOpen(db: SupportSQLiteDatabase) {\n            super.onOpen(db)\n            INSTANCE?.let { database ->\n                scope.launch(Dispatchers.IO) {\n                    populateDatabase(database.cacheDao())\n                }\n            }\n        }\n\n        suspend fun populateDatabase(wordDao: CacheDao) {\n            // when you want to execute something on database open\n//            wordDao.deleteAll()\n//\n//            var word = Word(\"Hello\")\n//            wordDao.insert(word)\n//            word = Word(\"World!\")\n//            wordDao.insert(word)\n        }\n    }\n\n}\n\n\n@Dao\ninterface CacheDao {\n\n    /**\n     *  存储缓存对象\n     * @param cache Cache 存储数据\n     * @return Long 是否成功\n     */\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun save(cache: Cache): Long\n\n    /**\n     * 获取缓存对象\n     * @param key String 缓存对象key\n     * @return Cache 缓存数据\n     */\n    @Query(\"select *from cache where `key`=:key\")\n    fun getCache(key: String): Cache\n\n    /**\n     * 删除缓存对象\n     * @param cache Cache 缓存数据\n     * @return Int 是否成功\n     */\n    @Delete\n    suspend fun delete(cache: Cache): Int\n\n    /**\n     * 更新缓存数据对象\n     * @param cache Cache 缓存数据\n     * @return Int\n     */\n    @Update(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun update(cache: Cache): Int\n}\n\n\n\n\n\nclass CacheRepository(private val cacheDao: CacheDao) {\n\n    @WorkerThread\n    fun get(key: String): Cache = cacheDao.getCache(key)\n\n    @WorkerThread\n    suspend fun save(cache: Cache) {\n        cacheDao.save(cache)\n    }\n\n    @WorkerThread\n    suspend fun delete(cache: Cache) {\n        cacheDao.delete(cache)\n    }\n\n    @WorkerThread\n    suspend fun update(cache: Cache) {\n        cacheDao.update(cache)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nval ViewModel.viewModelScope: CoroutineScope\n        get() {\n            val scope: CoroutineScope? = this.getTag(JOB_KEY)\n            if (scope != null) {\n                return scope\n            }\n            return setTagIfAbsent(JOB_KEY,\n                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))\n        }\n\ninternal class CloseableCoroutineScope(context: CoroutineContext) : Closeable, CoroutineScope {\n    override val coroutineContext: CoroutineContext = context\n\n    override fun close() {\n        coroutineContext.cancel()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580907555},"updatedAt":{"$$date":1598583269113},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AEM7AWHGoshR3OJJ"}
{"name":"kotlin-BusMsg","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\npackage com.ks.lightlearn.base.bean.eventbus\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author wuzhiguo\n * 邮箱：wuzhiguo@ksjgs.com\n * 创建时间: 2020-02-27     10:56\n * 用途:\n ***************************************\n */\nclass BusMsg<T : Any?> {\n\n    var code: Int = 0\n    var data: T? = null\n\n\n    constructor(code: Int, data: T) {\n        this.code = code\n        this.data = data\n    }\n\n    override fun toString(): String {\n        return \"EventMessage{code=$code, data=$data}\"\n    }\n\n    companion object {\n\n        /**********************************************商品模块 Start*****************************************************************/\n        const val PRODUCT_ADDRESS_SELECT_EVENT = 0x20001\n        const val PRODUCT_ADDRESS_ADD_SELECT_EVENT = 0x20002\n        const val PRODUCT_ADDRESS_UPDATE_SELECT_EVENT = 0x20003\n        const val PRODUCT_ADDRESS_DELETE_ALL_EVENT = 0x20004\n        /**********************************************商品模块 End*****************************************************************/\n\n        /**********************************************登录模块 Start*****************************************************************/\n        const val SIGN_IN = 0x30001\n        const val SIGN_OUT = 0x30002\n        const val UPDATE_USER_INFO = 0x30003\n        const val LOGIN_CLOSE_LOGIN_PAGE_EVENT = 0x30004\n        const val JUMP_LIMIT_LOGIN_PAGE = 0x30005\n        const val JUMP_WRITTEN_OFF_PAGE = 0x30006\n\n        /**********************************************登录模块 End*****************************************************************/\n\n        /**********************************************支付模块 Start*****************************************************************/\n        const val PAY_COURSE_RESULT_EVENT = 0x40000\n        /**********************************************支付模块 End*****************************************************************/\n\n        /**********************************************图片选择模块 Start*****************************************************************/\n        const val PICTURE_SELECT_EVENT = 0x50000\n        /**********************************************图片选择模块 End*****************************************************************/\n\n        /**********************************************首页模块 Start*****************************************************************/\n        const val REC_COURSE_REFRESH = 0x60000\n        //首页完全展示出来后\n        const val MAINTAB_RESUME = 0x60001\n        //宠物满级，点击更换按钮跳转到h5,时发送次事件\n        const val NEED_REFRESH_CURRENT_PET = 0x60002\n        /**********************************************首页模块 End*****************************************************************/\n\n\n        /**********************************************课中模块 Start*****************************************************************/\n        const val NET_CHANGE_TO_WIFI = 0x70000\n        const val STUDY_ACCOMPANY_STATUS = 0x70001\n\n//        课中 挽留弹窗显示了\n        const val COURSE_DETAIN_DIALOG_SHOW = 0x70002\n        //        课中 挽留弹窗隐藏了\n        const val COURSE_DETAIN_DIALOG_HIDE = 0x70003\n\n        /**********************************************课中模块 End*****************************************************************/\n\n\n    }\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403206525},"updatedAt":{"$$date":1597403720374},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AKyZuTSG3hGqlzGW"}
{"name":"java-方法引用","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"使用Lambda表达式，我们就可以不必编写FunctionalInterface接口的实现类，从而简化代码：\n\nArrays.sort(array, (s1, s2) -> {\n    return s1.compareTo(s2);\n});\n实际上，除了Lambda表达式，我们还可以直接传入方法引用。例如：\n\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, Main::cmp);\n        System.out.println(String.join(\", \", array));\n    }\n\n    static int cmp(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n}\n\n Run\n上述代码在Arrays.sort()中直接传入了静态方法cmp的引用，用Main::cmp表示。\n\n因此，所谓方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用。\n\n因为Comparator<String>接口定义的方法是int compare(String, String)，和静态方法int cmp(String, String)相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入：\n\nArrays.sort(array, Main::cmp);\n注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系。\n\n我们再看看如何引用实例方法。如果我们把代码改写如下：\n\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, String::compareTo);\n        System.out.println(String.join(\", \", array));\n    }\n}\n\n Run\n不但可以编译通过，而且运行结果也是一样的，这说明String.compareTo()方法也符合Lambda定义。\n\n观察String.compareTo()的方法定义：\n\npublic final class String {\n    public int compareTo(String o) {\n        ...\n    }\n}\n这个方法的签名只有一个参数，为什么和int Comparator<String>.compare(String, String)能匹配呢？\n\n因为实例方法有一个隐含的this参数，String类的compareTo()方法在实际调用的时候，第一个隐含参数总是传入this，相当于静态方法：\n\npublic static int compareTo(this, String o);\n所以，String.compareTo()方法也可作为方法引用传入。\n\n构造方法引用\n除了可以引用静态方法和实例方法，我们还可以引用构造方法。\n\n我们来看一个例子：如果要把一个List<String>转换为List<Person>，应该怎么办？\n\nclass Person {\n    String name;\n    public Person(String name) {\n        this.name = name;\n    }\n}\n\nList<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\nList<Person> persons = ???\n传统的做法是先定义一个ArrayList<Person>，然后用for循环填充这个List：\n\nList<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\nList<Person> persons = new ArrayList<>();\nfor (String name : names) {\n    persons.add(new Person(name));\n}\n要更简单地实现String到Person的转换，我们可以引用Person的构造方法：\n\n// 引用构造方法\nimport java.util.*;\nimport java.util.stream.*;\npublic class Main {\n    public static void main(String[] args) {\n        List<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\n        List<Person> persons = names.stream().map(Person::new).collect(Collectors.toList());\n        System.out.println(persons);\n    }\n}\n\nclass Person {\n    String name;\n    public Person(String name) {\n        this.name = name;\n    }\n    public String toString() {\n        return \"Person:\" + this.name;\n    }\n}\n\n Run\n后面我们会讲到Stream的map()方法。现在我们看到，这里的map()需要传入的FunctionalInterface的定义是：\n\n@FunctionalInterface\npublic interface Function<T, R> {\n    R apply(T t);\n}\n把泛型对应上就是方法签名Person apply(String)，即传入参数String，返回类型Person。而Person类的构造方法恰好满足这个条件，因为构造方法的参数是String，而构造方法虽然没有return语句，但它会隐式地返回this实例，类型就是Person，因此，此处可以引用构造方法。构造方法的引用写法是类名::new，因此，此处传入Person::new。\n\n练习\n从下载练习：使用方法引用实现忽略大小写排序 （推荐使用IDE练习插件快速下载）\n\n小结\nFunctionalInterface允许传入：\n\n接口的实现类（传统写法，代码较繁琐）；\nLambda表达式（只需列出参数名，由编译器推断类型）；\n符合方法签名的静态方法；\n符合方法签名的实例方法（实例类型被看做第一个参数类型）；\n符合方法签名的构造方法（实例类型被看做返回类型）。\nFunctionalInterface不强制继承关系，不需要方法名称相同，只要求方法参数（类型和数量）与方法返回类型相同，即认为方法签名相同。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973255909},"updatedAt":{"$$date":1594973664981},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AYTXD4TFlneEEBfu"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241220144},"updatedAt":{"$$date":1597241220144},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AaHhbmGoxhVF4FDH"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975695897},"updatedAt":{"$$date":1598975695897},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AgSijOURPZpQgoGE"}
{"name":"Android应用转移文档","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"Android应用转移文档\n华为市场 应用迁移\n业务\n定义\n操作指导\n普通应用转移\n不含华为支付渠道的应用\n目录：2. 普通应用转移\n应用内购买模式应用转移\n包含华为支付渠道的应用，即联运应用。\n目录：3. 应用内购买（含联运游戏）\n1、华为应用市场支持应用迁移，因华为市场有联运，需要发送邮件申请转移，可能需要更改支持回调，调参数等操作\n2、《https://developer.huawei.com/consumer/cn/doc/distribution/app/50112 应用转移流程》\nxiaomi市场 应用认领\n1、小米应用市场区分国内和国外，国外可以通过发送邮件的方式发起应用的转移，国内只支持应用认领\n2、《https://dev.mi.com/console/doc/detail?pId=1889 应用认领流程》\nOppo市场 应用认领\n如何迁移\n1、登录开放平台后台管理，在“管理中心---账号管理”中修改公司主体信息再提交审核。\n2、通过认领方式，把应用认领到新的账号名下。详细操作方法请点击参考文档：《https://open.oppomobile.com/wiki/doc#id=10182 应用认领流程》。\n注：进入OPPO开放平台官网-管理中心-应用服务平台，点击移动应用认领（联运合作的游戏不允许认领）\nVivo市场 应用认领\n1、只支持应用认领的方式\n2、《https://dev.vivo.com.cn/documentCenter/doc/54 应用认领流程》\n应用宝市场 应用迁移\n1、支持应用转让流程\n2、开发者账号登陆→管理中心→点击需要转让的应用→基础服务→工单系统→应用宝商务类→移动应用转让申请→填单提交。\n《https://wiki.open.qq.com/index.php?title=应用转让申请 应用转让流程》\n360市场 应用认领\n1、只支持应用认领\n2、管理中心-个人中心-修改公司资料\n《http://dev.360.cn/mod3/mobilenavs/index?_=2691116484# 应用认领流程》\n百度市场 应用认领\n1、只有应用认领\n2、《https://app.baidu.com/apps/claimlist 应用认领流程》\n豌豆荚市场 应用认领\n没有找到认领和装让渠道"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598543890824},"updatedAt":{"$$date":1598543891926},"_id":"AkYMMGlBFhzbRC21","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"css-CSS 计数器","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 计数器\nCSS 计数器通过一个变量来设置，根据规则递增变量。\n\n使用计数器自动编号\nCSS 计数器根据规则来递增变量。\n\nCSS 计数器使用到以下几个属性：\n\ncounter-reset - 创建或者重置计数器\ncounter-increment - 递增变量\ncontent - 插入生成的内容\ncounter() 或 counters() 函数 - 将计数器的值添加到元素\n要使用 CSS 计数器，得先用 counter-reset 创建：\n\n以下实例在页面创建一个计数器 (在 body 选择器中)，每个 <h2> 元素的计数值都会递增，并在每个 <h2> 元素前添加 \"Section <计数值>:\"\n\nCSS 实例\nbody {\n  counter-reset: section;\n}\n \nh2::before {\n  counter-increment: section;\n  content: \"Section \" counter(section) \": \";\n}\n\n尝试一下 »\n嵌套计数器\n以下实例在页面创建一个计数器，在每一个 <h1> 元素前添加计数值 \"Section <主标题计数值>.\", 嵌套的计数值则放在 <h2> 元素的前面，内容为 \"<主标题计数值>.<副标题计数值>\":\n\nCSS 实例\nbody {\n  counter-reset: section;\n}\n \nh1 {\n  counter-reset: subsection;\n}\n \nh1::before {\n  counter-increment: section;\n  content: \"Section \" counter(section) \". \";\n}\n \nh2::before {\n  counter-increment: subsection;\n  content: counter(section) \".\" counter(subsection) \" \";\n}\n\n尝试一下 »\n计数器也可用于列表中，列表的子元素会自动创建。这里我们使用了 counters() 函数在不同的嵌套层级中插入字符串:\n\nCSS 实例\nol {\n  counter-reset: section;\n  list-style-type: none;\n}\n \nli::before {\n  counter-increment: section;\n  content: counters(section,\".\") \" \";\n}\n\n尝试一下 »\nCSS 计数器属性\n属性\t描述\ncontent\t使用 ::before 和 ::after 伪元素来插入自动生成的内容\ncounter-increment\t递增一个或多个值\ncounter-reset\t创建或重置一个或多个计数器\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973631915},"updatedAt":{"$$date":1598974522316},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Al94OEbY84SN7VNs"}
{"name":"kqapp-lightlearn_module_home","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\nobject HomeObject {\n\n    const val NOTIFY_ID_1 = 101\n    const val NOTIFY_ID_2 = 102\n    const val NOTIFY_ID_3 = 103\n\n    private const val JPUSH_NOTIFY_ID = \"jpush_notify_id\"\n    var currentId: Int by Preference(JPUSH_NOTIFY_ID, NOTIFY_ID_1)\n\n    var NOTIFICATION_CHANNEL_NAME_PUSH = \"推送\"\n    var NOTIFICATION_CHANNEL_ID_PUSH = \"notification_push\"\n\n    var NOTIFICATION_CHANNEL_ID_UPDATE = \"notification_update\"\n    var NOTIFICATION_CHANNEL_NAME_UPDATE = \"版本更新\"\n\n    const val SHARE_WX = \"wx\"\n    const val SHARE_PYQ = \"timeline\"\n}\n\n\n\n\npublic interface UpdateProgressListener {\n    /**\n     * download start\n     */\n    void start();\n\n    /**\n     * update download progress\n     * @param progress\n     */\n    void update(int progress);\n\n    /**\n     * download success\n     */\n    void success();\n\n    /**\n     * download error\n     */\n    void error();\n}\n\n\n\n\n\nclass UpdateService : Service() {\n    private var downloadUrl: String? = null\n    private var icoResId: Int = 0\n    private var icoSmallResId = 0\n    private var updateProgress: Int = 0\n    private var storeDir: String? = null\n    private var downloadNotificationFlag = 0\n    private var downloadSuccessNotificationFlag = 0\n    private var downloadErrorNotificationFlag = 0\n    private var isSendBroadcast = false\n    private var updateVersionCode: String? = null\n    private var updateProgressListener: UpdateProgressListener? = null\n    private val localBinder = LocalBinder()\n\n    private val DOWNLOAD_FAIL = 0\n    private val DOWNLOAD_PROGRESS = 1\n    private val DOWNLOAD_SUCCESS = 2\n\n    private val handler = @SuppressLint(\"HandlerLeak\")\n    object : Handler() {\n        override fun handleMessage(msg: Message) {\n            super.handleMessage(msg)\n            if (msg.what == DOWNLOAD_FAIL) {\n                error()\n            } else if (msg.what == DOWNLOAD_PROGRESS) {\n                var progress: Int = msg.obj as Int\n                update(progress)\n            } else if (msg.what == DOWNLOAD_SUCCESS) {\n                var path: String = msg.obj as String\n                success(path)\n            }\n        }\n    }\n\n    /**\n     * Class used for the client Binder.\n     */\n    inner class LocalBinder : Binder() {\n        /**\n         * set update progress call back\n         * @param listener\n         */\n        fun setUpdateProgressListener(listener: UpdateProgressListener?) {\n            this@UpdateService.setUpdateProgressListener(listener)\n        }\n    }\n\n    private var startDownload: Boolean = false//开始下载 = false\n    private var lastProgressNumber = 0\n    private lateinit var builder: NotificationCompat.Builder\n    private lateinit var manager: NotificationManager\n    private var notifyId = 0\n    private var appName: String? = null\n    private lateinit var localBroadcastManager: LocalBroadcastManager\n    private lateinit var localIntent: Intent\n    private var downloadApkTask: DownloadUtils? = null\n\n    override fun onCreate() {\n        super.onCreate()\n        appName = applicationName\n    }\n\n    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {\n        if (!startDownload && intent != null) {\n            startDownload = true\n            downloadUrl = intent.getStringExtra(URL)\n            icoResId = intent.getIntExtra(ICO_RES_ID, DEFAULT_RES_ID)\n            icoSmallResId = intent.getIntExtra(ICO_SMALL_RES_ID, DEFAULT_RES_ID)\n            storeDir = intent.getStringExtra(STORE_DIR)\n            updateProgress = intent.getIntExtra(UPDATE_PROGRESS, UPDATE_NUMBER_SIZE)\n            downloadNotificationFlag = intent.getIntExtra(DOWNLOAD_NOTIFICATION_FLAG, 0)\n            downloadErrorNotificationFlag = intent.getIntExtra(DOWNLOAD_ERROR_NOTIFICATION_FLAG, 0)\n            downloadSuccessNotificationFlag = intent.getIntExtra(DOWNLOAD_SUCCESS_NOTIFICATION_FLAG, 0)\n            isSendBroadcast = intent.getBooleanExtra(IS_SEND_BROADCAST, false)\n            updateVersionCode = intent.getStringExtra(UPDATE_VERSION_CODE)\n            notifyId = startId\n            buildNotification()\n            buildBroadcast()\n            serviceStartDownload()\n        }\n        return super.onStartCommand(intent, flags, startId)\n    }\n\n    private fun serviceStartDownload() {\n        downloadApkTask = DownloadUtils()\n        // todo 指定为 apk 升级目录\n        val file = DiskManager.getInstance().getType(DiskManager.DIR_TYPE_APK).file\n\n//        val dir = file?.parentFile\n//        if (!dir?.exists()!!) {\n//            dir?.mkdirs()\n//        }\n        downloadUrl?.let {\n            downloadApkTask!!.downloadFile(it, file.absolutePath, getSaveFileName(downloadUrl), object : DownloadListener {\n                override fun onFail(msg: String) {\n                    handler.sendEmptyMessage(DOWNLOAD_FAIL)\n                }\n\n                override fun onProgress(progress: Int) {\n                    val msg = Message()\n                    msg.what = DOWNLOAD_PROGRESS\n                    msg.obj = progress\n                    handler.sendMessage(msg)\n                }\n\n                override fun onSuccess(path: String) {\n                    val msg = Message()\n                    msg.what = DOWNLOAD_SUCCESS\n                    msg.obj = path\n                    handler.sendMessage(msg)\n                }\n            })\n            start()\n        }\n    }\n\n    override fun onBind(intent: Intent): IBinder? {\n        return localBinder\n    }\n\n    override fun onUnbind(intent: Intent): Boolean {\n        return true\n    }\n\n    fun setUpdateProgressListener(updateProgressListener: UpdateProgressListener?) {\n        this.updateProgressListener = updateProgressListener\n    }\n\n    override fun onDestroy() {\n        if (updateProgressListener != null) {\n            updateProgressListener = null\n        }\n        super.onDestroy()\n    }\n\n    private val applicationName: String\n        get() {\n            var packageManager: PackageManager? = null\n            var applicationInfo: ApplicationInfo? = null\n            try {\n                packageManager = applicationContext.packageManager\n                applicationInfo = packageManager.getApplicationInfo(packageName, 0)\n            } catch (e: PackageManager.NameNotFoundException) {\n                applicationInfo = null\n            }\n            return packageManager!!.getApplicationLabel(applicationInfo) as String\n        }\n\n    private fun buildBroadcast() {\n        if (!isSendBroadcast) {\n            return\n        }\n        localBroadcastManager = LocalBroadcastManager.getInstance(this)\n        localIntent = Intent(ACTION)\n    }\n\n    private fun sendLocalBroadcast(status: Int, progress: Int) {\n        if (!isSendBroadcast || localIntent == null) {\n            return\n        }\n        localIntent.putExtra(STATUS, status)\n        localIntent.putExtra(PROGRESS, progress)\n        localBroadcastManager.sendBroadcast(localIntent)\n    }\n\n    @SuppressLint(\"StringFormatInvalid\")\n    private fun buildNotification() {\n        manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n        builder = NotificationCompat.Builder(this, HomeObject.NOTIFICATION_CHANNEL_ID_UPDATE)\n        builder.setContentTitle(getString(R.string.home_update_app_model_prepare, appName))\n                .setWhen(System.currentTimeMillis())\n                .setProgress(100, 1, false)\n                .setSmallIcon(icoSmallResId)\n                .setLargeIcon(BitmapFactory.decodeResource(getResources(), icoResId))\n                .setDefaults(downloadNotificationFlag)\n        builder.setOnlyAlertOnce(true)\n        manager.notify(notifyId, builder.build())\n    }\n\n    @MainThread\n    @SuppressLint(\"StringFormatInvalid\")\n    private fun start() {\n        builder.setContentTitle(appName)\n        builder.setContentText(getString(R.string.home_update_app_model_prepare, 1))\n        manager.notify(notifyId, builder.build())\n        sendLocalBroadcast(UPDATE_PROGRESS_STATUS, 1)\n        if (updateProgressListener != null) {\n            updateProgressListener!!.start()\n        }\n    }\n\n    /**\n     *\n     * @param progress download percent , max 100\n     */\n    @MainThread\n    private fun update(progress: Int) {\n        if (progress - lastProgressNumber > updateProgress) {\n            lastProgressNumber = progress\n            builder.setProgress(100, progress, false)\n            builder.setContentText(getString(R.string.home_update_app_model_progress, progress, \"%\"))\n            manager.notify(notifyId, builder.build())\n            sendLocalBroadcast(UPDATE_PROGRESS_STATUS, progress)\n            if (updateProgressListener != null) {\n                updateProgressListener!!.update(progress)\n            }\n        }\n    }\n\n    val homeRepository: HomeRepositoryImpl? by lazy { HomeRepositoryImpl() }\n    private fun toUploadGrayUpdateReslt() {\n        GlobalScope.launch {\n            homeRepository?.uploadGrayUpdateResult()\n        }\n    }\n\n    @MainThread\n    private fun success(path: String) {\n        toUploadGrayUpdateReslt()\n        builder.setProgress(0, 0, false)\n        builder.setContentText(getString(R.string.home_update_app_model_success))\n        val i = installIntent(path)\n        val intent = PendingIntent.getActivity(this, 0, i, PendingIntent.FLAG_UPDATE_CURRENT)\n        builder.setContentIntent(intent)\n        builder.setDefaults(downloadSuccessNotificationFlag)\n        val n = builder.build()\n        n.contentIntent = intent\n        manager.notify(notifyId, n)\n        sendLocalBroadcast(UPDATE_SUCCESS_STATUS, 100)\n        if (updateProgressListener != null) {\n            updateProgressListener!!.success()\n        }\n        try {\n            startActivity(i)\n            stopSelf()\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    @MainThread\n    private fun error() {\n        val i = webLauncher(downloadUrl)\n        val intent = PendingIntent.getActivity(this, 0, i, PendingIntent.FLAG_UPDATE_CURRENT)\n        builder.setContentText(getString(R.string.home_update_app_model_error))\n        builder.setContentIntent(intent)\n        builder.setProgress(0, 0, false)\n        builder.setDefaults(downloadErrorNotificationFlag)\n        val n = builder.build()\n        n.contentIntent = intent\n        manager.notify(notifyId, n)\n        sendLocalBroadcast(UPDATE_ERROR_STATUS, -1)\n        if (updateProgressListener != null) {\n            updateProgressListener!!.error()\n        }\n        stopSelf()\n    }\n\n    /**\n     * a builder class helper use UpdateService\n     */\n    open class Builder protected constructor(private val downloadUrl: String, private val updateVersionCode: String?) {\n        private var icoResId = DEFAULT_RES_ID\n        private var icoSmallResId = DEFAULT_RES_ID\n        private var updateProgress = UPDATE_NUMBER_SIZE\n        private var storeDir: String? = null\n        private var downloadNotificationFlag = 0\n        private var downloadSuccessNotificationFlag = 0\n        private var downloadErrorNotificationFlag = 0\n        private var isSendBroadcast = false\n\n        fun setIcoResId(icoResId: Int): Builder {\n            this.icoResId = icoResId\n            return this\n        }\n\n        fun setIcoSmallResId(icoSmallResId: Int): Builder {\n            this.icoSmallResId = icoSmallResId\n            return this\n        }\n\n        fun setUpdateProgress(updateProgress: Int): Builder {\n            require(updateProgress >= 1) { \"updateProgress < 1\" }\n            this.updateProgress = updateProgress\n            return this\n        }\n\n        fun setStoreDir(storeDir: String?): Builder {\n            this.storeDir = storeDir\n            return this\n        }\n\n        fun setDownloadNotificationFlag(downloadNotificationFlag: Int): Builder {\n            this.downloadNotificationFlag = downloadNotificationFlag\n            return this\n        }\n\n        fun setDownloadSuccessNotificationFlag(downloadSuccessNotificationFlag: Int): Builder {\n            this.downloadSuccessNotificationFlag = downloadSuccessNotificationFlag\n            return this\n        }\n\n        fun setDownloadErrorNotificationFlag(downloadErrorNotificationFlag: Int): Builder {\n            this.downloadErrorNotificationFlag = downloadErrorNotificationFlag\n            return this\n        }\n\n        fun setIsSendBroadcast(isSendBroadcast: Boolean): Builder {\n            this.isSendBroadcast = isSendBroadcast\n            return this\n        }\n\n        fun build(context: Context?): Builder {\n            if (context == null) {\n                throw NullPointerException(\"context == null\")\n            }\n            val intent = Intent()\n            intent.setClass(context, UpdateService::class.java)\n            intent.putExtra(URL, downloadUrl)\n            if (icoResId == DEFAULT_RES_ID) {\n                icoResId = getIcon(context)\n            }\n            if (icoSmallResId == DEFAULT_RES_ID) {\n                icoSmallResId = icoResId\n            }\n            intent.putExtra(ICO_RES_ID, icoResId)\n            intent.putExtra(STORE_DIR, storeDir)\n            intent.putExtra(ICO_SMALL_RES_ID, icoSmallResId)\n            intent.putExtra(UPDATE_PROGRESS, updateProgress)\n            intent.putExtra(DOWNLOAD_NOTIFICATION_FLAG, downloadNotificationFlag)\n            intent.putExtra(DOWNLOAD_SUCCESS_NOTIFICATION_FLAG, downloadSuccessNotificationFlag)\n            intent.putExtra(DOWNLOAD_ERROR_NOTIFICATION_FLAG, downloadErrorNotificationFlag)\n            intent.putExtra(IS_SEND_BROADCAST, isSendBroadcast)\n            intent.putExtra(UPDATE_VERSION_CODE, updateVersionCode)\n            context.startService(intent)\n            return this\n        }\n\n        private fun getIcon(context: Context): Int {\n            val packageManager = context.packageManager\n            var appInfo: ApplicationInfo? = null\n            try {\n                appInfo = packageManager.getApplicationInfo(context.packageName, PackageManager.GET_META_DATA)\n            } catch (e: PackageManager.NameNotFoundException) {\n                e.printStackTrace()\n            }\n            return appInfo?.icon ?: 0\n        }\n\n        companion object {\n            fun create(downloadUrl: String?, updateVersion: String?): Builder {\n                if (downloadUrl == null) {\n                    throw NullPointerException(\"downloadUrl == null\")\n                }\n                return Builder(downloadUrl, updateVersion)\n            }\n        }\n\n    }\n\n    companion object {\n        const val TAG = \"UpdateService\"\n        const val ACTION = \"me.shenfan.UPDATE_APP\"\n        const val STATUS = \"status\"\n        const val PROGRESS = \"progress\"\n        var DEBUG = false\n        //下载大小通知频率\n        const val UPDATE_NUMBER_SIZE = 1\n        const val DEFAULT_RES_ID = -1\n        const val UPDATE_PROGRESS_STATUS = 0\n        const val UPDATE_ERROR_STATUS = -1\n        const val UPDATE_SUCCESS_STATUS = 1\n        //params\n        private const val URL = \"downloadUrl\"\n        private const val ICO_RES_ID = \"icoResId\"\n        private const val ICO_SMALL_RES_ID = \"icoSmallResId\"\n        private const val UPDATE_PROGRESS = \"updateProgress\"\n        private const val STORE_DIR = \"storeDir\"\n        private const val DOWNLOAD_NOTIFICATION_FLAG = \"downloadNotificationFlag\"\n        private const val DOWNLOAD_SUCCESS_NOTIFICATION_FLAG = \"downloadSuccessNotificationFlag\"\n        private const val DOWNLOAD_ERROR_NOTIFICATION_FLAG = \"downloadErrorNotificationFlag\"\n        private const val IS_SEND_BROADCAST = \"isSendBroadcast\"\n        private const val UPDATE_VERSION_CODE = \"updateVersionCode\"\n\n        private fun installIntent(path: String): Intent {\n            val intent = Intent(Intent.ACTION_VIEW)\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n            intent.addCategory(Intent.CATEGORY_DEFAULT)\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) { //\n                var fileUri: Uri = FileProvider.getUriForFile(BaseApplication.instance, getFileProviderAuthority(BaseApplication.instance)!!, File(path))\n                intent.setDataAndType(fileUri, \"application/vnd.android.package-archive\")\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)\n            } else {\n                intent.setDataAndType(Uri.fromFile(File(path)), \"application/vnd.android.package-archive\")\n            }\n            return intent\n        }\n\n        /**\n         * 获取FileProvider的auth\n         */\n        private fun getFileProviderAuthority(context: Context): String? {\n            try {\n                for (provider in context.packageManager.getPackageInfo(context.packageName, PackageManager.GET_PROVIDERS).providers) {\n                    if (FileProvider::class.java.name == provider.name && provider.authority.endsWith(\".provider\")) {\n                        return provider.authority\n                    }\n                }\n            } catch (ignore: PackageManager.NameNotFoundException) {\n            }\n            return null\n        }\n\n        private fun webLauncher(downloadUrl: String?): Intent {\n            val download = Uri.parse(downloadUrl)\n            val intent = Intent(Intent.ACTION_VIEW, download)\n            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\n            return intent\n        }\n\n        private fun getSaveFileName(downloadUrl: String?): String {\n            return if (downloadUrl == null || TextUtils.isEmpty(downloadUrl)) {\n                \"noName.apk\"\n            } else downloadUrl.substring(downloadUrl.lastIndexOf(\"/\"))\n        }\n\n//        private fun getDownloadDir(service: UpdateService?): File? {\n//            var downloadDir: File? = null\n//            downloadDir = if (Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED) {\n//                if (service!!.storeDir != null) {\n//                    File(BaseApplication.instance.externalCacheDir, service.storeDir)\n//                } else {\n//                    File(service.externalCacheDir, \"update\")\n//                }\n//            } else {\n//                File(service!!.cacheDir, \"update\")\n//            }\n//            if (!downloadDir.exists()) {\n//                downloadDir.mkdirs()\n//            }\n//            return downloadDir\n//        }\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobject KsWebViewUtils {\n\n\n    fun addUserIdToCookie(context: Context?, userId: String?,  jsonAppInfo: String) {\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP && context != null) {\n            CookieSyncManager.createInstance(context)\n        }\n\n        val cookieManager = CookieManager.getInstance()\n        cookieManager.setAcceptCookie(true)\n        var h5Domain = HttpH5Manager.getH5Domain()\n        cookieManager.setCookie(h5Domain, \"uid=$userId;path=/\")\n        var appInfo = \"\"\n        try {\n            if (jsonAppInfo.isNotEmpty()) {\n                val encode = URLEncoder.encode(jsonAppInfo, \"UTF-8\")\n                appInfo = \"ks=\" + Base64Local.encode(encode.toByteArray(charset(\"UTF-8\"))).toString() + \";path=/\"\n            }\n        } catch (e: UnsupportedEncodingException) {\n            e.printStackTrace()\n        }\n        if (appInfo.isNotEmpty()) {\n            cookieManager.setCookie(h5Domain, \"ks=$appInfo;path=/\")\n        }\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {\n            CookieSyncManager.getInstance().sync()\n        } else {\n            cookieManager.flush()\n        }\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593275106},"updatedAt":{"$$date":1598601541939},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AqtUay44g5MzEmGx"}
{"name":"andr-片段   ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/components/fragments\n片段  |  Android 开发者  |  Android Developers\n27-34 minutes\nFragment 表示 FragmentActivity 中的行为或界面的一部分。您可以在一个 Activity 中组合多个片段，从而构建多窗格界面，并在多个 Activity 中重复使用某个片段。您可以将片段视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除片段（这有点像可以在不同 Activity 中重复使用的“子 Activity”）。\n\n片段必须始终托管在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。例如，当 Activity 暂停时，Activity 的所有片段也会暂停；当 Activity 被销毁时，所有片段也会被销毁。不过，当 Activity 正在运行（处于已恢复生命周期状态）时，您可以独立操纵每个片段，如添加或移除片段。当执行此类片段事务时，您也可将其添加到由 Activity 管理的返回栈 — Activity 中的每个返回栈条目都是一条已发生片段事务的记录。借助返回栈，用户可以通过按返回按钮撤消片段事务（后退）。\n\n当您将片段作为 Activity 布局的一部分添加时，其位于 Activity 视图层次结构的某个 ViewGroup 中，并且片段会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明片段，将其作为 <fragment> 元素插入您的 Activity 布局，或者通过将其添加到某个现有的 ViewGroup，利用应用代码将其插入布局。\n\n本文介绍如何在开发应用时使用片段，包括如何在将片段添加到 Activity 返回栈时保持其状态、如何与 Activity 及 Activity 中的其他片段共享事件、如何为 Activity 的应用栏发挥作用等等。\n\n如需了解有关处理生命周期的信息（包括最佳实践的相关指导），请参阅以下资源：\n\n使用具有生命周期感知能力的组件处理生命周期\n应用架构指南\n支持平板电脑和手机\n设计原理\nAndroid 在 Android 3.0（API 级别 11）中引入了片段，主要目的是为大屏幕（如平板电脑）上更加动态和灵活的界面设计提供支持。由于平板电脑的屏幕尺寸远胜于手机屏幕尺寸，因而有更多空间可供您组合和交换界面组件。利用片段实现此类设计时，您无需管理对视图层次结构做出的复杂更改。通过将 Activity 布局分成各个片段，您可以在运行时修改 Activity 的外观，并在由 Activity 管理的返回栈中保留这些更改。现在，您可以通过片段支持库获取大量片段。\n\n例如，新闻应用可以使用一个片段在左侧显示文章列表，使用另一个片段在右侧显示文章 — 两个片段并排显示在一个 Activity 中，每个片段都拥有自己的一套生命周期回调方法，并各自处理自己的用户输入事件。因此，用户无需使用一个 Activity 来选择文章，然后使用另一个 Activity 来阅读文章，而是可以在同一个 Activity 内选择文章并进行阅读，如图 1 中的平板电脑布局所示。\n\n您应将每个片段都设计为可重复使用的模块化 Activity 组件。换言之，由于每个片段都会通过各自的生命周期回调来定义自己的布局和行为，您可以将一个片段加入多个 Activity，因此，您应采用可复用式设计，避免直接通过某个片段操纵另一个片段。这一点颇为重要，因为模块化片段允许您更改片段的组合方式，从而适应不同的屏幕尺寸。在设计可同时支持平板电脑和手机的应用时，您可以在不同的布局配置中重复使用您的片段，以根据可用的屏幕空间优化用户体验。例如，在手机上，如果不能在同一 Activity 内储存多个片段，则可能必须利用单独的片段来实现单窗格界面。\n\n\n\n图 1. 由片段定义的两个界面模块如何适应不同设计的示例：通过组合成一个 Activity 来适应平板电脑设计，通过单独片段来适应手机设计。\n\n例如（仍以新闻应用为例），在平板电脑尺寸的设备上运行时，该应用可以在 Activity A 中嵌入两个片段。不过，手机尺寸的屏幕没有足够的空间来存储两个片段，因此 Activity A 只包含用于显示文章列表的片段，并且当用户选择文章时，它会启动 Activity B，其包含用于阅读文章的第二个片段。因此，应用可通过重复使用不同组合的片段来同时支持平板电脑和手机（如图 1 所示）。\n\n如需详细了解在设计应用时利用不同片段组合来适应不同屏幕配置，请参阅屏幕兼容性概览。\n\n创建片段\n\n\n图 2. 片段的生命周期（当其 Activity 运行时）。\n\n如要创建片段，您必须创建 Fragment 的子类（或已有其子类）。Fragment 类的代码与 Activity 非常相似。它包含与 Activity 类似的回调方法，如 onCreate()、onStart()、onPause() 和 onStop()。实际上，如果您要将现有 Android 应用转换为使用片段，可能只需将代码从 Activity 的回调方法移入片段相应的回调方法中。\n\n通常，您至少应实现以下生命周期方法：\n\nonCreate()\n系统会在创建片段时调用此方法。当片段经历暂停或停止状态继而恢复后，如果您希望保留此片段的基本组件，则应在您的实现中将其初始化。\nonCreateView()\n系统会在片段首次绘制其界面时调用此方法。如要为您的片段绘制界面，您从此方法中返回的 View 必须是片段布局的根视图。如果片段未提供界面，您可以返回 null。\nonPause()\n系统会将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。通常，您应在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。\n大多数应用至少应为每个片段实现这三个方法，但您还应使用几种其他回调方法来处理片段生命周期的各个阶段。处理片段生命周期部分对所有生命周期回调方法做了更详尽的阐述。\n\n请注意，用于实现依赖组件生命周期的代码应放在组件本身内，而非直接放在片段回调实现中。请参阅使用具有生命周期感知能力的组件处理生命周期，了解如何让您的依赖组件获得生命周期感知能力。\n\n您可能还想扩展几个子类，而非 Fragment 基类：\n\nDialogFragment\n显示浮动对话框。使用此类创建对话框可有效代替使用 Activity 类中的对话框辅助方法，因为您可以将片段对话框纳入由 Activity 管理的片段返回栈，从而使用户能够返回清除的片段。\nListFragment\n显示由适配器（如 SimpleCursorAdapter）管理的一系列项目，类似于 ListActivity。该类提供几种管理列表视图的方法，如用于处理点击事件的 onListItemClick() 回调。（请注意，显示列表的首选方法是使用 RecyclerView，而非 ListView。在此情况下，您需在列表布局中创建包含 RecyclerView 的片段。如需了解具体操作方法，请参阅使用 RecyclerView 创建列表）\nPreferenceFragmentCompat\n以列表形式显示 Preference 对象的层次结构。此类用于为您的应用创建设置屏幕。\n添加界面\n片段通常用作 Activity 界面的一部分，并且会将其自己的布局融入 Activity。\n\n如要为片段提供布局，您必须实现 onCreateView() 回调方法，Android 系统会在片段需要绘制其布局时调用该方法。此方法的实现所返回的 View 必须是片段布局的根视图。\n\n注意：如果您的片段是 ListFragment 的子类，则默认实现会从 onCreateView() 返回一个 ListView，因此您无需实现它。\n\n如要从 onCreateView() 返回布局，您可以通过 XML 中定义的布局资源来扩展布局。为帮助您执行此操作，onCreateView() 提供了一个 LayoutInflater 对象。\n\n例如，以下 Fragment 子类从 example_fragment.xml 文件加载布局：\n\nclass ExampleFragment : Fragment() {override fun onCreateView(\n            inflater: LayoutInflater,\n            container: ViewGroup?,\n            savedInstanceState: Bundle?\n    ): View {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.example_fragment, container, false)\n    }\n}\npublic static class ExampleFragment extends Fragment {\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.example_fragment, container, false);\n    }\n}\n注意：在上例中，R.layout.example_fragment 是对应用资源中保存的布局资源 example_fragment.xml 的引用。如需了解有关如何在 XML 中创建布局的信息，请参阅界面文档。\n\n传递至 onCreateView() 的 container 参数是您的片段布局将插入到的父级 ViewGroup（来自 Activity 的布局）。savedInstanceState 参数是在恢复片段时，提供上一片段实例相关数据的 Bundle（处理片段生命周期部分对恢复状态做了详细阐述）。\n\ninflate() 方法带有三个参数：\n\n您想要扩展的布局的资源 ID。\n将作为扩展布局父项的 ViewGroup。传递 container 对系统向扩展布局的根视图（由其所属的父视图指定）应用布局参数具有重要意义。\n指示是否应在扩展期间将扩展布局附加至 ViewGroup（第二个参数）的布尔值。（在本例中，此值为 false，因为系统已将扩展布局插入 container，而传递 true 值会在最终布局中创建一个多余的视图组。）\n现在，您已了解如何创建提供布局的片段。接下来，您需将该片段添加到您的 Activity 中。\n\n向 Activity 添加片段\n通常，片段会向宿主 Activity 贡献一部分界面，作为 Activity 整体视图层次结构的一部分嵌入到 Activity 中。可以通过两种方式向 Activity 布局添加片段：\n\n在 Activity 的布局文件内声明片段。\n在本例中，您可以将片段当作视图来为其指定布局属性。例如，以下是拥有两个片段的 Activity 的布局文件：\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <fragment android:name=\"com.example.news.ArticleListFragment\"\n            android:id=\"@+id/list\"\n            android:layout_weight=\"1\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\" />\n    <fragment android:name=\"com.example.news.ArticleReaderFragment\"\n            android:id=\"@+id/viewer\"\n            android:layout_weight=\"2\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\" />\n</LinearLayout>\n<fragment> 中的 android:name 属性指定要在布局中进行实例化的 Fragment 类。\n\n创建此 Activity 布局时，系统会将布局中指定的每个片段实例化，并为每个片段调用 onCreateView() 方法，以检索每个片段的布局。系统会直接插入片段返回的 View，从而代替 <fragment> 元素。\n\n注意：每个片段都需要唯一标识符，重启 Activity 时，系统可使用该标识符来恢复片段（您也可以使用该标识符来捕获片段，从而执行某些事务，如将其移除）。可以通过两种方式为片段提供 ID：\n\n为 android:id 属性提供唯一 ID。\n为 android:tag 属性提供唯一字符串。\n或者，通过编程方式将片段添加到某个现有 ViewGroup。\n在 Activity 运行期间，您可以随时将片段添加到 Activity 布局中。您只需指定要将片段放入哪个 ViewGroup。\n\n如要在您的 Activity 中执行片段事务（如添加、移除或替换片段），则必须使用 FragmentTransaction 中的 API。如下所示，您可以从 FragmentActivity 获取一个 FragmentTransaction 实例：\n\nval fragmentManager = supportFragmentManager\nval fragmentTransaction = fragmentManager.beginTransaction()\nFragmentManager fragmentManager = getSupportFragmentManager();\nFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n然后，您可以使用 add() 方法添加一个片段，指定要添加的片段以及将其插入哪个视图。例如：\n\nval fragment = ExampleFragment()\nfragmentTransaction.add(R.id.fragment_container, fragment)\nfragmentTransaction.commit()\nExampleFragment fragment = new ExampleFragment();\nfragmentTransaction.add(R.id.fragment_container, fragment);\nfragmentTransaction.commit();\n传递到 add() 的第一个参数是 ViewGroup，即应放置片段的位置，由资源 ID 指定，第二个参数是要添加的片段。\n\n一旦您通过 FragmentTransaction 做出了更改，就必须调用 commit() 以使更改生效。\n\n管理片段\n如要管理 Activity 中的片段，您需使用 FragmentManager。如要获取它，请从您的 Activity 调用 getSupportFragmentManager()。\n\n可使用 FragmentManager 执行的操作包括：\n\n通过 findFragmentById()（针对在 Activity 布局中提供界面的片段）或 findFragmentByTag()（针对提供或不提供界面的片段）获取 Activity 中存在的片段。\n通过 popBackStack()（模拟用户发出的返回命令）使片段从返回栈中弹出。\n通过 addOnBackStackChangedListener() 注册侦听返回栈变化的侦听器。\n如需了解有关这些方法以及其他方法的详细信息，请参阅 FragmentManager 类文档。\n\n如上文所述，您也可使用 FragmentManager 打开一个 FragmentTransaction，通过它来执行某些事务，如添加和移除片段。\n\n执行片段事务\n在 Activity 中使用片段的一大优点是，您可以通过片段执行添加、移除、替换以及其他操作，从而响应用户交互。提交给 Activity 的每组更改均称为事务，并且您可使用 FragmentTransaction 中的 API 来执行一项事务。您也可将每个事务保存到由 Activity 管理的返回栈内，从而让用户能够回退片段更改（类似于回退 Activity）。\n\n如下所示，您可以从 FragmentManager 获取一个 FragmentTransaction 实例：\n\nval fragmentManager = supportFragmentManager\nval fragmentTransaction = fragmentManager.beginTransaction()\nFragmentManager fragmentManager = getSupportFragmentManager();\nFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n每个事务都是您想要同时执行的一组更改。您可以使用 add()、remove() 和 replace() 等方法，为给定事务设置您想要执行的所有更改。然后，如要将事务应用到 Activity，您必须调用 commit()。\n\n不过，在调用 commit() 之前，您可能希望调用 addToBackStack()，以将事务添加到片段事务返回栈。该返回栈由 Activity 管理，允许用户通过按返回按钮返回上一片段状态。\n\n例如，以下示例说明如何将一个片段替换为另一个片段，以及如何在返回栈中保留先前的状态：\n\nval newFragment = ExampleFragment()\nval transaction = supportFragmentManager.beginTransaction()\ntransaction.replace(R.id.fragment_container, newFragment)\ntransaction.addToBackStack(null)\ntransaction.commit()\n// Create new fragment and transaction\nFragment newFragment = new ExampleFragment();\nFragmentTransaction transaction = getSupportFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,\n// and add the transaction to the back stack\ntransaction.replace(R.id.fragment_container, newFragment);\ntransaction.addToBackStack(null);// Commit the transaction\ntransaction.commit();\n在本例中，newFragment 会替换目前在 R.id.fragment_container ID 所标识的布局容器中的任何片段（如有）。通过调用 addToBackStack()，您可以将替换事务保存到返回栈，以便用户能够通过按返回按钮撤消事务并回退到上一片段。\n\n然后，FragmentActivity 会自动通过 onBackPressed() 从返回栈检索片段。\n\n如果您向事务添加多个更改（如又一个 add() 或 remove()），并调用 addToBackStack()，则调用 commit() 前应用的所有更改都将作为单一事务添加到返回栈，并且返回按钮会将它们一并撤消。\n\n向 FragmentTransaction 添加更改的顺序无关紧要，不过：\n\n您必须最后调用 commit()。\n如果您要向同一容器添加多个片段，则您添加片段的顺序将决定它们在视图层次结构中出现的顺序。\n如果您没有在执行删除片段的事务时调用 addToBackStack()，则事务提交时该片段会被销毁，用户将无法回退到该片段。不过，如果您在删除片段时调用 addToBackStack()，则系统会停止该片段，并随后在用户回退时将其恢复。\n\n提示：对于每个片段事务，您都可通过在提交前调用 setTransition() 来应用过渡动画。\n\n调用 commit() 不会立即执行事务，而是在 Activity 的界面线程（“主”线程）可执行该操作时，再安排该事务在线程上运行。不过，如有必要，您也可以从界面线程调用 executePendingTransactions()，以立即执行 commit() 提交的事务。通常不必这样做，除非其他线程中的作业依赖该事务。\n\n注意：您只能在 Activity 保存其状态（当用户离开 Activity）之前使用 commit() 提交事务。如果您试图在该时间点后提交，则会引发异常。这是因为如需恢复 Activity，则提交后的状态可能会丢失。对于丢失提交无关紧要的情况，请使用 commitAllowingStateLoss()。\n\n与 Activity 通信\n尽管 Fragment 作为独立于 FragmentActivity 的对象实现，并且可在多个 Activity 内使用，但片段的给定实例会直接绑定到托管该片段的 Activity。\n\n具体而言，片段可通过 getActivity() 访问 FragmentActivity 实例，并轻松执行在 Activity 布局中查找视图等任务：\n\n同样，您的 Activity 也可使用 findFragmentById() 或 findFragmentByTag()，通过从 FragmentManager 获取对 Fragment 的引用来调用片段中的方法。例如：\n\nval fragment = supportFragmentManager.findFragmentById(R.id.example_fragment) as ExampleFragment\nExampleFragment fragment = (ExampleFragment) getSupportFragmentManager().findFragmentById(R.id.example_fragment);\n创建 Activity 的事件回调\n在某些情况下，您可能需使用片段来与 Activity 和/或 Activity 托管的其他片段共享事件或数据。如要共享数据，请依照 ViewModel 指南中“在片段之间共享数据”部分所述，创建共享的 ViewModel。如需传播无法使用 ViewModel 处理的事件，则可改为在片段内定义回调接口，并要求宿主 Activity 实现此接口。当 Activity 通过该接口收到回调时，可根据需要与布局中的其他片段共享这些信息。\n\n例如，如果某个新闻应用的 Activity 有两个片段，其中一个用于显示文章列表（片段 A），另一个用于显示文章（片段 B），则片段 A 必须在列表项被选定后告知 Activity，以便它告知片段 B 显示该文章。在本例中，OnArticleSelectedListener 接口在片段 A 内进行声明：\n\npublic class FragmentA : ListFragment() {\n    ...\n    // Container Activity must implement this interface\n    interface OnArticleSelectedListener {\n        fun onArticleSelected(articleUri: Uri)\n    }\n    ...\n}\npublic static class FragmentA extends ListFragment {\n    ...\n    // Container Activity must implement this interface\n    public interface OnArticleSelectedListener {\n        public void onArticleSelected(Uri articleUri);\n    }\n    ...\n}\n然后，该片段的宿主 Activity 会实现 OnArticleSelectedListener 接口并重写 onArticleSelected()，将来自片段 A 的事件通知片段 B。为确保宿主 Activity 实现此接口，片段 A 的 onAttach() 回调方法（系统在向 Activity 添加片段时调用的方法）会通过转换传递到 onAttach() 中的 Activity 来实例化 OnArticleSelectedListener 的实例：\n\npublic class FragmentA : ListFragment() {var listener: OnArticleSelectedListener? = null\n    ...\n    override fun onAttach(context: Context) {\n        super.onAttach(context)\n        listener = context as? OnArticleSelectedListener\n        if (listener == null) {\n            throw ClassCastException(\"$context must implement OnArticleSelectedListener\")\n        }}\n    ...\n}\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener listener;\n    ...\n    @Override\n    public void onAttach(Context context) {\n        super.onAttach(context);\n        try {\n            listener = (OnArticleSelectedListener) context;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(context.toString() + \" must implement OnArticleSelectedListener\");\n        }\n    }\n    ...\n}\n如果 Activity 未实现接口，则片段会抛出 ClassCastException。若实现成功，mListener 成员会保留对 Activity 的 OnArticleSelectedListener 实现的引用，以便片段 A 可通过调用 OnArticleSelectedListener 接口定义的方法与 Activity 共享事件。例如，如果片段 A 是 ListFragment 的一个扩展，则用户每次点击列表项时，系统都会调用片段中的 onListItemClick()，然后该方法会通过调用 onArticleSelected() 与 Activity 共享事件：\n\npublic class FragmentA : ListFragment() {var listener: OnArticleSelectedListener? = null\n    ...\n    override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) {\n        // Append the clicked item's row ID with the content provider Uri\n        val noteUri: Uri = ContentUris.\nwithAppendedId\n(ArticleColumns.CONTENT_URI, id)\n        // Send the event and Uri to the host activity\n        listener?.onArticleSelected(noteUri)\n    }\n    ...\n}\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener listener;\n    ...\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Append the clicked item's row ID with the content provider Uri\n        Uri noteUri = ContentUris.\nwithAppendedId\n(ArticleColumns.CONTENT_URI, id);\n        // Send the event and Uri to the host activity\n        listener.onArticleSelected(noteUri);\n    }\n    ...\n}\n传递到 onListItemClick() 的 id 参数是被点击项的行 ID，即 Activity（或其他片段）用来从应用的 ContentProvider 获取文章的 ID。\n\n如需了解关于使用内容提供程序的详细信息，请参阅内容提供程序文档。\n\n向应用栏添加项目\n您的片段可通过实现 onCreateOptionsMenu() 向 Activity 的选项菜单（并因此向应用栏）贡献菜单项。不过，为使此方法能够收到调用，您必须在 onCreate() 期间调用 setHasOptionsMenu()，以指示片段想要向选项菜单添加菜单项。否则，片段不会收到对 onCreateOptionsMenu() 的调用。\n\n您之后从片段添加到选项菜单的任何菜单项都将追加到现有菜单项之后。选定菜单项时，片段还会收到对 onOptionsItemSelected() 的回调。\n\n您还可通过调用 registerForContextMenu()，在片段布局中注册一个视图来提供上下文菜单。当用户打开上下文菜单时，片段会收到对 onCreateContextMenu() 的调用。当用户选择某个菜单项时，片段会收到对 onContextItemSelected() 的调用。\n\n注意：尽管您的片段会收到与其添加的每个菜单项对应的 on-item-selected 回调，但当用户选择菜单项时，Activity 会首先收到相应的回调。如果 Activity 对 on-item-selected 回调的实现不处理选定的菜单项，则系统会将事件传递至片段的回调。这适用于选项菜单和上下文菜单。\n\n如需了解有关菜单的详细信息，请参阅菜单开发者指南和应用栏培训课程。\n\n处理片段生命周期\n\n\n图 3. Activity 生命周期对片段生命周期的影响。\n\n管理片段生命周期与管理 Activity 生命周期很相似。和 Activity 一样，片段也以三种状态存在：\n\n已恢复\n片段在运行中的 Activity 中可见。\n已暂停\n另一个 Activity 位于前台并具有焦点，但此片段所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。\n已停止\n片段不可见。宿主 Activity 已停止，或片段已从 Activity 中移除，但已添加到返回栈。已停止的片段仍处于活动状态（系统会保留所有状态和成员信息）。不过，它对用户不再可见，并随 Activity 的终止而终止。\n与 Activity 一样，您也可使用 onSaveInstanceState(Bundle)、ViewModel 和持久化本地存储的组合，在配置变更和进程终止后保留片段的界面状态。如要了解保留界面状态的更多信息，请参阅保存界面状态。\n\n对于 Activity 生命周期与片段生命周期而言，二者最显著的差异是在其各自返回栈中的存储方式。默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈中（以便用户通过返回按钮回退到 Activity，详细介绍请参阅任务和返回栈）。不过，只有当您在移除片段的事务执行期间通过调用 addToBackStack() 显式请求保存实例时，系统才会将片段放入由宿主 Activity 管理的返回栈。\n\n在其他方面，管理片段生命周期与管理 Activity 生命周期非常相似；对此，您可采取相同的做法。请参阅 Activity 生命周期指南和使用具有生命周期感知能力的组件处理生命周期，了解有关 Activity 生命周期及其管理措施的详情。\n\n注意：如果您的 Fragment 中需要 Context 对象，则可以调用 getContext()。但请注意，只有在该片段附加到 Activity 时才需调用 getContext()。如果尚未附加该片段，或者其在生命周期结束期间已分离，则 getContext() 返回 null。\n\n与 Activity 生命周期协调一致\n片段所在 Activity 的生命周期会直接影响片段的生命周期，其表现为，Activity 的每次生命周期回调都会引发每个片段的类似回调。例如，当 Activity 收到 onPause() 时，Activity 中的每个片段也会收到 onPause()。\n\n不过，片段还有几个额外的生命周期回调，用于处理与 Activity 的唯一交互，从而执行构建和销毁片段界面等操作。这些额外的回调方法是：\n\nonAttach()\n在片段已与 Activity 关联时进行调用（Activity 传递到此方法内）。\nonCreateView()\n调用它可创建与片段关联的视图层次结构。\nonActivityCreated()\n当 Activity 的 onCreate() 方法已返回时进行调用。\nonDestroyView()\n在移除与片段关联的视图层次结构时进行调用。\nonDetach()\n在取消片段与 Activity 的关联时进行调用。\n图 3 所示为受宿主 Activity 影响的片段生命周期流。在该图中，您可以看到 Activity 的每个连续状态如何确定片段可收到的回调方法。例如，当 Activity 收到其 onCreate() 回调时，Activity 中的片段只会收到 onActivityCreated() 回调。\n\n一旦 Activity 达到已恢复状态，您便可随意向 Activity 添加片段和移除其中的片段。因此，只有当 Activity 处于已恢复状态时，片段的生命周期才能独立变化。\n\n不过，当 Activity 离开已恢复状态时，片段会在 Activity 的推动下再次经历其生命周期。\n\n示例\n为将本文阐述的所有内容融会贯通，以下提供了一个示例，其中的 Activity 使用两个片段来创建一个双窗格布局。下面的 Activity 包括两个片段：一个用于显示莎士比亚戏剧标题列表，另一个用于在从列表中选定戏剧时显示其摘要。此外，它还展示了如何根据屏幕配置提供不同的片段配置。\n\n注意：有关此 Activity 的完整源代码，请参见示例应用，该应用展示了示例 FragmentLayout 类的用法。\n\n主 Activity 在 onCreate() 期间以常规方式应用布局：\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView\n\n(R.layout.fragment_layout)\n}\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView\n\n(R.layout.fragment_layout);\n}\n应用的布局为 fragment_layout.xml：\n\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"><fragment class=\"com.example.android.apis.app.FragmentLayout$TitlesFragment\"\n            android:id=\"@+id/titles\" android:layout_weight=\"1\"\n            android:layout_width=\"0px\" android:layout_height=\"match_parent\" /><FrameLayout android:id=\"@+id/details\" android:layout_weight=\"1\"\n            android:layout_width=\"0px\" android:layout_height=\"match_parent\"\n            android:background=\"?android:attr/detailsElementBackground\" /></LinearLayout>\n通过使用此布局，系统会在 Activity 加载布局时立即实例化 TitlesFragment（其列出了戏剧标题），而 FrameLayout（用于显示戏剧摘要的片段所在位置）则会占用屏幕右侧的空间，但最初处于空白状态。如下文所示，只有当用户从列表中选择某个项目后，系统才会将片段放入 FrameLayout。\n\n不过，并非所有屏幕配置都具有足够的宽度，可以一同显示戏剧列表和摘要。因此，以上布局仅用于横向屏幕配置（布局保存在 res/layout-land/fragment_layout.xml 中）。\n\n因此，当屏幕纵向显示时，系统会应用以下布局（保存在 res/layout/fragment_layout.xml 中）：\n\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\">\n    <fragment class=\"com.example.android.apis.app.FragmentLayout$TitlesFragment\"\n            android:id=\"@+id/titles\"\n            android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" />\n</FrameLayout>\n此布局仅包括 TitlesFragment。这意味着，当设备纵向显示时，用户只能看到戏剧标题列表。因此，当用户在此配置中点击某个列表项时，应用会启动一个新 Activity 来显示摘要，而非加载另一个片段。\n\n接下来，您将了解如何在片段类中实现此目的。第一个片段是 TitlesFragment，用于显示莎士比亚戏剧标题列表。该片段扩展了 ListFragment，并依靠它来处理大多数列表视图工作。\n\n当您检查此代码时，请注意，用户点击列表项时可能会出现两种行为：系统可能会创建并显示一个新片段，从而在同一 Activity 中显示详细信息（将片段添加到 FrameLayout），也可能会启动一个新 Activity（在该 Activity 中可显示片段），具体取决于这两个布局中哪一个处于活动状态。\n\nclass TitlesFragment : ListFragment() {private var dualPane: Boolean = false\n    private var curCheckPosition = 0override fun onActivityCreated(savedInstanceState: Bundle?) {\n        super.onActivityCreated(savedInstanceState)// Populate list with our static array of titles.\n        listAdapter = ArrayAdapter<String>(\n                activity,\n                android.R.layout.simple_list_item_activated_1,\n                Shakespeare.TITLES\n        )// Check to see if we have a frame in which to embed the details\n        // fragment directly in the containing UI.\n        val detailsFrame: View? = activity?.findViewById(R.id.details)\n        dualPane = detailsFrame?.visibility == View.VISIBLE\n        curCheckPosition \n\n= savedInstanceState?.getInt(\"curChoice\", 0) ?: 0if (dualPane) {\n            // In dual-pane mode, the list view highlights the selected item.\n            listView.choiceMode = ListView.CHOICE_MODE_SINGLE\n            // Make sure our UI is in the correct state.\n            showDetails(curCheckPosition)\n        }\n    }override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        outState.putInt(\"curChoice\", curCheckPosition)\n    }override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) {\n        showDetails(position)\n    }/**\n     * Helper function to show the details of a selected item, either by\n     * displaying a fragment in-place in the current UI, or starting a\n     * whole new activity in which it is displayed.\n     */\n    private fun showDetails(index: Int) {\n        curCheckPosition = indexif (dualPane) {\n            // We can display everything in-place with fragments, so update\n            // the list to highlight the selected item and show the data.\n            listView.setItemChecked(index, true)// Check what fragment is currently shown, replace if needed.\n            var details = fragmentManager?.findFragmentById(R.id.details) as? DetailsFragment\n            if (details?.shownIndex != index) {\n                // Make new fragment to show this selection.\n                details = DetailsFragment.newInstance(index)// Execute a transaction, replacing any existing fragment\n                // with this one inside the frame.\n                fragmentManager?.beginTransaction()?.apply {\n                    if (index == 0) {\n                        replace(R.id.details, details)\n                    } else {\n                        replace(R.id.a_item, details)\n                    }\n                    setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)\n                    commit()\n                }\n            }} else {\n            // Otherwise we need to launch a new activity to display\n            // the dialog fragment with selected text.\n            val intent = Intent().apply {\n                setClass(activity, DetailsActivity::class.java)\n                putExtra(\"index\", index)\n            }\n            startActivity(intent)\n        }\n    }\n}\npublic static class TitlesFragment extends ListFragment {\n    boolean dualPane;\n    int curCheckPosition = 0;@Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);// Populate list with our static array of titles.\n        setListAdapter(new ArrayAdapter<String>(getActivity(),\n                android.R.layout.simple_list_item_activated_1, Shakespeare.TITLES));// Check to see if we have a frame in which to embed the details\n        // fragment directly in the containing UI.\n        View detailsFrame = getActivity().findViewById(R.id.details);\n        dualPane = detailsFrame != null && detailsFrame.getVisibility() == View.VISIBLE;if (savedInstanceState != null) {\n            // Restore last state for checked position.\n            curCheckPosition = savedInstanceState.getInt(\"curChoice\", 0);\n        }if (dualPane) {\n            // In dual-pane mode, the list view highlights the selected item.\n            getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);\n            // Make sure our UI is in the correct state.\n            showDetails(curCheckPosition);\n        }\n    }@Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(\"curChoice\", curCheckPosition);\n    }@Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        showDetails(position);\n    }/**\n     * Helper function to show the details of a selected item, either by\n     * displaying a fragment in-place in the current UI, or starting a\n     * whole new activity in which it is displayed.\n     */\n    void showDetails(int index) {\n        curCheckPosition = index;if (dualPane) {\n            // We can display everything in-place with fragments, so update\n            // the list to highlight the selected item and show the data.\n            getListView().setItemChecked(index, true);// Check what fragment is currently shown, replace if needed.\n            DetailsFragment details = (DetailsFragment)\n                    getSupportFragmentManager().findFragmentById(R.id.details);\n            if (details == null || details.getShownIndex() != index) {\n                // Make new fragment to show this selection.\n                details = DetailsFragment.newInstance(index);// Execute a transaction, replacing any existing fragment\n                // with this one inside the frame.\n                FragmentTransaction ft = getSupportFragmentManager().beginTransaction();\n                if (index == 0) {\n                    ft.replace(R.id.details, details);\n                } else {\n                    ft.replace(R.id.a_item, details);\n                }\n                ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);\n                ft.commit();\n            }} else {\n            // Otherwise we need to launch a new activity to display\n            // the dialog fragment with selected text.\n            Intent intent = new Intent();\n            intent.setClass(getActivity(), DetailsActivity.class);\n            intent.putExtra(\"index\", index);\n            startActivity(intent);\n        }\n    }\n}\n第二个片段 DetailsFragment 显示从 TitlesFragment 的列表中选择的项目的戏剧摘要：\n\n    class DetailsFragment : Fragment() {val shownIndex: Int by lazy {\n            arguments?.getInt(\"index\", 0) ?: 0\n        }override fun onCreateView(\n                inflater: LayoutInflater,\n                container: ViewGroup?,\n                savedInstanceState: Bundle?\n        ): View? {\n            if (container == null) {\n                // We have different layouts, and in one of them this\n                // fragment's containing frame doesn't exist. The fragment\n                // may still be created from its saved state, but there is\n                // no reason to try to create its view hierarchy because it\n                // isn't displayed. Note this isn't needed -- we could just\n                // run the code below, where we would create and return the\n                // view hierarchy; it would just never be used.\n                return null\n            }val text = TextView(activity).apply {\n                val padding: Int = TypedValue.applyDimension(\n                        TypedValue.COMPLEX_UNIT_DIP,\n                        4f,\n                        activity?.resources?.displayMetrics\n                ).toInt()\n                setPadding(padding, padding, padding, padding)\n                text = Shakespeare.DIALOGUE[shownIndex]\n            }\n            return ScrollView(activity).apply {\n                addView(text)\n            }\n        }companion object {\n            /**\n             * Create a new instance of DetailsFragment, initialized to\n             * show the text at 'index'.\n             */\n            fun newInstance(index: Int): DetailsFragment {\n                val f = DetailsFragment()// Supply index input as an argument.\n                val args = Bundle()\n                args.putInt(\"index\", index)\n                f.arguments = argsreturn f\n            }\n        }\n    }\n}\npublic static class DetailsFragment extends Fragment {\n    /**\n     * Create a new instance of DetailsFragment, initialized to\n     * show the text at 'index'.\n     */\n    public static DetailsFragment newInstance(int index) {\n        DetailsFragment f = new DetailsFragment();// Supply index input as an argument.\n        Bundle args = new Bundle();\n        args.putInt(\"index\", index);\n        f.setArguments(args);return f;\n    }public int getShownIndex() {\n        return getArguments().getInt(\"index\", 0);\n    }@Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n        if (container == null) {\n            // We have different layouts, and in one of them this\n            // fragment's containing frame doesn't exist. The fragment\n            // may still be created from its saved state, but there is\n            // no reason to try to create its view hierarchy because it\n            // isn't displayed. Note this isn't needed -- we could just\n            // run the code below, where we would create and return the\n            // view hierarchy; it would just never be used.\n            return null;\n        }ScrollView scroller = new ScrollView(getActivity());\n        TextView text = new TextView(getActivity());\n        int padding = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,\n                4, getActivity().getResources().getDisplayMetrics());\n        text.setPadding(padding, padding, padding, padding);\n        scroller.addView(text);\n        text.setText(Shakespeare.DIALOGUE[getShownIndex()]);\n        return scroller;\n    }\n}\n从 TitlesFragment 类中重新调用，如果用户点击某个列表项，且当前布局不包括 R.id.details 视图（即 DetailsFragment 所属视图），则应用会启动 DetailsActivity Activity 以显示该项目的内容。\n\n以下是 DetailsActivity，它通过简单嵌入 DetailsFragment，在屏幕为纵向时显示所选的戏剧摘要：\n\nclass DetailsActivity : FragmentActivity() {override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {\n            // If the screen is now in landscape mode, we can show the\n            // dialog in-line with the list so we don't need this activity.\n            finish()\n            return\n        }if (savedInstanceState == null) {\n            // During initial setup, plug in the details fragment.\n            val details = DetailsFragment().apply {\n                arguments = intent.extras\n            }\n            supportFragmentManager.beginTransaction()\n                    .add(android.R.id.content, details)\n                    .commit()\n        }\n    }\n}\npublic static class DetailsActivity extends FragmentActivity {@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);if (getResources().getConfiguration().orientation\n                == Configuration.ORIENTATION_LANDSCAPE) {\n            // If the screen is now in landscape mode, we can show the\n            // dialog in-line with the list so we don't need this activity.\n            finish();\n            return;\n        }if (savedInstanceState == null) {\n            // During initial setup, plug in the details fragment.\n            DetailsFragment details = new DetailsFragment();\n            details.setArguments(getIntent().getExtras());\n            getSupportFragmentManager().beginTransaction().add(android.R.id.content, details).commit();\n        }\n    }\n}\n请注意，如果配置为横向，则此 Activity 会自行完成，这样主 Activity 便可接受并显示 TitlesFragment 和 DetailsFragment。如果用户在纵向模式下启动 DetailsActivity，但随后将设备旋转为横向（这会重启当前 Activity），则可能会出现这种情况。\n\n其他资源\nSunflower 演示应用中使用了 Fragment。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243442162},"updatedAt":{"$$date":1597243806669},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Ar9evxKFEuNkeo8j"}
{"name":"andr-可绘制对象","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"developer.android.google.cn /guide/topics/resources/drawable-resource\n可绘制对象资源 | Android 开发者 | Android Developers\n27-34 minutes\n可绘制对象资源是图形的一般概念，是指可在屏幕上绘制的图形，以及可使用 getDrawable(int) 等 API 检索，或应用到拥有 android:drawable 和 android:icon 等属性的其他 XML 资源的图形。可绘制对象包含以下多种类型：\n\n位图文件\n位图图形文件（.png、.jpg 或 .gif）。创建 BitmapDrawable。\n九宫格文件\n具有可伸缩区域的 PNG 文件，支持根据内容调整图像大小 (.9.png)。创建 NinePatchDrawable。\n图层列表\n管理其他可绘制对象阵列的可绘制对象。这些可绘制对象按阵列顺序绘制，因此索引最大的元素绘制于顶部。创建 LayerDrawable。\n状态列表\n此 XML 文件用于为不同状态引用不同位图图形（例如，按下按钮时使用不同图像）。创建 StateListDrawable。\n级别列表\n此 XML 文件用于定义管理大量备选可绘制对象的可绘制对象，每个可绘制对象都配有最大备选数量。创建 LevelListDrawable。\n转换可绘制对象\n此 XML 文件用于定义可在两种可绘制对象资源之间交错淡出的可绘制对象。创建 TransitionDrawable。\n插入可绘制对象\n此 XML 文件用于定义以指定距离插入其他可绘制对象的可绘制对象。当视图需要小于视图实际边界的背景可绘制对象时，此类可绘制对象非常有用。\n裁剪可绘制对象\n此 XML 文件用于定义对其他可绘制对象进行裁剪（根据其当前级别值）的可绘制对象。创建 ClipDrawable。\n缩放可绘制对象\n此 XML 文件用于定义更改其他可绘制对象大小（根据其当前级别值）的可绘制对象。创建 ScaleDrawable\n形状可绘制对象\n此 XML 文件用于定义几何形状（包括颜色和渐变）。创建 GradientDrawable。\n另请参阅动画资源文档，了解如何创建 AnimationDrawable。\n\n请注意：颜色资源也可用作 XML 中的可绘制对象。例如，在创建状态列表可绘制对象时，可以引用 android:drawable 属性的颜色资源 (android:drawable=\"@color/green\")。\n\n位图\n位图图像。Android 支持以下三种格式的位图文件：.png（首选）、.jpg（可接受）、.gif（不建议）。\n\n您可以使用文件名作为资源 ID 直接引用位图文件，也可以在 XML 中创建别名资源 ID。\n\n注：在构建过程中，可通过 aapt 工具自动优化位图文件，对图像进行无损压缩。例如，不需要超过 256 色的真彩色 PNG 可通过调色板转换为 8 位 PNG。这样产生的图像质量相同，但所需内存更少。因此请注意，此目录中的图像二进制文件在构建时可能会发生变化。如果您打算以比特流的形式读取图像，进而将其转换为位图，请改为将图像放在 res/raw/ 文件夹中，避免系统对其进行优化。\n\n位图文件\n位图文件是 .png、.jpg 或 .gif 文件。当您将任一位图文件保存到 res/drawable/ 目录中时，Android 会为其创建 Drawable 资源。\n\n文件位置：\nres/drawable/filename.png（.png、.jpg 或 .gif）\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 BitmapDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n示例：\n当图像保存为 res/drawable/myimage.png 后，此布局 XML 会将该图像应用至视图：\n<ImageView\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:src=\"@drawable/myimage\" />\n以下应用代码将图像作为 Drawable 进行检索：\n\nval drawable: Drawable? = ResourcesCompat.\ngetDrawable\n(resources, R.drawable.myimage, null)\nResources res = \ngetResources()\n;\nDrawable drawable = ResourcesCompat.\ngetDrawable\n(res, R.drawable.myimage, null);\n另请参阅：\n2D 图形\nBitmapDrawable\nXML 位图\nXML 位图是在 XML 文件中定义的资源，指向位图文件。实际上是原始位图文件的别名。XML 可以指定位图的其他属性，例如抖动和层叠。\n\n注：您可以将 <bitmap> 元素用作 <item> 元素的子项。例如，在创建状态列表或图层列表时，可以将 android:drawable 属性从 <item> 元素中排除，并在其中嵌套用于定义可绘制项的 <bitmap>。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 BitmapDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<bitmap\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:src=\"@[package:]drawable/drawable_resource\"\n    android:antialias=[\"true\" | \"false\"]\n    android:dither=[\"true\" | \"false\"]\n    android:filter=[\"true\" | \"false\"]\n    android:gravity=[\"top\" | \"bottom\" | \"left\" | \"right\" | \"center_vertical\" |\n                      \"fill_vertical\" | \"center_horizontal\" | \"fill_horizontal\" |\n                      \"center\" | \"fill\" | \"clip_vertical\" | \"clip_horizontal\"]\n    android:mipMap=[\"true\" | \"false\"]\n    android:tileMode=[\"disabled\" | \"clamp\" | \"repeat\" | \"mirror\"] />\n元素：\n<bitmap>\n定义位图来源及其属性。\n属性：\n\nxmlns:android\n字符串。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。这仅当 <bitmap> 是根元素时才需要，当 <bitmap> 嵌套在 <item> 内时不需要。\nandroid:src\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:antialias\n布尔值。启用或停用抗锯齿。\nandroid:dither\n布尔值。当位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕），启用或停用位图抖动。\nandroid:filter\n布尔值。启用或停用位图过滤。当位图收缩或拉伸以使其外观平滑时使用过滤。\nandroid:gravity\n关键字。定义位图的重力。重力指示当位图小于容器时，可绘制对象在其容器中放置的位置。\n必须是以下一个或多个（用 '|' 分隔）常量值：\n\n值\t说明\ntop\t将对象放在其容器顶部，不改变其大小。\nbottom\t将对象放在其容器底部，不改变其大小。\nleft\t将对象放在其容器左边缘，不改变其大小。\nright\t将对象放在其容器右边缘，不改变其大小。\ncenter_vertical\t将对象放在其容器的垂直中心，不改变其大小。\nfill_vertical\t按需要扩展对象的垂直大小，使其完全适应其容器。\ncenter_horizontal\t将对象放在其容器的水平中心，不改变其大小。\nfill_horizontal\t按需要扩展对象的水平大小，使其完全适应其容器。\ncenter\t将对象放在其容器的水平和垂直轴中心，不改变其大小。\nfill\t按需要扩展对象的垂直大小，使其完全适应其容器。这是默认值。\nclip_vertical\t可设置为让子元素的上边缘和/或下边缘裁剪至其容器边界的附加选项。裁剪基于垂直重力：顶部重力裁剪上边缘，底部重力裁剪下边缘，任一重力不会同时裁剪两边。\nclip_horizontal\t可设置为让子元素的左边和/或右边裁剪至其容器边界的附加选项。裁剪基于水平重力：左边重力裁剪右边缘，右边重力裁剪左边缘，任一重力不会同时裁剪两边。\nandroid:mipMap\n布尔值。启用或停用 mipmap 提示。如需了解详情，请参阅 setHasMipMap()。默认值为 false。\nandroid:tileMode\n关键字。定义平铺模式。当平铺模式启用时，位图会重复。重力在平铺模式启用时将被忽略。\n必须是以下常量值之一：\n\n值\t说明\ndisabled\t不平铺位图。这是默认值。\nclamp\t当着色器绘制范围超出其原边界时复制边缘颜色\nrepeat\t水平和垂直重复着色器的图像。\nmirror\t水平和垂直重复着色器的图像，交替镜像图像以使相邻图像始终相接。\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:src=\"@drawable/icon\"\n    android:tileMode=\"repeat\" />\n另请参阅：\nBitmapDrawable\n创建别名资源\n九宫格\nNinePatch 是一种 PNG 图像，您可在其中定义可伸缩区域，以便 Android 在视图中的内容超出正常图像边界时进行缩放。此类图像通常指定为至少有一个尺寸设置为 \"wrap_content\" 的视图背景，而且当视图通过扩展来适应内容时，九宫格图像也会通过扩展来匹配视图的大小。举例而言，Android 的标准 Button 微件所使用的背景便是典型的九宫格图像，其必须通过伸缩来适应按钮内的文本（或图像）。\n\n与普通位图一样，您可直接引用九宫格文件，也可通过 XML 定义资源对其进行引用。\n\n如需完整了解如何创建包含可伸缩区域的九宫格文件，请参阅 2D 图形文件。\n\n九宫格文件\n文件位置：\nres/drawable/filename.9.png\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 NinePatchDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n示例：\n当图像保存为 res/drawable/myninepatch.9.png 后，此布局 XML 会将九宫格应用到视图：\n<Button\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:background=\"@drawable/myninepatch\" />\n另请参阅：\n2D 图形\nNinePatchDrawable\nXML 九宫格\nXML 九宫格是在 XML 中定义的资源，指向九宫格文件。XML 可以为图像指定抖动。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 NinePatchDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<nine-patch\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:src=\"@[package:]drawable/drawable_resource\"\n    android:dither=[\"true\" | \"false\"] />\n元素：\n<nine-patch>\n定义九宫格来源及其属性。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:src\n可绘制对象资源。必备。引用九宫格文件。\nandroid:dither\n布尔值。当位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕），启用或停用位图抖动。\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<nine-patch xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:src=\"@drawable/myninepatch\"\n    android:dither=\"false\" />\n图层列表\nLayerDrawable 是管理其他可绘制对象阵列的可绘制对象。列表中的每个可绘制对象均按照列表顺序绘制，列表中的最后一个可绘制对象绘于顶部。\n\n每个可绘制对象由单一 <layer-list> 元素内的 <item> 元素表示。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 LayerDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list\n    xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item\n        android:drawable=\"@[package:]drawable/drawable_resource\"\n        android:id=\"@[+][package:]id/resource_name\"\n        android:top=\"dimension\"\n        android:right=\"dimension\"\n        android:bottom=\"dimension\"\n        android:left=\"dimension\" />\n</layer-list>\n元素：\n<layer-list>\n必备。这必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\n<item>\n定义放于图层可绘制对象中由其属性所定义位置的可绘制对象。必须是 <layer-list> 元素的子项。接受子 <bitmap> 元素。\n属性：\n\nandroid:drawable\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:id\n资源 ID。此可绘制对象的唯一资源 ID。要为此项新建资源 ID，请使用以下形式：\"@+id/name\"。加号表示应创建为新 ID。您可以使用此 ID 检索和修改拥有 View.findViewById() 或 Activity.findViewById() 的可绘制对象。\nandroid:top\n整型。顶部偏移（像素）。\nandroid:right\n整型。右边偏移（像素）。\nandroid:bottom\n整型。底部偏移（像素）。\nandroid:left\n整型。左边偏移（像素）。\n默认情况下，所有可绘制项都会缩放以适应包含视图的大小。因此，将图像放在图层列表中的不同位置可能会增大视图的大小，并且有些图像会相应地缩放。为避免缩放列表中的项目，请在 <item> 元素内使用 <bitmap> 元素指定可绘制对象，并且对某些不缩放的项目（例如 \"center\"）定义重力。例如，以下 <item> 定义缩放以适应其容器视图的项目：\n\n<item android:drawable=\"@drawable/image\" />\n为避免缩放，以下示例使用重力居中的 <bitmap> 元素：\n\n<item>\n  <bitmap android:src=\"@drawable/image\"\n          android:gravity=\"center\" />\n</item>\n示例：\nXML 文件保存在 res/drawable/layers.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item>\n      <bitmap android:src=\"@drawable/android_red\"\n        android:gravity=\"center\" />\n    </item>\n    <item android:top=\"10dp\" android:left=\"10dp\">\n      <bitmap android:src=\"@drawable/android_green\"\n        android:gravity=\"center\" />\n    </item>\n    <item android:top=\"20dp\" android:left=\"20dp\">\n      <bitmap android:src=\"@drawable/android_blue\"\n        android:gravity=\"center\" />\n    </item>\n</layer-list>\n请注意，此示例使用嵌套的 <bitmap> 元素为每个具有“中心”重力的项目定义可绘制对象资源。这可确保没有图像会为了适应容器的大小而缩放，因为偏移图像会造成大小调整。\n\n此布局 XML 会将可绘制对象应用到视图：\n\n<ImageView\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:src=\"@drawable/layers\" />\n结果是一堆不断偏移的图像：\n\n\n另请参阅：\nLayerDrawable\n状态列表\nStateListDrawable 是在 XML 文件中定义的可绘制对象，它会根据对象状态，使用多个不同的图像来表示同一个图形。例如，Button 微件可以是多种不同状态（按下、聚焦或这两种状态都不是）中的其中一种，并且您可利用状态列表可绘制对象，为每种状态提供不同的背景图片。\n\n您可以在 XML 文件中描述状态列表。每个图形由单一 <selector> 元素内的 <item> 元素表示。每个 <item> 均使用各种属性来描述应用作可绘制对象的图形的状态。\n\n在每个状态变更期间，将从上到下遍历状态列表，并使用第一个与当前状态匹配的项目 —此选择并非基于“最佳匹配”，而是选择符合状态最低条件的第一个项目。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 StateListDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:constantSize=[\"true\" | \"false\"]\n    android:dither=[\"true\" | \"false\"]\n    android:variablePadding=[\"true\" | \"false\"] >\n    <item\n        android:drawable=\"@[package:]drawable/drawable_resource\"\n        android:state_pressed=[\"true\" | \"false\"]\n        android:state_focused=[\"true\" | \"false\"]\n        android:state_hovered=[\"true\" | \"false\"]\n        android:state_selected=[\"true\" | \"false\"]\n        android:state_checkable=[\"true\" | \"false\"]\n        android:state_checked=[\"true\" | \"false\"]\n        android:state_enabled=[\"true\" | \"false\"]\n        android:state_activated=[\"true\" | \"false\"]\n        android:state_window_focused=[\"true\" | \"false\"] />\n</selector>\n元素：\n<selector>\n必备。这必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:constantSize\n布尔值。如果可绘制对象报告的内部大小在状态变更时保持不变，则值为“true”（大小是所有状态的最大值）；如果大小根据当前状态而变化，则值为“false”。默认值为 false。\nandroid:dither\n布尔值。值为“true”时，将在位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕）启用位图的抖动；值为“false”时则停用抖动。默认值为 true。\nandroid:variablePadding\n布尔值。如果可绘制对象的内边距应根据选择的当前状态而变化，则值为“true”；如果内边距应保持不变（基于所有状态的最大内边距），则值为“false”。启用此功能要求您在状态变更时处理执行布局，这通常不受支持。默认值为 false。\n<item>\n定义要在某些状态期间使用的可绘制对象，如其属性所述。必须是 <selector> 元素的子项。\n属性：\n\nandroid:drawable\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:state_pressed\n布尔值。如果在按下对象（例如触摸/点按某按钮）时应使用此项目，则值为“true”；如果在默认的未按下状态时应使用此项目，则值为“false”。\nandroid:state_focused\n布尔值。如果在对象具有输入焦点（例如当用户选择文本输入时）时应使用此项目，则值为“true”；如果在默认的非焦点状态时应使用此项目，则值为“false”。\nandroid:state_hovered\n布尔值。如果当光标悬停在对象上时应使用此项目，则值为“true”；如果在默认的非悬停状态时应使用此项目，则值为“false”。通常，这个可绘制对象可能与用于“聚焦”状态的可绘制对象相同。\n此项为 API 级别 14 新引入的配置。\n\nandroid:state_selected\n布尔值。如果在使用定向控件浏览（例如使用方向键浏览列表）的情况下对象为当前用户选择时应使用此项目，则值为“true”；如果在未选择对象时应使用此项目，则值为“false”。\n当焦点 (android:state_focused) 不充分（例如，列表视图有焦点但使用方向键选择其中的项目）时，使用所选状态。\n\nandroid:state_checkable\n布尔值。如果当对象可选中时应使用此项目，则值为“true”；如果当对象不可选中时应使用此项目，则值为“false”。（仅当对象可在可选中与不可选中小部件之间转换时才有用。）\nandroid:state_checked\n布尔值。如果在对象已选中时应使用此项目，则值为“true”；如果在对象未选中时应使用此项目，则值为“false”。\nandroid:state_enabled\n布尔值。如果在对象启用（能够接收触摸/点击事件）时应使用此项目，则值为“true”；如果在对象停用时应使用此项目，则值为“false”。\nandroid:state_activated\n布尔值。如果在对象激活作为持续选择（例如，在持续导航视图中“突出显示”之前选中的列表项）时应使用此项目，则值为“true”；如果在对象未激活时应使用此项目，则值为“false”。\n此项为 API 级别 11 新引入的配置。\n\nandroid:state_window_focused\n布尔值。如果当应用窗口有焦点（应用在前台）时应使用此项目，则值为“true”；如果当应用窗口没有焦点（例如，通知栏下拉或对话框出现）时应使用此项目，则值为“false”。\n注：请记住，Android 将应用状态列表中第一个与对象当前状态匹配的项目。因此，如果列表中的第一个项目不含上述任何状态属性，则每次都会应用它，这就是默认值应始终放在最后的原因（如以下示例所示）。\n\n示例：\nXML 文件保存在 res/drawable/button.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:state_pressed=\"true\"\n          android:drawable=\"@drawable/button_pressed\" /> <!-- pressed -->\n    <item android:state_focused=\"true\"\n          android:drawable=\"@drawable/button_focused\" /> <!-- focused -->\n    <item android:state_hovered=\"true\"\n          android:drawable=\"@drawable/button_focused\" /> <!-- hovered -->\n    <item android:drawable=\"@drawable/button_normal\" /> <!-- default -->\n</selector>\n此布局 XML 将状态列表可绘制对象应用到按钮：\n\n<Button\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:background=\"@drawable/button\" />\n另请参阅：\nStateListDrawable\n级别列表\n管理大量备选可绘制对象的可绘制对象，每个可绘制对象都配有最大备选数量。若使用 setLevel() 设置可绘制对象的级别值，则会加载级别列表中 android:maxLevel 值大于或等于传递至方法的值的可绘制对象资源。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 LevelListDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<level-list\n    xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item\n        android:drawable=\"@drawable/drawable_resource\"\n        android:maxLevel=\"integer\"\n        android:minLevel=\"integer\" />\n</level-list>\n元素：\n<level-list>\n这必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\n<item>\n定义要在某特定级别使用的可绘制对象。\n属性：\n\nandroid:drawable\n可绘制对象资源。必备。引用要插入的可绘制对象资源。\nandroid:maxLevel\n整型。此项目允许的最高级别。\nandroid:minLevel\n整型。此项目允许的最低级别。\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<level-list xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item\n        android:drawable=\"@drawable/status_off\"\n        android:maxLevel=\"0\" />\n    <item\n        android:drawable=\"@drawable/status_on\"\n        android:maxLevel=\"1\" />\n</level-list>\n在将此项目应用到 View 后，您便可通过 setLevel() 或 setImageLevel() 更改级别。\n\n另请参阅：\nLevelListDrawable\n转换可绘制对象\nTransitionDrawable 是可在两种可绘制对象资源之间交错淡出的可绘制对象。\n\n每个可绘制对象由单个 <transition> 元素内的 <item> 元素表示。不支持超过两个项目。如要向前转换，请调用 startTransition()。如要向后转换，则调用 reverseTransition()。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 TransitionDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<transition\nxmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item\n        android:drawable=\"@[package:]drawable/drawable_resource\"\n        android:id=\"@[+][package:]id/resource_name\"\n        android:top=\"dimension\"\n        android:right=\"dimension\"\n        android:bottom=\"dimension\"\n        android:left=\"dimension\" />\n</transition>\n元素：\n<transition>\n必备。这必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\n<item>\n定义要用作可绘制对象转换一部分的可绘制对象。必须是 <transition> 元素的子项。接受子 <bitmap> 元素。\n属性：\n\nandroid:drawable\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:id\n资源 ID。此可绘制对象的唯一资源 ID。要为此项新建资源 ID，请使用以下形式：\"@+id/name\"。加号表示应创建为新 ID。您可以使用此 ID 检索和修改拥有 View.findViewById() 或 Activity.findViewById() 的可绘制对象。\nandroid:top\n整型。顶部偏移（像素）。\nandroid:right\n整型。右边偏移（像素）。\nandroid:bottom\n整型。底部偏移（像素）。\nandroid:left\n整型。左边偏移（像素）。\n示例：\nXML 文件保存在 res/drawable/transition.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<transition xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:drawable=\"@drawable/on\" />\n    <item android:drawable=\"@drawable/off\" />\n</transition>\n此布局 XML 会将可绘制对象应用到视图：\n\n<ImageButton\n    android:id=\"@+id/button\"\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:src=\"@drawable/transition\" />\n以下代码会执行从第一个项目到第二个项目的 500ms 转换：\n\nval button: ImageButton = findViewById(R.id.button)\nval drawable: Drawable = button.drawable\nif (drawable is TransitionDrawable) {\n    drawable.startTransition(500)\n}\nImageButton button = (ImageButton) findViewById(R.id.button);\nDrawable drawable = button.getDrawable();\nif (drawable instanceof TransitionDrawable) {\n    ((TransitionDrawable) drawable).startTransition(500);\n}\n另请参阅：\nTransitionDrawable\n插入可绘制对象\n在 XML 文件中定义，以指定距离插入其他可绘制对象的可绘制对象。当视图需要小于视图实际边界的背景时，此类可绘制对象很有用。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 InsetDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<inset\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/drawable_resource\"\n    android:insetTop=\"dimension\"\n    android:insetRight=\"dimension\"\n    android:insetBottom=\"dimension\"\n    android:insetLeft=\"dimension\" />\n元素：\n<inset>\n定义插入可绘制对象。这必须是根元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:drawable\n可绘制对象资源。必备。引用要插入的可绘制对象资源。\nandroid:insetTop\n尺寸。顶部插入，表示为尺寸值或尺寸资源\nandroid:insetRight\n尺寸。右边插入，表示为尺寸值或尺寸资源\nandroid:insetBottom\n尺寸。底部插入，表示为尺寸值或尺寸资源\nandroid:insetLeft\n尺寸。左边插入，表示为尺寸值或尺寸资源\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<inset xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/background\"\n    android:insetTop=\"10dp\"\n    android:insetLeft=\"10dp\" />\n另请参阅：\nInsetDrawable\n裁剪可绘制对象\n在 XML 文件中定义，对其他可绘制对象进行裁剪（根据其当前级别）的可绘制对象。您可以根据级别以及用于控制其在整个容器中位置的重力，来控制子可绘制对象的裁剪宽度和高度。通常用于实现进度栏之类的项目。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 ClipDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<clip\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/drawable_resource\"\n    android:clipOrientation=[\"horizontal\" | \"vertical\"]\n    android:gravity=[\"top\" | \"bottom\" | \"left\" | \"right\" | \"center_vertical\" |\n                     \"fill_vertical\" | \"center_horizontal\" | \"fill_horizontal\" |\n                     \"center\" | \"fill\" | \"clip_vertical\" | \"clip_horizontal\"] />\n元素：\n<clip>\n定义裁剪可绘制对象。这必须是根元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:drawable\n可绘制对象资源。必备。引用要裁剪的可绘制对象资源。\nandroid:clipOrientation\n关键字。裁剪方向。\n必须是以下常量值之一：\n\n值\t说明\nhorizontal\t水平裁剪可绘制对象。\nvertical\t垂直裁剪可绘制对象。\nandroid:gravity\n关键字。指定可绘制对象中要裁剪的位置。\n必须是以下一个或多个（用 '|' 分隔）常量值：\n\n值\t说明\ntop\t将对象放在其容器顶部，不改变其大小。当 clipOrientation 是 \"vertical\" 时，在可绘制对象的底部裁剪。\nbottom\t将对象放在其容器底部，不改变其大小。当 clipOrientation 是 \"vertical\" 时，在可绘制对象的顶部裁剪。\nleft\t将对象放在其容器左边缘，不改变其大小。这是默认值。当 clipOrientation 是 \"horizontal\" 时，在可绘制对象的右边裁剪。这是默认值。\nright\t将对象放在其容器右边缘，不改变其大小。当 clipOrientation 是 \"horizontal\" 时，在可绘制对象的左边裁剪。\ncenter_vertical\t将对象放在其容器的垂直中心，不改变其大小。裁剪行为与重力为 \"center\" 时相同。\nfill_vertical\t按需要扩展对象的垂直大小，使其完全适应其容器。当 clipOrientation 是 \"vertical\" 时，不会进行裁剪，因为可绘制对象会填充垂直空间（除非可绘制对象级别为 0，此时它不可见）。\ncenter_horizontal\t将对象放在其容器的水平中心，不改变其大小。裁剪行为与重力为 \"center\" 时相同。\nfill_horizontal\t按需要扩展对象的水平大小，使其完全适应其容器。当 clipOrientation 是 \"horizontal\" 时，不会进行裁剪，因为可绘制对象会填充水平空间（除非可绘制对象级别为 0，此时它不可见）。\ncenter\t将对象放在其容器的水平和垂直轴中心，不改变其大小。当 clipOrientation 是 \"horizontal\" 时，在左边和右边裁剪。当 clipOrientation 是 \"vertical\" 时，在顶部和底部裁剪。\nfill\t按需要扩展对象的垂直大小，使其完全适应其容器。不会进行裁剪，因为可绘制对象会填充水平和垂直空间（除非可绘制对象级别为 0，此时它不可见）。\nclip_vertical\t可设置为让子元素的上边缘和/或下边缘裁剪至其容器边界的附加选项。裁剪基于垂直重力：顶部重力裁剪上边缘，底部重力裁剪下边缘，任一重力不会同时裁剪两边。\nclip_horizontal\t可设置为让子元素的左边和/或右边裁剪至其容器边界的附加选项。裁剪基于水平重力：左边重力裁剪右边缘，右边重力裁剪左边缘，任一重力不会同时裁剪两边。\n示例：\nXML 文件保存在 res/drawable/clip.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<clip xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/android\"\n    android:clipOrientation=\"horizontal\"\n    android:gravity=\"left\" />\n以下布局 XML 会将裁剪可绘制对象应用到视图：\n\n<ImageView\n    android:id=\"@+id/image\"\n    android:background=\"@drawable/clip\"\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\" />\n以下代码用于获取可绘制对象，并增加裁剪量，以便逐渐显示图像：\n\nval imageview: ImageView = findViewById(R.id.image)\nval drawable: Drawable = imageview.background\nif (drawable is ClipDrawable) {\n    drawable.level = drawable.level + 1000\n}\nImageView imageview = (ImageView) findViewById(R.id.image);\nDrawable drawable = imageview.getBackground();\nif (drawable instanceof CLipDrawable) {\n    ((ClipDrawable)drawable).setLevel(drawable.getLevel() + 1000);\n}\n通过提高级别，即可减少裁剪量并慢慢显示图像。以下图像的级别为 7000：\n\n\n请注意：默认级别为 0，即完全裁剪，使图像不可见。当级别为 10,000 时，图像不会裁剪，而是完全可见。\n\n另请参阅：\nClipDrawable\n缩放可绘制对象\n在 XML 文件中定义的更改其他可绘制对象大小（根据其当前级别）的可绘制对象。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 ScaleDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<scale\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/drawable_resource\"\n    android:scaleGravity=[\"top\" | \"bottom\" | \"left\" | \"right\" | \"center_vertical\" |\n                          \"fill_vertical\" | \"center_horizontal\" | \"fill_horizontal\" |\n                          \"center\" | \"fill\" | \"clip_vertical\" | \"clip_horizontal\"]\n    android:scaleHeight=\"percentage\"\n    android:scaleWidth=\"percentage\" />\n元素：\n<scale>\n定义缩放可绘制对象。这必须是根元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:drawable\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:scaleGravity\n关键字。指定缩放后的重力位置。\n必须是以下一个或多个（用 '|' 分隔）常量值：\n\n值\t说明\ntop\t将对象放在其容器顶部，不改变其大小。\nbottom\t将对象放在其容器底部，不改变其大小。\nleft\t将对象放在其容器左边缘，不改变其大小。这是默认值。\nright\t将对象放在其容器右边缘，不改变其大小。\ncenter_vertical\t将对象放在其容器的垂直中心，不改变其大小。\nfill_vertical\t按需要扩展对象的垂直大小，使其完全适应其容器。\ncenter_horizontal\t将对象放在其容器的水平中心，不改变其大小。\nfill_horizontal\t按需要扩展对象的水平大小，使其完全适应其容器。\ncenter\t将对象放在其容器的水平和垂直轴中心，不改变其大小。\nfill\t按需要扩展对象的垂直大小，使其完全适应其容器。\nclip_vertical\t可设置为让子元素的上边缘和/或下边缘裁剪至其容器边界的附加选项。裁剪基于垂直重力：顶部重力裁剪上边缘，底部重力裁剪下边缘，任一重力不会同时裁剪两边。\nclip_horizontal\t可设置为让子元素的左边和/或右边裁剪至其容器边界的附加选项。裁剪基于水平重力：左边重力裁剪右边缘，右边重力裁剪左边缘，任一重力不会同时裁剪两边。\nandroid:scaleHeight\n百分比。缩放高度，表示为可绘制对象边界的百分比。值的格式为 XX%。例如：100%、12.5% 等。\nandroid:scaleWidth\n百分比。缩放宽度，表示为可绘制对象边界的百分比。值的格式为 XX%。例如：100%、12.5% 等。\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/logo\"\n    android:scaleGravity=\"center_vertical|center_horizontal\"\n    android:scaleHeight=\"80%\"\n    android:scaleWidth=\"80%\" />\n另请参阅：\nScaleDrawable\n形状可绘制对象\n这是一种在 XML 文件中定义的通用形状。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 GradientDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"] >\n    <corners\n        android:radius=\"integer\"\n        android:topLeftRadius=\"integer\"\n        android:topRightRadius=\"integer\"\n        android:bottomLeftRadius=\"integer\"\n        android:bottomRightRadius=\"integer\" />\n    <gradient\n        android:angle=\"integer\"\n        android:centerX=\"float\"\n        android:centerY=\"float\"\n        android:centerColor=\"integer\"\n        android:endColor=\"color\"\n        android:gradientRadius=\"integer\"\n        android:startColor=\"color\"\n        android:type=[\"linear\" | \"radial\" | \"sweep\"]\n        android:useLevel=[\"true\" | \"false\"] />\n    <padding\n        android:left=\"integer\"\n        android:top=\"integer\"\n        android:right=\"integer\"\n        android:bottom=\"integer\" />\n    <size\n        android:width=\"integer\"\n        android:height=\"integer\" />\n    <solid\n        android:color=\"color\" />\n    <stroke\n        android:width=\"integer\"\n        android:color=\"color\"\n        android:dashWidth=\"integer\"\n        android:dashGap=\"integer\" />\n</shape>\n元素：\n<shape>\n形状可绘制对象。这必须是根元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:shape\n关键字。定义形状的类型。有效值为：\n值\t描述\n\"rectangle\"\t填充包含视图的矩形。这是默认形状。\n\"oval\"\t适应包含视图尺寸的椭圆形状。\n\"line\"\t跨越包含视图宽度的水平线。此形状需要 <stroke> 元素定义线宽。\n\"ring\"\t环形。\n仅当 android:shape=\"ring\" 如下时才使用以下属性：\n\nandroid:innerRadius\n尺寸。环内部（中间的孔）的半径，以尺寸值或尺寸资源表示。\nandroid:innerRadiusRatio\n浮点型。环内部的半径，以环宽度的比率表示。例如，如果 android:innerRadiusRatio=\"5\"，则内半径等于环宽度除以 5。此值被 android:innerRadius 覆盖。默认值为 9。\nandroid:thickness\n尺寸。环的厚度，以尺寸值或尺寸资源表示。\nandroid:thicknessRatio\n浮点型。环的厚度，表示为环宽度的比率。例如，如果 android:thicknessRatio=\"2\"，则厚度等于环宽度除以 2。此值被 android:innerRadius 覆盖。默认值为 3。\nandroid:useLevel\n布尔值。如果此属性用作 LevelListDrawable，则值为“true”。此属性的值通常应为“false”，否则无法显示形状。\n<corners>\n为形状产生圆角。仅当形状为矩形时适用。\n属性：\n\nandroid:radius\n尺寸。所有角的半径，以尺寸值或尺寸资源表示。对于每个角，这会被以下属性覆盖。\nandroid:topLeftRadius\n尺寸。左上角的半径，以尺寸值或尺寸资源表示。\nandroid:topRightRadius\n尺寸。右上角的半径，以尺寸值或尺寸资源表示。\nandroid:bottomLeftRadius\n尺寸。左下角的半径，以尺寸值或尺寸资源表示。\nandroid:bottomRightRadius\n尺寸。右下角的半径，以尺寸值或尺寸资源表示。\n注：（最初）必须为每个角提供大于 1 的角半径，否则无法产生圆角。如果希望特定角不要倒圆角，解决方法是使用 android:radius 设置大于 1 的默认角半径，然后使用实际所需的值替换每个角，为不希望倒圆角的角提供零（“0dp”）。\n\n<gradient>\n指定形状的渐变颜色。\n属性：\n\nandroid:angle\n整型。渐变的角度（度）。0 为从左到右，90 为从上到上。必须是 45 的倍数。默认值为 0。\nandroid:centerX\n浮点型。渐变中心的相对 X 轴位置 (0 - 1.0)。\nandroid:centerY\n浮点型。渐变中心的相对 Y 轴位置 (0 - 1.0)。\nandroid:centerColor\n颜色。起始颜色与结束颜色之间的可选颜色，以十六进制值或颜色资源表示。\nandroid:endColor\n颜色。结束颜色，表示为十六进制值或颜色资源。\nandroid:gradientRadius\n浮点型。渐变的半径。仅在 android:type=\"radial\" 时适用。\nandroid:startColor\n颜色。起始颜色，表示为十六进制值或颜色资源。\nandroid:type\n关键字。要应用的渐变图案的类型。有效值为：\n值\t说明\n\"linear\"\t线性渐变。这是默认值。\n\"radial\"\t径向渐变。起始颜色为中心颜色。\n\"sweep\"\t流线型渐变。\nandroid:useLevel\n布尔值。如果此属性用作 LevelListDrawable，则值为“true”。\n<padding>\n要应用到包含视图元素的内边距（这会填充视图内容的位置，而非形状）。\n属性：\n\nandroid:left\n尺寸。左内边距，表示为尺寸值或尺寸资源\nandroid:top\n尺寸。上内边距，表示为尺寸值或尺寸资源\nandroid:right\n尺寸。右内边距，表示为尺寸值或尺寸资源\nandroid:bottom\n尺寸。下内边距，表示为尺寸值或尺寸资源\n<size>\n形状的大小。\n属性：\n\nandroid:height\n尺寸。形状的高度，表示为尺寸值或尺寸资源\nandroid:width\n尺寸。形状的宽度，表示为尺寸值或尺寸资源\n注：默认情况下，形状根据此处定义的尺寸，按比例缩放至容器视图的大小。在 ImageView 中使用形状时，您可将 android:scaleType 设置为 \"center\"，从而限制缩放。\n\n<solid>\n用于填充形状的纯色。\n属性：\n\nandroid:color\n颜色。应用于形状的颜色，以十六进制值或颜色资源表示。\n<stroke>\n形状的笔划中线。\n属性：\n\nandroid:width\n尺寸。线宽，以尺寸值或尺寸资源表示。\nandroid:color\n颜色。线的颜色，表示为十六进制值或颜色资源。\nandroid:dashGap\n尺寸。短划线的间距，以尺寸值或尺寸资源表示。仅在设置了 android:dashWidth 时有效。\nandroid:dashWidth\n尺寸。每个短划线的大小，以尺寸值或尺寸资源表示。仅在设置了 android:dashGap 时有效。\n示例：\nXML 文件保存在 res/drawable/gradient_box.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=\"rectangle\">\n    <gradient\n        android:startColor=\"#FFFF0000\"\n        android:endColor=\"#80FF00FF\"\n        android:angle=\"45\"/>\n    <padding android:left=\"7dp\"\n        android:top=\"7dp\"\n        android:right=\"7dp\"\n        android:bottom=\"7dp\" />\n    <corners android:radius=\"8dp\" />\n</shape>\n此布局 XML 会将形状可绘制对象应用到视图：\n\n<TextView\n    android:background=\"@drawable/gradient_box\"\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\" />\n此应用代码会获取形状可绘制对象，并将其应用至视图：\n\nval shape: Drawable? = \ngetDrawable\n(\nresources\n, R.drawable.gradient_box, \ngetTheme()\n)val tv: TextView = findViewById(R.id.textview)\ntv.background = shape\nResources res = \ngetResources()\n;\nDrawable shape = ResourcesCompat.\ngetDrawable\n(res, R.drawable.gradient_box, \ngetTheme()\n);TextView tv = (TextView)findViewById(R.id.textview);\ntv.setBackground(shape);\n另请参阅：\nShapeDrawable"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242357382},"updatedAt":{"$$date":1597242667798},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AwLRKUfx1wdm1RjL"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598974376771},"updatedAt":{"$$date":1598974377661},"_id":"B2sHlOsavfczgP6e","folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-委托 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/delegation.html\n委托 - Kotlin 语言中文站\n6-7 minutes\n改进翻译\n属性委托在单独一页中讲：属性委托。\n\n委托模式已经证明是实现继承的一个很好的替代方式， 而 Kotlin 可以零样板代码地原生支持它。 Derived 类可以通过将其所有公有成员都委托给指定对象来实现一个接口 Base：\n\nTarget platform: JVMRunning on kotlin v. 1.3.72\n\nDerived 的超类型列表中的 by-子句表示 b 将会在 Derived 中内部存储， 并且编译器将生成转发给 b 的所有 Base 的方法。\n\n覆盖符合预期：编译器会使用 override 覆盖的实现而不是委托对象中的。如果将 override fun printMessage() { print(\"abc\") } 添加到 Derived，那么当调用 printMessage 时程序会输出“abc”而不是“10”：\n\ninterface Base {\n    fun printMessage()\n    fun printMessageLine()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override fun printMessage() { print(x) }\n    override fun printMessageLine() { println(x) }\n}\n\nclass Derived(b: Base) : Base by b {\n    override fun printMessage() { print(\"abc\") }\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    Derived(b).printMessage()\n    Derived(b).printMessageLine()\n}\n但请注意，以这种方式重写的成员不会在委托对象的成员中调用 ，委托对象的成员只能访问其自身对接口成员实现：\n\ninterface Base {\n    val message: String\n    fun print()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override val message = \"BaseImpl: x = $x\"\n    override fun print() { println(message) }\n}\n\nclass Derived(b: Base) : Base by b {\n    // 在 b 的 `print` 实现中不会访问到这个属性\n    override val message = \"Message of Derived\"\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    val derived = Derived(b)\n    derived.print()\n    println(derived.message)\n}\n在 JVM 平台：当使用带有 default 方法的接口（包括带有 @JvmDefault 注解的 Kotlin 接口）进行委托时， 即使实际的委托类型提供了其自身的实现也会调用默认实现。 详细信息请参见在 Java 中调用 Kotlin。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307931075},"updatedAt":{"$$date":1597308387892},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"BIRE0ahkgl3UhE7g"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597404255072},"updatedAt":{"$$date":1597404255072},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"BPEATBJRLV9rVM82"}
{"name":"java-使用ReadWriteLock","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"前面讲到的ReentrantLock保证了只有一个线程可以执行临界区代码：\n\npublic class Counter {\n    private final Lock lock = new ReentrantLock();\n    private int[] counts = new int[10];\n\n    public void inc(int index) {\n        lock.lock();\n        try {\n            counts[index] += 1;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public int[] get() {\n        lock.lock();\n        try {\n            return Arrays.copyOf(counts, counts.length);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用inc()方法是必须获取锁，但是，get()方法只读取数据，不修改数据，它实际上允许多个线程同时调用。\n\n实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：\n\n读\t写\n读\t允许\t不允许\n写\t不允许\t不允许\n使用ReadWriteLock可以解决这个问题，它保证：\n\n只允许一个线程写入（其他线程既不能写入也不能读取）；\n没有写入时，多个线程允许同时读（提高性能）。\n用ReadWriteLock实现这个功能十分容易。我们需要创建一个ReadWriteLock实例，然后分别获取读锁和写锁：\n\npublic class Counter {\n    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();\n    private final Lock rlock = rwlock.readLock();\n    private final Lock wlock = rwlock.writeLock();\n    private int[] counts = new int[10];\n\n    public void inc(int index) {\n        wlock.lock(); // 加写锁\n        try {\n            counts[index] += 1;\n        } finally {\n            wlock.unlock(); // 释放写锁\n        }\n    }\n\n    public int[] get() {\n        rlock.lock(); // 加读锁\n        try {\n            return Arrays.copyOf(counts, counts.length);\n        } finally {\n            rlock.unlock(); // 释放读锁\n        }\n    }\n}\n把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。\n\n使用ReadWriteLock时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。\n\n例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用ReadWriteLock。\n\n小结\n使用ReadWriteLock可以提高读取效率：\n\nReadWriteLock只允许一个线程写入；\n\nReadWriteLock允许多个线程在没有写入时同时读取；\n\nReadWriteLock适合读多写少的场景。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826926090},"updatedAt":{"$$date":1594967729192},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"BXM6MredpppmTlDT"}
{"name":"凯叔讲故事-三方平台使用情况","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"凯叔讲故事-三方平台使用情况\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n平台\t名称\tSDK类型\tSDK描述\tSDK使用业务场景\tSDK所需用户信息字段\tiOS SDK所需用户信息字段\t使用目的/理由\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t数字联盟\t\t设备唯一识别码解决方案\t生成设备唯一识别ID\t设备型号，MAC地址，IMEI号，系统版本，手机型号\t设备型号，系统版本号，手机型号，设备ID\t收集您的设备信息，以根据您的操作指令,判断是否为真实用户，防止舞弊,同时也为您提供账号安全防护；\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t极光推送\t推送通知\t全平台通用，提供相对稳定、可靠、高效的推送服务\t向用户推荐活动和提醒\t设备型号、app版本、IMEI/MEID、设备存储、地区、App运行进程信息\t设备型号，系统版本号，手机型号，发布渠道，deviceToken\t向用户推荐活动和提醒\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t极光魔链\t交际\t渠道服务推广、场景还原\t渠道服务推广、场景还原\t设备型号、app版本、IMEI/MEID、App运行进程信息\t设备型号，系统版本号，手机型号\t结合智能短链接服务，用户点击内容或者活动按钮可启动已安装的应用并展示个性化内容给用户，未安装应用可重定向到应用市场。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t支付宝\t支付\t支付\t支付宝支付\t设备型号，系统版本号，手机型号，订单信息。\t设备型号，系统版本号，手机型号，订单信息。\t用于商城里的商品购买\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t微博平台\t交际\t分享功能\t微博分享\t设备型号，系统版本号，手机型号\t设备型号，系统版本号，手机型号\tAPP分享故事，图片，活动至微博客户端\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\tQQ开放平台\t交际\tQQ登录、分享等功能\tQQ分享\t软件安装列表、设备型号、MAC地址、IMEI号、IMSI、系统版本、手机型号\t设备型号，系统版本号，手机型号\tAPP分享故事，图片，活动至QQ客户端\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t微信开放平台\t交际\t微信登录、分享、支付等功能\t微信登录、分享、支付\t软件安装列表、设备型号、MAC地址、IMEI号、IMSI、系统版本、手机型号\t设备型号，系统版本号，手机型号，订单信息，分享信息\tAPP分享故事，图片，活动至微信客户端\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t友盟分享\t交际\t分享功能\t分享到QQ、微信、微博\t设备型号，系统版本号，手机型号，分享信息\t设备型号，系统版本号，手机型号，分享信息\tAPP分享故事，图片，活动至微信、微博、QQ客户端\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t友盟统计\t数据统计\t提供数据统计，数据收集，数据分析服务\t日活，路径分析\t设备型号，系统版本号，手机型号，发布渠道，页面code数据\t设备型号，系统版本号，手机型号，发布渠道，页面code数据\tApp数据收集，进行数据分析。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t乐播投屏\t工具\t提供视频投送到电视等终端的服务、为视频类功能提供更好的体验\t视频类课程投屏到电视等终端的服务\t设备型号，系统版本号，手机型号\t设备型号，系统版本号，手机型号\t用于视频课投屏。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t个验一键登录\t登录\t提供手机号一键登录，便捷、快速登录用户账号\t手机号一键登录功能\t设备型号，系统版本号，手机型号\t设备型号，系统版本号，手机型号，当前页面，\t实现一键登录账号，为登录app提供便捷、快速的登录渠道\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t听云\t性能监测\t提供移动端应用运行时性能监控服务\t对APP进行性能监控，提升产品使用体验\t设备型号，MAC地址，IMEI号，系统版本，手机型号\t设备ID，设备型号，系统版本号，手机型号，\t对APP进行性能监控，提升产品使用体验\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\tBugly\t性能监测\t提供移动端应用运行时崩溃，卡顿监控服务\t对APP进行性能监控，提升产品使用体验\t设备型号、MAC地址、IMEI号，系统版本、手机型号\t设备ID，用户ID，IDFV\t监控app使用过程中的奔溃信息分析，提升用户体验\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t智齿客服\t咨询\t为用户提供便捷的问题反馈、咨询的服务\t对app使用过程中遇到的任何问题都可以通过客服来解决\t设备型号，系统版本号，手机型号，用户ID\t设备型号，系统版本号，手机型号，用户ID\t为用户提供便捷的问题反馈、咨询的服务\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t智聆评测\t工具\t语音跟读、评分\t单词跟读、评分\t用户ID，音频信息\tUUID，音频信息\t用于语音测评，提高用户互动率\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t保利威直播\t直播工具\t提供推流、实时视频展示服务\t活动促销直播\t设备型号，系统版本号，手机型号，用户昵称，用户ID，用户头像，会员信息，\t设备型号，系统版本号，手机型号，用户昵称，用户ID，用户头像，会员信息，\t提供推流、实时视频展示服务\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t讯飞语音识别\t工具\t识别用户声音，转换成文字，为学龄前儿童提供便捷的搜索服务\t语音搜索故事\t音频信息\t音频信息\t识别用户声音，转换成文字，为学龄前儿童提供便捷的搜索服务\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nAndroid\t小米推送\t推送通知\t小米消息推送服务在MIUI上为系统级通道，提供稳定、可靠、高效的推送服务\t小米渠道推送消息通知\t设备型号、app版本、IMEI/MEID、设备存储、地区、App运行进程信息\t\t小米推送服务在MIUI上为系统级通道，并且全平台通用，提供稳定、可靠、高效的推送服务\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nAndroid\t华为推送\t推送通知\t华为消息推送服务在华为手机上为系统级通道，提供稳定、可靠、高效的推送服务\t华为渠道推送消息通知\t设备型号、app版本、IMEI/MEID、设备存储、地区、App运行进程信息\t\t华为推送服务在华为上为系统级通道，提供稳定、可靠、高效的推送服务\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nAndroid\tOppo推送\t推送通知\tOppo消息推送服务在Oppo手机上为系统级通道，提供稳定、可靠、高效的推送服务\tOppo渠道推送消息通知\t设备型号、app版本、IMEI/MEID、设备存储、地区、App运行进程信息\t\tOppo推送服务在Oppo上为系统级通道，提供稳定、可靠、高效的推送服务\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\tGrowingIO\t数据统计\t提供数据统计，数据收集，数据分析服务\t无埋点，用户行为路径分析\t设备型号，系统版本号，手机型号，用户ID，数据信息\t设备型号，系统版本号，手机型号，用户ID，数据信息\t用于统计用户基础数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\niOS,Android\t阿里云\t文件上传\t提供文件上传服务\t图片、视频、语音评论的上传\t文件数据，文件类型，文件名称，\t文件数据，文件类型，文件名称，\t提供文件上传服务\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nIOS,Android\tFaceBookReact\t框架\tReact Native FBSDK是iOS Facebook SDK和Android Facebook SDK的包装\tFacebook的RN框架一部分，首页IP频道内容展示、商品推荐内容展示、会员购买页面展示等业务均使用RN实现\t设备型号、MAC地址、IMEI号、IMSI、系统版本、手机型号\t\t引入RN框架、使用RN实现业务开发\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598546837052},"updatedAt":{"$$date":1598546941588},"_id":"BZkaL4YIf9q5cljf","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"css-CSS 伪类(Pseudo-classes)","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS伪类是用来添加一些选择器的特殊效果。\n\n语法\n伪类的语法：\n\nselector:pseudo-class {property:value;}\nCSS类也可以使用伪类：\n\nselector.class:pseudo-class {property:value;}\n\nanchor伪类\n在支持 CSS 的浏览器中，链接的不同状态都可以以不同的方式显示\n\n实例\na:link {color:#FF0000;} /* 未访问的链接 */\na:visited {color:#00FF00;} /* 已访问的链接 */\na:hover {color:#FF00FF;} /* 鼠标划过链接 */\na:active {color:#0000FF;} /* 已选中的链接 */\n\n尝试一下 »\n注意： 在CSS定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。\n\n注意： 在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。\n\n注意：伪类的名称不区分大小写。\n\n伪类和CSS类\n伪类可以与 CSS 类配合使用：\n\na.red:visited {color:#FF0000;}\n \n<a class=\"red\" href=\"css-syntax.html\">CSS 语法</a>\n如果在上面的例子的链接已被访问，它会显示为红色。\n\nCSS :first-child 伪类\n您可以使用 :first-child 伪类来选择父元素的第一个子元素。\n\n注意：在IE8的之前版本必须声明<!DOCTYPE> ，这样 :first-child 才能生效。\n\n匹配第一个 <p> 元素\n在下面的例子中，选择器匹配作为任何元素的第一个子元素的 <p> 元素：\n\n实例\np:first-child\n{\n    color:blue;\n}\n\n尝试一下 »\n匹配所有<p> 元素中的第一个 <i> 元素\n在下面的例子中，选择相匹配的所有<p>元素的第一个 <i> 元素：\n\n实例\np > i:first-child\n{\n    color:blue;\n}\n\n尝试一下 »\n匹配所有作为第一个子元素的 <p> 元素中的所有 <i> 元素\n在下面的例子中，选择器匹配所有作为元素的第一个子元素的 <p> 元素中的所有 <i> 元素：\n\n实例\np:first-child i\n{\n    color:blue;\n}\n\n尝试一下 »\nCSS - :lang 伪类\n:lang 伪类使你有能力为不同的语言定义特殊的规则\n\n注意：IE8必须声明<!DOCTYPE>才能支持;lang伪类。\n\n在下面的例子中，:lang 类为属性值为 no 的q元素定义引号的类型：\n\n实例\nq:lang(no) {quotes: \"~\" \"~\";}\n\n尝试一下 »\n\nExamples\n更多实例\n为超链接添加不同样式\n这个例子演示了如何为超链接添加其他样式。\n\n使用 :focus\n这个例子演示了如何使用 :focus伪类。\n\n所有CSS伪类/元素\n选择器\t示例\t示例说明\n:checked\tinput:checked\t选择所有选中的表单元素\n:disabled\tinput:disabled\t选择所有禁用的表单元素\n:empty\tp:empty\t选择所有没有子元素的p元素\n:enabled\tinput:enabled\t选择所有启用的表单元素\n:first-of-type\tp:first-of-type\t选择的每个 p 元素是其父元素的第一个 p 元素\n:in-range\tinput:in-range\t选择元素指定范围内的值\n:invalid\tinput:invalid\t选择所有无效的元素\n:last-child\tp:last-child\t选择所有p元素的最后一个子元素\n:last-of-type\tp:last-of-type\t选择每个p元素是其母元素的最后一个p元素\n:not(selector)\t:not(p)\t选择所有p以外的元素\n:nth-child(n)\tp:nth-child(2)\t选择所有 p 元素的父元素的第二个子元素\n:nth-last-child(n)\tp:nth-last-child(2)\t选择所有p元素倒数的第二个子元素\n:nth-last-of-type(n)\tp:nth-last-of-type(2)\t选择所有p元素倒数的第二个为p的子元素\n:nth-of-type(n)\tp:nth-of-type(2)\t选择所有p元素第二个为p的子元素\n:only-of-type\tp:only-of-type\t选择所有仅有一个子元素为p的元素\n:only-child\tp:only-child\t选择所有仅有一个子元素的p元素\n:optional\tinput:optional\t选择没有\"required\"的元素属性\n:out-of-range\tinput:out-of-range\t选择指定范围以外的值的元素属性\n:read-only\tinput:read-only\t选择只读属性的元素属性\n:read-write\tinput:read-write\t选择没有只读属性的元素属性\n:required\tinput:required\t选择有\"required\"属性指定的元素属性\n:root\troot\t选择文档的根元素\n:target\t#news:target\t选择当前活动#news元素(点击URL包含锚的名字)\n:valid\tinput:valid\t选择所有有效值的属性\n:link\ta:link\t选择所有未访问链接\n:visited\ta:visited\t选择所有访问过的链接\n:active\ta:active\t选择正在活动链接\n:hover\ta:hover\t把鼠标放在链接上的状态\n:focus\tinput:focus\t选择元素输入后具有焦点\n:first-letter\tp:first-letter\t选择每个<p> 元素的第一个字母\n:first-line\tp:first-line\t选择每个<p> 元素的第一行\n:first-child\tp:first-child\t选择器匹配属于任意元素的第一个子元素的 <p> 元素\n:before\tp:before\t在每个<p>元素之前插入内容\n:after\tp:after\t在每个<p>元素之后插入内容\n:lang(language)\tp:lang(it)\t为<p>元素的lang属性选择一个开始值"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973612736},"updatedAt":{"$$date":1598973879708},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"BfKwGsZimoLP4Vcy"}
{"name":"qk-ks_lib_git_pluglin","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'groovy'\n\ndependencies {\n    implementation gradleApi()\n    implementation localGroovy()\n    implementation 'org.eclipse.jgit:org.eclipse.jgit:5.5.1.201910021850-r'\n}\n\n////这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\nclass GitPlugin implements Plugin<Project> {\n    @Override\n    void apply(Project project) {\n        //创建Task\n        project.tasks.create('getGitInfo',\n                GitInfoTask)\n    }\n\n}\n\n\n\n\n\n\n\n\n\nclass GitInfoTask extends DefaultTask {\n\n    /**\n     * Prefix used to specify special text before the tag. Useful in projects which manage\n     * multiple external version names.\n     */\n    String prefix = \"\"\n\n    /**\n     * Search pattern for tags of interest. Tags not matching this pattern will be ignored.\n     */\n    String tagPattern = \"\"\n\n    /**\n     * When set, only includes commits containing changes to the specified path\n     */\n    String onlyIn = \"\"\n\n    /**\n     * DEPRECATED (use codeFormat instead): The amount of space allocated for each digit in the\n     * version code. For example, for a multiplier of 1000, 1.2.3 would result in a version\n     * code of 1002003\n     */\n    @Deprecated\n    Integer multiplier\n\n    /**\n     * DEPRECATED (use codeFormat instead): Number of parts expected in the version number.\n     */\n    @Deprecated\n    Integer parts\n\n    /**\n     * Base code, added to all generated version codes. Defaults to 0\n     */\n    int baseCode = 0\n\n    /**\n     * The number of characters to take from the front of a commit hash.\n     */\n    int commitHashLength = 7\n\n    /**\n     * Branches that should NOT be shown even if on an untagged commit\n     */\n    List<String> hideBranches = [ \"master\", \"release\" ]\n\n    /**\n     * Treat a build as dirty if there are any untracked files\n     */\n    boolean untrackedIsDirty = false\n\n    /**\n     * Format of version name string.\n     */\n    String format = '%tag%%-count%%-commit%%-branch%%-dirty%'\n\n    /**\n     * Format for versionCode output. null if user is still using deprecated fields.\n     */\n    String codeFormat\n\n    /**\n     * Map of ABI designators to integers.\n     */\n    def abis = abis = ['armeabi':1, 'armeabi-v7a':2, 'arm64-v8a':3, 'mips':5, 'mips64':6,\n                       'x86':8, 'x86_64':9 ]\n\n    def currentAbi = 0\n\n    enum CodePart {\n        EMPTY, MAJOR, MINOR, PATCH, REVISION, BUILD, ABI\n    }\n    private List<List> codeParts\n\n    private Results results\n\n    GitInfoTask() {\n        group = 'ks'\n        description = 'upload git info'\n    }\n\n    /**\n     * 执行于gradle执行阶段的代码\n     */\n    @TaskAction\n    void doAction() {\n        if (!results) results = scan()\n\n        println(\"results.branchName: \" + results.branchName)\n        println(\"results.lastVersion: \" + results.lastVersion)\n    }\n\n\n    private void validateSettings() {\n        if (commitHashLength < 4 || commitHashLength > 40) {\n            throw new GradleException(\"commitHashLength of $commitHashLength must be in the range of 4..20\")\n        }\n    }\n\n    private Results scan() {\n        validateSettings()\n        Results results = new Results()\n\n        Repository repo\n        try {\n            repo = new FileRepositoryBuilder()\n                    .readEnvironment()\n                    .findGitDir(project.projectDir)\n                    .build()\n        } catch (IllegalArgumentException ignore) {\n            // No repo found\n            return results\n        }\n\n        def git = Git.wrap(repo)\n        def head = repo.findRef(Constants.HEAD).getTarget()\n        // No commits?\n        if (!head.getObjectId()) return results\n\n        results.commitPrefix = ObjectId.toString(head.getObjectId())[0..(commitHashLength - 1)]\n        results.branchName = repo.getBranch()\n\n        // Check to see if uncommitted files exist\n        results.dirty = git.status().call().hasUncommittedChanges() ||\n                (untrackedIsDirty && !git.status().call().getUntracked().isEmpty())\n\n        // Collect known tags\n        Iterable<TagInfo> tags = getTagInfos(repo, git)\n\n        // Review commits, counting revs until a suitable tag is found.\n        RevWalk revs = new RevWalk(repo)\n        revs.markStart(revs.parseCommit(head.getObjectId()))\n        results.revCount = 0\n        Collection<TagInfo> commitTags = null\n\n        for (RevCommit commit : revs) {\n            def tagsHere = tags.findAll { (it.getObjectId() == commit) }\n            if (tagsHere) {\n                commitTags = tagsHere\n                break\n            }\n\n            // Does this commit contain a change to a file in onlyIn?\n            if (containsRelevantChange(repo, commit)) {\n                results.revCount++\n            }\n        }\n\n        // No good tags?\n        if (!commitTags) {\n            results.lastVersion = \"untagged\"\n            return results\n        }\n\n        // Convert tags to names w/o prefixes and get the shortest and last one numerically\n        results.lastVersion = commitTags.\n                collect { (it.getName() - prefix) }.\n                sort { a, b ->\n                    [versionParts(a), versionParts(b)]\n                            .transpose()\n                            .findResult { x, y -> x <=> y ?: null } ?: b.size() <=> a.size()\n                }.\n                last()\n\n        String gitDescribeOutput = git.describe().setTags(true).call()\n        if (gitDescribeOutput != null) {\n            results.gitDescribeOutput = gitDescribeOutput\n        }\n        results\n    }\n\n\n    /** Collect all available tag information */\n    private List<TagInfo> getTagInfos(Repository repo, Git git) {\n        String searchPattern = tagPattern.isEmpty() ? /^$prefix[0-9]+.*/ : tagPattern\n        RevWalk walk = new RevWalk(repo)\n        List<TagInfo> infos = git.tagList().call().findResults { ref ->\n            RevObject obj = walk.parseAny(ref.getObjectId())\n            TagInfo tag = null\n            if (obj instanceof RevTag) {\n                // Annotated tag\n                tag = new TagInfo(obj.getObject().getId(), obj.getTagName())\n            } else if (obj instanceof RevCommit) {\n                // Lightweight tag\n                tag = new TagInfo(obj.getId(),\n                        Repository.shortenRefName(ref.getName()))\n            }\n\n            if (tag && tag.getName().matches(searchPattern) && tag.getName().startsWith(prefix)) {\n                tag\n            } else {\n                null\n            }\n        }\n        walk.close()\n        return infos\n    }\n\n    class TagInfo {\n        ObjectId objectId\n        String name\n\n        TagInfo(ObjectId objectId, String name) {\n            this.objectId = objectId\n            this.name = name\n        }\n\n        ObjectId getObjectId() {\n            objectId\n        }\n\n        String getName() {\n            name\n        }\n\n        @Override\n        String toString() { \"TagInfo: \" + objectId + \", name=\" + name }\n    }\n\n\n    class Results {\n        /** Number of commits since last relevant tag */\n        int revCount = 0\n\n        /** Prefix hash for the current commit */\n        String commitPrefix\n\n        /** Branch name for the current commit */\n        String branchName\n\n        /** true if there are uncommitted changes */\n        boolean dirty = false\n\n        /** Most recent version seen */\n        String lastVersion = 'unknown'\n\n        /** The resulting output from calling git describe */\n        String gitDescribeOutput = 'unknown'\n\n        List getVersionParts(int parts) {\n            List<String> empties = (1..parts).collect { \"0\" }\n            return (!lastVersion ? empties : lastVersion.\n                    split(/[^0-9]+/) + empties).\n                    findAll { !it.isEmpty() }.\n                    collect { it as int }[0..<parts]\n        }\n\n        int getVersionPart(int index) {\n            return getVersionParts(index + 1)[index]\n        }\n\n        int addCodePart(int code, CodePart part, int width) {\n            def digits\n            switch (part) {\n                case CodePart.MAJOR: digits = getVersionPart(0); break\n                case CodePart.MINOR: digits = getVersionPart(1); break\n                case CodePart.PATCH: digits = getVersionPart(2); break\n                case CodePart.REVISION: digits = getVersionPart(3); break\n                case CodePart.BUILD: digits = revCount; break\n                case CodePart.ABI: digits = currentAbi; break\n                case CodePart.EMPTY: digits = 0; break\n                default: throw new GradleException(\"Unimplemented part \" + part)\n            }\n            if (((int) Math.log10(digits)) + 1 > width) {\n                throw new GradleException(\"Not enough room for \" + digits + \" in \" + part +\n                        \" width=\" + width)\n            }\n            return code * Math.pow(10, width) + digits\n        }\n    }\n\n    /** Return true if this commit contains a change to the onlyIn path */\n    private boolean containsRelevantChange(Repository repo, RevCommit commit) {\n        if (!onlyIn) return true\n\n        if (commit.getParentCount() == 0) {\n            TreeWalk tw = new TreeWalk(repo)\n            tw.reset()\n            tw.setRecursive(true)\n            tw.addTree(commit.getTree())\n            //noinspection ChangeToOperator - ++tw may attempt to assign a boolean to tw\n            while (tw.next()) {\n                if (tw.getPathString().startsWith(onlyIn)) return true\n            }\n        } else {\n            RevWalk rw = new RevWalk(repo)\n            RevCommit parent = rw.parseCommit(commit.getParent(0).getId())\n            DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)\n            df.setRepository(repo)\n            df.setDiffComparator(RawTextComparator.DEFAULT)\n            df.setDetectRenames(true)\n            List<DiffEntry> diffs = df.scan(parent.getTree(), commit.getTree())\n            for (DiffEntry diff : diffs) {\n                if (diff.getOldPath().startsWith(onlyIn) || diff.getNewPath().startsWith(onlyIn)) return true\n            }\n        }\n        return false\n    }\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598584064420},"updatedAt":{"$$date":1598584443094},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"BgbDuhURv7obnu2M"}
{"name":"git b","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"1.git branch -a   查看远程分支\n\n2.git checkout -b xxxx（本地分支名称） yyyy(上条命令查找到的远程分支的名称)\n\n3.git branch 检查下 本地分支是否创建成功"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598549150599},"updatedAt":{"$$date":1598580857327},"_id":"BiyJUDAq7TpBMnaz","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-[Kotlin协程] 回调地狱的一种解决思路","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\njuejin.im /post/6844904192805453838\n[Kotlin协程] 回调地狱的一种解决思路 - 掘金\nBestNevermore 2020年06月16日 阅读 690 关注\n5-6 minutes\n背景\n异步回调的方式虽然实现了需求,但是牺牲了可读性,过多的回调让代码变得难以维护.\n\n解决思路\nrxjava->协程\nJava语言开发的时候,可以借助一些第三方库如RxJava,来让减少嵌套. 但是实际落地的效果并不理想, 因为不能保证团队里面每个人都擅长并且能够接受Rx的风格.\n\n在使用kotlin协程的时候我发现了新世界.\n\n协程+流式设计\n我的需求是实现一个订阅功能,并将功能模块化后提供给其他产品线.\n\n外部调用\n外部调用者传入一个id,sdk告诉外部购买成功还是发生异常.\n\n内部实现\n\n内部实现大体上是以上6步. 但是这里每一步都是异步的,如果用java实现,免不了处理很多回调代码. 我尝试使用kotlin+协程完成,发现出奇的简单易读.\n\n\nfun Activity.goSubscript(productID: String, exceptionHandler: CoroutineExceptionHandler) =\n    CoroutineScope(Dispatchers.Main).launch(exceptionHandler) {\n        SubscriptHelper(this@goSubscript).run {\n            \n            init() \n            \n            getAvailableHistory()?.let { purchase ->\n                if (checkPurchase(purchase)) {\n                    return@launch;\n                }\n            }\n            \n            val skuDetails = getAvailableProducte(productID)\n            \n            val purchase = subscriptProducte(this@goSubscript, skuDetails)\n            \n            val isCheckedSuccess = checkPurchase(purchase)\n            \n            if (!isCheckedSuccess) {\n                val acknowSuccess = acknowledgePurchase(purchase)\n                logd(content = \"客户端确认${if (acknowSuccess) \"成功\" else \"失败\"} \");\n            }\n        }\n    }\n复制代码\n体会了下kotlin的协程代码风格,这大概就是Kotlin的魅力吧. 那么怎么来实现上诉风格的代码呢? 这里大概需要有两个问题要解决:\n\n怎么把Java异步回调转化成suspend函数.\n怎么处理java回调哪些异常场景.\n把回调转化成suspend函数\n解决办法:利用通道\n\n使用suspendCoroutine\n    \n    suspend fun init(): Boolean = try {\n        withTimeout(1500) {\n            suspendCoroutine<Boolean> { continuation ->\n                billingClient =\n                    BillingClient.newBuilder(context).setListener(listenerUpdate)\n                        .enablePendingPurchases()\n                        .build()\n                        .apply {\n                            startConnection {\n                                onBillingSetupFinishedFun {\n                                    continuation.resume(true)\n                                }\n                            }\n                        };\n            }\n        }\n    } catch (e: TimeoutCancellationException) {\n        throw InitException()\n    }\n复制代码\n看上面这个初始化的栗子,先构造了一个withTimeout协程代码块,然后 在suspendCoroutine代码块会生成一个continuation参数,在onBillingSetupFinishedFun函数回调的时候,我们直接使用这个参数来发送消息,结束挂起.\n\n例如成功的时候返回\n\n    continuation.resume(true)\n复制代码\n异常的时候可以\n\n    continuation.resumeWithException()\n复制代码\n使用channel 有的情况下回调不是通过callback完成的,例如使用Handler机制完成的回调代码,怎么转化成协程.\n  var channel: Channel<BillingResult> = Channel();\n  \n  \n    var listenerUpdate: PurchasesUpdatedListener = object : PurchasesUpdatedListener {\n        override fun onPurchasesUpdated(\n            billingResult: BillingResult?,\n            purchases: MutableList<Purchase>?\n        ) {\n            CoroutineScope(Dispatchers.Main).launch {\n                purchases?.let {\n                    if (it.size >= 0) {\n                        purchase = it[0]\n                    }\n                }\n                channel.send(billingResult!!)\n                channel.close()\n            }\n        }\n    };  \n    \n\n    suspend fun subscriptProducte(activity: Activity, skuDetails: SkuDetails): Purchase {\n        billingClient.launchBillingFlow(\n            activity,\n            BillingFlowParams.newBuilder().setSkuDetails(skuDetails).build()\n        )\n        val result = channel.receive()\n        when (result.responseCode) {\n            BillingClient.BillingResponseCode.OK -> {\n                return purchase!!\n            }\n            BillingClient.BillingResponseCode.USER_CANCELED -> {\n                throw UserCancleException()\n            }\n\n            else -> {\n                throw SubscriptProductException(result.debugMessage)\n            }\n        }\n    }\n复制代码\n也就是说channel可以单独出来作为一个对象使用.\n\n协程异常处理\n上面的调用函数设计的时候,我构造了一个参数exceptionHandler,用作整个事件的异常处理.\n\nfun Activity.goSubscript(productID: String, exceptionHandler: CoroutineExceptionHandler) =\n    CoroutineScope(Dispatchers.Main).launch(exceptionHandler) {\n复制代码\n然后我定义了一些异常类型\n\nclass InitException(msg: String = \"\") : Exception()\nclass RepeateSubscription(msg: String = \"\") : Exception()\nclass NoProducteException(msg: String = \"\") : Exception()\nclass UserCancleException(msg: String = \"\") : Exception()\nclass SubscriptProductException(msg: String = \"\") : Exception()\nclass AcknowException(msg: String = \"\") : Exception()\n复制代码\n然后当内部出现购买失败的回调的时候,主动抛出一个异常,把整个事件流中断,外部处理这些异常也很简单,直接定义一个exceptionHandler(是个参数是throwable的函数)对象接收.\n\n\n总结起来就是:\n\n通过抛出异常来中断事件流\n异常在协程内部会向上传导\n外部开辟一个协程任务的时候,可以给内部指定一个异常处理器\n总结\n看过一些讲协程的文章,大多都是讲一些原理和API的使用,总感觉没有吸引到让我觉得他比线程模式更好,然后自己摸索着在项目中写了一次.\n大概这就是 纸上得来终觉浅，绝知此事要躬行吧.\n\nAndroid开发,为什么要用Kotlin而不是Java"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597400502774},"updatedAt":{"$$date":1597402949105},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ByBUv2pB8TT8PZ2C"}
{"name":"ad-app","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\npackage com.ks.frame\n\nimport android.content.Context\nimport android.util.Log\nimport androidx.multidex.MultiDex\nimport com.ks.frame.base.BaseApplication\nimport com.ks.frame.base.ExceptionHandler\nimport com.ks.frame.image.FrescoLoader\nimport com.ks.frame.image.GlideLoader\nimport com.ks.frame.imageload.ImageLoaderConfig\nimport com.ks.frame.imageload.KsLoader\nimport com.ks.frame.imageload.LoaderEnum\n\n/**\n *\n * @Author hailufeng\n * 邮箱：hilofeng@homail.com\n * 创建时间: 2020/8/20  6:20 PM\n * 用途\n * **************************************\n */\nclass App : BaseApplication() {\n    override fun initInOtherPocess() {\n    }\n\n    override fun <H : ExceptionHandler> getExceptionHandle(exceptionHandler: Thread.UncaughtExceptionHandler?): H? {\n       return null\n    }\n\n    override fun isUseDragBack(): Boolean {\n        return true\n    }\n\n    override fun initMainProcessTask() {\n\n        val config = ImageLoaderConfig.Builder()\n                //添加glide\n                .addImageLodaer(LoaderEnum.GLIDE,GlideLoader())\n                // 添加fresco\n                .addImageLodaer(LoaderEnum.FRESCO,FrescoLoader())\n                // 添加picasso\n               // .addImageLodaer(LoaderEnum.PICASSO,PicassoLoad())\n                // 图片缓存文件夹\n                .diskCacheDir(cacheDir.absolutePath)\n                // 配置磁盘缓存大小\n                .maxDiskSize(100*1024*1024)\n                // 配置最大内存缓存大小\n                .maxMemorySize(50*1024*1024)\n                .build()\n\n        KsLoader.init(this,config)\n\n\n      //  KsLoader.registLoader(LoaderEnum.FRESCO,FrescoLoader())\n\n\n        Log.e(\"fhl\",\"initMainProcessTask\")\n    }\n\n\n    override fun onTrimMemory(level: Int) {\n        super.onTrimMemory(level)\n\n    }\n\n    override fun attachBaseContext(base: Context?) {\n        super.attachBaseContext(base)\n      //  MultiDex.install(base)\n        Log.e(\"fhl\",\"attachBaseContext\")\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\nclass MainActivity : BaseAct<MainViewModle>() {\n    var vm: MainViewModle? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        vm = MainViewModle()\n        super.onCreate(savedInstanceState)\n\n    }\n\n\n\n    override fun startObserve() {\n        vm?.fresh?.observe(this, Observer {\n               val i = it%4\n                when(i){\n                    1->{\n                        setEmptyDrawable(R.drawable.ic_stat_name)\n                        showEmpty()\n                    }\n                    2->{\n                        showLoading()\n                    }\n                    3->{\n                        showError()\n                    }\n                    0->{\n                        showSuccess()\n                    }\n                }\n        })\n    }\n    override fun getLayoutResId(): Int {\n        return R.layout.activity_main\n    }\n\n    override fun onBackPressed() {\n\n        super.onBackPressed()\n\n    }\n\n    override fun initView() {\n        tv_click.setOnClickListener{\n            vm?.getData()\n        }\n        // 前后台监听\n        ActivityStackManager.instance.isForeground.observe(this, Observer {\n            Toast.makeText(applicationContext,\"是否后台${it}\",Toast.LENGTH_SHORT).show()\n            Log.e(\"ActivityStackManager\",\"是否后台${it}\")\n        })\n\n        tv_openFragment.setOnClickListener{\n            supportFragmentManager.beginTransaction().add(R.id.frame_root,TestFragment())\n                    .addToBackStack(\"test\").commit()\n        }\n\n        // 方式1：构建加载图片参数  初始化 高斯模糊、圆角、gif、圆形 等参数\n        KsLoader.loadImage(LoadOptions.Builder(iv_pic,ImageUrlsDatas.urls[1])\n                .error(R.drawable.ic_action_name).placeholder(R.drawable.ic_action_error)\n                .owner(this).build()\n        )\n\n        // 方式2  调用方法 加载Gif\n        KsLoader.loadGif(this, iv_gif,ImageUrlsDatas.urls[0],R.drawable.ic_action_error,R.drawable.ic_action_error,null)\n\n        // 方式2 调用方法 加载.9图\n        KsLoader.loadNinePatch(tv_text,ImageUrlsDatas.urls[2],R.drawable.ic_action_error)\n\n        // 方式2 调用方法加载圆图\n        KsLoader.loadCircle(this,iv_circle,ImageUrlsDatas.urls[5],R.drawable.ic_stat_name,R.drawable.ic_action_error)\n\n        // 切换当前默认图片加载器\n        KsLoader.switchLoad(LoaderEnum.FRESCO)\n\n        //指定图片加载器加载\n       // KsLoader.loadImage(LoaderEnum.GLIDE)\n\n    }\n\n    override fun wrapView(): View {\n        return frame_root\n    }\n\n\n    override fun initData() {}\n    override fun isUseEventBus(): Boolean {\n        return false\n    }\n}\n\n\n\n\n\n\n\n\n\nclass MainViewModle : BaseViewModel() {\n    val fresh = IntLiveData()\n\n    fun getData(){\n        launch {\n            getDatas()\n        }\n        fresh.value ++\n    }\n\n    suspend fun  getDatas(){\n        delay(4000)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion BuildVersion.compile_sdk\n    buildToolsVersion BuildVersion.tool_version\n\n\n    defaultConfig {\n        applicationId app_id\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        multiDexEnabled true\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    buildFeatures.dataBinding = true\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation deps.androidx.app_compat\n    implementation deps.androidx.constraint_layout\n\n    androidTestImplementation deps.test.junit\n    testImplementation deps.test.test_runner\n    testImplementation deps.test.spresso_core\n    api project(':ks_frame_ui')\n\n //   api 'com.ks.frame:baseui:0.0.1.1-SNAPSHOT'\n    // 图片加载核心库\n    api ('com.ks.frame:imageload-core:0.0.1.1-SNAPSHOT'){changing = true}\n    // glide\n    api 'com.ks.frame:imageload-glide:0.0.1.1-SNAPSHOT'\n    // fresco\n    api 'com.ks.frame:imageload-fresco:0.0.1.1-SNAPSHOT'\n    // picasso\n    //api 'com.ks.frame:imageload-picasso:0.0.1.1-SNAPSHOT'\n\n  //  api 'androidx.lifecycle:lifecycle-runtime:2.2.0'\n}\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539555103},"updatedAt":{"$$date":1598542820401},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"BzrjeyMr1cMoL4S4"}
{"name":"ad-local.properties","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n## This file must *NOT* be checked into Version Control Systems,\n# as it contains information specific to your local configuration.\n#\n# Location of the SDK. This is only used by Gradle.\n# For customization when using a Version Control System, please read the\n# header note.\n#Thu Jul 09 13:53:46 CST 2020\n\nsdk.dir=/Users/yanglc/Library/Android/sdk\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515776780},"updatedAt":{"$$date":1598516797115},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"C0ehnZECfHRxWIMK"}
{"name":"css-CSS 表格","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"表格边框\n指定CSS表格边框，使用border属性。\n\n下面的例子指定了一个表格的Th和TD元素的黑色边框：\n\n实例\ntable, th, td\n{\n    border: 1px solid black;\n}\n\n尝试一下 »\n请注意，在上面的例子中的表格有双边框。这是因为表和th/ td元素有独立的边界。\n\n为了显示一个表的单个边框，使用 border-collapse属性。\n\n折叠边框\nborder-collapse 属性设置表格的边框是否被折叠成一个单一的边框或隔开：\n\n实例\ntable\n{\n    border-collapse:collapse;\n}\ntable,th, td\n{\n    border: 1px solid black;\n}\n\n尝试一下 »\n\n表格宽度和高度\nWidth和height属性定义表格的宽度和高度。\n\n下面的例子是设置100％的宽度，50像素的th元素的高度的表格：\n\n实例\ntable \n{\n    width:100%;\n}\nth\n{\n    height:50px;\n}\n\n尝试一下 »\n\n表格文字对齐\n表格中的文本对齐和垂直对齐属性。\n\ntext-align属性设置水平对齐方式，向左，右，或中心：\n\n实例\ntd\n{\n    text-align:right;\n}\n\n尝试一下 »\n垂直对齐属性设置垂直对齐，比如顶部，底部或中间：\n\n实例\ntd\n{\n    height:50px;\n    vertical-align:bottom;\n}\n\n尝试一下 »\n\n表格填充\n如果在表的内容中控制空格之间的边框，应使用td和th元素的填充属性：\n\n实例\ntd\n{\n    padding:15px;\n}\n\n尝试一下 »\n\n表格颜色\n下面的例子指定边框的颜色，和th元素的文本和背景颜色：\n\n实例\ntable, td, th\n{\n    border:1px solid green;\n}\nth\n{\n    background-color:green;\n    color:white;\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888550978},"updatedAt":{"$$date":1598888927179},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"C8KlJoTXahtvtlYn"}
{"name":"qk-ks_lib_magic_indicator","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 101\n        versionName \"101\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n\n\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.appcompat\n    api deps.kotlin.stdlib_jdk\n}\n\nrepositories {\n    mavenCentral()\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580909894},"updatedAt":{"$$date":1598583905535},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"C8jPyR9vNBY0Cemp"}
{"name":"kotlin-取集合的一部分 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-parts.html\n取集合的一部分 - Kotlin 语言中文站\n12-15 minutes\n改进翻译\nKotlin 标准库包含用于取集合的一部分的扩展函数。 这些函数提供了多种方法来选择结果集合的元素：显式列出其位置、指定结果大小等。\n\nslice() 返回具有给定索引的集合元素列表。 索引既可以是作为区间传入的也可以是作为整数值的集合传入的。\n\nfun main() {\n//sampleStart    \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")    \n    println(numbers.slice(1..3))\n    println(numbers.slice(0..4 step 2))\n    println(numbers.slice(setOf(3, 5, 0)))    \n//sampleEnd\n}\n要从头开始获取指定数量的元素，请使用 take() 函数。 要从尾开始获取指定数量的元素，请使用 takeLast()。 当调用的数字大于集合的大小时，两个函数都将返回整个集合。\n\n要从头或从尾去除给定数量的元素，请调用 drop() 或 dropLast() 函数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.take(3))\n    println(numbers.takeLast(3))\n    println(numbers.drop(1))\n    println(numbers.dropLast(5))\n//sampleEnd\n}\n还可以使用谓词来定义要获取或去除的元素的数量。 有四个与上述功能相似的函数：\n\ntakeWhile() 是带有谓词的 take()：它将不停获取元素直到排除与谓词匹配的首个元素。如果首个集合元素与谓词匹配，则结果为空。\ntakeLastWhile() 与 takeLast() 类似：它从集合末尾获取与谓词匹配的元素区间。区间的首个元素是与谓词不匹配的最后一个元素右边的元素。如果最后一个集合元素与谓词匹配，则结果为空。\ndropWhile() 与具有相同谓词的 takeWhile() 相反：它将首个与谓词不匹配的元素返回到末尾。\ndropLastWhile() 与具有相同谓词的 takeLastWhile() 相反：它返回从开头到最后一个与谓词不匹配的元素。\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.takeWhile { !it.startsWith('f') })\n    println(numbers.takeLastWhile { it != \"three\" })\n    println(numbers.dropWhile { it.length == 3 })\n    println(numbers.dropLastWhile { it.contains('i') })\n//sampleEnd\n}\n要将集合分解为给定大小的“块”，请使用 chunked() 函数。 chunked() 采用一个参数（块的大小），并返回一个 List 其中包含给定大小的 List。 第一个块从第一个元素开始并包含 size 元素，第二个块包含下一个 size 元素，依此类推。 最后一个块的大小可能较小。\n\nfun main() {\n//sampleStart\n    val numbers = (0..13).toList()\n    println(numbers.chunked(3))\n//sampleEnd\n}\n还可以立即对返回的块应用转换。 为此，请在调用 chunked() 时将转换作为 lambda 函数提供。 lambda 参数是集合的一块。当通过转换调用 chunked() 时， 这些块是临时的 List，应立即在该 lambda 中使用。\n\nfun main() {\n//sampleStart\n    val numbers = (0..13).toList() \n    println(numbers.chunked(3) { it.sum() })  // `it` 为原始集合的一个块\n//sampleEnd\n}\n可以检索给定大小的集合元素中所有可能区间。 获取它们的函数称为 windowed()：它返回一个元素区间列表，比如通过给定大小的滑动窗口查看集合，则会看到该区间。 与 chunked() 不同，windowed() 返回从每个集合元素开始的元素区间（窗口）。 所有窗口都作为单个 List 的元素返回。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.windowed(3))\n//sampleEnd\n}\nwindowed() 通过可选参数提供更大的灵活性：\n\nstep 定义两个相邻窗口的第一个元素之间的距离。默认情况下，该值为 1，因此结果包含从所有元素开始的窗口。如果将 step 增加到 2，将只收到以奇数元素开头的窗口：第一个、第三个等。\npartialWindows 包含从集合末尾的元素开始的较小的窗口。例如，如果请求三个元素的窗口，就不能为最后两个元素构建它们。在本例中，启用 partialWindows 将包括两个大小为2与1的列表。\n最后，可以立即对返回的区间应用转换。 为此，在调用 windowed() 时将转换作为 lambda 函数提供。\n\nfun main() {\n//sampleStart\n    val numbers = (1..10).toList()\n    println(numbers.windowed(3, step = 2, partialWindows = true))\n    println(numbers.windowed(3) { it.sum() })\n//sampleEnd\n}\n要构建两个元素的窗口，有一个单独的函数——zipWithNext()。 它创建接收器集合的相邻元素对。 请注意，zipWithNext() 不会将集合分成几对；它为 每个 元素创建除最后一个元素外的对，因此它在 [1, 2, 3, 4] 上的结果为 [[1, 2], [2, 3], [3, 4]]，而不是 [[1, 2]，[3, 4]]。 zipWithNext() 也可以通过转换函数来调用；它应该以接收者集合的两个元素作为参数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.zipWithNext())\n    println(numbers.zipWithNext() { s1, s2 -> s1.length > s2.length})\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382131429},"updatedAt":{"$$date":1597383731943},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"CIFrqFCg29Fd4H1g"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975878417},"updatedAt":{"$$date":1598975878417},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"CRUsyduWmWCBHEEa"}
{"name":"yyyy","folderId":"ni3NGVu7G","content":[{"label":"Fragment 1","language":"text","value":"sdfsdfsrrrr"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1596552721209},"updatedAt":{"$$date":1596552725709},"_id":"CZGpq7vmIsAaVg6x","folder":{"id":"ni3NGVu7G","name":"Default","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"新BaseUi库简单使用文档","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"简介\n1.集成依赖\n   api 'com.ks.frame:baseui:0.0.1.0-SNAPSHOT'\n2.BaseActivity封装\n封装app层中间类，集成app自身风格的Loading，Empty、Error等状态页\n集成 BaseVMActivity \nabstract class BaseAct<VM :ViewModel> :BaseVMActivity<VM>() {\n    override fun onRetry() {\n    }\n    override fun errorLayoutId(): Int {\n        return R.layout.base_layout_error\n    }\n    override fun loadingLayoutId(): Int {\n        return  R.layout.loading_layout_loading\n    }\n    override fun emptyLayoutId(): Int {\n        return R.layout.base_layout_empty\n    }\n    \n    // 是否监听网络状态变化 \n    override fun isMonitNetworkChange(): Boolean {\n        return false\n    }\n}\n3.BaseFragment 封装\n封装app层中间类，集成app自身风格的Loading，Empty、Error等状态页\n集成 BaseVMFragment\n abstract  class BaseFrag<VM: ViewModel> : BaseVMFragment<VM>() {\n    override fun getErrorRes(): Int {\n        return R.drawable.ic_action_name\n    }\n    override fun onRetry() {\n    }\n    override fun loadingLayoutId(): Int {\n        return  R.layout.loading_layout_loading\n    }\n    override fun emptyLayoutId(): Int {\n        return R.layout.base_layout_empty\n    }\n    override fun isMonitNetworkChange(): Boolean {\n        return false\n    }\n    override fun errorLayoutId(): Int {\n        return R.layout.base_layout_error\n    }\n4.LoadingLayout 使用 \n重写Wrap（ ） 方法，返回目标View，返回的View 被LoadingLayout 替换并称作为LoadingLayout的子View\n    // 返回需要状态管理变化的View，这个View为数据成功展示的View\n    override fun wrapView(): View {\n        return frame_root\n    }\n    \n5. ViewModle使用\n    自定义ViewModle 继承 BaseViewModel \nBaseViewModel中封装协程相关方法\nclass TestViewModel : BaseViewModel() {\n    val testData = IntLiveData()\n    fun getData(){\n        // 异步launch 方法 添加到协程\n        launch {  getDataDelay()}\n    }\n    suspend fun  getDataDelay():Int{\n        delay(50000)\n        testData.value++\n        // 数据更新到liveData\n        testData.postValue(200)\n        return 200\n    }\n}\n注：Base库目前仅提供基础功能，更多功能后续不断完善，本文档为简单使用文档，后续功能完善后统一出详细使用文档"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598547668544},"updatedAt":{"$$date":1598547679301},"_id":"CZfUpvdVcEKMt5y2","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"CSS3 弹性盒子(Flex Box)","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"弹性盒子是 CSS3 的一种新的布局模式。\n\nCSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。\n\n引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。\n\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器的版本号。\n\n紧跟在数字后面的 -webkit- 或 -moz- 为指定浏览器的前缀。\n\n属性\t\t\t\t\t\nBasic support\n(single-line flexbox)\t29.0\n21.0 -webkit-\t11.0\t22.0\n18.0 -moz-\t6.1 -webkit-\t12.1 -webkit-\nMulti-line flexbox\t29.0\n21.0 -webkit-\t11.0\t28.0\t6.1 -webkit-\t17.0\n15.0 -webkit-\n12.1\nCSS3 弹性盒子内容\n弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。\n\n弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。\n\n弹性容器内包含了一个或多个弹性子元素。\n\n注意： 弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局。\n\n弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。\n\n以下元素展示了弹性子元素在一行内显示，从左到右:\n\n实例\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n \n.flex-item {\n    background-color: cornflowerblue;\n    width: 100px;\n    height: 100px;\n    margin: 10px;\n}\n</style>\n</head>\n<body>\n \n<div class=\"flex-container\">\n  <div class=\"flex-item\">flex item 1</div>\n  <div class=\"flex-item\">flex item 2</div>\n  <div class=\"flex-item\">flex item 3</div> \n</div>\n \n</body>\n</html>\n\n尝试一下 »\n当然我们可以修改排列方式。\n\n如果我们设置 direction 属性为 rtl (right-to-left),弹性子元素的排列方式也会改变，页面布局也跟着改变:\n\n实例\nbody {\n    direction: rtl;\n}\n \n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n \n.flex-item {\n    background-color: cornflowerblue;\n    width: 100px;\n    height: 100px;\n    margin: 10px;\n}\n\n尝试一下 »\nflex-direction\nflex-direction 属性指定了弹性子元素在父容器中的位置。\n\n语法\nflex-direction: row | row-reverse | column | column-reverse\nflex-direction的值有:\n\nrow：横向从左到右排列（左对齐），默认的排列方式。\nrow-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。\ncolumn：纵向排列。\ncolumn-reverse：反转纵向排列，从后往前排，最后一项排在最上面。\n以下实例演示了 row-reverse 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-flex-direction: row-reverse;\n    flex-direction: row-reverse;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 column 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-flex-direction: column;\n    flex-direction: column;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 column-reverse 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-flex-direction: column-reverse;\n    flex-direction: column-reverse;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\njustify-content 属性\n内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\n\njustify-content 语法如下：\n\njustify-content: flex-start | flex-end | center | space-between | space-around\n各个值解析:\n\nflex-start：\n弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。\n\nflex-end：\n弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。\n\ncenter：\n弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。\n\nspace-between：\n弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。\n\nspace-around：\n弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。\n\n效果图展示：\n\n\n\n以下实例演示了 flex-end 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-justify-content: flex-end;\n    justify-content: flex-end;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 center 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-justify-content: center;\n    justify-content: center;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 space-between 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-justify-content: space-between;\n    justify-content: space-between;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 space-around 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-justify-content: space-around;\n    justify-content: space-around;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\nalign-items 属性\nalign-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。\n\n语法\nalign-items: flex-start | flex-end | center | baseline | stretch\n各个值解析:\n\nflex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\nflex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\ncenter：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\nbaseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\nstretch：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n以下实例演示了 stretch(默认值) 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-align-items: stretch;\n    align-items: stretch;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 flex-start 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-align-items: flex-start;\n    align-items: flex-start;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 flex-end 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-align-items: flex-end;\n    align-items: flex-end;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 center 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-align-items: center;\n    align-items: center;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 baseline 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-align-items: baseline;\n    align-items: baseline;\n    width: 400px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\nflex-wrap 属性\nflex-wrap 属性用于指定弹性盒子的子元素换行方式。\n\n语法\nflex-wrap: nowrap|wrap|wrap-reverse|initial|inherit;\n各个值解析:\n\nnowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\nwrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\nwrap-reverse -反转 wrap 排列。\n以下实例演示了 nowrap 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-flex-wrap: nowrap;\n    flex-wrap: nowrap;\n    width: 300px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 wrap 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-flex-wrap: wrap;\n    flex-wrap: wrap;\n    width: 300px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n以下实例演示了 wrap-reverse 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-flex-wrap: wrap-reverse;\n    flex-wrap: wrap-reverse;\n    width: 300px;\n    height: 250px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\nalign-content 属性\nalign-content 属性用于修改 flex-wrap 属性的行为。类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐。\n\n语法\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch\n各个值解析:\n\nstretch - 默认。各行将会伸展以占用剩余的空间。\nflex-start - 各行向弹性盒容器的起始位置堆叠。\nflex-end - 各行向弹性盒容器的结束位置堆叠。\ncenter -各行向弹性盒容器的中间位置堆叠。\nspace-between -各行在弹性盒容器中平均分布。\nspace-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。\n以下实例演示了 center 的使用:\n\n实例\n.flex-container {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-flex-wrap: wrap;\n    flex-wrap: wrap;\n    -webkit-align-content: center;\n    align-content: center;\n    width: 300px;\n    height: 300px;\n    background-color: lightgrey;\n}\n\n尝试一下 »\n弹性子元素属性\n排序\n语法\norder: \n各个值解析:\n\n<integer>：用整数值来定义排列顺序，数值小的排在前面。可以为负值。\norder 属性设置弹性容器内弹性子元素的属性:\n\n实例\n.flex-item {\n    background-color: cornflowerblue;\n    width: 100px;\n    height: 100px;\n    margin: 10px;\n}\n \n.first {\n    -webkit-order: -1;\n    order: -1;\n}\n\n尝试一下 »\n对齐\n设置\"margin\"值为\"auto\"值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为\"auto\"，可以使弹性子元素在弹性容器的两上轴方向都完全居中。\n\n以下实例在第一个弹性子元素上设置了 margin-right: auto; 。 它将剩余的空间放置在元素的右侧：\n\n实例\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: 10px;\n}\n \n.flex-item:first-child {\n    margin-right: auto;\n}\n\n尝试一下 »\n完美的居中\n以下实例将完美解决我们平时碰到的居中问题。\n\n使用弹性盒子，居中变的很简单，只想要设置 margin: auto; 可以使得弹性子元素在两上轴方向上完全居中:\n\n实例\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: auto;\n}\n\n尝试一下 »\nalign-self\nalign-self 属性用于设置弹性元素自身在侧轴（纵轴）方向上的对齐方式。\n\n语法\nalign-self: auto | flex-start | flex-end | center | baseline | stretch\n各个值解析:\n\nauto：如果'align-self'的值为'auto'，则其计算值为元素的父元素的'align-items'值，如果其没有父元素，则计算值为'stretch'。\nflex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\nflex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\ncenter：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\nbaseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\nstretch：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n以下实例演示了弹性子元素上 align-self 不同值的应用效果：\n\n实例\n.flex-item {\n    background-color: cornflowerblue;\n    width: 60px;\n    min-height: 100px;\n    margin: 10px;\n}\n \n.item1 {\n    -webkit-align-self: flex-start;\n    align-self: flex-start;\n}\n.item2 {\n    -webkit-align-self: flex-end;\n    align-self: flex-end;\n}\n \n.item3 {\n    -webkit-align-self: center;\n    align-self: center;\n}\n \n.item4 {\n    -webkit-align-self: baseline;\n    align-self: baseline;\n}\n \n.item5 {\n    -webkit-align-self: stretch;\n    align-self: stretch;\n}\n\n尝试一下 »\nflex\nflex 属性用于指定弹性子元素如何分配空间。\n\n语法\nflex: auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]\n各个值解析:\n\nauto: 计算值为 1 1 auto\ninitial: 计算值为 0 1 auto\nnone：计算值为 0 0 auto\ninherit：从父元素继承\n[ flex-grow ]：定义弹性盒子元素的扩展比率。\n[ flex-shrink ]：定义弹性盒子元素的收缩比率。\n[ flex-basis ]：定义弹性盒子元素的默认基准值。\n以下实例中，第一个弹性子元素占用了 2/4 的空间，其他两个各占 1/4 的空间:\n\n实例\n.flex-item {\n    background-color: cornflowerblue;\n    margin: 10px;\n}\n \n.item1 {\n    -webkit-flex: 2;\n    flex: 2;\n}\n \n.item2 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n \n.item3 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n\n尝试一下 »\n实例\n更多实例\n使用弹性盒子创建响应式页面\n\nCSS3 弹性盒子属性\n下表列出了在弹性盒子中常用到的属性:\n\n属性\t描述\ndisplay\t指定 HTML 元素盒子类型。\nflex-direction\t指定了弹性容器中子元素的排列方式\njustify-content\t设置弹性盒子元素在主轴（横轴）方向上的对齐方式。\nalign-items\t设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。\nflex-wrap\t设置弹性盒子的子元素超出父容器时是否换行。\nalign-content\t修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐\nflex-flow\tflex-direction 和 flex-wrap 的简写\norder\t设置弹性盒子的子元素排列顺序。\nalign-self\t在弹性子元素上使用。覆盖容器的 align-items 属性。\nflex\t设置弹性盒子的子元素如何分配空间。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974630000},"updatedAt":{"$$date":1598975776680},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"CgSKo4jWZbXuNg59"}
{"name":"kotlin-数据类 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/data-classes.html\n数据类 - Kotlin 语言中文站\n8-9 minutes\n改进翻译\n我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为 data：\n\ndata class User(val name: String, val age: Int)\n编译器自动从主构造函数中声明的所有属性导出以下成员：\n\nequals()/hashCode() 对；\ntoString() 格式是 \"User(name=John, age=42)\"；\ncomponentN() 函数 按声明顺序对应于所有属性；\ncopy() 函数（见下文）。\n为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：\n\n主构造函数需要至少有一个参数；\n主构造函数的所有参数需要标记为 val 或 var；\n数据类不能是抽象、开放、密封或者内部的；\n（在1.1之前）数据类只能实现接口。\n此外，成员生成遵循关于成员继承的这些规则：\n\n如果在数据类体中有显式实现 equals()、 hashCode() 或者 toString()，或者这些函数在父类中有 final 实现，那么不会生成这些函数，而会使用现有函数；\n如果超类型具有 open 的 componentN() 函数并且返回兼容的类型， 那么会为数据类生成相应的函数，并覆盖超类的实现。如果超类型的这些函数由于签名不兼容或者是 final 而导致无法覆盖，那么会报错；\n从一个已具 copy(……) 函数且签名匹配的类型派生一个数据类在 Kotlin 1.2 中已弃用，并且在 Kotlin 1.3 中已禁用。\n不允许为 componentN() 以及 copy() 函数提供显式实现。\n自 1.1 起，数据类可以扩展其他类（示例请参见密封类）。\n\n在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。 （参见构造函数）。\n\ndata class User(val name: String = \"\", val age: Int = 0)\n请注意，对于那些自动生成的函数，编译器只使用在主构造函数内部定义的属性。如需在生成的实现中排除一个属性，请将其声明在类体中：\n\ndata class Person(val name: String) {\n    var age: Int = 0\n}\n在 toString()、 equals()、 hashCode() 以及 copy() 的实现中只会用到 name 属性，并且只有一个 component 函数 component1()。虽然两个 Person 对象可以有不同的年龄，但它们会视为相等。\n\ndata class Person(val name: String) {\n    var age: Int = 0\n}\nfun main() {\n//sampleStart\n    val person1 = Person(\"John\")\n    val person2 = Person(\"John\")\n    person1.age = 10\n    person2.age = 20\n//sampleEnd\n    println(\"person1 == person2: ${person1 == person2}\")\n    println(\"person1 with age ${person1.age}: ${person1}\")\n    println(\"person2 with age ${person2.age}: ${person2}\")\n}\n在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy() 函数就是为此而生成。对于上文的 User 类，其实现会类似下面这样：\n\nfun copy(name: String = this.name, age: Int = this.age) = User(name, age)     \n这让我们可以写：\n\nval jack = User(name = \"Jack\", age = 1)\nval olderJack = jack.copy(age = 2)\n为数据类生成的 Component 函数 使它们可在解构声明中使用：\n\nval jane = User(\"Jane\", 35)\nval (name, age) = jane\nprintln(\"$name, $age years of age\") // 输出 \"Jane, 35 years of age\"\n标准库提供了 Pair 与 Triple。尽管在很多情况下具名数据类是更好的设计选择， 因为它们通过为属性提供有意义的名称使代码更具可读性。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307921191},"updatedAt":{"$$date":1597308000463},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"CnY7t7Wss4IiEAfd"}
{"name":"andr-构建灵活的界面","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/basics/fragments/fragment-ui\n构建灵活的界面  |  Android 开发者  |  Android Developers\n6-8 minutes\n在设计支持各种屏幕尺寸的应用时，您可以在不同的布局配置中重复使用 Fragment，以根据可用的屏幕空间优化用户体验。\n\n例如，在手机上，一次只显示一个 Fragment 对于单窗格界面可能比较合适。相反，在平板电脑上，由于屏幕尺寸较大，因此您可能想要设置并排显示的 Fragment，以向用户显示更多信息。\n\n\n\n图 1. 同一 Activity 的两个 Fragment，采用不同的配置显示在不同屏幕尺寸的设备上。在较大的屏幕上，两个 Fragment 同屏并排显示，但在手机上，一次仅显示一个 Fragment，因此用户必须通过切换屏幕浏览这两个 Fragment。\n\n利用 FragmentManager 类提供的方法，您可以在运行时为 Activity 添加、移除和替换 Fragment，从而营造出动态的用户体验。\n\n如需详细了解如何实现 Fragment，请参阅以下资源。\n\nFragment\n支持平板电脑和手机\n示例应用\n在运行时为 Activity 添加 Fragment\n您可以在 Activity 运行时为其添加 Fragment，而不用像上一课中介绍的那样，使用 <fragment> 元素在布局文件中为 Activity 定义 Fragment。如果您打算在 Activity 的生命周期内更改 Fragment，就需要采用这种方法。\n\n要执行添加或移除 Fragment 等事务，您必须使用 FragmentManager 创建一个 FragmentTransaction，后者将提供添加、移除、替换 Fragment 以及执行其他 Fragment 事务所需的 API。\n\n如果您的 Activity 允许移除和替换 Fragment，应在 Activity 的 onCreate() 方法执行期间为其添加初始 Fragment。\n\n在处理 Fragment 时（尤其是在运行时添加 Fragment 时），需遵循的一个重要原则是，您的 Activity 布局必须包含一个可以插入 Fragment 的容器 View。\n\n下面是上一课所示布局的替代布局，该布局一次只显示一个 Fragment。为了能够将一个 Fragment 替换为另一个 Fragment，Activity 的布局包含一个充当 Fragment 容器的空 FrameLayout。\n\n请注意，虽然文件名与上一课中的布局文件相同，但布局目录没有 large 限定符，因此该布局会在设备屏幕尺寸小于“large”时使用，因为这种尺寸的屏幕无法同时容纳两个 Fragment。\n\nres/layout/news_articles.xml:\n\n    <FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:id=\"@+id/fragment_container\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n    \n在您的 Activity 内，使用支持库 API 调用 getSupportFragmentManager() 以获取 FragmentManager。然后，调用 beginTransaction() 以创建 FragmentTransaction，并调用 add() 以添加 Fragment。\n\n您可以使用同一 FragmentTransaction 为 Activity 执行多项 Fragment 事务。当您准备好进行更改时，必须调用 commit()。\n\n例如，下面展示了如何为先前的布局添加 Fragment：\n\n    import android.os.Bundle\n    import android.support.v4.app.FragmentActivityclass MainActivity : FragmentActivity() {\n        override fun onCreate(savedInstanceState: Bundle?) {\n            super.onCreate(savedInstanceState)\n            setContentView(R.layout.news_articles)// Check that the activity is using the layout version with\n            // the fragment_container FrameLayout\n            if (findViewById(R.id.fragment_container) != null) {// However, if we're being restored from a previous state,\n                // then we don't need to do anything and should return or else\n                // we could end up with overlapping fragments.\n                if (savedInstanceState != null) {\n                    return;\n                }// Create a new Fragment to be placed in the activity layout\n                val firstFragment = HeadlinesFragment()// In case this activity was started with special instructions from an\n                // Intent, pass the Intent's extras to the fragment as arguments\n                firstFragment.arguments = intent.extras// Add the fragment to the 'fragment_container' FrameLayout\n                supportFragmentManager.beginTransaction()\n                        .add(R.id.fragment_container, firstFragment).commit()\n            }\n        }\n    }\n    \n    import android.os.Bundle;\n    import android.support.v4.app.FragmentActivity;public class MainActivity extends FragmentActivity {\n        @Override\n        public void onCreate(Bundle savedInstanceState?) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.news_articles);// Check that the activity is using the layout version with\n            // the fragment_container FrameLayout\n            if (findViewById(R.id.fragment_container) != null) {// However, if we're being restored from a previous state,\n                // then we don't need to do anything and should return or else\n                // we could end up with overlapping fragments.\n                if (savedInstanceState != null) {\n                    return;\n                }// Create a new Fragment to be placed in the activity layout\n                HeadlinesFragment firstFragment = new HeadlinesFragment();// In case this activity was started with special instructions from an\n                // Intent, pass the Intent's extras to the fragment as arguments\n                firstFragment.setArguments(getIntent().getExtras());// Add the fragment to the 'fragment_container' FrameLayout\n                getSupportFragmentManager().beginTransaction()\n                        .add(R.id.fragment_container, firstFragment).commit();\n            }\n        }\n    }\n    \n由于该 Fragment 是在运行时被添加到 FrameLayout 容器的，而不是利用 <fragment> 元素在 Activity 布局中进行定义的，因此可以从 Activity 中移除该 Fragment，并将其替换为其他 Fragment。\n\n替换 Fragment\n替换 Fragment 的过程与添加 Fragment 类似，但需要调用 replace() 方法，而非 add()。\n\n请注意，当您执行替换或移除 Fragment 等 Fragment 事务时，通常最好让用户能够回退并“撤消”更改。要让用户回退所执行的 Fragment 事务，您必须先调用 addToBackStack()，然后再提交 FragmentTransaction。\n\n注意：当您移除或替换 Fragment 并向返回堆栈添加相应事务时，系统会停止（而非销毁）移除的 Fragment。如果用户执行回退操作进行 Fragment 恢复，该 Fragment 将重新启动。如果您不向返回堆栈添加相应事务，则系统会在您移除或替换 Fragment 时将其销毁。\n\n替换 Fragment 的示例：\n\n    // Create fragment and give it an argument specifying the article it should show\n    val newFragment = ArticleFragment()\n    Bundle args = Bundle()\n    args.putInt(ArticleFragment.ARG_POSITION, position)\n    newFragment.arguments = argsval transaction = supportFragmentManager.beginTransaction().apply {\n      // Replace whatever is in the fragment_container view with this fragment,\n      // and add the transaction to the back stack so the user can navigate back\n      replace(R.id.fragment_container, newFragment)\n      addToBackStack(null)\n    }// Commit the transaction\n    transaction.commit();\n    \n    // Create fragment and give it an argument specifying the article it should show\n    ArticleFragment newFragment = new ArticleFragment();\n    Bundle args = new Bundle();\n    args.putInt(ArticleFragment.ARG_POSITION, position);\n    newFragment.setArguments(args);FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,\n    // and add the transaction to the back stack so the user can navigate back\n    transaction.replace(R.id.fragment_container, newFragment);\n    transaction.addToBackStack(null);// Commit the transaction\n    transaction.commit();\n    \naddToBackStack() 方法采用一个可选的字符串参数，该参数会为事务指定一个唯一的名称。除非您打算使用 FragmentManager.BackStackEntry API 执行高级 Fragment 操作，否则不需要该名称。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243444508},"updatedAt":{"$$date":1597243862941},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"DHZV7IEIhdhSv2ow"}
{"name":"ad-ksdiskframe","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n    }\n\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.annotations\n    testImplementation deps.androidx.junit\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    //为了解决 kotlin data class ,fastjson 解析报 defalut constructor not found错误\n    implementation deps.kotlin.kotlin_reflect\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\nentity\nDirType\nDiskDetail\nIDirType\nlru\nDiskLruCache\nStrictLineReader\nUtil\nutil\nFileCountUtil\nFileUtils\nKsFileUtil\nSDCardUtil\nSuffixConstant\nDiskManager\nDisManagerImpl\nIDiskManager\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521320147},"updatedAt":{"$$date":1598523042253},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"DWL6xqic7FAGuEWv"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975687676},"updatedAt":{"$$date":1598975687676},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"DdNQUMb7EgjHWB3B"}
{"name":"ad-ksxtablayout","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n        }\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.app_compat\n    implementation deps.androidx.design, {\n        exclude group: \"com.android.support\", module: \"multidex\"\n    }\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\nclass AnimationUtils {\n\n    static final Interpolator LINEAR_INTERPOLATOR = new LinearInterpolator();\n    static final Interpolator FAST_OUT_SLOW_IN_INTERPOLATOR = new FastOutSlowInInterpolator();\n    static final Interpolator FAST_OUT_LINEAR_IN_INTERPOLATOR = new FastOutLinearInInterpolator();\n    static final Interpolator LINEAR_OUT_SLOW_IN_INTERPOLATOR = new LinearOutSlowInInterpolator();\n    static final Interpolator DECELERATE_INTERPOLATOR = new DecelerateInterpolator();\n\n    /**\n     * Linear interpolation between {@code startValue} and {@code endValue} by {@code fraction}.\n     */\n    static float lerp(float startValue, float endValue, float fraction) {\n        return startValue + (fraction * (endValue - startValue));\n    }\n\n    static int lerp(int startValue, int endValue, float fraction) {\n        return startValue + Math.round(fraction * (endValue - startValue));\n    }\n\n    static class AnimationListenerAdapter implements Animation.AnimationListener {\n        @Override\n        public void onAnimationStart(Animation animation) {\n        }\n\n        @Override\n        public void onAnimationEnd(Animation animation) {\n        }\n\n        @Override\n        public void onAnimationRepeat(Animation animation) {\n        }\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class KsXTabLayout extends XTabLayout {\n\n\n    public KsXTabLayout(Context context) {\n        super(context);\n    }\n\n    public KsXTabLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public KsXTabLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n    private KsListnterNumberCount mKsListnterNumberCount;\n\n    public void setKsListnterNumberCount(KsListnterNumberCount tKsListnterNumberCount) {\n        mKsListnterNumberCount = tKsListnterNumberCount;\n    }\n\n    @Override\n    void selectTab(Tab tab, boolean updateIndicator) {\n        boolean letGo = true;\n        if(mKsListnterNumberCount!=null){\n            letGo = mKsListnterNumberCount.tabSelectBefore(tab.getPosition());\n        }\n        if(letGo){\n            super.selectTab(tab, updateIndicator);\n        }\n    }\n}\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598517310142},"updatedAt":{"$$date":1598520170429},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"DpKFPQmyndknH6Fu"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598975692408},"updatedAt":{"$$date":1598975692408},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"E2kD3rQzAyhKrvU6"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980163155},"updatedAt":{"$$date":1594980163155},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"EDUj8YWCnvHNUYm5"}
{"name":"qk-","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598580897981},"updatedAt":{"$$date":1598580897981},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ERVhU6uOlwCrPUCB"}
{"name":"ad-ks_imageload_core","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\napply plugin: 'com.android.library'\n// 上传插件\napply from: rootProject.file(\"./gradle/upload_local_maven.gradle\")\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n}\n\n\n\n\n\n\n\n\npublic class KsLoader {\n\n    private static ILoadManager loadManager = PicLoaderManager.getInstance();\n\n    /**\n     * 设置LoadManger 自己实现\n     *\n     * @param iLoadManager\n     */\n    public static void setLoadManager(ILoadManager iLoadManager) {\n        if (iLoadManager != null) {\n            loadManager = iLoadManager;\n        }\n    }\n\n    /**\n     * @param context\n     * @param config  配置参数\n     */\n\n    public static void init(Context context, ImageLoaderConfig config) {\n        if (loadManager != null) {\n            loadManager.init(context, config);\n        }\n    }\n\n\n    /**\n     *   可创建默认的Options设置，假如不需要使用ImageView ，\n     *    请自行new一个Imageview传入即可\n     *  内部只需要获取Context\n     */\n    public static LoadOptions obtainOption(@NonNull View container, @NonNull String url) {\n        return new LoadOptions.Builder(container, url).isCrossFade(true).build();\n    }\n\n    /**\n     * 通过类型获取 图片加载器\n     *\n     * @param loaderEnum\n     * @return\n     */\n    public static ILoad getLoad(LoaderEnum loaderEnum) {\n        if (loadManager != null) {\n            return loadManager.getLoad(loaderEnum);\n        }\n        return null;\n    }\n\n    /**\n     * 注册添加 Loader\n     *\n     * @param loaderEnum\n     * @param load\n     */\n    public static void registLoader(LoaderEnum loaderEnum, ILoad load) {\n        if (loadManager != null) {\n            loadManager.registLoader(loaderEnum, load);\n        }\n    }\n\n\n    public static void loadImage(@NonNull LoadOptions options) {\n        if (loadManager != null) {\n            loadManager.loadImage(options);\n        }\n    }\n\n    /**\n     * @param uiComponent     context  Activity 或 Fragment  便于glide 等框架加载图片时进行生命周期管理\n     * @param ivTarget\n     * @param url\n     * @param placeHodle\n     * @param errorPlaceHolde\n     */\n\n    public static void loadImage(Object uiComponent, ImageView ivTarget, String url, int placeHodle, int errorPlaceHolde) {\n        if (loadManager != null) {\n            loadManager.loadImage(uiComponent, ivTarget, url, placeHodle, errorPlaceHolde);\n        }\n    }\n\n    /**\n     * 加载高斯模糊图\n     *\n     * @param uiComponent     context  Activity 或 Fragment  便于glide 等框架加载图片时进行生命周期管理\n     * @param ivTarget        目标ImageView\n     * @param url             图片url\n     * @param blurValue       高斯模糊参数，越大越模糊\n     * @param placeHodle      加载时占位图\n     * @param errorPlaceHolde 失败时占位图\n     */\n\n    public static void loadBlur(Object uiComponent, ImageView ivTarget, String url, int blurValue, int placeHodle, int errorPlaceHolde) {\n        if (loadManager != null) {\n            loadManager.loadBlur(uiComponent, ivTarget, url, blurValue, placeHodle, errorPlaceHolde);\n        }\n    }\n\n    /**\n     * 加载gif  方法\n     *\n     * @param uiComponent     context  Activity 或 Fragment  便于glide 等框架加载图片时进行生命周期管理\n     * @param ivTarget        目标ImageView\n     * @param url             图片url\n     * @param placeHodle      加载时占位图\n     * @param errorPlaceHolde 失败时占位图\n     * @param callback        gif加载 callback 通过callback 可以拿到 IGif对象，根据IGif  可以控制Gif的播放和暂停\n     */\n\n    public static void loadGif(Object uiComponent, ImageView ivTarget, String url, int placeHodle, int errorPlaceHolde, @Nullable GifCallback callback) {\n        if (loadManager != null) {\n            loadManager.loadGif(uiComponent, ivTarget, url, placeHodle, errorPlaceHolde, callback);\n        }\n    }\n\n    /**\n     * 加载圆形图\n     *\n     * @param uiComponent     context  Activity 或 Fragment  便于glide 等框架加载图片时进行生命周期管理\n     * @param ivTarget        目标ImageView\n     * @param url             图片url\n     * @param placeHodle      加载时占位图\n     * @param errorPlaceHolde 失败时占位图\n     */\n\n    public static void loadCircle(Object uiComponent, ImageView ivTarget, String url, int placeHodle, int errorPlaceHolde) {\n        if (loadManager != null) {\n            loadManager.loadCircle(uiComponent, ivTarget, url, placeHodle, errorPlaceHolde);\n        }\n    }\n\n    /**\n     * 加载.9图 ，并把生成NinePatchDrawable 设置为 target的background\n     *\n     * @param target    需要展示.9图的\n     * @param url       图片的path\n     * @param errorHold 失败时的.9图片\n     */\n\n    public static void loadNinePatch(View target, String url, int errorHold) {\n        if (loadManager != null) {\n            loadManager.loadNinePatch(target, url, errorHold);\n        }\n    }\n\n    /**\n     * 对图片进行高斯模糊处理\n     *\n     * @param src       原图\n     * @param blurValue 高斯模糊值\n     * @return 高斯模糊后的图\n     */\n\n    public static Bitmap blur(Bitmap src, int blurValue) {\n        if (loadManager != null) {\n            return loadManager.blur(src, blurValue);\n        } else {\n            return FastBlur.blur(src, blurValue, true);\n        }\n    }\n\n    /**\n     * 获取图片\n     *\n     * @param url\n     * @return maybe null please check\n     */\n\n    public static Bitmap getBitmap(String url) {\n        if (loadManager != null) {\n            return loadManager.getBitmap(url);\n        }\n        return null;\n    }\n\n    /**\n     * 获取本地缓存图片\n     *\n     * @param url\n     * @return\n     */\n\n    public static File getFileFromDiskCache(String url) {\n        if (loadManager != null) {\n            return loadManager.getFileFromDiskCache(url);\n        }\n        return null;\n    }\n\n    /**\n     * 是否有缓存\n     *\n     * @param url\n     * @return\n     */\n\n    public static boolean hasCache(String url) {\n\n        if (loadManager != null) {\n            return loadManager.hasCache(url);\n        }\n        return false;\n    }\n\n    /**\n     * 切换当前默认Loader\n     *\n     * @param loaderEnum\n     */\n\n    public static void switchLoad(LoaderEnum loaderEnum) {\n        if (loadManager != null) {\n            loadManager.switchLoad(loaderEnum);\n        }\n    }\n\n    /**\n     * 选择指定框架类型加载 展示图片\n     *\n     * @param loaderEnum\n     * @param options\n     */\n    public static void loadImage(LoaderEnum loaderEnum, @NonNull LoadOptions options) {\n        if (loadManager != null) {\n            loadManager.loadImage(loaderEnum, options);\n        }\n    }\n\n    /**\n     * 清除磁盘缓存\n     */\n\n    public static void clearDiskCache() {\n        if (loadManager != null) {\n            loadManager.clearDiskCache();\n        }\n    }\n\n    /**\n     * 清理内存缓存\n     */\n\n    public static void clearMemoryCache() {\n        if (loadManager != null) {\n            loadManager.clearMemoryCache();\n        }\n    }\n\n    /**\n     * 系统trim时调用\n     *\n     * @param level\n     */\n\n    public static void onTrim(int level) {\n        if (loadManager != null) {\n            loadManager.onTrim(level);\n        }\n    }\n\n    /**\n     * 根据图片url 移除缓存\n     *\n     * @param url\n     */\n\n    public static void removeCache(String url) {\n        if (loadManager != null) {\n            loadManager.removeCache(url);\n        }\n    }\n\n    /**\n     * 暂停\n     * Glide 建议使用\n     *\n     * @param container\n     */\n\n    public static void pause(Object container) {\n        if (loadManager != null) {\n            loadManager.pause(container);\n        }\n    }\n\n    /**\n     * 恢复\n     *\n     * @param container\n     */\n\n    public static void resume(Object container) {\n        if (loadManager != null) {\n            loadManager.resume(container);\n        }\n    }\n\n    /**\n     * 清除所有缓存\n     */\n\n    public static void clearAllCache() {\n        if (loadManager != null) {\n            loadManager.clearAllCache();\n        }\n    }\n}\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539545780},"updatedAt":{"$$date":1598540171733},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"EdpmXLIssKB5QYwP"}
{"name":"kotlin-集合转换操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-transformations.html\n集合转换操作 - Kotlin 语言中文站\n20-25 minutes\n改进翻译\nKotlin 标准库为集合 转换 提供了一组扩展函数。 这些函数根据提供的转换规则从现有集合中构建新集合。 在此页面中，我们将概述可用的集合转换函数。\n\n映射 转换从另一个集合的元素上的函数结果创建一个集合。 基本的映射函数是 map()。 它将给定的 lambda 函数应用于每个后续元素，并返回 lambda 结果列表。 结果的顺序与元素的原始顺序相同。 如需应用还要用到元素索引作为参数的转换，请使用 mapIndexed()。\n\nTarget platform: JVMRunning on kotlin v. 1.3.72\n\n如果转换在某些元素上产生 null 值，则可以通过调用 mapNotNull() 函数取代 map() 或 mapIndexedNotNull() 取代 mapIndexed() 来从结果集中过滤掉 null 值。\n\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3)\n    println(numbers.mapNotNull { if ( it == 2) null else it * 3 })\n    println(numbers.mapIndexedNotNull { idx, value -> if (idx == 0) null else value * idx })\n//sampleEnd\n}\n映射转换时，有两个选择：转换键，使值保持不变，反之亦然。 要将指定转换应用于键，请使用 mapKeys()；反过来，mapValues() 转换值。 这两个函数都使用将映射条目作为参数的转换，因此可以操作其键与值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    println(numbersMap.mapKeys { it.key.toUpperCase() })\n    println(numbersMap.mapValues { it.value + it.key.length })\n//sampleEnd\n}\n双路合并 转换是根据两个集合中具有相同位置的元素构建配对。 在 Kotlin 标准库中，这是通过 zip() 扩展函数完成的。 在一个集合（或数组）上以另一个集合（或数组）作为参数调用时，zip() 返回 Pair 对象的列表（List）。 接收者集合的元素是这些配对中的第一个元素。 如果集合的大小不同，则 zip() 的结果为较小集合的大小；结果中不包含较大集合的后续元素。 zip() 也可以中缀形式调用 a zip b 。\n\nfun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    println(colors zip animals)\n\n    val twoAnimals = listOf(\"fox\", \"bear\")\n    println(colors.zip(twoAnimals))\n//sampleEnd\n}\n也可以使用带有两个参数的转换函数来调用 zip()：接收者元素和参数元素。 在这种情况下，结果 List 包含在具有相同位置的接收者对和参数元素对上调用的转换函数的返回值。\n\nfun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    \n    println(colors.zip(animals) { color, animal -> \"The ${animal.capitalize()} is $color\"})\n//sampleEnd\n}\n当拥有 Pair 的 List 时，可以进行反向转换 unzipping——从这些键值对中构建两个列表：\n\n第一个列表包含原始列表中每个 Pair 的键。\n第二个列表包含原始列表中每个 Pair 的值。\n要分割键值对列表，请调用 unzip()。\n\nfun main() {\n//sampleStart\n    val numberPairs = listOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"four\" to 4)\n    println(numberPairs.unzip())\n//sampleEnd\n}\n关联 转换允许从集合元素和与其关联的某些值构建 Map。 在不同的关联类型中，元素可以是关联 Map 中的键或值。\n\n基本的关联函数 associateWith() 创建一个 Map，其中原始集合的元素是键，并通过给定的转换函数从中产生值。 如果两个元素相等，则仅最后一个保留在 Map 中。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n为了使用集合元素作为值来构建 Map，有一个函数 associateBy()。 它需要一个函数，该函数根据元素的值返回键。如果两个元素相等，则仅最后一个保留在 Map 中。 还可以使用值转换函数来调用 associateBy()。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.associateBy { it.first().toUpperCase() })\n    println(numbers.associateBy(keySelector = { it.first().toUpperCase() }, valueTransform = { it.length }))\n//sampleEnd\n}\n另一种构建 Map 的方法是使用函数 associate()，其中 Map 键和值都是通过集合元素生成的。 它需要一个 lambda 函数，该函数返回 Pair：键和相应 Map 条目的值。\n\n请注意，associate() 会生成临时的 Pair 对象，这可能会影响性能。 因此，当性能不是很关键或比其他选项更可取时，应使用 associate()。\n\n后者的一个示例：从一个元素一起生成键和相应的值。\n\nfun main() {\ndata class FullName (val firstName: String, val lastName: String)\n\nfun parseFullName(fullName: String): FullName {\n    val nameParts = fullName.split(\" \")\n    if (nameParts.size == 2) {\n        return FullName(nameParts[0], nameParts[1])\n    } else throw Exception(\"Wrong name format\")\n}\n\n//sampleStart\n    val names = listOf(\"Alice Adams\", \"Brian Brown\", \"Clara Campbell\")\n    println(names.associate { name -> parseFullName(name).let { it.lastName to it.firstName } })  \n//sampleEnd\n}\n此时，首先在一个元素上调用一个转换函数，然后根据该函数结果的属性建立 Pair。\n\n如需操作嵌套的集合，则可能会发现提供对嵌套集合元素进行打平访问的标准库函数很有用。\n\n第一个函数为 flatten()。可以在一个集合的集合（例如，一个 Set 组成的 List）上调用它。 该函数返回嵌套集合中的所有元素的一个 List。\n\nfun main() {\n//sampleStart\n    val numberSets = listOf(setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2))\n    println(numberSets.flatten())\n//sampleEnd\n}\n另一个函数——flatMap() 提供了一种灵活的方式来处理嵌套的集合。 它需要一个函数将一个集合元素映射到另一个集合。 因此，flatMap() 返回单个列表其中包含所有元素的值。 所以，flatMap() 表现为 map()（以集合作为映射结果）与 flatten() 的连续调用。\n\ndata class StringContainer(val values: List<String>)\n\nfun main() {\n//sampleStart\n    val containers = listOf(\n        StringContainer(listOf(\"one\", \"two\", \"three\")),\n        StringContainer(listOf(\"four\", \"five\", \"six\")),\n        StringContainer(listOf(\"seven\", \"eight\"))\n    )\n    println(containers.flatMap { it.values })\n//sampleEnd\n}\n如果需要以可读格式检索集合内容，请使用将集合转换为字符串的函数：joinToString() 与 joinTo()。\n\njoinToString() 根据提供的参数从集合元素构建单个 String。 joinTo() 执行相同的操作，但将结果附加到给定的 Appendable 对象。\n\n当使用默认参数调用时，函数返回的结果类似于在集合上调用 toString()：各元素的字符串表示形式以空格分隔而成的 String。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    println(numbers)         \n    println(numbers.joinToString())\n    \n    val listString = StringBuffer(\"The list of numbers: \")\n    numbers.joinTo(listString)\n    println(listString)\n//sampleEnd\n}\n要构建自定义字符串表示形式，可以在函数参数 separator、prefix 与 postfix中指定其参数。 结果字符串将以 prefix 开头，以 postfix 结尾。除最后一个元素外，separator 将位于每个元素之后。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")    \n    println(numbers.joinToString(separator = \" | \", prefix = \"start: \", postfix = \": end\"))\n//sampleEnd\n}\n对于较大的集合，可能需要指定 limit ——将包含在结果中元素的数量。 如果集合大小超出 limit，所有其他元素将被 truncated 参数的单个值替换。\n\nfun main() {\n//sampleStart\n    val numbers = (1..100).toList()\n    println(numbers.joinToString(limit = 10, truncated = \"<...>\"))\n//sampleEnd\n}\n最后，要自定义元素本身的表示形式，请提供 transform 函数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.joinToString { \"Element: ${it.toUpperCase()}\"})\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308436157},"updatedAt":{"$$date":1597382113910},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ErqgvGclTzaz7zJe"}
{"name":"kotlin-HightLightTextView","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\npackage com.ks.component.ui.view\n\nimport android.content.Context\nimport android.graphics.Color\nimport android.text.SpannableString\nimport android.text.Spanned\nimport android.text.style.ForegroundColorSpan\nimport android.util.AttributeSet\nimport android.widget.TextView\nimport com.ks.component.ui.R\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author ylc\n * 邮箱：yanglichuan@ksjgs.com\n * 创建时间: 2020-02-24\n * 用途:  是东方丽$哈哈$景喀什东路$你好$瑟瑟发抖  你好要高亮\n ***************************************\n */\nclass HightLightTextView : TextView {\n\n    private var hightlightColor: Int = -1\n\n    constructor(context: Context) : this(context, null)\n    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {\n\n        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.IconTitleRightArrow)\n\n        hightlightColor = typedArray.getColor(R.styleable.HightLightTextView_hightlightColor, Color.parseColor(\"#FFFE7401\"))\n\n        setTextWightHighLight(text as String)\n\n        typedArray.recycle()\n\n    }\n\n    var dolorIndexList = mutableListOf<Int>()\n\n    fun setTextWightHighLight(str: String?) {\n        if(str== null){\n            return\n        }\n        dolorIndexList.clear()\n        str.forEachIndexed { index, c ->\n            if (c == '$') {\n                dolorIndexList.add(index)\n            }\n        }\n        var pairs = mutableListOf<Pair<Int, Int>>()\n        var lastV = -1\n        var pr: Pair<Int, Int>\n        dolorIndexList.forEachIndexed { index, i ->\n            if (index % 2 == 0) {\n                lastV = i\n            } else {\n                pr = Pair(lastV - index + 1, i - lastV - 1)\n                println(pr)\n                pairs.add(pr)\n            }\n        }\n        var strNew = str.replace(\"$\", \"\")\n        val spannableString = SpannableString(strNew)\n        pairs.forEachIndexed { _, pair ->\n            val foregroundColorSpan = ForegroundColorSpan(Color.parseColor(\"#FFFE7401\"))\n            spannableString.setSpan(foregroundColorSpan, pair.first, pair.first + pair.second, Spanned.SPAN_INCLUSIVE_EXCLUSIVE)\n\n        }\n        text = spannableString\n    }\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403208837},"updatedAt":{"$$date":1597403939896},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Ez8pYccc0G5edWqZ"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973269349},"updatedAt":{"$$date":1594973269349},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"F6DJlCIGAhIj3Tmd"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\njQuery 教程\njQuery 是一个 JavaScript 库。\n\njQuery 极大地简化了 JavaScript 编程。\n\njQuery 很容易学习。\n\n本章节的每一篇都包含了在线实例\n通过本站的在线编辑器，你可以在线运行修改后的代码，并查看运行结果。\n\n实例\n$(document).ready(function(){\n  $(\"p\").click(function(){\n    $(this).hide();\n  });\n});"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975844734},"updatedAt":{"$$date":1598975881084},"_id":"FJjJGYYrQgFNm4HM","folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"css-CSS padding（填充）","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS padding（填充）\nCSS padding（填充）是一个简写属性，定义元素边框与元素内容之间的空间，即上下左右的内边距。\n\npadding（填充）\n当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充。\n\n单独使用 padding 属性可以改变上下左右的填充。\n\n\n\n可能的值\n值\t说明\nlength\t定义一个固定的填充(像素, pt, em,等)\n%\t使用百分比值定义一个填充\n\n填充- 单边内边距属性\n在CSS中，它可以指定不同的侧面不同的填充：\n\n实例\npadding-top:25px;\npadding-bottom:25px;\npadding-right:50px;\npadding-left:50px;\n\n尝试一下 »\n上内边距是 25px\n右内边距是 50px\n下内边距是 25px\n左内边距是 50px\n\n填充 - 简写属性\n为了缩短代码，它可以在一个属性中指定的所有填充属性。\n\n这就是所谓的简写属性。所有的填充属性的简写属性是 padding :\n\n实例\npadding:25px 50px;\n\n尝试一下 »\nPadding属性，可以有一到四个值。\n\n  padding:25px 50px 75px 100px;\n\n上填充为25px\n右填充为50px\n下填充为75px\n左填充为100px\n  padding:25px 50px 75px;\n\n上填充为25px\n左右填充为50px\n下填充为75px\n  padding:25px 50px;\n\n上下填充为25px\n左右填充为50px\n  padding:25px;\n\n所有的填充都是25px\nExamples\n更多实例\n在一个声明中的所有填充属性\n这个例子演示了使用简写属性设置在一个声明中的所有填充属性，可以有一到四个值。\n\n设置左部填充\n这个例子演示了如何设置元素左填充。\n\n设置右部填充\n这个例子演示了如何设置元素右填充。.\n\n设置上部填充\n这个例子演示了如何设置元素上填充。\n\n设置下部填充\n这个例子演示了如何设置元素下填充。\n\n所有的CSS填充属性\n属性\t说明\npadding\t使用简写属性设置在一个声明中的所有填充属性\npadding-bottom\t设置元素的底部填充\npadding-left\t设置元素的左部填充\npadding-right\t设置元素的右部填充\npadding-top\t设置元素的顶部填充\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888557387},"updatedAt":{"$$date":1598889078459},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"FOP7AcnjhuebptLG"}
{"name":"CSS3 背景","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 背景\nCSS3 中包含几个新的背景属性，提供更大背景元素控制。\n\n在本章您将了解以下背景属性：\n\nbackground-image\nbackground-size\nbackground-origin\nbackground-clip\n您还将学习如何使用多重背景图像。\n\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器版本号。\n\n紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号。\n\n属性\t\t\t\t\t\nbackground-image\n(with multiple backgrounds)\t4.0\t9.0\t3.6\t3.1\t11.5\nbackground-size\t4.0\n1.0 -webkit-\t9.0\t4.0\n3.6 -moz-\t4.1\n3.0 -webkit-\t10.5\n10.0 -o-\nbackground-origin\t1.0\t9.0\t4.0\t3.0\t10.5\nbackground-clip\t4.0\t9.0\t4.0\t3.0\t10.5\nCSS3 background-image属性\nCSS3中可以通过background-image属性添加背景图片。\n\n不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。\n\n实例\n#example1 { \n    background-image: url(img_flwr.gif), url(paper.gif); \n    background-position: right bottom, left top; \n    background-repeat: no-repeat, repeat; \n}\n\n尝试一下 »\n\n可以给不同的图片设置多个不同的属性\n\n实例\n#example1 {\n    background: url(img_flwr.gif) right bottom no-repeat, url(paper.gif) left top repeat;\n}\n\n尝试一下 »\n\nCSS3 background-size 属性\nbackground-size指定背景图像的大小。CSS3以前，背景图像大小由图像的实际大小决定。\n\nCSS3中可以指定背景图片，让我们重新在不同的环境中指定背景图片的大小。您可以指定像素或百分比大小。\n\n你指定的大小是相对于父元素的宽度和高度的百分比的大小。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例 1\n重置背景图像：\n\ndiv\n{\n    background:url(img_flwr.gif);\n    background-size:80px 60px;\n    background-repeat:no-repeat;\n}\n\n尝试一下 »\n\nOperaSafariChromeFirefoxInternet Explorer\n实例 2\n伸展背景图像完全填充内容区域：\n\ndiv\n{\n    background:url(img_flwr.gif);\n    background-size:100% 100%;\n    background-repeat:no-repeat;\n}\n\n尝试一下 »\n\nCSS3 的 background-origin 属性\nbackground-origin 属性指定了背景图像的位置区域。\n\ncontent-box, padding-box,和 border-box区域内可以放置背景图像。\n\n\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n在 content-box 中定位背景图片：\n\ndiv\n{\n    background:url(img_flwr.gif);\n    background-repeat:no-repeat;\n    background-size:100% 100%;\n    background-origin:content-box;\n}\n\n尝试一下 »\n\nCSS3 多个背景图像\nCSS3 允许你在元素上添加多个背景图像。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n在 body 元素中设置两个背景图像：\n\nbody\n{ \n    background-image:url(img_flwr.gif),url(img_tree.gif);\n}\n\n尝试一下 »\n\nCSS3 background-clip属性\nCSS3中background-clip背景剪裁属性是从指定位置开始绘制。\n\n实例\n#example1 { \n    border: 10px dotted black; \n    padding: 35px; \n    background: yellow; \n    background-clip: content-box; \n}\n\n尝试一下 »\n\n新的背景属性\n顺序\t描述\tCSS\nbackground-clip\t规定背景的绘制区域。\t3\nbackground-origin\t规定背景图片的定位区域。\t3\nbackground-size\t规定背景图片的尺寸。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974612076},"updatedAt":{"$$date":1598974751588},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"FOk9VT3DptaD0RBk"}
{"name":"qk-ks_component_push","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 100\n        versionName \"100\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    buildTypes {\n        release {\n            // 移除无用的resource文件\n            debuggable false\n            shrinkResources false\n            minifyEnabled false\n        }\n\n        debug {\n            debuggable true\n        }\n\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    repositories {\n        flatDir {\n            dirs 'libs'\n        }\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n    //极光\n    api deps.jiguang.jpush\n    implementation deps.jiguang.jcore\n    implementation deps.jpush.jpush_xiaomi\n    implementation deps.jpush.jpush_meizu\n    implementation deps.jpush.jpush_huawei\n    implementation deps.jpush.jpush_vivo\n    implementation deps.jpush.jpush_oppo\n//    implementation deps.fastjson\n    implementation deps.androidx.core_ktx\n    if (develop) {\n        implementation project(':ks_component_net')\n        implementation project(':ks_lib_picture')\n    } else {\n        implementation ks.lib_picture\n        implementation ks.component_net\n    }\n}\n\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobject JPushHolder {\n\n    private val JPUSH_REGIST_ID: String = \"jpush_regist_id\"\n    var mJPushRegistId: String by Preference(JPUSH_REGIST_ID, \"\")\n\n    private val jPushRepository by lazy { JPushRepository() }\n\n    suspend fun bindJPushDevice(): KsResult<Any> {\n        val jsonObject = JSONObject()\n        with(jsonObject) {\n            put(\"sid\", DeviceUtils.fix_getimei(JpushDelegate.getApplication()))\n            put(\"rid\", mJPushRegistId)\n            put(\"platform\", \"android\")\n            if (Build.VERSION.SDK_INT >= 29) {\n                put(\"oaid\", DeviceUtils.oaid)\n            }\n        }\n        return jPushRepository.bindJPushDevice(jsonObject.toString())\n    }\n\n}\n\n\n\n\n\nclass JPushRepository : KsBaseRepository() {\n\n\n    /**\n     * 绑定设备id\n     * @return KsResult<Any>\n     */\n    suspend fun bindJPushDevice(json: String): KsResult<Any> {\n\n        return safeApiCall(call = { requestBindJPushDevice(json.toRequestBody()) })\n    }\n\n    private suspend fun requestBindJPushDevice(toRequestBody: RequestBody): KsResult<Any> =\n        executeResponse(getService(KsJPService::class.java).bindJPushDevice(toRequestBody))\n\n}\n\n\n\n\n\n\ninterface KsJPService {\n    /**\n     * 极光绑定设备\n     * @param toRequestBody RequestBody\n     * @return KsResponse<Any>\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @POST(\"/pangu/user/device/reportOpenIdRelation\")\n    suspend fun bindJPushDevice(@Body toRequestBody: RequestBody): KsResponse<Any>\n}\n\n\n\n\n\n\n\n\n\n\n@Keep\nobject JpushDelegate {\n\n\n    val PUSH_TITLE = \"title\"\n    val PUSH_TEXT = \"text\"\n    val PUSH_CONTENTTYPE = \"contenttype\"\n    val PUSH_CONTENIID = \"contentid\"\n    val PUSH_LINK = \"link\"\n    val PUSH_STAGEID = \"stageId\"\n\n\n    private var config: JpsuhConfig? = null\n    private var isInit: Boolean = false\n    fun init(config: JpsuhConfig) {\n        if (isInit) {\n            return\n        }\n        JpushDelegate.config = config\n        isInit = true\n    }\n\n    interface JpsuhConfig {\n        fun handleCustomNotifyClick(context: Context, json: JSONObject)\n\n        fun getApplication(): Context\n        fun processCustomMessage(context: Context, json: JSONObject)\n\n    }\n\n    fun getApplication(): Context {\n        return checkConfig().getApplication()\n    }\n\n\n    fun checkConfig(): JpsuhConfig {\n        if (config == null) {\n            throw RuntimeException(\"请先调用 JpushDelegate.init(config: JpsuhConfig) 初始化 jpush代理\")\n        }\n\n        return config!!\n    }\n\n\n    fun handleCustomNotifyClick(context: Context, json: JSONObject) {\n        checkConfig().handleCustomNotifyClick(context, json)\n    }\n\n    fun processCustomMessage(context: Context, json: JSONObject) {\n        checkConfig().processCustomMessage(context, json)\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 自定义接收器\n *\n *\n * 如果不定义这个 Receiver，则：\n * 1) 默认用户会打开主界面\n * 2) 接收不到自定义消息\n */\nclass JPushOperaReceiver : BroadcastReceiver() {\n\n    private val NOTIFY_ID_1 = 101\n    private val NOTIFY_ID_2 = 102\n    private val NOTIFY_ID_3 = 103\n    private val mCurentId: Int = 0\n\n    private var nm: NotificationManager? = null\n    private val postRunnable: Runnable? = null\n\n    override fun onReceive(context: Context, intent: Intent) {\n        if (nm == null) {\n            nm = context.getSystemService(Activity.NOTIFICATION_SERVICE) as NotificationManager\n        }\n\n        try {\n            val bundle = intent.extras\n            Log.d(TAG, \"[MyReceiver] onReceive - \" + intent.action + \", extras: \" + printBundle(bundle!!))\n            if (JPushInterface.ACTION_REGISTRATION_ID == intent.action) {\n                val regId = bundle.getString(JPushInterface.EXTRA_REGISTRATION_ID)\n                Log.d(TAG, \"[MyReceiver] regId - $regId\")\n\n                //                SPUtils.put(SPUtils.JPUSH_REGISTER_ID, regId);\n\n            } else if (JPushInterface.ACTION_MESSAGE_RECEIVED == intent.action) {\n                    Log.d(TAG, \"[MyReceiver] 接收到推送下来的自定义消息: \" + bundle.getString(JPushInterface.EXTRA_MESSAGE))\n\n                //                processCustomMessage(context, bundle);\n\n\n            } else if (JPushInterface.ACTION_NOTIFICATION_RECEIVED == intent.action) {\n\n                val notifactionId = bundle.getInt(JPushInterface.EXTRA_NOTIFICATION_ID)\n                Log.d(TAG, \"[MyReceiver] 接收到推送下来的通知的ID: $notifactionId\")\n\n                try {\n                    val json = JSONObject(bundle.getString(JPushInterface.EXTRA_EXTRA))\n                    //                    pointShowPush(json);\n\n//                    JpushDelegate.pointShowPush(json)\n                } catch (e: JSONException) {\n                }\n\n            } else if (JPushInterface.ACTION_NOTIFICATION_OPENED == intent.action) {\n                try {\n                    val json = JSONObject(bundle.getString(JPushInterface.EXTRA_EXTRA))\n                    //                    handleCustomNotifyClick(context, json);\n\n//                    JpushDelegate.handleCustomNotifyClick(json)\n\n                } catch (e: JSONException) {\n                    Log.e(\"lzm\", \"Get message extra JSON error!\")\n                }\n\n            } else if (JPushInterface.ACTION_RICHPUSH_CALLBACK == intent.action) {\n\n            } else if (JPushInterface.ACTION_CONNECTION_CHANGE == intent.action) {\n                val connected =\n                    intent.getBooleanExtra(JPushInterface.EXTRA_CONNECTION_CHANGE, false)\n\n            } else {\n            }\n        } catch (e: Exception) {\n\n        }\n\n    }\n\n    companion object {\n        private val TAG = \"JIGUANG-KS\"\n\n        // 打印所有的 intent extra 数据\n        private fun printBundle(bundle: Bundle): String {\n            val sb = StringBuilder()\n            for (key in bundle.keySet()) {\n                if (key == JPushInterface.EXTRA_NOTIFICATION_ID) {\n                    sb.append(\"\\nkey:\" + key + \", value:\" + bundle.getInt(key))\n                } else if (key == JPushInterface.EXTRA_CONNECTION_CHANGE) {\n                    sb.append(\"\\nkey:\" + key + \", value:\" + bundle.getBoolean(key))\n                } else if (key == JPushInterface.EXTRA_EXTRA) {\n                    if (TextUtils.isEmpty(bundle.getString(JPushInterface.EXTRA_EXTRA))) {\n                        Log.i(TAG, \"This message has no Extra data\")\n                        continue\n                    }\n                    try {\n                        val json = JSONObject(bundle.getString(JPushInterface.EXTRA_EXTRA))\n                        Log.e(TAG, \"extra_json=$json\")\n                        val it = json.keys()\n                        while (it.hasNext()) {\n                            val myKey = it.next().toString()\n                            sb.append(\n                                \"\\nkey:\" + key + \", value: [\" +\n                                        myKey + \" - \" + json.optString(myKey) + \"]\"\n                            )\n                        }\n                    } catch (e: JSONException) {\n                        Log.e(TAG, \"Get message extra JSON error!\")\n                    }\n\n                } else {\n                    sb.append(\"\\nkey:\" + key + \", value:\" + bundle.getString(key))\n                }\n            }\n            return sb.toString()\n        }\n    }\n\n    //    //send msg to MainActivity\n    //    private void processCustomMessage(Context context, Bundle bundle) {\n    //        String message = bundle.getString(JPushInterface.EXTRA_MESSAGE);\n    //        String extras = bundle.getString(JPushInterface.EXTRA_EXTRA);\n    //\n    //        Log.e(\"lzm\", \"###自定义消息：message\" + message + \"_extars=\" + extras);\n    //        if (\"{errcode:4008}\".equals(message)) {\n    //            ToastUtil.toast(\"你的账号已被其他账号绑定，请重新登录。\");\n    //            LoginController.logOffAndGenerateToken(new LogOutConsumer() {\n    //                @Override\n    //                public void accept(PublicUseBean<TokenBean> publicUseBean) throws Exception {\n    //                    super.accept(publicUseBean);\n    //                    if (KaishuApplication.isActivityInFrontGound) {\n    //                        KsRouterHelper.loginByPhone(ProvideLoginConstant.COMMON);\n    //                    }\n    //                }\n    //            });\n    //        } else {\n    //            try {\n    //                JSONObject json = new JSONObject(extras);\n    //                handlePopNotifaction(context, json, extras);\n    //            } catch (Exception e) {\n    //                Log.e(\"lzm\", \"Get message extra JSON error!\");\n    //            }\n    //        }\n    //    }\n    //\n    //    /****\n    //     * 自定义消息处理\n    //     */\n    //    private void handlePopNotifaction(Context context, JSONObject jsonObject, String extras) {\n    //        if (jsonObject == null) {\n    //            return;\n    //        }\n    //\n    //        String contentType = null;\n    //        try {\n    //            contentType = jsonObject.getString(\"contenttype\");\n    //        } catch (JSONException e) {\n    //            e.printStackTrace();\n    //        }\n    //\n    //        if (\"gushiji_tobuy\".equals(contentType)) { //故事机推送购买\n    //            SPUtils.put(SPUtils.ROBOT_JPUSH_BUY_MSG, extras);\n    //            BusProvider.getInstance().post(new RobotBuyMsgEvent());\n    //            return;\n    //        } else if (\"gushiji_notify\".equals(contentType)) { //故事机推送设备即时信息\n    //            BusProvider.getInstance().post(new RobotPushNotifyMsgEvent(extras));\n    //            return;\n    //        } else if (\"gushiji_bind\".equals(contentType)) {\n    //            BusProvider.getInstance().post(new RobotPushNotifyMsgEvent(extras));\n    //            return;\n    //        }\n    //\n    //        int errcode = jsonObject.optInt(\"errcode\");\n    //        String simpleName = \"FirstActivity\";\n    //        // 多人登陆通知\n    //        switch (errcode) {\n    //            case LoginController.ACCOUNTCANCELLATION_CODE:\n    //                if (context != null && context.getApplicationContext() == KaishuApplication.getContext()) {\n    //                    if (KaishuApplication.countActivity > 0 && !simpleName.equals(KaishuApplication.currentActivity)) {\n    //                        try {\n    //                            KsRouterHelper.compSafetyAccoutCancellationTip();\n    //                        } catch (Exception e) {\n    //                            e.printStackTrace();\n    //                        }\n    //                    } else {\n    //                        KSAbstractActivity.accountCancellationObj = true;\n    //                    }\n    //                }\n    //                return;\n    //            case LoginController.DEVICE_LIMITE_CODE:\n    //                if (context != null && context.getApplicationContext() == KaishuApplication.getContext()) {\n    //                    if (KaishuApplication.countActivity > 0 && !simpleName.equals(KaishuApplication.currentActivity)) {\n    //                        //LoginController.justLogOff();\n    //                        KsRouterHelper.showExit();\n    //                    } else {\n    //                        KaishuApplication.CODE = ProvideMainConstant.EXTRA_DATA_CODE_EXIT;\n    //                        KaishuApplication.showAbnormalExitTip = true;\n    //                    }\n    //                }\n    //                return;\n    //\n    //            // 封号通知\n    //            case LoginController.DEVICE_BLOCK_LOGIN_CODE:\n    //                if (context != null && context.getApplicationContext() == KaishuApplication.getContext()) {\n    //                    if (KaishuApplication.countActivity > 0 && !simpleName.equals(KaishuApplication.currentActivity)) {\n    //                        if (LoginController.isLogined()) {\n    //                            KsRouterHelper.showBlockLogin((String) SPUtils.get(SPUtils.ENCODE_USER_ID, \"\"));\n    //                            //LoginController.justLogOff();\n    //                        }\n    //                    } else {\n    //                        KaishuApplication.CODE = ProvideMainConstant.EXTRA_DATA_CODE_BLOCK_LOGIN;\n    //                        KaishuApplication.showAbnormalExitTip = true;\n    //                    }\n    //                }\n    //                return;\n    //\n    //            // 会员冻结通知\n    //            case LoginController.DEVICE_VIP_FREEZED_CODE:\n    //                if (context != null && context.getApplicationContext() == KaishuApplication.getContext()) {\n    //                    MemberUtils.updateVipStatusToFreezed();\n    //                    if (KaishuApplication.countActivity > 0 && !simpleName.equals(KaishuApplication.currentActivity)) {\n    //                        KsRouterHelper.showVipFreezed();\n    //                    } else {\n    //                        KaishuApplication.CODE = ProvideMainConstant.EXTRA_DATA_CODE_VIP_FREEZED;\n    //                        KaishuApplication.showAbnormalExitTip = true;\n    //                    }\n    //                }\n    //                return;\n    //        }\n    //\n    //        mCurentId = (int) SPUtils.get(SPUtils.JPUSH_NOTIFY_ID, NOTIFY_ID_1);\n    //        switch (mCurentId) {\n    //            case NOTIFY_ID_1:\n    //                mCurentId = NOTIFY_ID_2;\n    //                break;\n    //            case NOTIFY_ID_2:\n    //                mCurentId = NOTIFY_ID_3;\n    //                break;\n    //            default:\n    //                mCurentId = NOTIFY_ID_1;\n    //                break;\n    //        }\n    //        SPUtils.put(SPUtils.JPUSH_NOTIFY_ID, mCurentId);\n    //\n    //        pointShowPush(jsonObject);\n    //\n    //        h.removeCallbacks(postRunnable);\n    //        h.postDelayed(getUpdateRunnable(context, jsonObject), 500);\n    //    }\n    //\n    //    private void pointShowPush(JSONObject jsonObject) {\n    //        if (jsonObject == null) {\n    //            return;\n    //        }\n    ////        String title = jsonObject.optString(\"title\");\n    ////        String text = jsonObject.optString(\"text\");\n    ////        String contentid = jsonObject.optString(\"contentid\");\n    ////        String link = jsonObject.optString(\"link\");\n    ////        String contenttype = jsonObject.optString(\"contenttype\");\n    ////        com.alibaba.fastjson.JSONObject analysisJson = new com.alibaba.fastjson.JSONObject();\n    ////        analysisJson.put(\"contenttype\", contenttype);\n    ////        analysisJson.put(\"contentid\", contentid);\n    ////        analysisJson.put(\"title\", title);\n    ////        analysisJson.put(\"text\", text);\n    ////        analysisJson.put(\"link\", link);\n    //        AnalysisBehaviorPointRecoder.push_show(jsonObject.toString());\n    //    }\n    //\n    //    private Runnable getUpdateRunnable(final Context context, JSONObject jsonObject) {\n    //        postRunnable = () -> updateNotifyImage(context, jsonObject);\n    //        return postRunnable;\n    //    }\n    //\n    //    private void updateNotifyImage(Context context, JSONObject jsonObject) {\n    //        //{\"contentid\":\"1\",\"text\":\"点击解锁今日小知识:测试花生米先生\",\"contenttype\":\"subscribe_album_column\",\"errcode\":\"2001\",\"title\":\"测试\"}\n    //        String title = jsonObject.optString(\"title\");\n    //        String text = jsonObject.optString(\"text\");\n    //        String imgUrl = jsonObject.optString(\"img\");\n    //        Log.e(\"lzm\", \"title=\" + title);\n    //        Log.e(\"lzm\", \"text=\" + text);\n    //\n    //\n    //        Log.e(\"lzm\", \"imgUrl  update imeg-=\" + imgUrl);\n    //        if (!TextUtils.isEmpty(imgUrl)) {\n    //            ImagePipeline imagePipeline = Fresco.getImagePipeline();\n    //            ImageRequest imageRequest = ImageRequest.fromUri(imgUrl);\n    //            DataSource<CloseableReference<CloseableImage>>\n    //                    dataSource = imagePipeline.fetchDecodedImage(imageRequest, context);\n    //            dataSource.subscribe(new BaseBitmapDataSubscriber() {\n    //                @Override\n    //                public void onNewResultImpl(@Nullable Bitmap bitmap) {\n    //                    if (bitmap != null && !bitmap.isRecycled()) {\n    ////                        if (remoteViews != null) {\n    ////                            remoteViews.setImageViewBitmap(R.id.custom_notification_large_icon, bitmap);\n    ////                        }\n    ////                        if (bigremoteViews != null) {\n    ////                            bigremoteViews.setImageViewBitmap(R.id.custom_notification_large_icon, bitmap);\n    ////                        }\n    //                        try {\n    //                            nm.notify(mCurentId, createNotification(context, jsonObject, bitmap));\n    //                        } catch (Exception e) {\n    //                            e.printStackTrace();\n    //                        }\n    //                    }\n    //                }\n    //\n    //                @Override\n    //                public void onFailureImpl(DataSource dataSource) {\n    ////                    if (remoteViews != null) {\n    ////                        remoteViews.setImageViewResource(R.id.custom_notification_large_icon, R.drawable.launch_icon);\n    ////                    }\n    ////                    if (bigremoteViews != null) {\n    ////                        bigremoteViews.setImageViewResource(R.id.custom_notification_large_icon, R.drawable.launch_icon);\n    ////                    }\n    //                    try {\n    //                        nm.notify(mCurentId, createNotification(context, jsonObject, null));\n    //                    } catch (Exception e) {\n    //                        e.printStackTrace();\n    //                    }\n    //                }\n    //            }, UiThreadImmediateExecutorService.getInstance());\n    //        } else {\n    ////            if (remoteViews != null) {\n    ////                remoteViews.setImageViewResource(R.id.custom_notification_large_icon, R.drawable.launch_icon);\n    ////            }\n    ////            if (bigremoteViews != null) {\n    ////                bigremoteViews.setImageViewResource(R.id.custom_notification_large_icon, R.drawable.launch_icon);\n    ////            }\n    //            try {\n    //                Log.e(\"lzm\", \"notify.......\");\n    //                nm.notify(mCurentId, createNotification(context, jsonObject, null));\n    //            } catch (Exception e) {\n    //                Log.e(\"lzm\", \"notify... error....\");\n    //                e.printStackTrace();\n    //            }\n    //        }\n    //    }\n    //\n    //    /**\n    //     * 自定义弹出push通知\n    //     */\n    //    private Notification createNotification(Context context, JSONObject jsonObject,\n    //                                            Bitmap bitmap) {\n    //        String title = jsonObject.optString(\"title\");\n    //        String text = jsonObject.optString(\"text\");\n    //        String contenttype = jsonObject.optString(\"contenttype\");\n    //        String contentid = jsonObject.optString(\"contentid\");\n    //        String link = jsonObject.optString(\"link\");\n    //\n    //        long commentId = jsonObject.optLong(\"commentId\");\n    //        long campId = jsonObject.optLong(\"campId\");\n    //        long stageId = jsonObject.optLong(\"stageId\");\n    //        long courseId = jsonObject.optLong(\"storyId\");//课程id\n    //\n    //        //实例化工具类，并且调用接口\n    //        int smallIcon = R.mipmap.launch_icon;\n    //        //5.0系统需要透明背景纯色图标才能正常显示在状态栏\n    //        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n    //            smallIcon = R.mipmap.ic_notify_sm;\n    //        }\n    //        Intent broadcastIntent = new Intent(context, NotificationPushOpenReceiver.class);\n    //        broadcastIntent.putExtra(NotificationPushOpenReceiver.PUSH_TITLE, title);\n    //        broadcastIntent.putExtra(NotificationPushOpenReceiver.PUSH_TEXT, text);\n    //        broadcastIntent.putExtra(NotificationPushOpenReceiver.PUSH_CONTENTTYPE, contenttype);\n    //        broadcastIntent.putExtra(NotificationPushOpenReceiver.PUSH_CONTENIID, contentid);\n    //        broadcastIntent.putExtra(NotificationPushOpenReceiver.PUSH_LINK, link);\n    //\n    //        broadcastIntent.putExtra(NotificationPushOpenReceiver.PUSH_COMMENTID, commentId);\n    //        broadcastIntent.putExtra(NotificationPushOpenReceiver.PUSH_CAMPID, campId);\n    //        broadcastIntent.putExtra(NotificationPushOpenReceiver.PUSH_STAGEID, stageId);\n    //        broadcastIntent.putExtra(NotificationPushOpenReceiver.PUSH_COURSEID, courseId);\n    //\n    //        PendingIntent pIntent = PendingIntent.\n    //                getBroadcast(context, mCurentId, broadcastIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n    //\n    //        NotificationCompat.Builder cBuilder = new NotificationCompat.Builder(context, GlobalConstant.NOTIFICATION_CHANNEL_ID_PUSH);\n    ////        NotificationCompat.Builder cBuilder = new NotificationCompat.Builder(context);\n    //        cBuilder.setContentIntent(pIntent);// 该通知要启动的Intent\n    //        cBuilder.setSmallIcon(smallIcon);// 设置顶部状态栏的小图标\n    //        cBuilder.setTicker(title);// 在顶部状态栏中的提示信息\n    //        cBuilder.setContentTitle(title);// 设置通知中心的标题\n    //        cBuilder.setNumber(2);\n    //        cBuilder.setContentText(text);// 设置通知中心中的内容\n    //        if (bitmap == null) {\n    //            bitmap = BitmapFactory.decodeResource(context.getResources(), R.mipmap.launch_icon);\n    //            cBuilder.setLargeIcon(bitmap);\n    //        } else {\n    //            cBuilder.setLargeIcon(bitmap);\n    //        }\n    //        cBuilder.setWhen(System.currentTimeMillis());\n    //\n    //        /*\n    //         * 将AutoCancel设为true后，当你点击通知栏的notification后，它会自动被取消消失,\n    //         * 不设置的话点击消息后也不清除，但可以滑动删除\n    //         */\n    //        cBuilder.setAutoCancel(true);\n    //        /*\n    //         * 从Android4.1开始，可以通过以下方法，设置notification的优先级，\n    //         * 优先级越高的，通知排的越靠前，优先级低的，不会在手机最顶部的状态栏显示图标\n    //         */\n    //        cBuilder.setPriority(NotificationCompat.PRIORITY_MAX);\n    //        /*\n    //         * Notification.DEFAULT_ALL：铃声、闪光、震动均系统默认。\n    //         * Notification.DEFAULT_SOUND：系统默认铃声。\n    //         * Notification.DEFAULT_VIBRATE：系统默认震动。\n    //         * Notification.DEFAULT_LIGHTS：系统默认闪光。\n    //         * notifyBuilder.setDefaults(Notification.DEFAULT_ALL);\n    //         */\n    //        cBuilder.setDefaults(Notification.DEFAULT_VIBRATE);\n    ////        if(\"OPPO R9m\".equals(Build.MODEL)) {\n    ////            cBuilder.setCustomBigContentView(bigNotiView);\n    ////        } else {\n    ////            cBuilder.setCustomContentView(myNotificationView);\n    ////            cBuilder.setCustomBigContentView(bigNotiView);\n    ////        }\n    //        Notification notifyCation = cBuilder.build();\n    //        return notifyCation;\n    //    }\n    //\n    //\n    //\n    //    private static Handler h = new Handler();\n    //\n    //    /**\n    //     * 点击自定义通知\n    //     *\n    //     * @param jsonObject\n    //     */\n    //    private void handleCustomNotifyClick(Context context, JSONObject jsonObject) {\n    //        //判断app进程是否存活\n    //        if (SystemUtils.isAppAlive(context, GlobalConstant.APP_PACKAGENAME)) {\n    //            if (KaishuApplication.mainTabExist) {\n    //                KaishuJumpUtils.jump_JPushOperaReceiver(context, jsonObject);\n    //            } else {\n    ////                final Intent parentIntent = new Intent(context, MainTabActivity.class);\n    //                try {\n    //                    Class<?> mMainTabClass = Class.forName(\"com.ks.kaishustory.ui.activity.MainTabActivity\");\n    //                    final Intent parentIntent = new Intent(context, mMainTabClass);\n    //                    PendingIntent pendingIntent = PendingIntent.getActivity(context,\n    //                            0, parentIntent, PendingIntent.FLAG_ONE_SHOT);\n    //                    try {\n    //                        pendingIntent.send();\n    //                    } catch (Exception e) {\n    //                        e.printStackTrace();\n    //                    }\n    //                } catch (ClassNotFoundException e) {\n    //                    e.printStackTrace();\n    //                }\n    //\n    //                KaishuJumpUtils.jump_JPushOperaReceiver(context, jsonObject);\n    //            }\n    //        } else {\n    //            Intent launchIntent = context.getPackageManager().\n    //                    getLaunchIntentForPackage(\"com.ks.kaishustory\");\n    //            launchIntent.setFlags(\n    //                    Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);\n    //            context.startActivity(launchIntent);\n    //        }\n    //    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nclass JPushRegistInfoReceiver : JPushMessageReceiver() {\n\n    //自定义消息\n    override fun onMessage(context: Context, customMessage: CustomMessage) {\n        Log.e(TAG, \"[onMessage] $customMessage\")\n        processCustomMessage(context, customMessage)\n    }\n\n    //通知打开\n    override fun onNotifyMessageOpened(context: Context, message: NotificationMessage) {\n        Log.e(TAG, \"[onNotifyMessageOpened] $message\")\n        JPushInterface.reportNotificationOpened(context, message.msgId, message.platform.toByte())\n        JpushDelegate.handleCustomNotifyClick(context, JSONObject(message.notificationExtras))\n    }\n\n    override fun onMultiActionClicked(context: Context, intent: Intent) {\n        Log.e(TAG, \"[onMultiActionClicked] 用户点击了通知栏按钮\")\n        val nActionExtra = intent.extras!!.getString(JPushInterface.EXTRA_NOTIFICATION_ACTION_EXTRA)\n\n        //开发者根据不同 Action 携带的 extra 字段来分配不同的动作。\n        if (nActionExtra == null) {\n            Log.d(TAG, \"ACTION_NOTIFICATION_CLICK_ACTION nActionExtra is null\")\n            return\n        }\n        if (nActionExtra == \"my_extra1\") {\n            Log.e(TAG, \"[onMultiActionClicked] 用户点击通知栏按钮一\")\n        } else if (nActionExtra == \"my_extra2\") {\n            Log.e(TAG, \"[onMultiActionClicked] 用户点击通知栏按钮二\")\n        } else if (nActionExtra == \"my_extra3\") {\n            Log.e(TAG, \"[onMultiActionClicked] 用户点击通知栏按钮三\")\n        } else {\n            Log.e(TAG, \"[onMultiActionClicked] 用户点击通知栏按钮未定义\")\n        }\n    }\n\n    //接收到通知\n    override fun onNotifyMessageArrived(context: Context, message: NotificationMessage) {\n        Log.e(TAG, \"[onNotifyMessageArrived] $message\")\n    }\n\n    override fun onNotifyMessageDismiss(context: Context?, message: NotificationMessage?) {\n        Log.e(TAG, \"[onNotifyMessageDismiss] \" + message!!)\n    }\n\n    override fun onRegister(context: Context?, registrationId: String?) {\n        Log.e(TAG, \"[onRegister] \" + registrationId!!)\n        JPushHolder.mJPushRegistId = registrationId\n    }\n\n    override fun onConnected(context: Context?, isConnected: Boolean) {\n        Log.e(TAG, \"[onConnected] $isConnected\")\n    }\n\n    override fun onCommandResult(context: Context?, cmdMessage: CmdMessage?) {\n        Log.e(TAG, \"[onCommandResult] \" + cmdMessage!!)\n    }\n\n    override fun onTagOperatorResult(context: Context?, jPushMessage: JPushMessage?) {\n        context?.let { TagAliasOperatorHelper.instance?.onTagOperatorResult(it, jPushMessage!!) }\n        super.onTagOperatorResult(context, jPushMessage)\n    }\n\n    override fun onCheckTagOperatorResult(context: Context?, jPushMessage: JPushMessage?) {\n        context?.let {\n            TagAliasOperatorHelper.instance?.onCheckTagOperatorResult(\n                it,\n                jPushMessage!!\n            )\n        }\n        super.onCheckTagOperatorResult(context, jPushMessage)\n    }\n\n    override fun onAliasOperatorResult(context: Context?, jPushMessage: JPushMessage?) {\n        context?.let { TagAliasOperatorHelper.instance?.onAliasOperatorResult(it, jPushMessage!!) }\n        super.onAliasOperatorResult(context, jPushMessage)\n    }\n\n    override fun onMobileNumberOperatorResult(context: Context?, jPushMessage: JPushMessage?) {\n        context?.let {\n            TagAliasOperatorHelper.instance?.onMobileNumberOperatorResult(\n                it,\n                jPushMessage!!\n            )\n        }\n        super.onMobileNumberOperatorResult(context, jPushMessage)\n    }\n\n    /**\n     * 接收到自定义消息\n     * @param context Context\n     * @param customMessage CustomMessage\n     */\n    private fun processCustomMessage(context: Context, customMessage: CustomMessage) {\n        //        if (MainActivity.isForeground) {\n        val extra = customMessage.extra\n        try {\n            var json = JSONObject()\n            if (extra.isNotEmpty()) {\n                json = JSONObject(extra)\n            }\n            JpushDelegate.processCustomMessage(context, json)\n        } catch (e: JSONException) {\n            e.printStackTrace()\n        }\n    }\n\n//    override fun onNotificationSettingsCheck(context: Context?, isOn: Boolean, source: Int) {\n//        super.onNotificationSettingsCheck(context, isOn, source)\n//        Log.e(TAG, \"[onNotificationSettingsCheck] isOn:$isOn,source:$source\")\n//    }\n\n    companion object {\n\n        private val TAG = \"JIGUANG-KS\"\n    }\n\n}\n\n\n\n\n\n\n\nclass NotificationPushOpenReceiver : BroadcastReceiver() {\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (context == null || intent == null) {\n            return\n        }\n        val pushTilte = intent.getStringExtra(JpushDelegate.PUSH_TITLE)\n        val pushText = intent.getStringExtra(JpushDelegate.PUSH_TEXT)\n        val pushContenttype = intent.getStringExtra(JpushDelegate.PUSH_CONTENTTYPE)\n        val pushContentid = intent.getStringExtra(JpushDelegate.PUSH_CONTENIID)\n        val pushLink = intent.getStringExtra(JpushDelegate.PUSH_LINK)\n        val stageId = intent.getStringExtra(JpushDelegate.PUSH_STAGEID)\n\n        val jsonObject = org.json.JSONObject().apply {\n            optString(JpushDelegate.PUSH_CONTENTTYPE, pushContenttype)\n            optString(JpushDelegate.PUSH_CONTENIID, pushContentid)\n            optString(JpushDelegate.PUSH_TITLE, pushTilte)\n            optString(JpushDelegate.PUSH_TEXT, pushText)\n            optString(JpushDelegate.PUSH_LINK, pushLink)\n            optString(JpushDelegate.PUSH_STAGEID, stageId)\n        }\n\n        JpushDelegate.handleCustomNotifyClick(context, jsonObject)\n\n    }\n}\n\n\n\n\n\n\n\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    package=\"com.ks.push\">\n\n    <!-- Required -->\n    <permission\n        android:name=\"${applicationId}.permission.JPUSH_MESSAGE\"\n        android:protectionLevel=\"signature\"\n        />\n\n    <uses-permission android:name=\"android.permission.RECEIVE_USER_PRESENT\" />\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\" />\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n\n    <application\n        >\n\n        <receiver\n            android:name=\".ui.receiver.JPushOperaReceiver\"\n            android:enabled=\"true\"\n            android:exported=\"false\">\n            <intent-filter>\n                <action android:name=\"cn.jpush.android.intent.REGISTRATION\" /> <!-- Required  用户注册SDK的intent -->\n                <action android:name=\"cn.jpush.android.intent.MESSAGE_RECEIVED\" /> <!-- Required  用户接收SDK消息的intent -->\n                <action android:name=\"cn.jpush.android.intent.NOTIFICATION_RECEIVED\" /> <!-- Required  用户接收SDK通知栏信息的intent -->\n                <action android:name=\"cn.jpush.android.intent.NOTIFICATION_OPENED\" /> <!-- Required  用户打开自定义通知栏的intent -->\n                <action android:name=\"cn.jpush.android.intent.NOTIFICATION_CLICK_ACTION\" />\n                <action android:name=\"cn.jpush.android.intent.CONNECTION\" /> <!-- 接收网络变化 连接/断开 since 1.6.3 -->\n                <category android:name=\"${applicationId}\" />\n            </intent-filter>\n        </receiver>\n\n        <!-- Since JCore2.0.0 Required SDK核心功能-->\n        <!-- 可配置android:process参数将Service放在其他进程中；android:enabled属性不能是false -->\n        <!-- 这个是自定义Service，要继承极光JCommonService，可以在更多手机平台上使得推送通道保持的更稳定 -->\n        <service\n            android:name=\".ui.service.KsJpushService\"\n            android:enabled=\"true\"\n            android:exported=\"false\"\n            android:process=\":pushcore\">\n            <intent-filter>\n                <action android:name=\"cn.jiguang.user.service.action\" />\n            </intent-filter>\n        </service>\n\n\n        <receiver android:name=\".ui.receiver.NotificationPushOpenReceiver\" />\n\n        <receiver android:name=\".ui.receiver.JPushRegistInfoReceiver\"\n            >\n            <intent-filter>\n                <action android:name=\"cn.jpush.android.intent.RECEIVE_MESSAGE\" />\n\n                <category android:name=\"${applicationId}\" />\n            </intent-filter>\n        </receiver>\n\n\n        <!-- Required SDK 核心功能-->\n        <!-- 可配置android:process参数将PushService放在其他进程中 -->\n        <service\n            android:name=\"cn.jpush.android.service.PushService\"\n            android:exported=\"false\"\n            android:process=\":pushcore\">\n            <intent-filter>\n                <action android:name=\"cn.jpush.android.intent.REGISTER\" />\n                <action android:name=\"cn.jpush.android.intent.REPORT\" />\n                <action android:name=\"cn.jpush.android.intent.PushService\" />\n                <action android:name=\"cn.jpush.android.intent.PUSH_TIME\" />\n            </intent-filter>\n        </service>\n\n\n        <!-- since 3.0.9 Required SDK 核心功能-->\n        <provider\n            tools:replace=\"android:authorities\"\n            android:name=\"cn.jpush.android.service.DataProvider\"\n            android:authorities=\"${applicationId}.DataProvider\"\n            android:exported=\"false\"\n            android:process=\":pushcore\" />\n\n        <!-- since 1.8.0 option 可选项。用于同一设备中不同应用的JPush服务相互拉起的功能。 -->\n        <!-- 若不启用该功能可删除该组件，将不拉起其他应用也不能被其他应用拉起 -->\n        <service\n            android:name=\"cn.jpush.android.service.DaemonService\"\n            android:enabled=\"true\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"cn.jpush.android.intent.DaemonService\" />\n                <category android:name=\"${applicationId}\" />\n            </intent-filter>\n\n        </service>\n\n        <!-- since 3.1.0 Required SDK 核心功能-->\n        <provider\n            tools:replace=\"android:authorities\"\n            android:name=\"cn.jpush.android.service.DownloadProvider\"\n            android:authorities=\"${applicationId}.DownloadProvider\"\n            android:exported=\"true\" />\n\n        <!-- Required SDK核心功能-->\n        <receiver\n            android:name=\"cn.jpush.android.service.PushReceiver\"\n            android:enabled=\"true\"\n            android:exported=\"false\">\n            <intent-filter android:priority=\"1000\">\n                <action android:name=\"cn.jpush.android.intent.NOTIFICATION_RECEIVED_PROXY\" />   <!--Required  显示通知栏 -->\n                <category android:name=\"${applicationId}\" />\n            </intent-filter>\n            <intent-filter>\n                <action android:name=\"android.intent.action.USER_PRESENT\" />\n                <action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" />\n            </intent-filter>\n            <!-- Optional -->\n            <intent-filter>\n                <action android:name=\"android.intent.action.PACKAGE_ADDED\" />\n                <action android:name=\"android.intent.action.PACKAGE_REMOVED\" />\n\n                <data android:scheme=\"package\" />\n            </intent-filter>\n        </receiver>\n\n        <!-- Required SDK核心功能-->\n        <receiver\n            android:name=\"cn.jpush.android.service.AlarmReceiver\"\n            android:exported=\"false\" />\n\n\n        <!-- 3.5.0新增，用于定时展示功能 -->\n        <receiver\n            android:name=\"cn.jpush.android.service.SchedulerReceiver\"\n            android:exported=\"false\" />\n\n\n        <!--since 3.3.0 Required SDK核心功能-->\n        <activity\n            android:name=\"cn.jpush.android.service.JNotifyActivity\"\n            android:exported=\"false\"\n            tools:replace=\"android:exported\"\n            android:taskAffinity=\"jpush.custom\"\n            android:theme=\"@android:style/Theme.Translucent.NoTitleBar\">\n            <intent-filter>\n                <action android:name=\"cn.jpush.android.intent.JNotifyActivity\" />\n                <category android:name=\"${applicationId}\" />\n            </intent-filter>\n        </activity>\n\n\n        <meta-data\n            android:name=\"JPUSH_CHANNEL\"\n            android:value=\"${JPUSH_CHANNEL}\"\n            tools:replace=\"android:value\"/>\n        <meta-data\n            android:name=\"JPUSH_APPKEY\"\n            android:value=\"${JPUSH_APPKEY}\"\n            tools:replace=\"android:value\"/>\n\n    </application>\n</manifest>\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598585027701},"updatedAt":{"$$date":1598586158647},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"FTd3aDpoUr871q7v"}
{"name":"kqapp-轻课dialog","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author liangsaifei\n * 邮箱：liangsaifei@ksjgs.com\n * 创建时间: 2020-03-09     10:19\n * 用途: 挽留弹窗\n ***************************************\n\n */\nclass CourseMiddleDetainDialog(picUrl: String?=\"\", val activity: FragmentActivity, val leaveEvent: () -> Unit,val stayEvent:()->Unit) {\n\n    init {\n        activity.run {\n            DialogPlus.newDialog(this)\n                    .setMargin(dp2px(40f), 0, dp2px(40f), 0)\n                    .setContentHolder(ViewHolder(R.layout.course_dialog_course_middle_detain))\n                    .setContentBackgroundResource(R.color.ui_color_transparent)\n                    .setGravity(Gravity.CENTER)\n                    .setOnCancelListener(null)\n                    .setExpanded(false)\n                    .setCancelable(false)\n                    .create().apply {\n                        show()\n                        if (picUrl.isNullOrEmpty()) {\n                            findView<SimpleDraweeView>(R.id.sdvCourseDialogDetain)?.setActualImageResource(R.drawable.course_middle_wan_liu)\n                        } else {\n                            //设置宠物\n                            findView<SimpleDraweeView>(R.id.sdvCourseDialogDetain)?.setImageUriWebp(picUrl)\n                        }\n\n\n                        //离开\n                        findView<TextView>(R.id.tvCourseDialogDetainLeave)?.setOnClickListener {\n                            leaveEvent()\n                        }\n\n                        //留下\n                        findView<TextView>(R.id.tvCourseDialogDetainStay)?.setOnClickListener {\n                            stayEvent()\n                            BusProvider.instance?.post(BusMsg(BusMsg.COURSE_DETAIN_DIALOG_HIDE, null))\n                            dismiss()\n                        }\n\n\n                    }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n    /**\n     * 显示\n     * @param picUrl String\n     */\n    private fun showDetain(picUrl: String?) {\n        BusProvider.instance?.post(BusMsg(BusMsg.COURSE_DETAIN_DIALOG_SHOW, null))\n        CourseMiddleDetainDialog(picUrl, this, leaveEvent = {\n            releaseResource()\n            tracePoint(\"bc_leave\")\n        }, stayEvent = {\n            tracePoint(\"bc_stay\")\n        })\n    }\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author jiaruihua\n * 邮箱：jiaruihua@ksjgs.com\n * 创建时间: 2020/7/30     4:10 PM\n * 用途:\n * 选择图片弹框\n ***************************************\n */\nclass CoursePicSelectorDialog(val activity: FragmentActivity?, takePhoto: () -> Unit, selectPic: () -> Unit) {\n\n    init {\n        activity?.run {\n            DialogPlus.newDialog(this)\n                    .setContentHolder(ViewHolder(R.layout.course_pic_select_dialog))\n                    .setContentBackgroundResource(R.color.ui_color_transparent)\n                    .setGravity(Gravity.BOTTOM)\n                    .setOnCancelListener(null)\n                    .setExpanded(false)\n                    .setCancelable(false)\n                    .create().apply {\n                        findView<TextView>(R.id.txt_picture_select_dialog_icon_take_pic)?.click {\n                            takePhoto()\n                            dismiss()\n                        }\n                        findView<TextView>(R.id.txt_picture_select_dialog_icon_from_photo)?.click {\n                            selectPic()\n                            dismiss()\n                        }\n                        findView<TextView>(R.id.txt_picture_select_dialog_cancel)?.click { dismiss() }\n\n                    }.show()\n        }\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593272412},"updatedAt":{"$$date":1598600433177},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"FZer2ZslKOD0xibW"}
{"name":"py-Python的字符串","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。\n\n在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：\n\n>>> print('包含中文的str')\n包含中文的str\n对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：\n\n>>> ord('A')\n65\n>>> ord('中')\n20013\n>>> chr(66)\n'B'\n>>> chr(25991)\n'文'\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973930261},"updatedAt":{"$$date":1594974659105},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"FtzI1QTMZPuFWLVs"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241216525},"updatedAt":{"$$date":1597241216525},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Fvgd8mP9bscacn4s"}
{"name":"kotlin-组合挂起函数 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/coroutines/composing-suspending-functions.html\n组合挂起函数 - Kotlin 语言中文站\n25-31 minutes\n改进翻译\n目录\n\n组合挂起函数\n默认顺序调用\n使用 async 并发\n惰性启动的 async\nasync 风格的函数\n使用 async 的结构化并发\n本节介绍了将挂起函数组合的各种方法。\n\n假设我们在不同的地方定义了两个进行某种调用远程服务或者进行计算的挂起函数。我们只假设它们都是有用的，但是实际上它们在这个示例中只是为了该目的而延迟了一秒钟：\n\n如果需要按 顺序 调用它们，我们接下来会做什么——首先调用 doSomethingUsefulOne 接下来 调用 doSomethingUsefulTwo，并且计算它们结果的和吗？ 实际上，如果我们要根据第一个函数的结果来决定是否我们需要调用第二个函数或者决定如何调用它时，我们就会这样做。\n\n我们使用普通的顺序来进行调用，因为这些代码是运行在协程中的，只要像常规的代码一样 顺序 都是默认的。下面的示例展示了测量执行两个挂起函数所需要的总时间：\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了一些有用的事\n    return 29\n}\n可以在这里获取完整代码。\n\n它的打印输出如下：\n\nThe answer is 42\nCompleted in 2017 ms\n如果 doSomethingUsefulOne 与 doSomethingUsefulTwo 之间没有依赖，并且我们想更快的得到结果，让它们进行 并发 吗？这就是 async 可以帮助我们的地方。\n\n在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了些有用的事\n    return 29\n}\n可以在这里获取完整代码。\n\n它的打印输出如下：\n\nThe answer is 42\nCompleted in 1017 ms\n这里快了两倍，因为两个协程并发执行。 请注意，使用协程进行并发总是显式的。\n\n可选的，async 可以通过将 start 参数设置为 CoroutineStart.LAZY 而变为惰性的。 在这个模式下，只有结果通过 await 获取的时候协程才会启动，或者在 Job 的 start 函数调用的时候。运行下面的示例：\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }\n        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }\n        // 执行一些计算\n        one.start() // 启动第一个\n        two.start() // 启动第二个\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了些有用的事\n    return 29\n}\n可以在这里获取完整代码。\n\n它的打印输出如下：\n\nThe answer is 42\nCompleted in 1017 ms\n因此，在先前的例子中这里定义的两个协程没有执行，但是控制权在于程序员准确的在开始执行时调用 start。我们首先 调用 one，然后调用 two，接下来等待这个协程执行完毕。\n\n注意，如果我们只是在 println 中调用 await，而没有在单独的协程中调用 start，这将会导致顺序行为，直到 await 启动该协程 执行并等待至它结束，这并不是惰性的预期用例。 在计算一个值涉及挂起函数时，这个 async(start = CoroutineStart.LAZY) 的用例用于替代标准库中的 lazy 函数。\n\n我们可以定义异步风格的函数来 异步 的调用 doSomethingUsefulOne 和 doSomethingUsefulTwo 并使用 async 协程建造器并带有一个显式的 GlobalScope 引用。 我们给这样的函数的名称中加上“……Async”后缀来突出表明：事实上，它们只做异步计算并且需要使用延期的值来获得结果。\n\n// somethingUsefulOneAsync 函数的返回值类型是 Deferred<Int>\nfun somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n\n// somethingUsefulTwoAsync 函数的返回值类型是 Deferred<Int>\nfun somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}\n注意，这些 xxxAsync 函数不是 挂起 函数。它们可以在任何地方使用。 然而，它们总是在调用它们的代码中意味着异步（这里的意思是 并发 ）执行。\n\n下面的例子展示了它们在协程的外面是如何使用的：\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\n//sampleStart\n// 注意，在这个示例中我们在 `main` 函数的右边没有加上 `runBlocking`\nfun main() {\n    val time = measureTimeMillis {\n        // 我们可以在协程外面启动异步执行\n        val one = somethingUsefulOneAsync()\n        val two = somethingUsefulTwoAsync()\n        // 但是等待结果必须调用其它的挂起或者阻塞\n        // 当我们等待结果的时候，这里我们使用 `runBlocking { …… }` 来阻塞主线程\n        runBlocking {\n            println(\"The answer is ${one.await() + two.await()}\")\n        }\n    }\n    println(\"Completed in $time ms\")\n}\n//sampleEnd\n\nfun somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n\nfun somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了些有用的事\n    return 29\n}\n可以在这里获取完整代码。\n\n这种带有异步函数的编程风格仅供参考，因为这在其它编程语言中是一种受欢迎的风格。在 Kotlin 的协程中使用这种风格是强烈不推荐的， 原因如下所述。\n\n考虑一下如果 val one = somethingUsefulOneAsync() 这一行和 one.await() 表达式这里在代码中有逻辑错误， 并且程序抛出了异常以及程序在操作的过程中中止，将会发生什么。 通常情况下，一个全局的异常处理者会捕获这个异常，将异常打印成日记并报告给开发者，但是反之该程序将会继续执行其它操作。但是这里我们的 somethingUsefulOneAsync 仍然在后台执行， 尽管如此，启动它的那次操作也会被终止。这个程序将不会进行结构化并发，如下一小节所示。\n\n让我们使用使用 async 的并发这一小节的例子并且提取出一个函数并发的调用 doSomethingUsefulOne 与 doSomethingUsefulTwo 并且返回它们两个的结果之和。 由于 async 被定义为了 CoroutineScope 上的扩展，我们需要将它写在作用域内，并且这是 coroutineScope 函数所提供的：\n\nsuspend fun concurrentSum(): Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}\n这种情况下，如果在 concurrentSum 函数内部发生了错误，并且它抛出了一个异常， 所有在作用域中启动的协程都会被取消。\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val time = measureTimeMillis {\n        println(\"The answer is ${concurrentSum()}\")\n    }\n    println(\"Completed in $time ms\")\n//sampleEnd    \n}\n\nsuspend fun concurrentSum(): Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了些有用的事\n    return 29\n}\n可以在这里获取完整代码。\n\n从上面的 main 函数的输出可以看出，我们仍然可以同时执行这两个操作：\n\nThe answer is 42\nCompleted in 1017 ms\n取消始终通过协程的层次结构来进行传递：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    try {\n        failedConcurrentSum()\n    } catch(e: ArithmeticException) {\n        println(\"Computation failed with ArithmeticException\")\n    }\n}\n\nsuspend fun failedConcurrentSum(): Int = coroutineScope {\n    val one = async<Int> { \n        try {\n            delay(Long.MAX_VALUE) // 模拟一个长时间的运算\n            42\n        } finally {\n            println(\"First child was cancelled\")\n        }\n    }\n    val two = async<Int> { \n        println(\"Second child throws an exception\")\n        throw ArithmeticException()\n    }\n    one.await() + two.await()\n}\n可以在这里获取完整代码。\n\n请注意，如果其中一个子协程（即 two）失败，第一个 async 以及等待中的父协程都会被取消：\n\nSecond child throws an exception\nFirst child was cancelled\nComputation failed with ArithmeticException"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382143266},"updatedAt":{"$$date":1597388279177},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"FzlQl7Mg6qKQtzNb"}
{"name":"html-HTML 样式- CSS","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\nHTML 样式- CSS\nCSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式。\n\nLook! Styles and colors\nManipulate Text\nColors,  Boxes\nand more...\n\n\n尝试一下 »\n\n实例\n尝试一下 - 实例\nHTML使用样式\n本例演示如何使用添加到 <head> 部分的样式信息对 HTML 进行格式化。\n\n本例演示如何使用样式属性做一个没有下划线的链接。\n如何使用 style 属性制作一个没有下划线的链接。\n\n链接到一个外部样式表\n本例演示如何 标签链接到一个外部样式表。\n\n如何使用CSS\nCSS 是在 HTML 4 开始使用的,是为了更好的渲染HTML元素而引入的.\n\nCSS 可以通过以下方式添加到HTML中:\n\n内联样式- 在HTML元素中使用\"style\" 属性\n内部样式表 -在HTML文档头部 <head> 区域使用<style> 元素 来包含CSS\n外部引用 - 使用外部 CSS 文件\n最好的方式是通过外部引用CSS文件.\n\n在本站的HTML教程中我们使用了内联CSS样式来介绍实例，这是为了简化的例子，也使得你能更容易在线编辑代码并在线运行实例。\n\n你可以通过本站的 CSS 教程 学习更多的 CSS 知识。\n\n内联样式\n当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。\n\n<p style=\"color:blue;margin-left:20px;\">这是一个段落。</p>\n学习更多样式，请访问 CSS 教程.\n\nHTML样式实例 - 背景颜色\n背景色属性（background-color）定义一个元素的背景颜色：\n\n实例\n<body style=\"background-color:yellow;\">\n<h2 style=\"background-color:red;\">这是一个标题</h2>\n<p style=\"background-color:green;\">这是一个段落。</p>\n</body>\n\n尝试一下 »\n早期背景色属性（background-color）是使用 bgcolor 属性定义。\n\n尝试一下: 旧版HTML来设置背景方式\n\nHTML 样式实例 - 字体, 字体颜色 ，字体大小\n我们可以使用font-family（字体），color（颜色），和font-size（字体大小）属性来定义字体的样式:\n\n实例\n<h1 style=\"font-family:verdana;\">一个标题</h1>\n<p style=\"font-family:arial;color:red;font-size:20px;\">一个段落。</p>\n\n尝试一下 »\n现在通常使用font-family（字体），color（颜色），和font-size（字体大小）属性来定义文本样式，而不是使用<font>标签。\n\nHTML 样式实例 - 文本对齐方式\n使用 text-align（文字对齐）属性指定文本的水平与垂直对齐方式：\n\n实例\n<h1 style=\"text-align:center;\">居中对齐的标题</h1>\n<p>这是一个段落。</p>\n\n尝试一下 »\n文本对齐属性 text-align取代了旧标签 <center> 。\n\n尝试一下\n\n内部样式表\n当单个文件需要特别样式时，就可以使用内部样式表。你可以在<head> 部分通过 <style>标签定义内部样式表:\n\n<head>\n<style type=\"text/css\">\nbody {background-color:yellow;}\np {color:blue;}\n</style>\n</head>\n外部样式表\n当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。\n\n<head>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\">\n</head>\nHTML 样式标签\n标签\t描述\n<style>\t定义文本样式\n<link>\t定义资源引用地址\n\n已弃用的标签和属性\n在HTML 4, 原来支持定义HTML元素样式的标签和属性已被弃用。这些标签将不支持新版本的HTML标签。\n\n不建议使用的标签有: <font>, <center>, <strike>\n\n不建议使用的属性: color 和 bgcolor.\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886122410},"updatedAt":{"$$date":1598886283810},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"G0nJEa1yKig8p4ak"}
{"name":"kotlin-过滤集合 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-filtering.html\n过滤集合 - Kotlin 语言中文站\n11-14 minutes\n改进翻译\n过滤是最常用的集合处理任务之一。在Kotlin中，过滤条件由 谓词 定义——接受一个集合元素并且返回布尔值的 lambda 表达式：true 说明给定元素与谓词匹配，false 则表示不匹配。\n\n标准库包含了一组让你能够通过单个调用就可以过滤集合的扩展函数。这些函数不会改变原始集合，因此它们既可用于可变集合也可用于只读集合。为了操作过滤结果，应该在过滤后将其赋值给变量或链接其他函数。\n\n基本的过滤函数是 filter()。当使用一个谓词来调用时，filter() 返回与其匹配的集合元素。对于 List 和 Set，过滤结果都是一个 List，对 Map 来说结果还是一个 Map。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\nfilter() 中的谓词只能检查元素的值。如果想在过滤中使用元素在集合中的位置，应该使用 filterIndexed()。它接受一个带有两个参数的谓词：元素的索引和元素的值。\n\n如果想使用否定条件来过滤集合，请使用 filterNot()。它返回一个让谓词产生 false 的元素列表。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    val filteredIdx = numbers.filterIndexed { index, s -> (index != 0) && (s.length < 5)  }\n    val filteredNot = numbers.filterNot { it.length <= 3 }\n\n    println(filteredIdx)\n    println(filteredNot)\n//sampleEnd\n}\n还有一些函数能够通过过滤给定类型的元素来缩小元素的类型：\n\nfilterIsInstance() 返回给定类型的集合元素。在一个 List<Any> 上被调用时，filterIsInstance<T>() 返回一个 List<T>，从而让你能够在集合元素上调用 T 类型的函数。\nfun main() {\n//sampleStart\n    val numbers = listOf(null, 1, \"two\", 3.0, \"four\")\n    println(\"All String elements in upper case:\")\n    numbers.filterIsInstance<String>().forEach {\n        println(it.toUpperCase())\n    }\n//sampleEnd\n}\nfilterNotNull() 返回所有的非空元素。在一个 List<T?> 上被调用时，filterNotNull() 返回一个 List<T: Any>，从而让你能够将所有元素视为非空对象。\nfun main() {\n//sampleStart\n    val numbers = listOf(null, \"one\", \"two\", null)\n    numbers.filterNotNull().forEach {\n        println(it.length)   // 对可空的 String 来说长度不可用\n    }\n//sampleEnd\n}\n另一个过滤函数 – partition() – 通过一个谓词过滤集合并且将不匹配的元素存放在一个单独的列表中。因此，你得到一个 List 的 Pair 作为返回值：第一个列表包含与谓词匹配的元素并且第二个列表包含原始集合中的所有其他元素。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val (match, rest) = numbers.partition { it.length > 3 }\n\n    println(match)\n    println(rest)\n//sampleEnd\n}\n最后，有些函数只是针对集合元素简单地检测一个谓词：\n\n如果至少有一个元素匹配给定谓词，那么 any() 返回 true。\n如果没有元素与给定谓词匹配，那么 none() 返回 true。\n如果所有元素都匹配给定谓词，那么 all() 返回 true。注意，在一个空集合上使用任何有效的谓词去调用 all() 都会返回 true 。这种行为在逻辑上被称为 vacuous truth。\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.any { it.endsWith(\"e\") })\n    println(numbers.none { it.endsWith(\"a\") })\n    println(numbers.all { it.endsWith(\"e\") })\n\n    println(emptyList<Int>().all { it > 5 })   // vacuous truth\n//sampleEnd\n}\nany() 和 none() 也可以不带谓词使用：在这种情况下它们只是用来检查集合是否为空。 如果集合中有元素，any() 返回 true，否则返回 false；none() 则相反。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val empty = emptyList<String>()\n\n    println(numbers.any())\n    println(empty.any())\n    \n    println(numbers.none())\n    println(empty.none())\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308437272},"updatedAt":{"$$date":1597382410219},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"GPt42dGAgBuagJbV"}
{"name":"kqapp-Preference","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\nclass Preference<T>(val name: String, private val default: T) : ReadWriteProperty<Any?, T> {\n\n\n\n    private val prefs: SharedPreferences by lazy {\n        PreferenceManager.getDefaultSharedPreferences(NetComponent.application)\n    }\n\n    override fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return getValue(name, default)\n    }\n\n    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {\n        putValue(name, value)\n    }\n\n    @SuppressLint(\"CommitPrefEdits\")\n    private fun <T> putValue(name: String, value: T) = with(prefs.edit()) {\n        when (value) {\n            is Long -> putLong(name, value)\n            is String -> putString(name, value)\n            is Int -> putInt(name, value)\n            is Boolean -> putBoolean(name, value)\n            is Float -> putFloat(name, value)\n            else -> putString(name, serialize(value))\n        }.apply()\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun <T> getValue(name: String, default: T): T = with(prefs) {\n        val res: Any = when (default) {\n            is Long -> getLong(name, default)\n            is String -> getString(name, default)!!\n            is Int -> getInt(name, default)\n            is Boolean -> getBoolean(name, default)\n            is Float -> getFloat(name, default)\n            else -> deSerialization(getString(name, serialize(default))!!)\n        }\n        return res as T\n    }\n\n    /**\n     * 删除全部数据\n     */\n    fun clearPreference() {\n        prefs.edit().clear().apply()\n    }\n\n    /**\n     * 根据key删除存储数据\n     */\n    fun clearPreference(key: String) {\n        prefs.edit().remove(key).apply()\n    }\n\n    /**\n     * 序列化对象\n     * @param person\n     * *\n     * @return\n     * *\n     * @throws IOException\n     */\n    @Throws(IOException::class)\n    private fun <A> serialize(obj: A): String {\n        val byteArrayOutputStream = ByteArrayOutputStream()\n        val objectOutputStream = ObjectOutputStream(\n                byteArrayOutputStream)\n        objectOutputStream.writeObject(obj)\n        var serStr = byteArrayOutputStream.toString(\"ISO-8859-1\")\n        serStr = java.net.URLEncoder.encode(serStr, \"UTF-8\")\n        objectOutputStream.close()\n        byteArrayOutputStream.close()\n        return serStr\n    }\n\n    /**\n     * 反序列化对象\n     * @param str\n     * *\n     * @return\n     * *\n     * @throws IOException\n     * *\n     * @throws ClassNotFoundException\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    @Throws(IOException::class, ClassNotFoundException::class)\n    private fun <A> deSerialization(str: String): A {\n        val redStr = java.net.URLDecoder.decode(str, \"UTF-8\")\n        val byteArrayInputStream = ByteArrayInputStream(\n                redStr.toByteArray(charset(\"ISO-8859-1\")))\n        val objectInputStream = ObjectInputStream(\n                byteArrayInputStream)\n        val obj = objectInputStream.readObject() as A\n        objectInputStream.close()\n        byteArrayInputStream.close()\n        return obj\n    }\n\n\n    /**\n     * 查询某个key是否已经存在\n     *\n     * @param key\n     * @return\n     */\n    fun contains(key: String): Boolean {\n        return prefs.contains(key)\n    }\n\n    /**\n     * 返回所有的键值对\n     *\n     * @param context\n     * @return\n     */\n    fun getAll(): Map<String, *> {\n        return prefs.all\n    }\n}\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593261813},"updatedAt":{"$$date":1598594515880},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"GoqGYyEoFS8KYIvU"}
{"name":"kqapp-settings.gradle","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n\n/////////业务module///////////////\n/**轻课 模块基础库*/\ninclude ':lightlearn_module_base'\n\nif (useModuleSource.toBoolean() || !lightlearn_module_mine_aar_enable.toBoolean()) {\n    /**我的 业务module*/\n    include ':lightlearn_module_mine'\n}\n/**项目入口 ，启动APP后 打开的页面*/\ninclude ':lightlearn_module_main'\n\nif (useModuleSource.toBoolean() || !lightlearn_module_login_aar_enable.toBoolean()) {\n    /**登录业务module*/\n    include ':lightlearn_module_login'\n}\nif (useModuleSource.toBoolean() || !lightlearn_module_payment_aar_enable.toBoolean()) {\n    /**支付模块*/\n    include ':lightlearn_module_payment'\n}\nif (useModuleSource.toBoolean() || !lightlearn_module_course_aar_enable.toBoolean()) {\n/**课程模块*/\n    include ':lightlearn_module_course'\n}\nif (useModuleSource.toBoolean() || !lightlearn_module_product_aar_enable.toBoolean()) {\n\n/**商品模块*/\n    include ':lightlearn_module_product'\n}\nif (useModuleSource.toBoolean() || !lightlearn_module_home_aar_enable.toBoolean()) {\n/**首页模块*/\n    include ':lightlearn_module_home'\n}\nif (useModuleSource.toBoolean() || !lightlearn_module_pictureselect_aar_enable.toBoolean()) {\n/**相册选择模块（上线前抽取到 component ）*/\n    include ':lightlearn_module_pictureselect'\n}\n\n//////组件，后面等稳定后 沉下去 到kt-lib 库////\n/**UI 组件*/\ninclude ':ks_component_ui'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593257705},"updatedAt":{"$$date":1598593541345},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HAJ8vE37McuYZqpF"}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244744261},"updatedAt":{"$$date":1597244744261},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HDuTUHXWq0JvXUmb"}
{"name":"java-使用Atomic","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"Java的java.util.concurrent包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于java.util.concurrent.atomic包。\n\n我们以AtomicInteger为例，它提供的主要操作有：\n\n增加值并返回新值：int addAndGet(int delta)\n加1后返回新值：int incrementAndGet()\n获取当前值：int get()\n用CAS方式设置：int compareAndSet(int expect, int update)\nAtomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。\n\n如果我们自己通过CAS编写incrementAndGet()，它大概长这样：\n\npublic int incrementAndGet(AtomicInteger var) {\n    int prev, next;\n    do {\n        prev = var.get();\n        next = prev + 1;\n    } while ( ! var.compareAndSet(prev, next));\n    return next;\n}\nCAS是指，在这个操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。如果AtomicInteger的当前值不是prev，就什么也不干，返回false。通过CAS操作并配合do ... while循环，即使其他线程修改了AtomicInteger的值，最终的结果也是正确的。\n\n我们利用AtomicLong可以编写一个多线程安全的全局唯一ID生成器：\n\nclass IdGenerator {\n    AtomicLong var = new AtomicLong(0);\n\n    public long getNextId() {\n        return var.incrementAndGet();\n    }\n}\n通常情况下，我们并不需要直接用do ... while循环调用compareAndSet实现复杂的并发操作，而是用incrementAndGet()这样的封装好的方法，因此，使用起来非常简单。\n\n在高度竞争的情况下，还可以使用Java 8提供的LongAdder和LongAccumulator。\n\n小结\n使用java.util.concurrent.atomic提供的原子操作可以简化多线程编程：\n\n原子操作实现了无锁的线程安全；\n\n适用于计数器，累加器等。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826928487},"updatedAt":{"$$date":1594968002841},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HEpFMUgbRFH7Z7Lu"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403216443},"updatedAt":{"$$date":1597403216443},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HFZCpaFUpkxR9XV4"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975694650},"updatedAt":{"$$date":1598975694650},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HVpTITJjhopfbzX7"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241217956},"updatedAt":{"$$date":1597241217956},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HYy4LacymiW0u7DG"}
{"name":"方法耗时优化篇","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"前言\n前言：根据目前通过工具检测、第三方测试报告中的CPU使用率以及使用过程中会有卡顿现象的反馈，需要对项目中的一些耗时操作做优化，使应用更加流畅。经过对比较熟知的一些工具的使用和对比，采用DoKit + Profiler 的模式进行。在优化的过程中可以科学判断优化点（有些耗时是必须的，比如activity和fragment的创建）\n目标：使用Dokit log出的数据，经过筛选后分析耗时超过100ms以上的方法（由于项目比较大，和具体工期的安排，这个标准被可以根据耗时的比例作调整）。\n工具：Android Studio的Profiler\nAndroid Profiler 简单介绍\n步骤：1，如需打开 Profiler 窗口，请依次选择 View > Tool Windows > Profiler，或点击工具栏中的 Profile  图标。如果 Select Deployment Target 对话框提示，请选择要在哪个设备上分析您的应用。如果您使用的是 Android Emulator 或已取得 root 权限的设备，Android Profiler 将列出所有正在运行的进程，即使这些进程可能无法调试也会列出。当您启动可调试的应用时，默认情况下会选择该进程。Android Profiler 会持续收集分析数据，直到您断开设备连接或点击 End Session。\n1  1 Android Profiler 显示当前正在分析的进程和设备。\n2 2 在 Sessions 窗格中，选择要查看的会话，或启动一个新的分析会话。\n3 3 使用缩放按钮控制要查看时间轴范围，或使用 Attach to live 按钮跳转到实时更新。\n4 4 事件时间轴显示与用户输入相关的事件，包括键盘 Activity、音量控制更改和屏幕旋转。\n5 5 共享时间轴视图，包括 CPU、内存、网络和耗电量图表。\n此共享时间轴视图只显示时间轴图表。要使用详细分析工具，请点击与您要检查的性能数据对应的图表。例如，要使用相关工具检查堆数据和跟踪内存分配，请点击 Memory 图表。\n并非所有分析数据在默认情况下都可见。如果您看到一条消息，显示“Advanced profiling is unavailable for the selected process”，您可以在运行配置中启用高级分析以查看其他数据。\n会话\n您可以将分析器数据另存为会话，这些会话将一直保留，直到您退出 Android Studio。通过在多个会话中记录分析信息并在它们之间进行切换，您可以比较各种场景中的资源使用情况。\n• 如需启动一个新的会话，请点击 Start a new profiling session 按钮，然后从出现的下拉菜单中选择一个应用进程。\n在您记录跟踪记录或捕获堆转储后，Android Studio 会将相应数据（以及您应用的网络活动）作为单独的条目添加到当前会话。\n• 要停止向当前会话添加数据，请点击 Stop the current profiling session 图标 。\n• 要导入之前运行 Android Studio 时导出的轨迹，请点击 Start new profiler session 图标 ，然后选择 Load from file。\n启用高级分析\n要在运行搭载 Android 7.1 或更低版本的设备时向您显示高级分析数据，Android Studio 必须将监控逻辑注入您编译的应用\n要启用高级分析功能，请按以下步骤操作：\n1. 依次选择 Run > Edit Configurations。\n2. 在左侧窗格中选择您的应用模块。\n3. 点击 Profiling 标签，然后勾选 Enable advanced profiling。\n4. 重新编译并运行您的应用。\n高级分析配置会使编译过程变慢，所以仅在您想要开始分析您的应用时，才应启用该配置。\n耗时方法分析\n1，新建Sessions，选择设备，选择进程，因为是检查耗时所以选择在会话中选择CPU视图\n2，通过Dokit导出的数据，过滤出主线程耗时超过100ms的方法\n这里选择儿教中耗时较多的一个方法来分析。\n3，在进入要分析的方法之前先点击record或者右键选择Record CPU trace\n4，手机上点击进入要分析的方法，执行完之后点击stop\n5，会话中会出现不同类型的图示，具体作用如图中标识\n6，咱们要分析com.ks.kaishustory.coursepage.presenter.TrainingCampCourseMiddlePresenter.getCourseMiddleModuleList4Pos1 这个方法，就在搜索中直接搜索，出现高亮标识，就按照高亮标识一直找到\n7，可以看到包含两个方法，继续点击调用链，查看可以优化的方法，以下面图示举例\n右键这个localFileIsExists方法跳转到对应的代码，找到对应的使用localFileIsExists的地方，都知道IO操作比较耗时，看到两个连续的地方用到localFileIsExists(learnSegment.getTransitionLocalPath())，所以抽取为一个变量boolean localImg = localFileIsExists(learnSegment.getTransitionLocalPath());再跑一遍，下面是改完的耗时\n耗时减少了一半多。\n分享之后\n通过大家讨论，主要得出以下结论\n1，由于涉及到手机设备的不同以及不同使用状况下手机性能不同导致导出的数据会不同，所以导出的数据只是在相同状况下的一个参考值。比如：1）不同性能的设备执行同一个方法的耗时不同。2）同一设备在不同使用状况下的性能也会不同，所以执行同一个方法的耗时也会不同。\n2，为了解决上面的问题，可以借助第三方（比如听云）的数据，针对性的解决出现的卡顿，以及对比优化前后的数据。\n3，大家继续调研分析，集思广益，寻找更多更好方法。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598547265721},"updatedAt":{"$$date":1598547344339},"_id":"HbQX9ldTF3D9CzZf","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-imageload_picasso","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation project(path: ':frame_imageload')\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n    // picasso\n    implementation 'com.squareup.picasso:picasso:2.71828'\n    // gif drawable  picasso 不支持gif 加载 ，使用 gifdrawable 替换\n    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.19'\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522807635},"updatedAt":{"$$date":1598528333016},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HkVj23d9BbFOKR3G"}
{"name":"kotlin-Kotlin下的5种单例模式","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\njuejin.im /post/6844903590545326088\nKotlin下的5种单例模式 - 掘金\nAndyJennifer 2018年04月12日 阅读 16668 关注\n7-9 minutes\nKotlin.jpg\n前言\n最近在学习Kotlin这门语言，在项目开发中，运用到了单例模式。因为其表达方式与Java是不同的。所以对不同单例模式的实现进行了分别探讨。主要单例模式实现如下：\n\n饿汉式\n懒汉式\n线程安全的懒汉式\n双重校验锁式\n静态内部类式\nPS:该篇文章不讨论单例模式的运用场景与各种模式下的单例模式的优缺点。只讨论在Java下不同单例模式下的对应Kotlin实现。\n\n一、饿汉式实现\n//Java实现\npublic class SingletonDemo {\n    private static SingletonDemo instance=new SingletonDemo();\n    private SingletonDemo(){\n\n    }\n    public static SingletonDemo getInstance(){\n        return instance;\n    }\n}\n//Kotlin实现\nobject SingletonDemo\n复制代码\n这里很多小伙伴，就吃了一惊。我靠一个object 关键字就完成相同的功能？一行代码？\n\nKotlin的对象声明\n学习了Kotlin的小伙伴肯定知道,在Kotlin中类没有静态方法。如果你需要写一个可以无需用一个类的实例来调用，但需要访问类内部的函数（例如，工厂方法,单例等），你可以把该类声明为一个对象。该对象与其他语言的静态成员是类似的。如果你想了解Kotlin对象声明的更多内容。请点击- - - 传送门\n\n到这里，如果还是有很多小伙伴不是很相信一行代码就能解决这个功能，我们可以通过一下方式查看Kotlin的字节码。\n\n查看Kotlin对应字节码\n查看Kotlin字节码.png\n我们进入我们的Android Studio(我的Android Studio 3.0,如果你的编译器版本过低，请自动升级) 选择Tools工具栏，选择\"Kotlin\",选择“Show Kotlin Bytecode\"\n\n选择过后就会进入到下方界面：\n\n查看Kotlin字节码.png\n点击\"Decompile\" 根据字节码得到以下代码\n\npublic final class SingletonDemo {\n   public static final SingletonDemo INSTANCE;\n   private SingletonDemo(){}\n   static {\n      SingletonDemo var0 = new SingletonDemo();\n      INSTANCE = var0;\n   }\n}\n复制代码\n通过以上代码，我们了解事实就是这个样子的，使用Kotlin\"object\"进行对象声明与我们的饿汉式单例的代码是相同的。\n\n二、懒汉式\n//Java实现\npublic class SingletonDemo {\n    private static SingletonDemo instance;\n    private SingletonDemo(){}\n    public static SingletonDemo getInstance(){\n        if(instance==null){\n            instance=new SingletonDemo();\n        }\n        return instance;\n    }\n}\n//Kotlin实现\nclass SingletonDemo private constructor() {\n    companion object {\n        private var instance: SingletonDemo? = null\n            get() {\n                if (field == null) {\n                    field = SingletonDemo()\n                }\n                return field\n            }\n        fun get(): SingletonDemo{\n        //细心的小伙伴肯定发现了，这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字\n         return instance!!\n        }\n    }\n}\n复制代码\n上述代码中，我们可以发现在Kotlin实现中，我们让其主构造函数私有化并自定义了其属性访问器，其余内容大同小异。\n\n如果有小伙伴不清楚Kotlin构造函数的使用方式。请点击 - - - 构造函数\n不清楚Kotlin的属性与访问器，请点击 - - -属性和字段\n三、线程安全的懒汉式\n//Java实现\npublic class SingletonDemo {\n    private static SingletonDemo instance;\n    private SingletonDemo(){}\n    public static synchronized SingletonDemo getInstance(){//使用同步锁\n        if(instance==null){\n            instance=new SingletonDemo();\n        }\n        return instance;\n    }\n}\n//Kotlin实现\nclass SingletonDemo private constructor() {\n    companion object {\n        private var instance: SingletonDemo? = null\n            get() {\n                if (field == null) {\n                    field = SingletonDemo()\n                }\n                return field\n            }\n        @Synchronized\n        fun get(): SingletonDemo{\n            return instance!!\n        }\n    }\n\n}\n复制代码\n大家都知道在使用懒汉式会出现线程安全的问题，需要使用使用同步锁，在Kotlin中，如果你需要将方法声明为同步，需要添加**@Synchronized**注解。\n\n四、双重校验锁式（Double Check)\n//Java实现\npublic class SingletonDemo {\n    private volatile static SingletonDemo instance;\n    private SingletonDemo(){} \n    public static SingletonDemo getInstance(){\n        if(instance==null){\n            synchronized (SingletonDemo.class){\n                if(instance==null){\n                    instance=new SingletonDemo();\n                }\n            }\n        }\n        return instance;\n    }\n}\n//kotlin实现\nclass SingletonDemo private constructor() {\n    companion object {\n        val instance: SingletonDemo by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {\n        SingletonDemo() }\n    }\n}\n复制代码\n哇！小伙伴们惊喜不，感不感动啊。我们居然几行代码就实现了多行的Java代码。其中我们运用到了Kotlin的延迟属性 Lazy。\n\nLazy是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。\n\n这里还有有两个额外的知识点。\n\n高阶函数，高阶函数是将函数用作参数或返回值的函数（我很纠结我到底讲不讲，哎）。大家还是看这个 ---高阶函数\n委托属性\n如果你了解以上知识点，我们直接来看Lazy的内部实现。\n\nLazy内部实现\npublic fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> =\n        when (mode) {\n            LazyThreadSafetyMode.SYNCHRONIZED -> SynchronizedLazyImpl(initializer)\n            LazyThreadSafetyMode.PUBLICATION -> SafePublicationLazyImpl(initializer)\n            LazyThreadSafetyMode.NONE -> UnsafeLazyImpl(initializer)\n        }\n复制代码\n观察上述代码，因为我们传入的mode = LazyThreadSafetyMode.SYNCHRONIZED， 那么会直接走 SynchronizedLazyImpl，我们继续观察SynchronizedLazyImpl。\n\nLazy接口\nSynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下：\n\npublic interface Lazy<out T> {\n     //当前实例化对象，一旦实例化后，该对象不会再改变\n    public val value: T\n    //返回true表示，已经延迟实例化过了，false 表示，没有被实例化，\n    //一旦方法返回true，该方法会一直返回true,且不会再继续实例化\n    public fun isInitialized(): Boolean\n}\n复制代码\n继续查看SynchronizedLazyImpl，具体实现如下：\n\nSynchronizedLazyImpl内部实现\nprivate class SynchronizedLazyImpl<out T>(initializer: () -> T, lock: Any? = null) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    @Volatile private var _value: Any? = UNINITIALIZED_VALUE\n    // final field is required to enable safe publication of constructed instance\n    private val lock = lock ?: this\n\n    override val value: T\n        get() {\n            val _v1 = _value\n            //判断是否已经初始化过，如果初始化过直接返回，不在调用高级函数内部逻辑\n            if (_v1 !== UNINITIALIZED_VALUE) {\n                @Suppress(\"UNCHECKED_CAST\")\n                return _v1 as T\n            }\n\n            return synchronized(lock) {\n                val _v2 = _value\n                if (_v2 !== UNINITIALIZED_VALUE) {\n                    @Suppress(\"UNCHECKED_CAST\") (_v2 as T)\n                }\n                else {\n                    val typedValue = initializer!!()//调用高级函数获取其返回值\n                    _value = typedValue   //将返回值赋值给_value,用于下次判断时，直接返回高级函数的返回值\n                    initializer = null\n                    typedValue  \n                }\n            }\n        }\n\t\t//省略部分代码\n}\n复制代码\n通过上述代码，我们发现 SynchronizedLazyImpl 覆盖了Lazy接口的value属性，并且重新了其属性访问器。其具体逻辑与Java的双重检验是类似的。\n\n到里这里其实大家还是肯定有疑问，我这里只是实例化了SynchronizedLazyImpl对象，并没有进行值的获取，它是怎么拿到高阶函数的返回值呢？。这里又涉及到了委托属性。\n\n委托属性语法是： val/var <属性名>: <类型> by <表达式>。在 by 后面的表达式是该 委托， 因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）。\n\n而Lazy.kt文件中，声明了Lazy接口的getValue扩展函数。故在最终赋值的时候会调用该方法。\n\n@kotlin.internal.InlineOnly\n//返回初始化的值。\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n复制代码\n五、静态内部类式\n//Java实现\npublic class SingletonDemo {\n    private static class SingletonHolder{\n        private static SingletonDemo instance=new SingletonDemo();\n    }\n    private SingletonDemo(){\n        System.out.println(\"Singleton has loaded\");\n    }\n    public static SingletonDemo getInstance(){\n        return SingletonHolder.instance;\n    }\n}\n//kotlin实现\nclass SingletonDemo private constructor() {\n    companion object {\n        val instance = SingletonHolder.holder\n    }\n\n    private object SingletonHolder {\n        val holder= SingletonDemo()\n    }\n\n}\n复制代码\n静态内部类的实现方式，也没有什么好说的。Kotlin与Java实现基本雷同。\n\n补充\n在该篇文章结束后，有很多小伙伴咨询，如何在Kotlin版的Double Check，给单例添加一个属性，这里我给大家提供了一个实现的方式。（不好意思，最近才抽出时间来解决这个问题）\n\nclass SingletonDemo private constructor(private val property: Int) {//这里可以根据实际需求发生改变\n  \n    companion object {\n        @Volatile private var instance: SingletonDemo? = null\n        fun getInstance(property: Int) =\n                instance ?: synchronized(this) {\n                    instance ?: SingletonDemo(property).also { instance = it }\n                }\n    }\n}\n复制代码\n其中关于?:操作符，如果 ?: 左侧表达式非空，就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。\n\n观察代码我们可以发现大致上和我们的Java中的Double check是一样的。\n\n最后\n附上我写的一个基于Kotlin 仿开眼的项目SimpleEyes(ps: 其实在我之前，已经有很多小朋友开始仿这款应用了，但是我觉得要做就做好。所以我的项目和其他的人应该不同，不仅仅是简单的一个应用。但是，但是。但是。重要的话说三遍。还在开发阶段，不要打我)，欢迎大家follow和start"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397428803},"updatedAt":{"$$date":1597398479652},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HnHkUvK4oYa5Aydq"}
{"name":"java-Lambda基础","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"在了解Lambda之前，我们先回顾一下Java的方法。\n\nJava的方法分为实例方法，例如Integer定义的equals()方法：\n\npublic final class Integer {\n    boolean equals(Object o) {\n        ...\n    }\n}\n以及静态方法，例如Integer定义的parseInt()方法：\n\npublic final class Integer {\n    public static int parseInt(String s) {\n        ...\n    }\n}\n无论是实例方法，还是静态方法，本质上都相当于过程式语言的函数。例如C函数：\n\nchar* strcpy(char* dest, char* src)\n只不过Java的实例方法隐含地传入了一个this变量，即实例方法总是有一个隐含参数this。\n\n函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。历史上研究函数式编程的理论是Lambda演算，所以我们经常把支持函数式编程的编码风格称为Lambda表达式。\n\nLambda表达式\n在Java程序中，我们经常遇到一大堆单方法接口，即一个接口只定义了一个方法：\n\nComparator\nRunnable\nCallable\n以Comparator为例，我们想要调用Arrays.sort()时，可以传入一个Comparator实例，以匿名类方式编写如下：\n\nString[] array = ...\nArrays.sort(array, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n});\n上述写法非常繁琐。从Java 8开始，我们可以用Lambda表达式替换单方法接口。改写上述代码如下：\n\n// Lambda\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, (s1, s2) -> {\n            return s1.compareTo(s2);\n        });\n        System.out.println(String.join(\", \", array));\n    }\n}\n\n Run\n观察Lambda表达式的写法，它只需要写出方法定义：\n\n(s1, s2) -> {\n    return s1.compareTo(s2);\n}\n其中，参数是(s1, s2)，参数类型可以省略，因为编译器可以自动推断出String类型。-> { ... }表示方法体，所有代码写在内部即可。Lambda表达式没有class定义，因此写法非常简洁。\n\n如果只有一行return xxx的代码，完全可以用更简单的写法：\n\nArrays.sort(array, (s1, s2) -> s1.compareTo(s2));\n返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。\n\nFunctionalInterface\n我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口：\n\n@FunctionalInterface\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n再来看Comparator接口：\n\n@FunctionalInterface\npublic interface Comparator<T> {\n\n    int compare(T o1, T o2);\n\n    boolean equals(Object obj);\n\n    default Comparator<T> reversed() {\n        return Collections.reverseOrder(this);\n    }\n\n    default Comparator<T> thenComparing(Comparator<? super T> other) {\n        ...\n    }\n    ...\n}\n虽然Comparator接口有很多方法，但只有一个抽象方法int compare(T o1, T o2)，其他的方法都是default方法或static方法。另外注意到boolean equals(Object obj)是Object定义的方法，不算在接口方法内。因此，Comparator也是一个FunctionalInterface。\n\n练习\n从下载练习：使用Lambda表达式实现忽略大小写排序 （推荐使用IDE练习插件快速下载）\n\n小结\n单方法接口被称为FunctionalInterface。\n\n接收FunctionalInterface作为参数的时候，可以把实例化的匿名类改写为Lambda表达式，能大大简化代码。\n\nLambda表达式的参数和返回值均可由编译器自动推断。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973254137},"updatedAt":{"$$date":1594973597718},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HoxHsXrHuv41e1u5"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980159204},"updatedAt":{"$$date":1594980159204},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HpwUA8dwKuQz2CKz"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977487234},"updatedAt":{"$$date":1594977487234},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HrgxxoYWGSrnjZKf"}
{"name":"andr-布局","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/layout-resource\n布局资源  |  Android 开发者  |  Android Developers\n6-7 minutes\n布局资源定义了 Activity 中的界面或界面中的组件的架构。\n\n文件位置：\nres/layout/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 View（或子类）资源的资源指针。\n资源引用：\n在 Java 中：R.layout.filename\n在 XML 中：@[package:]layout/filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <ViewGroup\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:id=\"@[+][package:]id/resource_name\"\n        android:layout_height=[\"dimension\" | \"match_parent\" | \"wrap_content\"]\n        android:layout_width=[\"dimension\" | \"match_parent\" | \"wrap_content\"]\n        [ViewGroup-specific attributes] >\n        <View\n            android:id=\"@[+][package:]id/resource_name\"\n            android:layout_height=[\"dimension\" | \"match_parent\" | \"wrap_content\"]\n            android:layout_width=[\"dimension\" | \"match_parent\" | \"wrap_content\"]\n            [View-specific attributes] >\n            <requestFocus/>\n        </View>\n        <ViewGroup >\n            <View />\n        </ViewGroup>\n        <include layout=\"@layout/layout_resource\"/>\n    </ViewGroup>\n    \n注意：根元素可以是 ViewGroup、View 或 <merge> 元素，但只能有一个根元素，并且它必须包含带有 android 命名空间的 xmlns:android 属性，如上所示。\n\n元素：\n<ViewGroup>\n其他 View 元素的容器。ViewGroup 对象有许多种类型，每一种都支持您以不同的方式指定子元素的布局。不同类型的 ViewGroup 对象包括 LinearLayout、RelativeLayout 和 FrameLayout。\n您不应假设 ViewGroup 的任何派生对象都接受嵌套的 View。有些 ViewGroup 是 AdapterView 类的实现，该类仅从 Adapter 确定其子项。\n\n属性：\n\nandroid:id\n资源 ID。元素的唯一资源名称，可用于从应用中获取对 ViewGroup 的引用。要详细了解 android:id 的值，请参见下文。\nandroid:layout_height\n尺寸或关键字。必需。组的高度，采用尺寸值（或尺寸资源）或关键字（\"match_parent\" 或 \"wrap_content\"）的形式。请参阅下面的有效值。\nandroid:layout_width\n尺寸或关键字。必需。组的宽度，采用尺寸值（或尺寸资源）或关键字（\"match_parent\" 或 \"wrap_content\"）的形式。请参阅下面的有效值。\nViewGroup 基类支持更多属性，而且 的每个实现又另外支持很多属性。有关所有可用属性的参考信息，请参阅 ViewGroup 类的对应参考文档（例如，LinearLayout XML 属性）。\n\n<View>\n单个界面组件，通常称为“微件”。不同类型的 View 对象包括 TextView、Button 和 CheckBox。\n属性：\n\nandroid:id\n资源 ID。元素的唯一资源名称，可用于从应用中获取对 View 的引用。要详细了解 android:id 的值，请参见下文。\nandroid:layout_height\n尺寸或关键字。必需。元素的高度，采用尺寸值（或尺寸资源）或关键字（\"match_parent\" 或 \"wrap_content\"）的形式。请参阅下面的有效值。\nandroid:layout_width\n尺寸或关键字。必需。元素的宽度，采用尺寸值（或尺寸资源）或关键字（\"match_parent\" 或 \"wrap_content\"）的形式。请参阅下面的有效值。\nView 基类支持更多属性，而且 的每个实现又另外支持很多属性。如需了解详情，请参阅布局。有关所有可用属性的参考信息，请参阅对应的参考文档（例如，TextView XML 属性）。\n\n<requestFocus>\n任何代表 View 对象的元素都可以包含这个空元素，它会在屏幕上为其父项提供初始焦点。每个文件只能包含一个这种元素。\n<include>\n在此布局中包含一个布局文件。\n属性：\n\nlayout\n布局资源。必需。对布局资源的引用。\nandroid:id\n资源 ID。替换提供给所含布局中的根视图的 ID。\nandroid:layout_height\n尺寸或关键字。替换提供给所含布局中的根视图的高度。仅在同时也声明了 android:layout_width 时才有效。\nandroid:layout_width\n尺寸或关键字。替换提供给所含布局中的根视图的宽度。仅在同时也声明了 android:layout_height 时才有效。\n您可以在 <include> 中添加所含布局中的根元素所支持的任何其他布局属性，它们将替换根元素中定义的相应属性。\n\n注意：如果要使用 <include> 标记来替换布局属性，您必须同时替换 android:layout_height 和 android:layout_width 才能让其他布局属性生效。\n\n添加布局的另一种方式是使用 ViewStub。这是一个轻型视图，在对其进行明确膨胀（此时它会添加由其 android:layout 属性定义的布局文件）之前，它不会占用任何布局空间。如需详细了解如何使用 ViewStub，请参阅按需加载视图。\n\n<merge>\n未在布局层次结构中绘制的替代根元素。如果您知道此布局将被放置到一个已包含相应父视图的布局中，以包含 <merge> 元素的子项，则将此元素用作根元素会非常有用。当您打算使用 <include> 将此布局添加到另一个布局文件中，并且此布局不需要不同的 ViewGroup 容器时，这样做尤其有用。如需详细了解如何合并布局，请参阅通过 <include/> 重新使用布局。\nandroid:id 的值\n对于 ID 值，通常应该使用这种语法形式：\"@+id/name\"。加号 + 表示这是一个新的资源 ID，如果不存在，aapt 工具会在 R.java 类中创建一个新的资源整数。例如：\n\n    <TextView android:id=\"@+id/nameTextbox\"/>\n    \nnameTextbox 名称现在是附加到此元素的资源 ID。然后，您就可以在 Java 中引用与此 ID 关联的 TextView：\n\n    val textView: TextView? = findViewById(R.id.nameTextbox)\n    \n    TextView textView = findViewById(R.id.nameTextbox);\n    \n此代码会返回 TextView 对象。\n\n但是，如果您已经定义了一个 ID 资源并且尚未使用它，则可以通过去掉 android:id 值中的加号，将该 ID 应用到 View 元素。\n\nandroid:layout_height 和 android:layout_width 的值：\n高度和宽度值可使用 Android 支持的任意尺寸单位（px、dp、sp、pt、in、mm）或以下关键字来表示：\n\n值\t说明\nmatch_parent\t将尺寸设为与父元素的尺寸一致。在 API 级别 8 中引入以替代 fill_parent。\nwrap_content\t将尺寸设为适配此元素的内容所需的大小。\n自定义 View 元素\n您可以创建自己的自定义 View 和 ViewGroup 元素，并将它们应用到您的布局，就像应用标准布局元素一样。您还可以指定 XML 元素中支持的属性。要了解详情，请参阅自定义组件开发者指南。\n\n示例：\n保存在 res/layout/main_activity.xml 的 XML 文件：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"match_parent\"\n                  android:orientation=\"vertical\" >\n        <TextView android:id=\"@+id/text\"\n                  android:layout_width=\"wrap_content\"\n                  android:layout_height=\"wrap_content\"\n                  android:text=\"Hello, I am a TextView\" />\n        <Button android:id=\"@+id/button\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Hello, I am a Button\" />\n    </LinearLayout>\n    \n此应用代码会在 onCreate() 方法中加载 Activity 的布局：\n\n    public override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.main_activity)\n    }\n    \n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main_activity);\n    }\n    \n另请参阅：\n布局\nView\nViewGroup"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242640658},"updatedAt":{"$$date":1597242721544},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HwQvISrWx3TDMxQ6"}
{"name":"css-CSS 创建","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 创建\n当读到一个样式表时，浏览器会根据它来格式化 HTML 文档。\n\n如何插入样式表\n插入样式表的方法有三种:\n\n外部样式表(External style sheet)\n内部样式表(Internal style sheet)\n内联样式(Inline style)\n外部样式表\n当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 <link> 标签链接到样式表。 <link> 标签在（文档的）头部：\n\n<head>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\">\n</head>\n浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档。\n\n外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .css 扩展名进行保存。下面是一个样式表文件的例子：\n\nhr {color:sienna;}\np {margin-left:20px;}\nbody {background-image:url(\"/images/back40.gif\");}\nRemark 不要在属性值与单位之间留有空格（如：\"margin-left: 20 px\" ），正确的写法是 \"margin-left: 20px\" 。\n\n内部样式表\n当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 <style> 标签在文档头部定义内部样式表，就像这样:\n\n<head>\n<style>\nhr {color:sienna;}\np {margin-left:20px;}\nbody {background-image:url(\"images/back40.gif\");}\n</style>\n</head>\n\n内联样式\n由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。\n\n要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：\n\n<p style=\"color:sienna;margin-left:20px\">这是一个段落。</p>\n\n多重样式\n如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。 \n\n例如，外部样式表拥有针对 h3 选择器的三个属性：\n\nh3\n{\n    color:red;\n    text-align:left;\n    font-size:8pt;\n}\n而内部样式表拥有针对 h3 选择器的两个属性：\n\nh3\n{\n    text-align:right;\n    font-size:20pt;\n}\n假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h3 得到的样式是：\n\ncolor:red;\ntext-align:right;\nfont-size:20pt;\n即颜色属性将被继承于外部样式表，而文字排列（text-alignment）和字体尺寸（font-size）会被内部样式表中的规则取代。\n\n多重样式优先级\n样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。\n\n一般情况下，优先级如下：\n\n内联样式）Inline style > （内部样式）Internal style sheet >（外部样式）External style sheet > 浏览器默认样式\n\n<head>\n    <!-- 外部样式 style.css -->\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"/>\n    <!-- 设置：h3{color:blue;} -->\n    <style type=\"text/css\">\n      /* 内部样式 */\n      h3{color:green;}\n    </style>\n</head>\n<body>\n    <h3>测试！</h3>\n</body>\n注意：如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888543989},"updatedAt":{"$$date":1598888665698},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"I3UL1UEajvfAb0fD"}
{"name":"HTML5 Audio(音频)","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\nHTML5 Audio(音频)\nHTML5 提供了播放音频文件的标准。\n\n互联网上的音频\n直到现在，仍然不存在一项旨在网页上播放音频的标准。\n\n今天，大多数音频是通过插件（比如 Flash）来播放的。然而，并非所有浏览器都拥有同样的插件。\n\nHTML5 规定了在网页上嵌入音频元素的标准，即使用 <audio> 元素。\n\n浏览器支持\nInternet ExplorerFirefoxOperaGoogle ChromeSafari\n\nInternet Explorer 9+, Firefox, Opera, Chrome, 和 Safari 都支持 <audio> 元素.\n\n注意: Internet Explorer 8 及更早IE版本不支持 <audio> 元素.\n\nHTML5 Audio - 如何工作\n如需在 HTML5 中播放音频，你需要使用以下代码：\n\n实例\n<audio controls>\n  <source src=\"horse.ogg\" type=\"audio/ogg\">\n  <source src=\"horse.mp3\" type=\"audio/mpeg\">\n您的浏览器不支持 audio 元素。\n</audio>\n\n尝试一下 »\ncontrol 属性供添加播放、暂停和音量控件。\n\n在<audio> 与 </audio> 之间你需要插入浏览器不支持的<audio>元素的提示文本 。\n\n<audio> 元素允许使用多个 <source> 元素. <source> 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件\n\n音频格式及浏览器支持\n目前, <audio>元素支持三种音频格式文件: MP3, Wav, 和 Ogg:\n\n浏览器\tMP3\tWav\tOgg\nInternet Explorer 9+\tYES\tNO\tNO\nChrome 6+\tYES\tYES\tYES\nFirefox 3.6+\tYES\tYES\tYES\nSafari 5+\tYES\tYES\tNO\nOpera 10+\tYES\tYES\tYES\n\n音频格式的MIME类型\nFormat\tMIME-type\nMP3\t    audio/mpeg\nOgg\t    audio/ogg\nWav\t    audio/wav\n\nHTML5 Audio 标签\n标签\t描述\n<audio>\t定义了声音内容\n<source>\t规定了多媒体资源, 可以是多个，在 <video> 与 <audio>标签中使用\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886967848},"updatedAt":{"$$date":1598887765531},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"IEQNihxgBf1dTa0d"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598975864002},"updatedAt":{"$$date":1598975864002},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"IHEUKtC3Hspqf9uw"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977490826},"updatedAt":{"$$date":1594977490826},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"IOuAhkO4PsIXapZy"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975867886},"updatedAt":{"$$date":1598975867886},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"IQhwM4AqUIi8kLHK"}
{"name":"轻课资源文档","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"轻课资源文档\n竞品账号\n斑马英语 15369871661 （彼得）单点登录，打电话要验证码\n叫叫阅读 微信登录 （自己下载领体验课）叫叫阅读如果想看年课，可以找“花生”扫码\n轻课信息\n应用信息\n• 应用名称：凯叔语文\n• 应用简介：面向3-8岁儿童的语文学习平台，通过体系化教学设计，实现儿童语文素养与思维品质的双提升。\n• 应用类型：教育培训/儿童早教\n工程项目信息\nAndroid\n• 签名：56B6A792F2B544B5137D48DBDB524C58\n• 包名：com.ks.lightlearn\n• URL scheme：kslightlearn://   \n• 支持： pad phone \niOS\n• 包名（Bundle ID）：com.ks.lightlearn\n• URL scheme：kslightlearn://\n• Universal Link：https://mlinkpangu.ksjgs.com/\n• APPID：1499051605\n• 下载链接：https://apps.apple.com/cn/app/id1499051605\n• 支持： pad phone\nAPI接口地址\nYAPI（金乌模块）\n设计稿\nUI设计稿（蓝湖）\n进入蓝湖团队（没有加入项目的小伙伴可以通过这个链接加入有效期到3月11号）\n切图\n📎切图（补课列表、课程表、课程详情、绘本故事、视频题）.zip（部分小图标）\n📎登录_我的订单切图.zip\n📎首页和商品详情页 切图.zip\n📎轻课-个人中心首页-切图.zip\n原型文档\nPRD原型文档\n友盟\nAndroid\n• APPKEY：\"5e4664fb0cafb24c060000c3\"\niOS\n• APPKEY：\"5e4665f9570df36c7d0001da\"\n极光\nAndroid&iOS（线上）\n• APPKEY：\"15819198d47f83d2b838b3a6\"\nAndroid&iOS（测试）\n• APPKEY：\"2c74ee14fa17dc922c986911\"\niOS Associated Domains\n• Test：applinks:sl2cof.jmlk.co\n• Release：applinks:sjivpt.jmlk.co\n智齿\nAndroid&iOS（线上）\n• APPKEY：待补充\n• ServicerH5URL：待补充\n腾讯智龄评测\nAppId,SecretID,SecretKey\n输入密码查看，不知道密码的请联系 阿凡提（徐海缘）\n此处为语雀加密文本，点击链接查看：https://kaishu.yuque.com/bu8pzp/qtpdtp/yx7gn7#1UbQj\niOS\n轻课智龄（英文）\n//1.初始化参数\nTAIOralEvaluationParam *param = [[TAIOralEvaluationParam alloc] init];\nparam.seoAppId = \"soe_1002371\";\n轻课智龄（中文）\n//1.初始化参数\nTAIOralEvaluationParam *param = [[TAIOralEvaluationParam alloc] init];\nparam.seoAppId = \"soe_1001526\";\nAndroid\n轻课智龄（英文）\n//1.初始化参数\nTAIOralEvaluationParam param = new TAIOralEvaluationParam();\nparam.seoAppId = \"soe_1002372\";\n \n轻课智龄（中文）\n//1.初始化参数\nTAIOralEvaluationParam param = new TAIOralEvaluationParam();\nparam.seoAppId = \"soe_1001527\";\n开发任务及人员\n轻课任务.xmind\nUI页面优先级（UI设计稿）\n轻课疑问（部分产品继续跟进，大部分解答完成）\n轻课疑问.xmind\n接口优先级\n• 登录注册（相关接口）\n• 下载（课中部分，资源包）方案\n• 首页\n• 单节课\n• 个人中心\n• 订单\n• 课程表\n• 全部课程"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598547163084},"updatedAt":{"$$date":1598547255345},"_id":"IRGAgIVHtmoNJw1I","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597404261508},"updatedAt":{"$$date":1597404261508},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"IU0zjrYEXqcv7lGq"}
{"name":"kotlin-Android Jetpack 使用入门  |  Android 开发者  |  Android Developers","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /jetpack/docs/getting-started\nAndroid Jetpack 使用入门  |  Android 开发者  |  Android Developers\n2-2 minutes\nJetpack 包含一系列 Android 库，它们都采用最佳做法并在 Android 应用中提供向后兼容性。\n\nJetpack 应用架构指南概述了构建 Android 应用时要考虑的最佳做法和推荐架构。\n\n下文介绍了如何开始使用 Jetpack 组件。\n\n在应用中使用 Jetpack 库\n所有 Jetpack 组件都可在 Google Maven 代码库中找到。\n\n打开项目的 build.gradle 文件并添加 google() 代码库，如下所示：\n\n    allprojects {\n        repositories {\n            google()\n            jcenter()\n        }\n    }\n    \n然后，您可以添加 Jetpack 组件（例如 LiveData 和 ViewModel 等架构组件），如下所示：\n\n    dependencies {\n        def lifecycle_version = \"2.2.0\"\n        implementation \"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version\"\n        implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version\"\n        ...\n    }\n    \n许多 Jetpack 库都提供 Android KTX 扩展，如上面的 lifecycle-livedata-ktx 和 lifecycle-viewmodel-ktx 所示。 KTX 扩展在基于 Java 的 API 基础上构建，充分利用了 Kotlin 特有的语言功能。\n\n如需了解新的 Jetpack 库版本，请查看版本页面。\n\n基于 Kotlin 以及基于 Java 的 API 参考页面适用于所有 Jetpack 库。\n\n利用 Jetpack\nJetpack 库可以单独使用，也可以组合使用，以满足应用的不同需求。\n\nWorkManager - 满足您的后台调度需求。\nRoom - 实现数据存储持久性。\nNavigation - 管理应用导航流程。\nCameraX - 满足相机应用需求。\n请参阅所有 Jetpack 库的概览。\nJetpack 库在 androidx 命名空间中发布。如果项目目前使用 Android 支持库，请阅读如何迁移到 androidx 命名空间。\n\n要详细了解如何使用 Jetpack，请查看以下页面：\n\nAndroid 架构组件\nJetpack 组件的完整列表\n其他资源\n在线培训\n使用 Kotlin 开发 Android 应用（Udacity 课程）\n示例代码\nSunflower 演示版应用使用许多不同的 Jetpack 组件来演示 Android 开发的最佳做法。\nCodelab\nAndroid Lifecycles\n带 View 的 Room\n视频\n组装您的 Jetpack"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597400498001},"updatedAt":{"$$date":1597400646562},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"IVORadKhMZf8PpnJ"}
{"name":"andr-创建 Fragment ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/basics/fragments/creating\n创建 Fragment  |  Android 开发者  |  Android Developers\n4-5 minutes\n您可以将 Fragment 视为 Activity 的模块化部分，它有自己的生命周期，接收自己的输入事件，并且可以在 Activity 运行期间添加或移除（有些类似于可以在不同 Activity 中重用的“子 Activity”）。本节课介绍如何使用支持库扩展 Fragment 类，以便您的应用与搭载低至 Android 1.6 的系统版本的设备保持兼容。\n\n您应该创建一个生命周期感知组件，而不是在 Fragment 的生命周期方法中设置依赖组件。生命周期感知组件可以处理 Fragment 历经整个生命周期时所需的任何设置或拆解工作。该组件随后可以在其他 Fragment 和 Activity 中重复使用以避免代码重复，并减少您在 Fragment/Activity 本身中需要执行的设置量。有关详情，请参阅使用生命周期感知组件处理生命周期。\n\n在开始本节课之前，您必须设置 Android 项目以使用支持库。如果您以前没有使用过支持库，请按照支持库设置文档设置项目以使用 v4 库。不过，您也可以通过使用 v7 appcompat 库在 Activity 中加入应用栏，该库与 Android 2.1（API 级别 7）兼容，并且还包含 Fragment API。\n\n如需详细了解如何实现 Fragment，请参阅 Fragment。您还可以通过浏览相关示例应用了解详情。\n\n创建 Fragment 类\n要创建 Fragment，请扩展 Fragment 类，然后替换关键生命周期方法以插入应用逻辑，创建方式类似于 Activity 类。\n\n创建 Fragment 时的一个区别是您必须使用 onCreateView() 回调定义布局。事实上，这是为了让 Fragment 运行所需的唯一回调。例如，下面是一个指定其自身布局的简单 Fragment：\n\n    import android.os.Bundle\n    import android.support.v4.app.Fragment\n    import android.view.LayoutInflater\n    import android.view.ViewGroupclass ArticleFragment : Fragment() {\n        override fun onCreateView(inflater: LayoutInflater, container: ViewGroup,\n                         savedInstanceState: Bundle?): View {\n            // Inflate the layout for this fragment\n            return inflater.inflate(R.layout.article_view, container, false)\n        }\n    }\n    \n    import android.os.Bundle;\n    import android.support.v4.app.Fragment;\n    import android.view.LayoutInflater;\n    import android.view.ViewGroup;public class ArticleFragment extends Fragment {\n        @Override\n        public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n            // Inflate the layout for this fragment\n            return inflater.inflate(R.layout.article_view, container, false);\n        }\n    }\n    \n和 Activity 一样，Fragment 也应实现其他生命周期回调，以便您能在为 Activity 添加或移除 Fragment 以及 Activity 在其生命周期状态之间转换时管理 Fragment 的状态。例如，在调用 Activity 的 onPause() 方法时，Activity 中的任何 Fragment 也会收到对 onPause() 的调用。\n\n如需详细了解 Fragment 生命周期和回调方法，请参阅 Fragment 开发者指南。\n\n使用 XML 向 Activity 添加 Fragment\n虽然 Fragment 是可重复使用的模块化界面组件，但 Fragment 类的每个实例都必须与父级 FragmentActivity 相关联。您可以通过在 Activity 布局 XML 文件中定义每个 Fragment 来实现这种关联。\n\n注意：FragmentActivity 是支持库中提供的特殊 Activity，用于处理早于 API 级别 11 的系统版本上的 Fragment。如果您支持的最低系统版本为 API 级别 11 或更高版本，那么您可以使用常规 Activity。\n\n下面是一个示例布局文件，该文件在设备屏幕被视为“大”（由目录名称中的 large 限定符指定）时向 Activity 添加两个 Fragment。\n\nres/layout-large/news_articles.xml\n\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:orientation=\"horizontal\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"><fragment android:name=\"com.example.android.fragments.HeadlinesFragment\"\n                  android:id=\"@+id/headlines_fragment\"\n                  android:layout_weight=\"1\"\n                  android:layout_width=\"0dp\"\n                  android:layout_height=\"match_parent\" /><fragment android:name=\"com.example.android.fragments.ArticleFragment\"\n                  android:id=\"@+id/article_fragment\"\n                  android:layout_weight=\"2\"\n                  android:layout_width=\"0dp\"\n                  android:layout_height=\"match_parent\" /></LinearLayout>\n    \n提示：如需详细了解如何针对不同屏幕尺寸创建布局，请参阅支持不同的屏幕尺寸。\n\n然后将布局应用到您的 Activity：\n\n    import android.os.Bundle\n    import android.support.v4.app.FragmentActivityclass MainActivity : FragmentActivity() {\n        override fun onCreate(savedInstanceState: Bundle?) {\n            super.onCreate(savedInstanceState)\n            setContentView(R.layout.news_articles)\n        }\n    }\n    \n    import android.os.Bundle;\n    import android.support.v4.app.FragmentActivity;public class MainActivity extends FragmentActivity {\n        @Override\n        public void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.news_articles);\n        }\n    }\n    \n如果您使用的是 v7 appcompat 库，那么 Activity 应扩展 AppCompatActivity，它是 FragmentActivity 的子类。有关详情，请阅读添加应用栏。\n\n注意：如果您通过在布局 XML 文件中定义 Fragment，将该 Fragment 添加到 Activity 布局中，您不能在运行时移除该 Fragment。如果您计划在用户互动期间更换 Fragment，则必须在 Activity 首次启动时就向其添加 Fragment，如构建灵活的界面中所示。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243443211},"updatedAt":{"$$date":1597243825295},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Iz9gEr41hm1VmvRS"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975685344},"updatedAt":{"$$date":1598975685344},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"JBJ1Tl3V8p6kFhjB"}
{"name":"kotlin-可见性修饰符 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/visibility-modifiers.html\n可见性修饰符 - Kotlin 语言中文站\n7-8 minutes\n改进翻译\n类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 可见性修饰符。 （getter 总是与属性有着相同的可见性。） 在 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public。 如果没有显式指定修饰符的话，默认可见性是 public。\n\n在本页可以学到这些修饰符如何应用到不同类型的声明作用域。\n\n函数、属性和类、对象和接口可以在顶层声明，即直接在包内：\n\n如果你不指定任何可见性修饰符，默认为 public，这意味着你的声明将随处可见；\n如果你声明为 private，它只会在声明它的文件内可见；\n如果你声明为 internal，它会在相同模块内随处可见；\nprotected 不适用于顶层声明。\n注意：要使用另一包中可见的顶层声明，仍需将其导入进来。\n\n例如:\n\n// 文件名：example.kt\npackage foo\n\nprivate fun foo() { …… } // 在 example.kt 内可见\n\npublic var bar: Int = 5 // 该属性随处可见\n    private set         // setter 只在 example.kt 内可见\n    \ninternal val baz = 6    // 相同模块内可见\n对于类内部声明的成员：\n\nprivate 意味着只在这个类内部（包含其所有成员）可见；\nprotected—— 和 private一样 + 在子类中可见。\ninternal —— 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员；\npublic —— 能见到类声明的任何客户端都可见其 public 成员。\n请注意在 Kotlin 中，外部类不能访问内部类的 private 成员。\n\n如果你覆盖一个 protected 成员并且没有显式指定其可见性，该成员还会是 protected 可见性。\n\n例子:\n\nopen class Outer {\n    private val a = 1\n    protected open val b = 2\n    internal val c = 3\n    val d = 4  // 默认 public\n    \n    protected class Nested {\n        public val e: Int = 5\n    }\n}\n\nclass Subclass : Outer() {\n    // a 不可见\n    // b、c、d 可见\n    // Nested 和 e 可见\n\n    override val b = 5   // “b”为 protected\n}\n\nclass Unrelated(o: Outer) {\n    // o.a、o.b 不可见\n    // o.c 和 o.d 可见（相同模块）\n    // Outer.Nested 不可见，Nested::e 也不可见\n}\n要指定一个类的的主构造函数的可见性，使用以下语法（注意你需要添加一个显式 constructor 关键字）：\n\nclass C private constructor(a: Int) { …… }\n这里的构造函数是私有的。默认情况下，所有构造函数都是 public，这实际上等于类可见的地方它就可见（即 一个 internal 类的构造函数只能在相同模块内可见).\n\n局部变量、函数和类不能有可见性修饰符。\n\n可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件：\n\n一个 IntelliJ IDEA 模块；\n一个 Maven 项目；\n一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）；\n一次 <kotlinc> Ant 任务执行所编译的一套文件。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306189325},"updatedAt":{"$$date":1597307958560},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"JkP5wIclnJCRY9C1"}
{"name":"kqapp-来源页","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\nasset \n\n    sourceConfig.properties\n\n\n#语文主页\nMainTabActivity=yw_home\n#全部课程页面\nCourseAllActivity=yw_all_courses\n#商品详情页\nProductDetailActivity=yw_product_detail\n#我的班主任\nMineTeacherActivity=yw_my_teacher\n#单节课列表\nCourseDetailActivity=yw_single_class_list\n#课程表\nCourseScheduleActivity=yw_timetable\n#支付付款弹窗页面\nKsPayActivity=yw_payment\n#登录模块：获取验证码页面\nLoginGetSmsCodeActivity=yw_login\n#登录模块：完善信息页面\nLoginImproveUserInfoActivity=yw_add_information\n#补课列表\nCourseMakeupListActivity=yw_repair\n\n\n\n\n\n\n\n在baseActivity中调用：\n\n\n    open fun getPageCode(): String? {\n        val simpleName = this::class.java.simpleName\n        return getKsStatisticPageName(simpleName)\n    }\n\n    open fun getKsStatisticPageName(simpleName: String): String? {\n        return ProPertiesUtils.getValue(simpleName)\n    }\n\n\n\n\n\n\n\n\nobject ProPertiesUtils {\n\n    private var properties: Properties = Properties()\n\n    init {\n        try {\n            properties?.let {\n                it.load(BaseApplication.instance.assets.open(\"sourceConfig.properties\"))\n            }\n        } catch (e: Exception) {\n        }\n    }\n\n    fun getValue(key: String): String {\n        if (properties != null && properties.containsKey(key)) {\n            return properties.getProperty(key)\n        }\n        return \"\"\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593264844},"updatedAt":{"$$date":1598597892210},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"JreE002mqPk56Avf"}
{"name":"html-HTML 布局","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\nHTML 布局\n网页布局对改善网站的外观非常重要。\n\n请慎重设计您的网页布局。\n\nExamples\n在线实例\n使用 <div> 元素的网页布局\n如何使用 <div> 元素添加布局。\n\n使用 <table> 元素的网页布局\n如何使用 <table> 元素添加布局。\n\n网站布局\n大多数网站会把内容安排到多个列中（就像杂志或报纸那样）。\n\n大多数网站可以使用 <div> 或者 <table> 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。\n\nlamp\t虽然我们可以使用HTML table标签来设计出漂亮的布局，但是table标签是不建议作为布局工具使用的 - 表格不是布局工具。\n\nHTML 布局 - 使用<div> 元素\ndiv 元素是用于分组 HTML 元素的块级元素。\n\n下面的例子使用五个 div 元素来创建多列布局：\n\n实例\n<!DOCTYPE html>\n<html>\n<head> \n<meta charset=\"utf-8\"> \n<title>菜鸟教程(runoob.com)</title> \n</head>\n<body>\n \n<div id=\"container\" style=\"width:500px\">\n \n<div id=\"header\" style=\"background-color:#FFA500;\">\n<h1 style=\"margin-bottom:0;\">主要的网页标题</h1></div>\n \n<div id=\"menu\" style=\"background-color:#FFD700;height:200px;width:100px;float:left;\">\n<b>菜单</b><br>\nHTML<br>\nCSS<br>\nJavaScript</div>\n \n<div id=\"content\" style=\"background-color:#EEEEEE;height:200px;width:400px;float:left;\">\n内容在这里</div>\n \n<div id=\"footer\" style=\"background-color:#FFA500;clear:both;text-align:center;\">\n版权 © runoob.com</div>\n \n</div>\n \n</body>\n</html>\n\n尝试一下 »\n上面的 HTML 代码会产生如下结果：\n\n\n\nHTML 布局 - 使用表格\n使用 HTML <table> 标签是创建布局的一种简单的方式。\n\n大多数站点可以使用 <div> 或者 <table> 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。\n\nlamp\t即使可以使用 HTML 表格来创建漂亮的布局，但设计表格的目的是呈现表格化数据 - 表格不是布局工具！\n下面的例子使用三行两列的表格 - 第一和最后一行使用 colspan 属性来横跨两列：\n\n实例\n<!DOCTYPE html>\n<html>\n<head> \n<meta charset=\"utf-8\"> \n<title>菜鸟教程(runoob.com)</title> \n</head>\n<body>\n \n<table width=\"500\" border=\"0\">\n<tr>\n<td colspan=\"2\" style=\"background-color:#FFA500;\">\n<h1>主要的网页标题</h1>\n</td>\n</tr>\n \n<tr>\n<td style=\"background-color:#FFD700;width:100px;\">\n<b>菜单</b><br>\nHTML<br>\nCSS<br>\nJavaScript\n</td>\n<td style=\"background-color:#eeeeee;height:200px;width:400px;\">\n内容在这里</td>\n</tr>\n \n<tr>\n<td colspan=\"2\" style=\"background-color:#FFA500;text-align:center;\">\n版权 © runoob.com</td>\n</tr>\n</table>\n \n</body>\n</html>\n\n尝试一下 »\n上面的 HTML 代码会产生以下结果：\n\n\n\n\nHTML 布局 - 有用的提示\nTip: 使用 CSS 最大的好处是，如果把 CSS 代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局。如需学习更多有关 CSS 的知识，请访问我们的CSS 教程。\n\nTip: 由于创建高级的布局非常耗时，使用模板是一个快速的选项。通过搜索引擎可以找到很多免费的网站模板（您可以使用这些预先构建好的网站布局，并优化它们）。\n\nHTML 布局标签\n标签\t描述\n<div>\t定义文档区块，块级(block-level)\n<span>\t定义 span，用来组合文档中的行内元素。\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886131968},"updatedAt":{"$$date":1598886597509},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"K3rMqVnvTJwXYzZ8"}
{"name":"HTML5 语义元素","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\nHTML5 语义元素\n语义= 意义\n\n语义元素 = 有意义的元素\n\n什么是语义元素?\n一个语义元素能够清楚的描述其意义给浏览器和开发者。\n\n无语义 元素实例: <div> 和 <span> - 无需考虑内容.\n\n语义元素实例: <form>, <table>, and <img> - 清楚的定义了它的内容.\n\n浏览器支持\nInternet ExplorerFirefoxOperaGoogle ChromeSafari\n\nInternet Explorer 9+, Firefox, Chrome, Safari 和 Opera 支持语义元素。\n\n注意: Internet Explorer 8 及更早版本不支持该元素。 但是文章底部提供了兼容的解决方法.\n\nHTML5中新的语义元素\n许多现有网站都包含以下HTML代码： <div id=\"nav\">, <div class=\"header\">, 或者 <div id=\"footer\">, 来指明导航链接, 头部, 以及尾部.\n\nHTML5 提供了新的语义元素来明确一个Web页面的不同部分:\n\n<header>\n<nav>\n<section>\n<article>\n<aside>\n<figcaption>\n<figure>\n<footer>\nHTML5 语义元素\nHTML5 <section> 元素\n<section> 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。\n\n根据W3C HTML5文档: section 包含了一组内容及其标题。\n\n实例\n<section>\n  <h1>WWF</h1>\n  <p>The World Wide Fund for Nature (WWF) is....</p>\n</section>\n\n尝试一下 »\n\nHTML5 <article> 元素\n<article> 标签定义独立的内容。.\n\n<article> 元素使用实例:\n\nForum post\nBlog post\nNews story\nComment\n实例\n<article>\n  <h1>Internet Explorer 9</h1>\n  <p>Windows Internet Explorer 9(缩写为 IE9 )在2011年3月14日21:00 发布。</p>\n</article>\n\n尝试一下 »\n\nHTML5 <nav> 元素\n<nav> 标签定义导航链接的部分。\n\n<nav> 元素用于定义页面的导航链接部分区域，但是，不是所有的链接都需要包含在 <nav> 元素中!\n\n实例\n<nav>\n    <a href=\"/html/\">HTML</a> |\n    <a href=\"/css/\">CSS</a> |\n    <a href=\"/js/\">JavaScript</a> |\n    <a href=\"/jquery/\">jQuery</a>\n</nav>\n\n尝试一下 »\n\nHTML5 <aside> 元素\n<aside> 标签定义页面主区域内容之外的内容（比如侧边栏）。\n\naside 标签的内容应与主区域的内容相关.\n\n实例\n<p>My family and I visited The Epcot center this summer.</p>\n \n<aside>\n  <h4>Epcot Center</h4>\n  <p>The Epcot Center is a theme park in Disney World, Florida.</p>\n</aside>\n\n尝试一下 »\n\nHTML5 <header> 元素\n<header>元素描述了文档的头部区域\n\n<header>元素主要用于定义内容的介绍展示区域.\n\n在页面中你可以使用多个<header> 元素.\n\n以下实例定义了文章的头部:\n\n实例\n<article>\n  <header>\n    <h1>Internet Explorer 9</h1>\n    <p><time pubdate datetime=\"2011-03-15\"></time></p>\n  </header>\n  <p>Windows Internet Explorer 9(缩写为 IE9 )是在2011年3月14日21:00发布的</p>\n</article>\n\n尝试一下 »\n\nHTML5 <footer> 元素\n<footer> 元素描述了文档的底部区域.\n\n<footer> 元素应该包含它的包含元素\n\n一个页脚通常包含文档的作者，著作权信息，链接的使用条款，联系信息等\n\n文档中你可以使用多个 <footer>元素.\n\n实例\n<footer>\n  <p>Posted by: Hege Refsnes</p>\n  <p><time pubdate datetime=\"2012-03-01\"></time></p>\n</footer>\n\n尝试一下 »\n\nHTML5 <figure> 和 <figcaption> 元素\n<figure>标签规定独立的流内容（图像、图表、照片、代码等等）。\n\n<figure> 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。\n\n<figcaption> 标签定义 <figure> 元素的标题.\n\n<figcaption>元素应该被置于 \"figure\" 元素的第一个或最后一个子元素的位置。\n\n实例\n<figure>\n  <img src=\"img_pulpit.jpg\" alt=\"The Pulpit Rock\" width=\"304\" height=\"228\">\n  <figcaption>Fig1. - The Pulpit Pock, Norway.</figcaption>\n</figure>\n\n尝试一下 »\n\n我们可以开始使用这些语义元素吗?\n以上的元素都是块元素(除了<figcaption>).\n\n为了让这些块及元素在所有版本的浏览器中生效，你需要在样式表文件中设置一下属性 (以下样式代码可以让旧版本浏览器支持本章介绍的块级元素):\n\nheader, section, footer, aside, nav, article, figure\n{\n    display: block;\n}\nInternet Explorer 8 及更早IE版本中的问题\nIE8 及更早IE版本无法在这些元素中渲染CSS效果，以至于你不能使用 <header>, <section>, <footer>, <aside>, <nav>, <article>, <figure>, 或者其他的HTML5 elements.\n\n解决办法: 你可以使用HTML5 Shiv Javascript脚本来解决IE的兼容问题。HTML5 Shiv下载地址：https://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\n\n下载后，将以下代码放入到网页中：\n\n<!--[if lt IE 9]>\n<script src=\"html5shiv.js\"></script>\n<![endif]-->\n以上代码在浏览器小于IE9版本时会加载html5shiv.js文件. 你必须将其放置于<head> 元素中，因为 IE浏览器需要在头部加载后渲染这些HTML5的新元素\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887691835},"updatedAt":{"$$date":1598887913109},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"K4Ou1mkhBJEQmnXz"}
{"name":"ad-ksautosizebybd","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    lintOptions {\n        abortOnError false\n        warning 'InvalidPackage'\n    }\n}\n\ndependencies {\n    compileOnly deps.androidx.app_compat\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nautosize\nexternal\ninternal\nunit\nutils\nActivityLifecycleCallbacksImpl\nAutoAdaptStrategy\nAutoSize\nAutoSizeCompat\nAutoSizeConfig\nDefaultAutoAdaptStrategy\nDisplayMetricsInfo\nFragmentLifecycleCallbacksImpl\nInitProvider\nonAdaptListener\nWrapperAutoAdaptStrategy\n\n\n\n\n\n\n\n\n\n\n\n\npublic class DefaultAutoAdaptStrategy implements AutoAdaptStrategy {\n    @Override\n    public void applyAdapt(Object target, Activity activity) {\n\n        //检查是否开启了外部三方库的适配模式, 只要不主动调用 ExternalAdaptManager 的方法, 下面的代码就不会执行\n        if (AutoSizeConfig.getInstance().getExternalAdaptManager().isRun()) {\n            if (AutoSizeConfig.getInstance().getExternalAdaptManager().isCancelAdapt(target.getClass())) {\n                LogUtils.w(String.format(Locale.ENGLISH, \"%s canceled the adaptation!\", target.getClass().getName()));\n                AutoSize.cancelAdapt(activity);\n                return;\n            } else {\n                ExternalAdaptInfo info = AutoSizeConfig.getInstance().getExternalAdaptManager()\n                        .getExternalAdaptInfoOfActivity(target.getClass());\n                if (info != null) {\n                    LogUtils.d(String.format(Locale.ENGLISH, \"%s used %s for adaptation!\", target.getClass().getName(), ExternalAdaptInfo.class.getName()));\n                    AutoSize.autoConvertDensityOfExternalAdaptInfo(activity, info);\n                    return;\n                }\n            }\n        }\n\n\n        //如果 target 实现 CustomAdapt 接口表示该 target 想自定义一些用于适配的参数, 从而改变最终的适配效果\n        if (target instanceof CustomAdapt) {\n            LogUtils.d(String.format(Locale.ENGLISH, \"%s implemented by %s!\", target.getClass().getName(), CustomAdapt.class.getName()));\n            AutoSize.autoConvertDensityOfCustomAdapt(activity, (CustomAdapt) target);\n        } else {\n\n            //如果 target 实现 CancelAdapt 接口表示放弃适配, 所有的适配效果都将失效\n            if (target instanceof CancelAdapt) {\n                LogUtils.w(String.format(Locale.ENGLISH, \"%s canceled the adaptation!\", target.getClass().getName()));\n                AutoSize.cancelAdapt(activity);\n                return;\n            }\n            LogUtils.d(String.format(Locale.ENGLISH, \"%s used the global configuration.\", target.getClass().getName()));\n            AutoSize.cancelAdapt(activity);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522798563},"updatedAt":{"$$date":1598523950823},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"K8eriWfMbzM5lCqw"}
{"name":"andr-视图绑定 ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/view-binding\n视图绑定  |  Android 开发者  |  Android Developers\n5-6 minutes\n通过视图绑定功能，您可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。\n\n在大多数情况下，视图绑定会替代 findViewById。\n\n设置说明\n视图绑定功能可按模块启用。要在某个模块中启用视图绑定，请将 viewBinding 元素添加到其 build.gradle 文件中，如下例所示：\n\nandroid {\n        ...\n        viewBinding {\n            enabled = true\n        }\n    }\n    \n如果您希望在生成绑定类时忽略某个布局文件，请将 tools:viewBindingIgnore=\"true\" 属性添加到相应布局文件的根视图中：\n\n<LinearLayout\n            ...\n            tools:viewBindingIgnore=\"true\" >\n        ...\n    </LinearLayout>\n    \n用法\n为某个模块启用视图绑定功能后，系统会为该模块中包含的每个 XML 布局文件生成一个绑定类。每个绑定类均包含对根视图以及具有 ID 的所有视图的引用。系统会通过以下方式生成绑定类的名称：将 XML 文件的名称转换为驼峰式大小写，并在末尾添加“Binding”一词。\n\n例如，假设某个布局文件的名称为 result_profile.xml：\n\n<LinearLayout ... >\n        <TextView android:id=\"@+id/name\" />\n        <ImageView android:cropToPadding=\"true\" />\n        <Button android:id=\"@+id/button\"\n            android:background=\"@drawable/rounded_button\" />\n    </LinearLayout>\n    \n所生成的绑定类的名称就为 ResultProfileBinding。此类具有两个字段：一个是名为 name 的 TextView，另一个是名为 button 的 Button。该布局中的 ImageView 没有 ID，因此绑定类中不存在对它的引用。\n\n每个绑定类还包含一个 getRoot() 方法，用于为相应布局文件的根视图提供直接引用。在此示例中，ResultProfileBinding 类中的 getRoot() 方法会返回 LinearLayout 根视图。\n\n以下几个部分介绍了生成的绑定类在 Activity 和 Fragment 中的使用。\n\n在 Activity 中使用视图绑定\n如需设置绑定类的实例以供 Activity 使用，请在 Activity 的 onCreate() 方法中执行以下步骤：\n\n调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Activity 使用。\n通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。\n将根视图传递到 setContentView()，使其成为屏幕上的活动视图。\n    private lateinit var binding: ResultProfileBindingoverride fun onCreate(savedInstanceState: Bundle) {\n        super.onCreate(savedInstanceState)\n        binding = ResultProfileBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n    }\n    \n    private ResultProfileBinding binding;@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        binding = ResultProfileBinding.inflate(getLayoutInflater());\n        View view = binding.getRoot();\n        setContentView(view);\n    }\n    \n您现在即可使用该绑定类的实例来引用任何视图：\n\n    binding.name.text = viewModel.name\n    binding.button.setOnClickListener { viewModel.userClicked() }\n    \n    binding.getName().setText(viewModel.getName());\n    binding.button.setOnClickListener(new View.OnClickListener() {\n        viewModel.userClicked()\n    });\n    \n在 Fragment 中使用视图绑定\n如需设置绑定类的实例以供 Fragment 使用，请在 Fragment 的 onCreateView() 方法中执行以下步骤：\n\n调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Fragment 使用。\n通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。\n从 onCreateView() 方法返回根视图，使其成为屏幕上的活动视图。\n    private var _binding: ResultProfileBinding? = null\n    // This property is only valid between onCreateView and\n    // onDestroyView.\n    private val binding get() = _binding!!override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        _binding = ResultProfileBinding.inflate(inflater, container, false)\n        val view = binding.root\n        return view\n    }override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n    \n    private ResultProfileBinding binding;@Override\n    public View onCreateView (LayoutInflater inflater,\n                              ViewGroup container,\n                              Bundle savedInstanceState) {\n        binding = ResultProfileBinding.inflate(inflater, container, false);\n        View view = binding.getRoot();\n        return view;\n    }@Override\n    public void onDestroyView() {\n        super.onDestroyView();\n        binding = null;\n    }\n    \n您现在即可使用该绑定类的实例来引用任何视图：\n\n    binding.name.text = viewModel.name\n    binding.button.setOnClickListener { viewModel.userClicked() }\n    \n    binding.getName().setText(viewModel.getName());\n    binding.button.setOnClickListener(new View.OnClickListener() {\n        viewModel.userClicked()\n    });\n    \n与 findViewById 的区别\n与使用 findViewById 相比，视图绑定具有一些很显著的优点：\n\nNull 安全：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 @Nullable 标记。\n类型安全：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。\n这些差异意味着布局和代码之间的不兼容将会导致构建在编译时（而非运行时）失败。\n\n与数据绑定的对比\n视图绑定和数据绑定均会生成可用于直接引用视图的绑定类。但是，视图绑定旨在处理更简单的用例，与数据绑定相比，具有以下优势：\n\n更快的编译速度：视图绑定不需要处理注释，因此编译时间更短。\n易于使用：视图绑定不需要特别标记的 XML 布局文件，因此在应用中采用速度更快。在模块中启用视图绑定后，它会自动应用于该模块的所有布局。\n反过来，与数据绑定相比，视图绑定也具有以下限制：\n\n视图绑定不支持布局变量或布局表达式，因此不能用于直接在 XML 布局文件中声明动态界面内容。\n视图绑定不支持双向数据绑定。\n考虑到这些因素，在某些情况下，最好在项目中同时使用视图绑定和数据绑定。您可以在需要高级功能的布局中使用数据绑定，而在不需要高级功能的布局中使用视图绑定。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243904043},"updatedAt":{"$$date":1597244134501},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"KPUAS4nZemP3SJuI"}
{"name":"py-返回多个值","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n函数可以返回多个值吗？答案是肯定的。\n\n比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：\n\nimport math\n\ndef move(x, y, step, angle=0):\n    nx = x + step * math.cos(angle)\n    ny = y - step * math.sin(angle)\n    return nx, ny\nimport math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。\n\n然后，我们就可以同时获得返回值：\n\n>>> x, y = move(100, 100, 60, math.pi / 6)\n>>> print(x, y)\n151.96152422706632 70.0\n但其实这只是一种假象，Python函数返回的仍然是单一值：\n\n>>> r = move(100, 100, 60, math.pi / 6)\n>>> print(r)\n(151.96152422706632, 70.0)\n原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973949442},"updatedAt":{"$$date":1594977447683},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"KSjojrgu1nvdM7Ed"}
{"name":"java-使用Future","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现Runnable接口，就可以让线程池去执行：\n\nclass Task implements Runnable {\n    public String result;\n\n    public void run() {\n        this.result = longTimeCalculation(); \n    }\n}\nRunnable接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个Callable接口，和Runnable接口比，它多了一个返回值：\n\nclass Task implements Callable<String> {\n    public String call() throws Exception {\n        return longTimeCalculation(); \n    }\n}\n并且Callable接口是一个泛型接口，可以返回指定类型的结果。\n\n现在的问题是，如何获得异步执行的结果？\n\n如果仔细看ExecutorService.submit()方法，可以看到，它返回了一个Future类型，一个Future类型的实例代表一个未来能获取结果的对象：\n\nExecutorService executor = Executors.newFixedThreadPool(4); \n// 定义任务:\nCallable<String> task = new Task();\n// 提交任务并获得Future:\nFuture<String> future = executor.submit(task);\n// 从Future获取异步执行返回的结果:\nString result = future.get(); // 可能阻塞\n当我们提交一个Callable任务后，我们会同时获得一个Future对象，然后，我们在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。在调用get()时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。\n\n一个Future<V>接口表示一个未来可能会返回的结果，它定义的方法有：\n\nget()：获取结果（可能会等待）\nget(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；\ncancel(boolean mayInterruptIfRunning)：取消当前任务；\nisDone()：判断任务是否已完成。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826930794},"updatedAt":{"$$date":1594973243287},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"KWeQgUlYEtqFyjFW"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598517300638},"updatedAt":{"$$date":1598517300638},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"KZNlVNue2B3k4kQ9"}
{"name":"CSS 按钮","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 按钮\n本章节我们为大家介绍使用 CSS 来制作按钮。\n\n基本按钮样式\n默认按钮 \n\nCSS 实例\n.button {\n    background-color: #4CAF50; /* Green */\n    border: none;\n    color: white;\n    padding: 15px 32px;\n    text-align: center;\n    text-decoration: none;\n    display: inline-block;\n    font-size: 16px;\n}\n\n尝试一下 »\n按钮颜色\n    \n我们可以使用 background-color 属性来设置按钮颜色:\n\nCSS 实例\n.button1 {background-color: #4CAF50;} /* Green */\n.button2 {background-color: #008CBA;} /* Blue */\n.button3 {background-color: #f44336;} /* Red */\n.button4 {background-color: #e7e7e7; color: black;} /* Gray */\n.button5 {background-color: #555555;} /* Black */\n\n尝试一下 »\n按钮大小\n    \n我们可以使用 font-size 属性来设置按钮大小:\n\nCSS 实例\n.button1 {font-size: 10px;}\n.button2 {font-size: 12px;}\n.button3 {font-size: 16px;}\n.button4 {font-size: 20px;}\n.button5 {font-size: 24px;}\n\n尝试一下 »\n圆角按钮\n    \n我们可以使用 border-radius 属性来设置圆角按钮:\n\nCSS 实例\n.button1 {border-radius: 2px;}\n.button2 {border-radius: 4px;}\n.button3 {border-radius: 8px;}\n.button4 {border-radius: 12px;}\n.button5 {border-radius: 50%;}\n\n尝试一下 »\n按钮边框颜色\n    \n我们可以使用 border 属性设置按钮边框颜色:\n\nCSS 实例\n.button1 {\n    background-color: white;\n    color: black;\n    border: 2px solid #4CAF50; /* Green */\n}\n...\n\n尝试一下 »\n鼠标悬停按钮\n    \n    \n我们可以使用 :hover 选择器来修改鼠标悬停在按钮上的样式。\n\n提示: 我们可以使用 transition-duration 属性来设置 \"hover\" 效果的速度:\n\nCSS 实例\n.button {\n    -webkit-transition-duration: 0.4s; /* Safari */\n    transition-duration: 0.4s;\n}\n\n.button:hover {\n    background-color: #4CAF50; /* Green */\n    color: white;\n}\n...\n\n尝试一下 »\n按钮阴影\n \n我们可以使用 box-shadow 属性来为按钮添加阴影:\n\nCSS 实例\n.button1 {\n    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);\n}\n\n.button2:hover {\n    box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24), 0 17px 50px 0 rgba(0,0,0,0.19);\n}\n\n尝试一下 »\n禁用按钮\n \n我们可以使用 opacity 属性为按钮添加透明度 (看起来类似 \"disabled\" 属性效果)。\n\n提示: 我们可以添加 cursor 属性并设置为 \"not-allowed\" 来设置一个禁用的图片:\n\nCSS 实例\n.disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n尝试一下 »\n按钮宽度\n\n \n默认情况下，按钮的大小有按钮上的文本内容决定( 根据文本内容匹配长度 )。 我们可以使用 width 属性来设置按钮的宽度:\n\n提示: 如果要设置固定宽度可以使用像素 (px) 为单位，如果要设置响应式的按钮可以设置为百分比。\n\nCSS 实例\n.button1 {width: 250px;}\n.button2 {width: 50%;}\n.button3 {width: 100%;}\n\n尝试一下 »\n按钮组\n\n移除外边距并添加 float:left 来设置按钮组:\n\nCSS 实例\n.button {\n    float: left;\n}\n\n尝试一下 »\n带边框按钮组\n\n我们可以使用 border 属性来设置带边框的按钮组:\n\nCSS 实例\n.button {\n    float: left;\n    border: 1px solid green\n}\n\n尝试一下 »\n按钮动画\nCSS 实例\n鼠标移动到按钮上后添加箭头标记:\n\nHover\n\n尝试一下 »\nCSS 实例\n点击时添加 \"波纹\" 效果:\n\nClick\n\n尝试一下 »\nCSS 实例\n点击时添加 \"压下\" 效果:\n\nClick\n  "}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974626570},"updatedAt":{"$$date":1598975422311},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"KgIf6n5pDOIZIWG3"}
{"name":"CSS3 动画","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 动画\nCSS3 动画\nCSS3 可以创建动画，它可以取代许多网页动画图像、Flash 动画和 JavaScript 实现的效果。\n\nCSS3\n动画\nCSS3 @keyframes 规则\n要创建 CSS3 动画，你需要了解 @keyframes 规则。\n\n@keyframes 规则是创建动画。\n\n@keyframes 规则内指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。\n\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器版本号。\n\n紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号。\n\n属性\t\t\t\t\t\n@keyframes\t43.0\n4.0 -webkit-\t10.0\t16.0\n5.0 -moz-\t9.0\n4.0 -webkit-\t30.0\n15.0 -webkit-\n12.0 -o-\nanimation\t43.0\n4.0 -webkit-\t10.0\t16.0\n5.0 -moz-\t9.0\n4.0 -webkit-\t30.0\n15.0 -webkit-\n12.0 -o-\nOperaSafariChromeFirefoxInternet Explorer\n实例\n@keyframes myfirst\n{\n    from {background: red;}\n    to {background: yellow;}\n}\n \n@-webkit-keyframes myfirst /* Safari 与 Chrome */\n{\n    from {background: red;}\n    to {background: yellow;}\n}\n\nCSS3 动画\n当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会有任何效果。\n\n指定至少这两个CSS3的动画属性绑定向一个选择器：\n\n规定动画的名称\n规定动画的时长\nOperaSafariChromeFirefoxInternet Explorer\n实例\n把 \"myfirst\" 动画捆绑到 div 元素，时长：5 秒：\n\ndiv\n{\n    animation: myfirst 5s;\n    -webkit-animation: myfirst 5s; /* Safari 与 Chrome */\n}\n\n尝试一下 »\n注意: 您必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。\n\nCSS3动画是什么？\n动画是使元素从一种样式逐渐变化为另一种样式的效果。\n\n您可以改变任意多的样式任意多的次数。\n\n请用百分比来规定变化发生的时间，或用关键词 \"from\" 和 \"to\"，等同于 0% 和 100%。\n\n0% 是动画的开始，100% 是动画的完成。\n\n为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变：\n\n@keyframes myfirst\n{\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n}\n \n@-webkit-keyframes myfirst /* Safari 与 Chrome */\n{\n    0%   {background: red;}\n    25%  {background: yellow;}\n    50%  {background: blue;}\n    100% {background: green;}\n}\n\n尝试一下 »\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n改变背景色和位置：\n\n@keyframes myfirst\n{\n    0%   {background: red; left:0px; top:0px;}\n    25%  {background: yellow; left:200px; top:0px;}\n    50%  {background: blue; left:200px; top:200px;}\n    75%  {background: green; left:0px; top:200px;}\n    100% {background: red; left:0px; top:0px;}\n}\n \n@-webkit-keyframes myfirst /* Safari 与 Chrome */\n{\n    0%   {background: red; left:0px; top:0px;}\n    25%  {background: yellow; left:200px; top:0px;}\n    50%  {background: blue; left:200px; top:200px;}\n    75%  {background: green; left:0px; top:200px;}\n    100% {background: red; left:0px; top:0px;}\n}\n\n尝试一下 »\n\nCSS3的动画属性\n下面的表格列出了 @keyframes 规则和所有动画属性：\n\n属性\t描述\tCSS\n@keyframes\t规定动画。\t3\nanimation\t所有动画属性的简写属性。\t3\nanimation-name\t规定 @keyframes 动画的名称。\t3\nanimation-duration\t规定动画完成一个周期所花费的秒或毫秒。默认是 0。\t3\nanimation-timing-function\t规定动画的速度曲线。默认是 \"ease\"。\t3\nanimation-fill-mode\t规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。\t3\nanimation-delay\t规定动画何时开始。默认是 0。\t3\nanimation-iteration-count\t规定动画被播放的次数。默认是 1。\t3\nanimation-direction\t规定动画是否在下一周期逆向地播放。默认是 \"normal\"。\t3\nanimation-play-state\t规定动画是否正在运行或暂停。默认是 \"running\"。\t3\n下面两个例子设置所有动画属性：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n运行myfirst动画，设置所有的属性：\n\ndiv\n{\n    animation-name: myfirst;\n    animation-duration: 5s;\n    animation-timing-function: linear;\n    animation-delay: 2s;\n    animation-iteration-count: infinite;\n    animation-direction: alternate;\n    animation-play-state: running;\n    /* Safari 与 Chrome: */\n    -webkit-animation-name: myfirst;\n    -webkit-animation-duration: 5s;\n    -webkit-animation-timing-function: linear;\n    -webkit-animation-delay: 2s;\n    -webkit-animation-iteration-count: infinite;\n    -webkit-animation-direction: alternate;\n    -webkit-animation-play-state: running;\n}\n\n尝试一下 »\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n与上面的动画相同，但是使用了简写的动画 animation 属性：\n\ndiv\n{\n    animation: myfirst 5s linear 2s infinite alternate;\n    /* Safari 与 Chrome: */\n    -webkit-animation: myfirst 5s linear 2s infinite alternate;\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974620758},"updatedAt":{"$$date":1598975002530},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Khj6uaVlpHjQyKSH"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975690014},"updatedAt":{"$$date":1598975690014},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Kt9YuMDGsW3lNg7M"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975702705},"updatedAt":{"$$date":1598975702705},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"KvE67U5NNMWT3HAB"}
{"name":"直播-","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"\n\n\n非摄像团队\n• 摄像头 X2 \n• 三脚架 X2\n• 声卡接口 X2\n• 路由器 X2\n• 电脑接口扩展坞 X1\n• 电脑网线转接头 X1\n• 宽带专线 X1  （20M宽带只提供推流使用）\n• 小蜜蜂音频采集器 X2 （准备5号充电电池）\n• 推流端电脑 X1 （建议使用OBS推流，只推一路，如多路需要服务器做转推）\n• 充电宝 X2 （暂无设备）\n• 主播手机 X2 （1个iOS，1个Android 高配）\n• 三网聚合 X1 （在户外直播有用，在保利威31及32层不稳定）\n• 流量卡 X3 （视直播位置信号强度及速度决定覆盖哪些，避免使用同一运营商，如户外场馆人员聚集时基站链接数有限，需协调户外的运营商基站车）\n• 电子大屏 X3 （互动，提词器，场外各需一台投屏电视）\n外部摄像团队\n 设备统一由专业摄像团队提供。\n\n\n\n\n\n\n\n\n\n\n\n\n OBS推流教程\n简介：\n直播中需要推流（将音视频上传给目标服务器），我们使用的推流软件为OBS，其中涉及到相关设置及使用会在后续的文档中进行介绍。\n软件下载：\nOBS软件下载地址：OBS中文网 （根据系统下载对应安装包）\n此文已MAC系统为例\n软件安装：\n1. 软件安装需要将MAC安全权限设置为允许任何来源     \n打开终端（MAC的命令行工具） -> 键入下方命令行 -> 输入电脑密码，回车即可。\nsudo spctl --master-disable\n打开系统偏好设置 » 安全性与隐私，若显示任何来源，大功告成。\n2. 如果扔提示安装包已损坏则使用下方命令（移除这个应用的安全隔离属性）\nxattr -r -d com.apple.quarantine /Applications/OBS.app\n3. 此时再打开OBS应用程序，不会提示错误了。（如扔无法打开可联系技术人员即可，任意技术伙伴都OK，看此文档就可以）\n软件预览：\n1. 红色区域：直播视频画面实时显示区\n2. 蓝色区域：直播操作及参数设置区（正式直播时，使用工作室模式）\n3. 绿色区域：场景设置区（场景设置如远近景，开场/结束垫片儿 + 场景切换过渡效果设置 ）\n4. 粉色区域：数据采集区（如双摄像头 + 开场/结束垫片儿 + 音效/音乐的数据来源）\n5. 黄色区域：音频监控区（来源及监控，如麦克风及视频音效是否过大，可进行调节/静音）\n软件设置：\n建议勾选图中两项，避免误操作。\n视频设置，直播竖屏我们选择如上设置，建议画布与输出分辨率相同，避免拖拽引起误操作。\n简单模式\n输出设置如上，使用简单模式。如特殊需要使用高级模式，进行各项参数的单独配置。\n高级模式\n在选择高级模式时，请确认您选择的每一项设置都知道其作用。可以联系技术支持小伙伴。\n场景设置：\n场景作用类似机位，信号切换。\n点击 + 新增场景，进行命名即可\n点击 - 删除场景\n来源设置：\n场景是强依赖来源的，场景是一个标题，场景下的内容需要来源设置来填充\n点击 + 新增来源\n简易的直播使用如下：\n1. 媒体源：如垫片儿（录好的视频），准备好的音乐（配合图像使用）\n2. 图像：静态图片显示\n3. 视频捕获设备：摄像头/摄像机\n4. 音频输入捕获：小蜜蜂音频采集器\n注意：根据不同的场景配置不同的来源，方便切换场景来控制，如果单独操作来源出错率高，也不够流畅。\n音效监听：\n当播放本地媒体源，连接导播台音视频信号源后无法听到音频，对于切换时机或效果无法得到反馈，此时需要对OBS混音器模块进行监听配置。\n1.点击对应来源项，在混音器中点击设置，点击高级音频属性（如图）\n2.在弹出框中选择 音频监听选项，监听并输出即可（如图）。\n注：如包含多个音频及视频源，则全需要单独进行此项配置。并在开播前做一次检查监听是否正常，直播设备是否也正常。\n滤镜设置：\n1. 由于摄像头不能调节色彩，使用OBS对音视频源可以添加滤镜。\n2. 右键左侧视频源，选择滤镜，添加对应滤镜如：色彩校正 进行数据调节。\n3. 音频可做噪声抑制，噪音阈值（需要现场调试）。\n动态比特率：\n1.OBS Studio 24引入了一项称为动态比特率的新功能。此功能可检测您的互联网连接何时受到限制，并会自动降低比特率以补偿而不是丢帧。一旦拥塞消失，它将自动将您的比特率提高到其原始值。\n工作室模式：\n真实直播中建议使用此模式，可以查看预览，如果非此模式点击场景则默认切换。\n在多场景下，左侧区域是预览区域，不会将数据传出。点击中间切换时候才会进行切换传出。\n红色区域：预览区\n绿色区域：输出区 （直播出去的音视频）\n数据推流：\n1. 各平台数据推流地址不同，格式不同，需要查看其推流文档在OBS软件中进行填写。\n2. 转播三方的部分直播到站内/合作渠道\n  首先创建媒体源，选择属性\n选择如下图所示，填充对方提供的拉流地址\n** 当源变为活动状态时重新启动播放 ** \n如果不勾选不出现断流没有问题，如果出现断流切换场景后无法进行正常的播放。\n建议勾选\n注意事项：\n1. OBS推流仅支持推一路流（Windows可装BiliBili开源的插件进行多路推流，但多路推流对网络上传带宽产生影响，例：一路3M多路则翻倍，不推荐此方式）\n2. 多路推流应使用服务器转推（例：推一路至目标服务器，从服务器转推多路到多平台）\n3. 各平台有各自的安全策略，推流地址会进行更换（如字节跳动如果断流超过规定时间，推流地址失效，需要重新获取，如保利威每30分钟会变更一次推流地址）\n4. OBS本身存在Bug，在开播前应重新启动电脑，在对OBS进行各项设置结束后，不在变更时候建议重启OBS软件。\n5. 如确认网络正常，但OBS推流上行数据较低不稳定时，快速断流重新推流（可能因OBS的Bug导致数据上行受限）\n6. 在直播前应使用测试直播间进行推流测试，确保OBS设置生效，无误。\n7. 推流电脑确认关闭占用内存及网速的软件（如：iCloud同步，百度网盘，迅雷，多开的浏览器等）\n8. 大型活动建议准备两台电脑设备，以备不时之需。\n9. 操作人员一定要对OBS软件及操作有熟练的操作，如遇突发情况可以快速做出判断。\n10. 电脑连接的转接口及线路确保进行胶带固定（避免移动设备，人员走动导致线路接触不良或断开）\n11. 在许多情况下，无线连接由于其不稳定的性质而可能引起问题。流媒体确实需要稳定的连接。通常，无线连接是可以的，但是如果您遇到问题，那么如果您使用的是无线连接，我们将很难帮助您诊断它，因为它会增加另一个变量。我们建议通过有线连接流式传输。\n12. 如果使用Windows系统，关闭杀毒软件，互联网安全软件，防火墙等。\n技术支持\n@徐海缘（阿凡提）(afanti-dgpfg)进行技术支持，过于细节的使用操作。\n@哈立敏(halimin)进行技术支持，参数设置相关问题。\n\n\n\n\n\n\n\n\n\n\n\n\n\n评论Demo文档（保利威提供）\nkai_demo 凯叔全部房间文本消息监控页文档\n附件：HTML页面，Demo  📎kai-demo_v1.0.9.zip\n使用说明：\n此Demo页面提供给直播期间，用户留言的信息，用于主播及时与用户产生互动，反馈。\n如有需要可找前端伙伴基于文件进行二次开发@张三。\n启动文件：\n1. 解压附件，查看解压后的文件夹及目录，打开index.html文件。\n2. 填写房间及显示频率（点我）开始监听消息。\n配置参数：\n2. 在kai_demo/js/index.js 文件下补充getTokenUrl变量（获取聊天室token接口）API接口地址。\n/**\n此接口是凯叔服务端提供，请联系直播服务接口提供相关人员@李晓东\n暂时此接口访问需要开启公司VPN\n*/\nvar getTokenUrl = 'http://tapi.kaishustory.com/live/get_chat_token';\n启动监听：\n3. 点击启动即可监测该频道的全部房间文本消息。\n   频道号：保利威后台的直播间号，非服务端的shareid。\n   消息频率：消息频率（每秒在监测页面中显示出的消息数，视窗口大小动态调整，调整后不需要重复点击启动按钮）。\n   消息频率举例：填写10/秒，如果此时刷屏消息达到200/秒，也只会取最新的10条显示，消息过多如果全部用于展示，则无法看清留言信息。\n   消息总数：收到消息的总数（没用于展示出的消息也会记录数据，可以体现出留言互动的活跃程度）\n   丢弃数：没用于展示的消息数（会被记录在数据库中，并非真的丢弃）\n 注：页面最多只显示1000条新消息（历史消息会隐藏只保留最新的1000条，依次滚动显示）。\n非特殊情况禁止使用：\n紧急条件下，若获取token接口出问题无法获取，则可以在index.js文件中补充appId、appSecret、userId并解开注释，并修改获取token的调用方法即可从前端处获取token。\n此处为语雀加密文本，点击链接查看：https://kaishu.yuque.com/bu8pzp/zzlol2/hiq24g#NVXkW\n\n\n\n\n\n\n\n\n\n评论大屏显示\n投屏设备\n小米电视：\n使用小米电视作为投屏设备，小米电视保持与电脑使用同一WIFI。\n笔记本电脑：\n使用笔记本电脑打开 下方文档中的HTML网页，并进行投屏操作。\n笔记本开机密码：KaiShu2099\n此处为语雀文档，点击链接查看：https://kaishu.yuque.com/bu8pzp/zzlol2/hsg3n6\n投屏方式\nHDMI线：\n可以使用HDMI线连接电视与笔记本电脑，电脑使用HDMI拓展坞。\n隔空投放：\n确保电脑与电视连接相同WIFI下，使用MAC中隔空投放功能。\n隔空投放功能，点击设置 - 显示器 - 在菜单栏中显示镜像选项 （如无法显示，重启电脑删除多余的工具栏）\n注意事项：\n电视音量：\n调整电视音量为静音。\n电视屏保：\n电视屏保调整为不自动。\n电脑自动息屏：\n调整电脑自动息屏 - 永不。\n电脑及电视WIFI：\n如使用隔空投放，切记将其它WIFI自动连接取消，避免跳网后两台设备WIFI不一致，无法投屏。\n投屏期间：\n投屏期间切记不断检查电视是否正常投屏，如电视不显示投屏内容及时进行修复，也告知现场工作人员可能出现的情况。\n\n\n\n\n\n\n\n\n\n\n技术测话术\n为了快速有效与技术伙伴进行沟通，列出话术如下\n为了现场快速定位问题，对于技术支持的小伙伴需要较为明确的话术指引，如果话术不统一，将增加沟通及排查的成本，无法快速有效的定位到问题。\n如下进行相关功能的描述，话术中带有关键词来快速与技术小伙伴们进行沟通。\n直播设备\n1. 评论大屏：投屏给主播显示的电视屏幕\n2. 数据大屏：用于显示直播中各项数据的屏幕\n3. 投屏电脑：连接评论大屏的电脑\n4. 直播电脑：直播中使用OBS软件进行推流及操作的电脑\n5. 音频输入采集卡：连接音频信号输入源的采集卡\n6. 网络输入转换器：连接网络输入的转换头，网线转USB\n7. 视频输入采集卡：连接视频引号输入源的采集卡\n8. 测试机Android/iOS : 一般为提供主持人截图使用\n9. 专线：用于提供给推流设备进行网络传输的专线\n10. 充电宝：直播超1小时则需准备充电宝对设备进行供电\n直播软件\n1. OBS：直播推流及操作的软件 -- 核心\n2. 投屏HTML：用于直播中显示所有评论的网页\n3. KMS：进行直播间控制的后台\n4. 保利威后台：进行直播间创建及角色管理的后台\nAPP软件功能\n1. 直播楼层：首页中展示的直播入口\n2. 直播间：直播中的房间，通过直播入口进入后的带有音视频的界面\n3. 购物袋：下方的购物袋，点击后显示商品列表\n4. IM互动区：左下方聊天信息的区域\n5. 小礼物：显示 X99（1-99） 两行的小礼物信息\n6. 大礼物：显示 动效的大礼物信息\n7. 清屏：向右侧滑动后屏蔽掉信息的功能\n8. 浮窗商品：右下角显示的浮窗用于抢购或讲解中的提示功能\n9. 贴纸：上方显示的长方形图片，用于进行相关介绍\n10. 商品详情页：通过购物袋进入/通过浮窗商品进入的页面\n卡！！！\n1. 音视频卡顿：音视频不同步，有追帧现象（类似快放）\n2. 音视频断流：出现黑屏现象\n3. IM互动区卡顿：IM互动消息不流畅，断断续续，不更新。\n4. 商品详情页卡顿：进入商品详情页后显示的慢，白屏时间长。\n5. 商品详情页报错：进入商品详情页后显示乱码，提示错误。\n6. 进入直播间卡顿：进入直播间时响应时间长，提示错误信息，无法快速进入直播间\n7. 购物袋卡顿：打开购物袋显示商品列表时访问较慢\n\n\n\n\n\n\n\n\n\n\n\n\n保利威后台操作\n进行一场直播\n当确认要进行一场直播后，在保利威后台需要做哪些工作呢？推流地址从哪里来？服务端及大数据的房间号怎样确认？房管如何进行评论的监控？房管的信息如何设置？直播后的录像从哪里找？\n保利威直播后台地址\n点我打开后台地址\n账号及密码请联系@阿凡提（徐海缘）\n为某场直播创建直播房间\n打开保利威后台，点击选项卡，选择云直播（如图）\n点击新建直播，如图进行填充及选择，点击确认创建，完成直播间的创建操作。\n1.直播间创建 XXX直播备用\n2.直播间创建 XXX备用房间\n注：直播前的彩排及测试，都在备用房间中完成。直播当天会使用正式房间进行直播。备用房间会在主房间发生不可恢复性异常时进行房间切换，是一套灾备方案。\n后续所讲到的配置，需要进行双份儿的配置。\n进行直播间的角色设置\n角色设置即房管设置。点击选择创建的直播间后进入配置页面，点击角色管理进行房管的设置。\n1. 新建子频道： 此项即新增房管，一个直播间默认有包含4-5个频道，需要进行修改。\n2. 助教链接：点击后进入的地址为房管进入的管理页面的地址，根据子频道号及频道密码登录。\n3. 设置：对房管的昵称及密码进行编辑，如：【鸡飞飞】-房管 \n4. 由于此平台包含其他功能，我们直播并非全部使用，请不要对未介绍的功能进行操作。\n    敏感词过滤\n直播中的文字是需要进行敏感词过滤的，需要批量导入违规词汇。\n最新版本违规词汇文件📎A1敏感词-2020.6.11.xls\n1. 点击直播监控，点击聊天严禁词\n2. 点击批量添加，导入最新版本的严禁词文件即可\n直播回放\n直播完成后，进行直播回放文件的相关文件导出。\n1. 直播回放暂存文件只保留180天，请及时导出备份或转存至回放列表\n总结\n进行如上的设置后，把对应的信息给到合作部门即可。\n1. 给技术部确认：保利威的房间号。\n2. 给业务部门：房管登录地址及房管账号密码。\n3. 给业务/运营：保存直播回放文件。\n4. 注意主房间/备用房间：不要粗心大意给错主房间/备用房间的信息。\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598542942079},"updatedAt":{"$$date":1598543582484},"_id":"Kyj5PvuCmDUpkDFe","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"接口","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"• dapi\n{\n    \"errcode\": 0,\n    \"result\": {\n        \"duration\": 192,\n        \"feetype\": \"01\",\n        \"shareTitle\": \"\",\n        \"downLoad\": false,\n        \"storyid\": 102608,\n        \"storyname\": \"凯叔·声律启蒙·二冬②\",\n        \"iconurl\": \"https://cdn.kaishuhezi.com/kstory/story/image/710e7c68-d31f-4d2e-920a-deba1dbc1a17.png\",\n        \"coverurl\": \"https://cdn.kaishuhezi.com/kstory/story/image/710e7c68-d31f-4d2e-920a-deba1dbc1a17.png\",\n        \"voiceurl\": \"\",\n        \"subhead\": \"明对暗，淡对浓，上智对中庸 。\",\n        \"isdownload\": false,\n        \"voicetype\": 1\n    }\n}\n• test\n{\n    \"errcode\": 0,\n    \"result\": {\n        \"duration\": 210,\n        \"feetype\": \"01\",\n        \"shareTitle\": \"\",\n        \"selectionId\": 0,\n        \"recommend\": 1,\n        \"labelNames\": [],\n        \"isTreat\": 1,\n        \"packPer\": 0,\n        \"storyid\": 107179,\n        \"storyname\": \"凯叔西游记：经典重现！\",\n        \"iconurl\": \"https://cdn.kaishuhezi.com/kstory/story/image/397007f7-bd78-4f98-bd66-686c4d9a9fe6.jpg\",\n        \"coverurl\": \"https://cdn.kaishuhezi.com/kstory/story/image/397007f7-bd78-4f98-bd66-686c4d9a9fe6.jpg\",\n        \"voiceurl\": \"http://tcdn.kaishustory.com/kstory/story/audio/f2134083-c01e-4911-981a-ddde84b9be79.mp3\",\n        \"timetext\": \"03:30\",\n        \"subhead\": \"听西游记，做自己的取经人\",\n        \"auditiduration\": 210,\n        \"isdownload\": true,\n        \"voicetype\": 1,\n        \"alreadybuy\": 0,\n        \"iscolumn\": 0,\n        \"commentcount\": 9\n    }\n}\n• release\n{\n    \"errcode\": 0,\n    \"result\": {\n        \"duration\": 192,\n        \"feetype\": \"01\",\n        \"shareTitle\": \"\",\n        \"selectionId\": 0,\n        \"recommend\": 1,\n        \"labelNames\": [],\n        \"isTreat\": 1,\n        \"packPer\": 0,\n        \"storyid\": 102608,\n        \"storyname\": \"凯叔·声律启蒙·二冬②\",\n        \"iconurl\": \"https://cdn.kaishuhezi.com/kstory/story/image/710e7c68-d31f-4d2e-920a-deba1dbc1a17.png\",\n        \"coverurl\": \"https://cdn.kaishuhezi.com/kstory/story/image/12e120a4-401a-4afd-9d40-bba4595ede91.png\",\n        \"voiceurl\": \"https://cdn.kaishuhezi.com/kstory/story/audio/c9f8a8de-ce79-4f36-b47d-8af5602efc66.mp3\",\n        \"timetext\": \"03:12\",\n        \"subhead\": \"明对暗，淡对浓，上智对中庸 。\",\n        \"auditiduration\": 1,\n        \"isdownload\": true,\n        \"voicetype\": 1,\n        \"alreadybuy\": 0,\n        \"iscolumn\": 0,\n        \"commentcount\": 420\n    }\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598546205263},"updatedAt":{"$$date":1598546821669},"_id":"L4xgo1VTLdnBNyPg","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-ks_frame_ui","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n// 上传插件\napply from: rootProject.file(\"./gradle/upload_local_maven.gradle\")\n//apply plugin: 'dagger.hilt.android.plugin'\n//apply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion BuildVersion.compile_sdk\n    buildToolsVersion BuildVersion.tool_version\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    buildFeatures.dataBinding = true\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n\n\n    //api ArchLifecycle.lifecycle_extensions\n    api ArchLifecycle.lifecycle_livedata_ktx\n    api ArchLifecycle.lifecycle_viewmodel_ktx\n    api ArchLifecycle.lifecycle_runtime_ktx\n    api ArchLifecycle.lifecycle_compiler\n    api ArchLifecycle.lifecycle_viewmodel\n    api ArchLifecycle.lifecycle_extensions\n\n    api Androidx.multidex\n    api Androidx.appcompat\n    api Androidx.core_ktx\n\n    api Kotlin.std_lib\n    api Kotlin.coroutines_core\n    api Kotlin.coroutines_android\n\n    api Ks_lib.lib_loading\n\n    api Deps.eventbus\n\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n    // 依赖注入 hilt\n//    implementation 'com.google.dagger:hilt-android:2.28-alpha'\n//    kapt 'com.google.dagger:hilt-android-compiler:2.28-alpha'\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBooleanLiveData\nByteLiveData\nDoubleLiveData\nEventLiveData\nFloatLiveData\nIntLiveData\nShortLiveData\nStringLiveData\nUnPeekLiveData\n\n\n\n\nclass BooleanLiveData : MutableLiveData<Boolean>() {\n\n    override fun getValue(): Boolean {\n        return super.getValue() ?: false\n    }\n}\n\n\n\n\n\n\n\n\n\n/**\n * 描述　:自定义的Boolean类型 MutableLiveData 提供了默认值，避免取值的时候还要判空\n */\nclass IntLiveData : MutableLiveData<Int>() {\n\n    override fun getValue(): Int {\n        return super.getValue() ?: 0\n    }\n}\n\n\n\n\n\n\n\nclass StringLiveData : MutableLiveData<String>() {\n\n    override fun getValue(): String {\n        return super.getValue() ?: \"\"\n    }\n\n}\n\n\n\n\n\n\n\n\n/**\n * 防止数据倒灌的LiveData\n */\n\nclass UnPeekLiveData<T> : MutableLiveData<T>() {\n    private var isCleaning = false\n    private var hasHandled = true\n    private var isDelaying = false\n    private val mTimer = Timer()\n    private var mTask: TimerTask? = null\n    private var DELAY_TO_CLEAR_EVENT = 1000\n\n    override fun observe(owner: LifecycleOwner, observer: Observer<in T>) {\n        super.observe(owner, Observer {\n            if (isCleaning) {\n                hasHandled = true\n                isDelaying = false\n                isCleaning = false\n                return@Observer\n            }\n            if (!hasHandled) {\n                hasHandled = true\n                isDelaying = true\n                observer.onChanged(it)\n            } else if (isDelaying) {\n                observer.onChanged(it)\n            }\n        })\n    }\n\n    override fun observeForever(observer: Observer<in T>) {\n        super.observeForever(Observer {\n            if (isCleaning) {\n                hasHandled = true\n                isDelaying = false\n                isCleaning = false\n                return@Observer\n            }\n            if (!hasHandled) {\n                hasHandled = true\n                isDelaying = true\n                observer.onChanged(it)\n            } else if (isDelaying) {\n                observer.onChanged(it)\n            }\n        })\n    }\n\n    /**\n     * 重写的 setValue 方法\n     * @param value\n     */\n    override fun setValue(value: T?) {\n        hasHandled = false\n        isDelaying = false\n        super.setValue(value)\n        mTask?.let {\n            it.cancel()\n            mTimer.purge()\n        }\n        mTask = object : TimerTask() {\n            override fun run() {\n                clear()\n            }\n        }\n        mTimer.schedule(mTask, DELAY_TO_CLEAR_EVENT.toLong())\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n *\n * @Author hailufeng\n * 邮箱：hilofeng@homail.com\n * 创建时间: 2020/8/19  2:20 PM\n * 用途\n * **************************************\n */\nabstract class BaseMvpActivity<P : IPresent> : BaseActivity(),IView {\n    private val p:P by lazy {\n     getPresent() as P\n    }\n    abstract fun getPresent(): P\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        p.onCreate()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        p.onPause()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        p.onResume()\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        p.onDestroy()\n    }\n\n\n\n\n    override fun showEmpty(info: String) {\n\n    }\n\n\n}\n\n\n\n\n\n\n\n    private fun clear() {\n        hasHandled = true\n        isDelaying = false\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n *\n * @Author hailufeng\n * 邮箱：hilofeng@homail.com\n * 创建时间: 2020/8/19  2:16 PM\n * 用途\n * **************************************\n */\ninterface IView  {\n    /**展示Loading*/\n    fun showLoading()\n    fun showEmpty(info:String)\n    fun showError(info:String)\n}\n\n\n\n\n\n\n\n/**\n *\n * @Author hailufeng\n * 邮箱：hilofeng@homail.com\n * 创建时间: 2020/8/19  2:18 PM\n * 用途\n * **************************************\n */\ninterface IPresent {\n    fun onCreate()\n    fun onPause()\n    fun onResume()\n    fun onDestroy()\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * ViewModel base from 轻课\n */\nopen class BaseViewModel : ViewModel() {\n\n    open class BaseUiModel<T>(\n            var showLoading: Boolean = false,\n            var showError: String? = null,\n            var showSuccess: T? = null,\n            var showEnd: Boolean = false, // 加载更多\n            var isRefresh: Boolean = false // 刷新\n\n    )\n\n    val mException: MutableLiveData<Throwable> = MutableLiveData()\n\n    suspend fun runOnUI(block: () -> Unit) {\n        withContext(Dispatchers.Main) {\n            block()\n        }\n    }\n\n    private fun launchOnUI(block: suspend CoroutineScope.() -> Unit) {\n\n        viewModelScope.launch(Dispatchers.Main) { block() }\n\n    }\n\n    fun <T> launchOnIO(block: suspend CoroutineScope.() -> T) {\n        viewModelScope.launch(Dispatchers.IO) {\n            block()\n        }\n    }\n\n    fun launch(tryBlock: suspend CoroutineScope.() -> Unit) {\n        launchOnUI {\n            tryCatch(tryBlock, {}, {}, true)\n        }\n    }\n\n\n    fun launchOnUITryCatch(tryBlock: suspend CoroutineScope.() -> Unit,\n                           catchBlock: suspend CoroutineScope.(Throwable) -> Unit,\n                           finallyBlock: suspend CoroutineScope.() -> Unit,\n                           handleCancellationExceptionManually: Boolean\n    ) {\n        launchOnUI {\n            tryCatch(tryBlock, catchBlock, finallyBlock, handleCancellationExceptionManually)\n        }\n    }\n\n    fun launchOnUITryCatch(tryBlock: suspend CoroutineScope.() -> Unit,\n                           handleCancellationExceptionManually: Boolean = false\n    ) {\n        launchOnUI {\n            tryCatch(tryBlock, {}, {}, handleCancellationExceptionManually)\n        }\n    }\n\n\n    private suspend fun tryCatch(\n            tryBlock: suspend CoroutineScope.() -> Unit,\n            catchBlock: suspend CoroutineScope.(Throwable) -> Unit,\n            finallyBlock: suspend CoroutineScope.() -> Unit,\n            handleCancellationExceptionManually: Boolean = false) {\n        coroutineScope {\n            try {\n                tryBlock()\n            } catch (e: Throwable) {\n                if (e !is CancellationException || handleCancellationExceptionManually) {\n                    mException.value = e\n                    catchBlock(e)\n                } else {\n                    throw e\n                }\n            } finally {\n                finallyBlock()\n            }\n        }\n    }\n\n    private var timeJob: Job? = null\n\n    /** 倒计时*/\n    fun timeDown(seconds: Int, action: () -> Unit) {\n        timeJob?.cancel()\n        launch {\n            timeJob = launch {\n\n                flow {\n                    for (i in 0..seconds) {\n                        delay(1000)\n                        emit(i)\n                    }\n                }.collect { time ->\n\n                    if (time == seconds) {\n                        action()\n                    }\n                }\n            }\n        }\n    }\n\n    /** 取消倒计时*/\n    fun cancelTimer() = timeJob?.cancel()\n}\n\n\n\n\n\n\n\n\nabstract class BaseVMActivity<VM : ViewModel>(useBinding: Boolean = false) : BaseActivity() {\n\n\n\n\n    override fun setLayoutView() {\n        startObserve()\n        if (useBinding()) {\n            mBinding = DataBindingUtil.setContentView<ViewDataBinding>(this, getLayoutResId())\n            mBinding.lifecycleOwner =this\n        } else setContentView(getLayoutResId())\n    }\n\n    protected lateinit var mBinding: ViewDataBinding\n\n    /**\n     * 数据金鼎绑定\n     */\n    abstract fun startObserve()\n\n    /**\n     * 是否使用 DataBing 数据绑定\n     * @return true 使用 false 不使用\n     *\n     */\n    abstract fun useBinding():Boolean\n\n    @LayoutRes abstract fun getLayoutResId(): Int\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nabstract class BaseVMFragment<VM : ViewModel> : BaseFragment() {\n    val liveData : MutableLiveData<String> = MutableLiveData()\n    protected lateinit var mBinding: ViewDataBinding\n\n    lateinit var mRootView:View\n    protected lateinit var mViewModel: VM\n\n    private val loadingLayout: LoadingLayout by lazy {\n\n        LoadingLayout.wrap(wrapView()).apply {\n            setEmpty(emptyLayoutId())\n            setLoading(loadingLayoutId())\n            mErrorResId = errorLayoutId()\n            setRetryListener(View.OnClickListener { onRetry() })\n\n     }\n\n    }\n\n    /**\n     * 是否使用LoadingLayout\n     * @return true 使用 ，false 不使用 ，有些页面不需要显示loading、error 等状态\n     * 无需添加，建议 返回false ，较少view渲染\n     */\n    abstract fun isUseLoadingLayout(): Boolean\n\n\n    @LayoutRes abstract fun errorLayoutId(): Int\n\n    /**\n     * 返回错误页布局\n     */\n    @DrawableRes abstract fun getErrorRes(): Int\n\n    /**\n     *\n     * 获取loading layout ，\n     * app 层 根据自身UI 定制\n     *\n     */\n    @LayoutRes abstract fun loadingLayoutId(): Int\n    /**\n     *\n     * 获取 空状态 layout ，\n     * app 层 根据自身UI 定制\n     *\n     */\n    @LayoutRes abstract fun emptyLayoutId(): Int\n\n    /**\n     * 显示Empty 附带错误 drawable\n     * @param emptyDrawableRes 空白图片\n     */\n    fun showEmpty(@DrawableRes emptyDrawableRes:Int ){\n        loadingLayout.setEmptyImage(emptyDrawableRes)\n        loadingLayout.showEmpty()\n    }\n\n\n    /**\n     * 设置错误页错误切图\n     *\n     */\n    fun setErrorDrawable(@DrawableRes errorId:Int){\n        loadingLayout.setErrorImage(errorId)\n    }\n\n    /**\n     * 设置空白页图片\n     */\n    fun setEmptyDrawable(@DrawableRes emptyRes:Int){\n        loadingLayout.setEmptyImage(emptyRes)\n    }\n\n\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n        return if (isUseBinding()) {\n            mBinding = DataBindingUtil.inflate(inflater, getLayoutResId(), container, false)\n            mRootView = mBinding.root\n            mRootView\n        } else{\n            mRootView = inflater.inflate(getLayoutResId(), container, false)\n            mRootView\n        }\n    }\n\n    /**\n     * 是否使用数据绑定\n     * @return true 使用 false 不使用\n     */\n    abstract fun isUseBinding(): Boolean\n\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        mViewModel = initViewModle()\n        if(isMonitNetworkChange()){\n            //使用\n            NetWorkStateManager.instance.mNetworkStateLiveData.observe(this, Observer {\n                onNetChange(it)\n            })\n        }\n        initView()\n        initData()\n        startObserve()\n\n    }\n\n\n\n\n    /**\n     * 返回初始化 ViewModel对象\n     * @return VM\n     */\n    abstract fun initViewModle(): VM\n    abstract fun getLayoutResId(): Int\n    abstract fun initView()\n    abstract fun initData()\n    abstract fun startObserve()\n    open fun wrapView(): View? {\n        return (activity?.findViewById<ViewGroup>(android.R.id.content))?.getChildAt(0)\n    }\n\n    /**\n     *\n     */\n    fun showLoading() {\n        loadingLayout.showLoading()\n    }\n\n    fun dismissLoading() {\n        loadingLayout.showContent()\n    }\n\n    fun showError() {\n        loadingLayout.showError()\n    }\n\n    fun showEmpty() {\n        loadingLayout.showEmpty()\n    }\n\n    /**\n     * 无数据时或者网络错误 时，重试\n     */\n    open fun onRetry() {\n\n    }\n\n    fun setEmptyView(@DrawableRes imgResId: Int,text:String) {\n        loadingLayout.setEmptyImage(imgResId)\n        loadingLayout.setEmptyText(text)\n    }\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nabstract class BaseVMFragmentWithCoroutineScope<VM : ViewModel>(val useBinding: Boolean = false) : Fragment(), CoroutineScope by MainScope() {\n\n    protected lateinit var mBinding: ViewDataBinding\n\n\n\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n        return if (useBinding) {\n            mBinding = DataBindingUtil.inflate(inflater, getLayoutResId(), container, false)\n            mBinding.root\n        } else\n            inflater.inflate(getLayoutResId(), container, false)\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        initView()\n        initData()\n        startObserve()\n        super.onViewCreated(view, savedInstanceState)\n    }\n\n    abstract fun getLayoutResId(): Int\n    abstract fun initView()\n    abstract fun initData()\n    abstract fun startObserve()\n\n    override fun onDestroy() {\n        super.onDestroy()\n        cancel()\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass NetStateReceiver : BroadcastReceiver() {\n    var hasInit = false\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent?.action == ConnectivityManager.CONNECTIVITY_ACTION) {\n            if(!hasInit){\n                if (!NetWorkUtil.isNetworkAvailable(context)) {\n                    //收到没有网络时判断之前的值是不是有网络，如果有网络才提示通知 ，防止重复通知\n                    NetWorkStateManager.instance.mNetworkStateLiveData.value?.let {\n                        if(it.isSuccess){\n                            //没网\n                            NetWorkStateManager.instance.mNetworkStateLiveData.postValue(NetState(isSuccess = false))\n                        }\n                        return\n                    }\n                    NetWorkStateManager.instance.mNetworkStateLiveData.postValue(NetState(isSuccess = false))\n                }else{\n                    //收到有网络时判断之前的值是不是没有网络，如果没有网络才提示通知 ，防止重复通知\n                    NetWorkStateManager.instance.mNetworkStateLiveData.value?.let {\n                        if(!it.isSuccess){\n                            //有网络了\n                            NetWorkStateManager.instance.mNetworkStateLiveData.postValue(NetState(isSuccess = true))\n                        }\n                        return\n                    }\n                    NetWorkStateManager.instance.mNetworkStateLiveData.postValue(NetState(isSuccess = true))\n                }\n            }\n            hasInit = false\n        }\n    }\n}\n\n\n\n\n\n\n\nframe\nbase\nActivityLifeCallback\nActivityStackManager\nBaseActivity\nBaseActivityWithCoroutineScope\nBaseApplication\nBaseFragment\nBaseFragmentActivity\nBaseFragmentWithCoroutineScope\nBaseSwipActivity\nExceptionHandler\nProcessLifeObserver\nlivedata\nBooleanLiveData\nByteLiveData\nDoubleLiveData\nEventLiveData\nFloatLiveData\nIntLiveData\nShortLiveData\nStringLiveData\nUnPeekLiveData\nmvp\nBaseMvpActivity\nIPresent\nIView\nmvvm\nBaseViewModel\nBaseVMActivity\nBaseVMFragment\nBaseVMFragmentWithCoroutineScope\nnet\nNetState\nNetStateReceiver\nNetWorkStateManager\nNetWorkUtil\nutil\nAppUtils\n\n\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539547032},"updatedAt":{"$$date":1598541455640},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"LLCJYiAnirafggxU"}
{"name":"html-HTML 段落","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\nHTML 段落\nHTML 可以将文档分割为若干段落。\n\nHTML 段落\n段落是通过 <p> 标签定义的。\n\n实例\n<p>这是一个段落 </p>\n<p>这是另一个段落</p>\n\n尝试一下 »\n注意：浏览器会自动地在段落的前后添加空行。（</p> 是块级元素）\n\n不要忘记结束标签\n即使忘了使用结束标签，大多数浏览器也会正确地将 HTML 显示出来：\n\n实例\n<p>这是一个段落\n<p>这是另一个段落\n\n尝试一下 »\n上面的例子在大多数浏览器中都没问题，但不要依赖这种做法。忘记使用结束标签会产生意想不到的结果和错误。\n\n注释: 在未来的 HTML 版本中，不允许省略结束标签。\n\nHTML 折行\n如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 <br> 标签：\n\n实例\n<p>这个<br>段落<br>演示了分行的效果</p>\n\n尝试一下 »\n<br /> 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。\n\nHTML 输出- 使用提醒\n我们无法确定 HTML 被显示的确切效果。屏幕的大小，以及对窗口的调整都可能导致不同的结果。\n\n对于 HTML，您无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。\n\n当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。\n\n尝试一下\n\n（这个例子演示了一些 HTML 格式化方面的问题）\n\nExamples\n本站实例\nHTML 段落\n如何在浏览器中显示 HTML 段落。\n\n换行\n在 HTML 文档中使用换行。\n\n在 HTML 代码中的排版一首唐诗\n浏览器在显示 HTML 时，会省略源代码中多余的空白字符（空格或回车等）。\n\n更多实例\n更多段落\n段落的默认行为。\n\nHTML 标签参考手册\n菜鸟教程的标签参考手册提供了有关 HTML 元素及其属性的更多信息。\n\n标签\t描述\n<p>\t定义一个段落\n<br>\t插入单个折行（换行）\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885697448},"updatedAt":{"$$date":1598886052882},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"LWQ5ePsFIIZsykyu"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975697161},"updatedAt":{"$$date":1598975697161},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"LWk8e0EXbE4MzvwO"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973275877},"updatedAt":{"$$date":1594973275877},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"LsAWWBEv1HzFhhol"}
{"name":"kotlin-取单个元素 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-elements.html\n取单个元素 - Kotlin 语言中文站\n12-15 minutes\n改进翻译\nKotlin 集合提供了一套从集合中检索单个元素的函数。 此页面描述的函数适用于 list 和 set。\n\n正如 list 的定义所言，list 是有序集合。 因此，list 中的每个元素都有其位置可供你引用。 除了此页面上描述的函数外，list 还提供了更广泛的一套方法去按索引检索和搜索元素。 有关更多详细信息，请参见 List 相关操作。\n\n反过来，从定义来看，set 并不是有序集合。 但是，Kotlin 中的 Set 按某些顺序存储元素。 这些可以是插入顺序（在 LinkedHashSet 中）、自然排序顺序（在 SortedSet 中）或者其他顺序。 一组元素的顺序也可以是未知的。 在这种情况下，元素仍会以某种顺序排序，因此，依赖元素位置的函数仍会返回其结果。 但是，除非调用者知道所使用的 Set 的具体实现，否则这些结果对于调用者是不可预测的。\n\n为了检索特定位置的元素，有一个函数 elementAt()。 用一个整数作为参数来调用它，你会得到给定位置的集合元素。 第一个元素的位置是 0，最后一个元素的位置是 (size - 1)。\n\nelementAt() 对于不提供索引访问或非静态已知提供索引访问的集合很有用。 在使用 List 的情况下，使用索引访问操作符 （get() 或 []）更为习惯。\n\nfun main() {\n//sampleStart\n    val numbers = linkedSetOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    println(numbers.elementAt(3))    \n\n    val numbersSortedSet = sortedSetOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbersSortedSet.elementAt(0)) // 元素以升序存储\n//sampleEnd\n}\n还有一些有用的别名来检索集合的第一个和最后一个元素：first() 和 last()。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    println(numbers.first())    \n    println(numbers.last())    \n//sampleEnd\n}\n为了避免在检索位置不存在的元素时出现异常，请使用 elementAt() 的安全变体：\n\n当指定位置超出集合范围时，elementAtOrNull() 返回 null。\nelementAtOrElse() 还接受一个 lambda 表达式，该表达式能将一个 Int 参数映射为一个集合元素类型的实例。 当使用一个越界位置来调用时，elementAtOrElse() 返回对给定值调用该 lambda 表达式的结果。\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    println(numbers.elementAtOrNull(5))\n    println(numbers.elementAtOrElse(5) { index -> \"The value for index $index is undefined\"})\n//sampleEnd\n}\n函数 first() 和 last() 还可以让你在集合中搜索与给定谓词匹配的元素。 当你使用测试集合元素的谓词调用 first() 时，你会得到对其调用谓词产生 true 的第一个元素。 反过来，带有一个谓词的 last() 返回与其匹配的最后一个元素。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.first { it.length > 3 })\n    println(numbers.last { it.startsWith(\"f\") })\n//sampleEnd\n}\n如果没有元素与谓词匹配，两个函数都会抛异常。 为了避免它们，请改用 firstOrNull() 和 lastOrNull()：如果找不到匹配的元素，它们将返回 null。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.firstOrNull { it.length > 6 })\n//sampleEnd\n}\n或者，如果别名更适合你的情况，那么可以使用别名：\n\n使用 find() 代替 firstOrNull()\n使用 findLast() 代替 lastOrNull()\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3, 4)\n    println(numbers.find { it % 2 == 0 })\n    println(numbers.findLast { it % 2 == 0 })\n//sampleEnd\n}\n如果需要检索集合的一个随机元素，那么请调用 random() 函数。 你可以不带参数或者使用一个 Random 对象作为随机源来调用它。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3, 4)\n    println(numbers.random())\n//sampleEnd\n}\n如需检查集合中某个元素的存在，可以使用 contains() 函数。 如果存在一个集合元素等于（equals()）函数参数，那么它返回 true。 你可以使用 in 关键字以操作符的形式调用 contains()。\n\n如需一次检查多个实例的存在，可以使用这些实例的集合作为参数调用 containsAll()。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.contains(\"four\"))\n    println(\"zero\" in numbers)\n    \n    println(numbers.containsAll(listOf(\"four\", \"two\")))\n    println(numbers.containsAll(listOf(\"one\", \"zero\")))\n//sampleEnd\n}\n此外，你可以通过调用 isEmpty() 和 isNotEmpty() 来检查集合中是否包含任何元素。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.isEmpty())\n    println(numbers.isNotEmpty())\n    \n    val empty = emptyList<String>()\n    println(empty.isEmpty())\n    println(empty.isNotEmpty())\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382132706},"updatedAt":{"$$date":1597384375652},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"M2GufjtgNH0MywFo"}
{"name":"py-常量","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：\n\nPI = 3.14159265359\n但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。\n\n最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：\n\n>>> 10 / 3\n3.3333333333333335\n/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：\n\n>>> 9 / 3\n3.0\n还有一种除法是//，称为地板除，两个整数的除法仍然是整数：\n\n>>> 10 // 3\n3\n你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。\n\n因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：\n\n>>> 10 % 3\n1\n无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973929128},"updatedAt":{"$$date":1594974325253},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"MAh0TRvV3v6SFlEB"}
{"name":"kqapp-数盟id","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\nclass MiitHelper(private val _listener: AppIdsUpdater) : IIdentifierListener {\n\n\n    fun getDeviceIds(cxt: Context) {\n        val nres = CallFromReflect(cxt)\n        if (nres == ErrorCode.INIT_ERROR_DEVICE_NOSUPPORT) {//不支持的设备\n            DeviceUtils.isSupportMitt = false\n        } else if (nres == ErrorCode.INIT_ERROR_LOAD_CONFIGFILE) {//加载配置文件出错\n            DeviceUtils.isSupportMitt = false\n        } else if (nres == ErrorCode.INIT_ERROR_MANUFACTURER_NOSUPPORT) {//不支持的设备厂商\n            DeviceUtils.isSupportMitt = false\n        } else if (nres == ErrorCode.INIT_ERROR_RESULT_DELAY) {//获取接口是异步的，结果会在回调中返回，回调执行的回调可能在工作线程\n            DeviceUtils.isSupportMitt = true\n        } else if (nres == ErrorCode.INIT_HELPER_CALL_ERROR) {//反射调用出错\n            DeviceUtils.isSupportMitt = false\n        }\n    }\n\n\n    /*\n     * 通过反射调用，解决android 9以后的类加载升级，导至找不到so中的方法\n     *\n     * */\n    private fun CallFromReflect(cxt: Context): Int {\n        return MdidSdkHelper.InitSdk(cxt, true, this)\n    }\n\n    override fun OnSupport(isSupport: Boolean, _supplier: IdSupplier?) {\n        DeviceUtils.isSupportMitt = isSupport\n        _supplier?.let {\n            _listener.OnIdsAvalid(_supplier.oaid, _supplier.aaid)\n        }\n\n    }\n\n    interface AppIdsUpdater {\n        fun OnIdsAvalid(oaid: String, aaid: String)\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@Route(path = RouterPath.Home.HOME_INIT_MITT)\nclass HomeInitMittProvider : MittProvider {\n\n    val homeRepository: HomeRepositoryImpl? by lazy { HomeRepositoryImpl() }\n\n    private var sContext: Context? = null\n\n    override fun initMitt() {\n        try {\n            if (Build.VERSION.SDK_INT >= 29) {\n                val miitHelper = MiitHelper(object : MiitHelper.AppIdsUpdater {\n                    override fun OnIdsAvalid(oaid: String, aaid: String) {\n                        DeviceUtils.oaid = oaid\n                        DeviceUtils.aaid = aaid\n                        val jsonObject = JSONObject()\n                        jsonObject.put(\"adrksimei\", DeviceUtils.fix_getimei(BaseApplication.instance))\n                        jsonObject.put(\"adrdid\", DeviceUtils.fix_getadrdid(BaseApplication.instance))\n                        jsonObject.put(\"adrksoaid\", oaid)\n                        jsonObject.put(\"adrksaaid\", aaid)\n                        uploadPara(jsonObject)\n                    }\n                })\n                sContext?.let { miitHelper.getDeviceIds(it) }\n            }\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    override fun initCdid() {\n        var umengChannel = HttpConfigManager.getUmengChannel()\n        if (umengChannel.isNotEmpty()) {\n            Main.init(sContext, GlobalConstants.SM_ID)\n            GlobalScope.launch(Dispatchers.IO) {\n                //本地deviceid\n                var deviceId = DeviceIdHolder.deviceId\n                //服务器生成deviceid\n                if (deviceId.isNullOrEmpty()) {\n                    deviceId = DeviceIdHolder.getDeviceId()\n                }\n                //自己手动生成\n                if (deviceId.isNullOrEmpty()) {\n                    deviceId = DeviceIdHolder.createDeviceIdByLocal()\n                }\n                if (deviceId?.isNotEmpty()!!) {\n                    Main.getQueryID(sContext, umengChannel, deviceId, 1) { cdid ->\n                        if (cdid.isNotEmpty()) {\n                            if (BaseApplication.openTingYun) {\n                                NBSAppAgent.setUserIdentifier(cdid)\n                            }\n                            DeviceIdHolder.cdid = cdid\n                            val jsonObject = JSONObject()\n                            jsonObject.put(\"adrksimei\", DeviceUtils.fix_getimei(BaseApplication.instance))\n                            jsonObject.put(\"cdid\", cdid)\n                            jsonObject.put(\"adrdid\", DeviceUtils.fix_getadrdid(BaseApplication.instance))\n                            uploadPara(jsonObject)\n\n                            cdidReport(cdid)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 上报数盟id\n     * @param cdid String?\n     */\n    private fun cdidReport(cdid: String?) {\n        GlobalScope.launch {\n            homeRepository?.reportCdid(cdid)\n        }\n    }\n\n    /**\n     * 上报生成devideid的辅助点\n     * @param jsonObject JSONObject\n     */\n    private fun uploadPara(jsonObject: JSONObject) {\n        GlobalScope.launch(Dispatchers.Default) {\n            DeviceIdHolder.uploadCreateDevicesIdParams(jsonObject)\n        }\n    }\n\n    override fun init(context: Context?) {\n        sContext = context\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593276279},"updatedAt":{"$$date":1598601904248},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"MDe73Z6jiUjMQUun"}
{"name":"css-CSS 网页布局","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 网页布局\n网页布局\n网页布局有很多种方式，一般分为以下几个部分：头部区域、菜单导航区域、内容区域、底部区域。\n\n\n\n头部区域\n头部区域位于整个网页的顶部，一般用于设置网页的标题或者网页的 logo：\n\nCSS3 实例\n.header {\n  background-color: #F1F1F1;\n  text-align: center;\n  padding: 20px;\n}\n\n尝试一下 »\n菜单导航区域\n菜单导航条包含了一些链接，可以引导用户浏览其他页面：\n\nCSS3 实例\n/* 导航条 */\n.topnav {\n  overflow: hidden;\n  background-color: #333;\n}\n \n/* 导航链接 */\n.topnav a {\n  float: left;\n  display: block;\n  color: #f2f2f2;\n  text-align: center;\n  padding: 14px 16px;\n  text-decoration: none;\n}\n \n/* 链接 - 修改颜色 */\n.topnav a:hover {\n  background-color: #ddd;\n  color: black;\n}\n\n尝试一下 »\n内容区域\n内容区域一般有三种形式:\n\n1 列：一般用于移动端\n2 列：一般用于平板设备\n3 列：一般用于 PC 桌面设备\n\n\n我们将创建一个 3 列布局，在小的屏幕上将会变成 1 列布局（响应式）：\n\nCSS3 实例\n/* 创建三个相等的列 */\n.column {\n  float: left;\n  width: 33.33%;\n}\n \n/* 列后清除浮动 */\n.row:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n \n/* 响应式布局 - 小于 600 px 时改为上下布局 */\n@media screen and (max-width: 600px) {\n  .column {\n    width: 100%;\n  }\n}\n\n尝试一下 »\n提示:要设置两列可以设置 width 为 50%。创建 4 列可以设置为 25%。\n\n提示:如果你想了解更多 @media 的规则可以查看 CSS3 多媒体查询。\n\n提示: 现在更高级的方式是使用 CSS Flexbox 来创建列的布局，但 Internet Explorer 10 及更早的版本不支持该方式， IE6-10 可以使用浮动方式。\n\nCSS Flexbox 的更多内容可以查看 CSS3 弹性盒子(Flex Box)。\n\n不相等的列\n不相等的列一般是在中间部分设置内容区域，这块也是最大最主要的，左右两次侧可以作为一些导航等相关内容，这三列加起来的宽度是 100％。\n\nCSS3 实例\n.column {\n  float: left;\n}\n \n/* 左右侧栏的宽度 */\n.column.side {\n  width: 25%;\n}\n \n/* 中间列宽度 */\n.column.middle {\n  width: 50%;\n}\n \n/* 响应式布局 - 宽度小于600px时设置上下布局 */\n@media screen and (max-width: 600px) {\n  .column.side, .column.middle {\n    width: 100%;\n  }\n}\n\n尝试一下 »\n底部区域\n底部区域在网页的最下方，一般包含版权信息和联系方式等。\n\nCSS3 实例\n.footer {\n  background-color: #F1F1F1;\n  text-align: center;\n  padding: 10px;\n}\n\n尝试一下 »\n响应式网页布局\n通过以上等学习我们来创建一个响应式等页面，页面的布局会根据屏幕的大小来调整：\n\nCSS3 实例\n* {\n  box-sizing: border-box;\n}\n \nbody {\n  font-family: Arial;\n  padding: 10px;\n  background: #f1f1f1;\n}\n \n/* 头部标题 */\n.header {\n  padding: 30px;\n  text-align: center;\n  background: white;\n}\n \n.header h1 {\n  font-size: 50px;\n}\n \n/* 导航条 */\n.topnav {\n  overflow: hidden;\n  background-color: #333;\n}\n \n/* 导航条链接 */\n.topnav a {\n  float: left;\n  display: block;\n  color: #f2f2f2;\n  text-align: center;\n  padding: 14px 16px;\n  text-decoration: none;\n}\n \n/* 链接颜色修改 */\n.topnav a:hover {\n  background-color: #ddd;\n  color: black;\n}\n \n/* 创建两列 */\n/* Left column */\n.leftcolumn {   \n  float: left;\n  width: 75%;\n}\n \n/* 右侧栏 */\n.rightcolumn {\n  float: left;\n  width: 25%;\n  background-color: #f1f1f1;\n  padding-left: 20px;\n}\n \n/* 图像部分 */\n.fakeimg {\n  background-color: #aaa;\n  width: 100%;\n  padding: 20px;\n}\n \n/* 文章卡片效果 */\n.card {\n  background-color: white;\n  padding: 20px;\n  margin-top: 20px;\n}\n \n/* 列后面清除浮动 */\n.row:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n \n/* 底部 */\n.footer {\n  padding: 20px;\n  text-align: center;\n  background: #ddd;\n  margin-top: 20px;\n}\n \n/* 响应式布局 - 屏幕尺寸小于 800px 时，两列布局改为上下布局 */\n@media screen and (max-width: 800px) {\n  .leftcolumn, .rightcolumn {   \n    width: 100%;\n    padding: 0;\n  }\n}\n \n/* 响应式布局 -屏幕尺寸小于 400px 时，导航等布局改为上下布局 */\n@media screen and (max-width: 400px) {\n  .topnav a {\n    float: none;\n    width: 100%;\n  }\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973633361},"updatedAt":{"$$date":1598974590022},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ME1661Y6TwrHKuow"}
{"name":"ad-","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539558276},"updatedAt":{"$$date":1598539558276},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"MIDIZJMEjNn70DrX"}
{"name":"kqapp-oss","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n/**\n * https://www.alibabacloud.com/help/zh/doc-detail/32044.htm?spm=a2c63.p38356.b99.157.545f219fADUeZx\n *\n * 阿里云文件上传类\n * kotlin实现方式，协程 上传\n */\nclass AliOssUploadKt {\n\n    sealed class AliResult<out T> {\n        class UploadFailed(val exception: Exception) : AliResult<Nothing>()\n        class UploadSuccess<out T> : AliResult<T>()\n    }\n\n\n    private val oss: OSS\n\n    /**\n     * suspend 上传，协程 实现方式\n     *\n     *\n     * @param uploadFilePath\n     * @param uploadObject\n     *\n     */\n    suspend fun upload(uploadFilePath: String,\n                       uploadObject: String,progress:((currentSize:Long,totalSize:Long)->Unit)?=null): AliResult<UploadResult> {\n        return try {\n            AliPutObjectKt(oss, bucket, uploadObject, uploadFilePath).uploadFile(progress)\n            AliResult.UploadSuccess()\n        } catch (e: Exception) {\n            AliResult.UploadFailed(e)\n        }\n    }\n\n    private val bucket: String = when (env()) {\n        HttpConfigManager.ENV_DAPI, HttpConfigManager.ENV_DEBUG -> testBucket\n        HttpConfigManager.ENV_GAMA, HttpConfigManager.ENV_RELEASE -> nomalBucket\n        else -> nomalBucket\n    }\n\n\n    val thePreHost: String = when (env()) {\n        HttpConfigManager.ENV_DAPI, HttpConfigManager.ENV_DEBUG -> testPreHost\n        HttpConfigManager.ENV_GAMA, HttpConfigManager.ENV_RELEASE -> preHost\n        else -> preHost\n    }\n\n\n    companion object {\n        // 运行sample前需要配置以下字段为有效的值\n        const val httpPrf = \"http://\"\n        const val endPoint = \"oss-cn-beijing.aliyuncs.com\"\n        const val nomalBucket = \"kaishustory-yuwen-files\"\n        const val testBucket = \"kaishustory-yuwen-files-test\"\n        const val preHost = \"https://yuwencdn.kaishustory.com/\"\n        const val testPreHost = \"https://tyuwencdn.kaishustory.com/\"\n        const val usericon_prefiledir = \"headimgs/\"\n        const val audioFile = \"audio/\"\n        const val mediaFile = \"media/\"\n    }\n\n    /**\n     * 构造函数\n     *\n     * @param context\n     */\n    init { //**********************************************\n        val credentialProvider: OSSCredentialProvider = OSSPlainTextAKSKCredentialProvider(\n                GlobalConstants.OSSAccessKeyId, GlobalConstants.OSSAccessKeySecret)\n        val conf = ClientConfiguration()\n        conf.connectionTimeout = 15 * 1000 // 连接超时，默认15秒\n        conf.socketTimeout = 15 * 1000 // socket超时，默认15秒\n        conf.maxConcurrentRequest = 5 // 最大并发请求书，默认5个\n        conf.maxErrorRetry = 2 // 失败后最大重试次数，默认2次\n        OSSLog.enableLog()\n        oss = OSSClient(instance, httpPrf + endPoint, credentialProvider, conf)\n        //*************************************\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author liangsaifei\n * 邮箱：liangsaifei@ksjgs.com\n * 创建时间: 2020/3/27     4:52 PM\n * 用途: kt版本的 上传阿里云 ，封装成 suspend ，可以协程\n ***************************************\n\n */\n\n/**\n * Constructor\n *\n * @param bucketName     The bucket name\n * @param objectKey      The object key\n * @param uploadFilePath The local file path to upload from\n */\nclass AliPutObjectKt(private val ossClient: OSS, private val bucketName: String, private val objectKey: String, private val uploadFilePath: String) {\n\n\n    /**\n     * 从本地文件上传，使用非阻塞的异步接口\n     */\n    suspend fun uploadFile(progress:((currentSize:Long,totalSize:Long)->Unit)?=null):UploadResult = suspendCancellableCoroutine { continuation ->\n\n        // 构造上传请求\n        val request = PutObjectRequest(bucketName, objectKey, uploadFilePath)\n\n        // 异步上传时可以设置进度回调\n        request.setProgressCallback { _, currentSize, totalSize ->\n            \"PutObject currentSize: $currentSize totalSize: $totalSize\".loge()\n            progress?.invoke(currentSize,totalSize)\n        }\n\n        val task: OSSAsyncTask<*> = ossClient.asyncPutObject(request, object : OSSCompletedCallback<PutObjectRequest?, PutObjectResult> {\n            override fun onSuccess(request: PutObjectRequest?, result: PutObjectResult) {\n                \"PutObject, UploadSuccess\".loge()\n                result.eTag.loge()\n                \"RequestId, ${result.requestId}\".loge()\n                continuation.resume(UploadResult(request,result))\n            }\n\n            override fun onFailure(request: PutObjectRequest?, clientExcepion: ClientException, serviceException: ServiceException) { // 请求异常\n                clientExcepion.printStackTrace()\n                // 服务异常\n                \"ErrorCode${serviceException.errorCode}\".loge()\n                \"RequestId${ serviceException.requestId}\".loge()\n                \"HostId${ serviceException.hostId}\".loge()\n                \"RawMessage ${serviceException.rawMessage}\".loge()\n                continuation.resumeWithException(clientExcepion)\n            }\n        })\n\n        //当协程 cancel时，把 task也cancel，与LifeCycleOwner 生命周期一致，不会内存泄漏\n        continuation.invokeOnCancellation {\n            task.cancel()\n        }\n    }\n}\ndata class UploadResult(val task:PutObjectRequest?,val result:PutObjectResult)\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class MediaFile implements Parcelable {\n\n    public static int photo = 0;\n    public static int video = 1;\n    public static int audio = 2;\n    public int type = -1;\n    public int id = 0;\n    public String path = \"\";\n    public String thumbPath = \"\";\n    public String name = \"\";\n    public long size = 0;\n    public long date = 0;\n    public long duration = 0;\n    public String uploaduri = \"\";\n\n    public boolean compress;\n    public boolean uploaded;\n    public String uploadPath = \"\";\n    public String thumbImageUri = \"\";\n    public boolean uploading;\n\n    public MediaFile(int id, String path, String thumbPath, long duration, int type, long size) {\n        this.id = id;\n        this.path = path;\n        this.thumbPath = thumbPath;\n        this.duration = duration;\n        this.type = type;\n        this.size = size;\n    }\n\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof MediaFile)) return false;\n\n        MediaFile photo = (MediaFile) o;\n\n        return id == photo.id;\n    }\n\n    @Override\n    public int hashCode() {\n        return id;\n    }\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeInt(this.id);\n        dest.writeString(this.path);\n        dest.writeString(this.thumbPath);\n        dest.writeString(this.name);\n        dest.writeLong(this.size);\n        dest.writeLong(this.date);\n        dest.writeLong(this.duration);\n    }\n\n    public MediaFile() {\n    }\n\n    protected MediaFile(Parcel in) {\n        this.id = in.readInt();\n        this.path = in.readString();\n        this.thumbPath = in.readString();\n        this.name = in.readString();\n        this.size = in.readLong();\n        this.date = in.readLong();\n        this.duration = in.readLong();\n    }\n\n    public static final Creator<MediaFile> CREATOR = new Creator<MediaFile>() {\n        @Override\n        public MediaFile createFromParcel(Parcel source) {\n            return new MediaFile(source);\n        }\n\n        @Override\n        public MediaFile[] newArray(int size) {\n            return new MediaFile[size];\n        }\n    };\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public String getThumbPath() {\n        return thumbPath;\n    }\n\n    public void setThumbPath(String thumbPath) {\n        this.thumbPath = thumbPath;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public long getSize() {\n        return size;\n    }\n\n    public void setSize(long size) {\n        this.size = size;\n    }\n\n    public long getDate() {\n        return date;\n    }\n\n    public void setDate(long date) {\n        this.date = date;\n    }\n\n    public long getDuration() {\n        return duration;\n    }\n\n    public void setDuration(long duration) {\n        this.duration = duration;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593263855},"updatedAt":{"$$date":1598596039071},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"McbuPNf1MzRPF2Oj"}
{"name":"qk-","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n# Project-wide Gradle settings.\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\n\norg.gradle.jvmargs=-Xmx1536m\n\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n# org.gradle.parallel=true\n# AndroidX package structure to make it clearer which packages are bundled with the\n# Android operating system, and which are packaged with your app's APK\n# https://developer.android.com/topic/libraries/support-library/androidx-rn\n\nandroid.useAndroidX=true\n\n# Automatically convert third-party libraries to use AndroidX\n\nandroid.enableJetifier=true\n\n# Kotlin code style for this project: \"official\" or \"obsolete\":\nkotlin.code.style=official\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580894291},"updatedAt":{"$$date":1598581068367},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"MvSf0rT9yIvvbDJ1"}
{"name":"html-HTML 框架","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"HTML 框架\n通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。\n\n\niframe语法:\n\n<iframe src=\"URL\"></iframe>\n该URL指向不同的网页。\n\nIframe - 设置高度与宽度\nheight 和 width 属性用来定义iframe标签的高度与宽度。\n\n属性默认以像素为单位, 但是你可以指定其按比例显示 (如：\"80%\")。\n\n实例\n<iframe src=\"demo_iframe.htm\" width=\"200\" height=\"200\"></iframe>\n\n尝试一下 »\n\nIframe - 移除边框\nframeborder 属性用于定义iframe表示是否显示边框。\n\n设置属性值为 \"0\" 移除iframe的边框:\n\n实例\n<iframe src=\"demo_iframe.htm\" frameborder=\"0\"></iframe>\n\n尝试一下 »\n\n使用iframe来显示目标链接页面\niframe可以显示一个目标链接的页面\n\n目标链接的属性必须使用iframe的属性，如下实例:\n\n实例\n<iframe src=\"demo_iframe.htm\" name=\"iframe_a\"></iframe>\n<p><a href=\"http://www.runoob.com\" target=\"iframe_a\">RUNOOB.COM</a></p>\n\n尝试一下 »\n\nHTML iframe 标签\n标签\t说明\n<iframe>\t定义一个内联的iframe\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886135765},"updatedAt":{"$$date":1598886722361},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"NIV5svk2JwtriWsH"}
{"name":"ad-ks_imageload_picasso","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\n// 上传插件\napply from: rootProject.file(\"./gradle/upload_local_maven.gradle\")\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    //implementation project(path: ':ks_imageload_core')\n    api 'com.ks.frame:imageload-core:0.0.1.1-SNAPSHOT'\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n    // picasso\n    implementation 'com.squareup.picasso:picasso:2.71828'\n    // gif drawable  picasso 不支持gif 加载 ，使用 gifdrawable 替换\n    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.19'\n\n}\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539540832},"updatedAt":{"$$date":1598539761223},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"NO7ZnpWwFgbS3UtF"}
{"name":"kotlin-学习 Kotlin 编程语言  |  Android 开发者  |  Android Developers","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /kotlin/learn\n学习 Kotlin 编程语言  |  Android 开发者  |  Android Developers\n7-9 minutes\nKotlin 是世界各地的 Android 开发者广泛使用的一种编程语言。本主题可用作 Kotlin 速成课程，帮助您快速上手。\n\n变量声明\nKotlin 使用两个不同的关键字（即 val 和 var）来声明变量。\n\nval 用于值从不更改的变量。使用 val 声明的变量无法重新赋值。\nvar 用于值可以更改的变量。\n在以下示例中，count 是一个 Int 类型的变量，初始赋值为 10：\n\nvar count: Int = 10\nInt 是一种表示整数的类型，是可以用 Kotlin 表示的众多数值类型之一。与其他语言类似，您还可以使用 Byte、Short、Long、Float 和 Double，具体取决于您的数值数据。\n\nvar 关键字表示可以根据需要为 count 重新赋值。例如，可以将 count 的值从 10 更改为 15：\n\nvar count: Int = 10\ncount = 15\n不过，有些值不应更改。假设有一个名为 languageName 的 String。如果希望确保 languageName 的值始终为“Kotlin”，则可以使用 val 关键字声明 languageName：\n\nval languageName: String = \"Kotlin\"\n通过这些关键字，您可以明确指出哪些变量的值可以更改。请根据需要加以利用。如果引用的变量必须可重新赋值，则将其声明为 var。否则，请使用 val。\n\n类型推断\n接着前面的示例来讲，为 languageName 赋予初始值后，Kotlin 编译器可根据所赋值的类型来推断其类型。\n\n由于 \"Kotlin\" 的值为 String 类型，因此编译器推断 languageName 也为 String。请注意，Kotlin 是一种静态类型的语言。这意味着，类型将在编译时解析且从不改变。\n\n在以下示例中，languageName 推断为 String，因此无法对其调用任何不属于 String 类的函数：\n\nval languageName = \"Kotlin\"\nval upperCaseName = languageName.toUpperCase()// Fails to compile\nlanguageName.inc()\ntoUpperCase() 是一个只能对 String 类型的变量调用的函数。由于 Kotlin 编译器已将 languageName 推断为 String，因此可以安全地调用 toUpperCase()。不过，inc() 是一个 Int 运算符函数，因此无法对 String 调用它。利用 Kotlin 的类型推断，既能确保代码简洁，又能确保类型安全。\n\nNull 安全\n在某些语言中，可以声明引用类型变量而不明确提供初始值。在这类情况下，变量通常包含 null 值。默认情况下，Kotlin 变量不能持有 null 值。这意味着以下代码段无效：\n\n// Fails to compile\nval languageName: String = null\n要使变量持有 null 值，它必须是可为 null 类型。可以在变量类型后面加上 ? 后缀，将变量指定为可为 null，如以下示例所示：\n\nval languageName: String? = null\n指定 String? 类型后，可以为 languageName 赋予 String 值或 null。\n\n必须小心处理可为 null 的变量，否则可能会出现可怕的 NullPointerException。例如，在 Java 中，如果尝试对 null 值调用方法，程序会发生崩溃。\n\nKotlin 提供了多种机制来安全地处理可为 null 的变量。如需了解详情，请参阅 Android 平台中常见的 Kotlin 模式：可为 null 性。\n\n条件语句\nKotlin 提供了几种实现条件逻辑的机制，其中最常见的是 if-else 语句。如果 if 关键字后面括在圆括号内的表达式求值为 true，则会执行该分支中的代码（即，紧跟在后面的括在大括号内的代码）。否则，会执行 else 分支中的代码。\n\nif (count == 42) {\n    println(\"I have the answer.\")\n} else {\n    println(\"The answer eludes me.\")\n}\n您可以使用 else if 表示多个条件。这样，您就可以在单个条件语句中表示更精细、更复杂的逻辑，如以下示例所示：\n\nif (count == 42) {\n    println(\"I have the answer.\")\n} else if (count > 35) {\n    println(\"The answer is close.\")\n} else {\n    println(\"The answer eludes me.\")\n}\n条件语句对于表示有状态的逻辑很有用，但您可能会发现，编写这些语句时会出现重复。在上面的示例中，每个分支都是输出一个 String。为了避免这种重复，Kotlin 提供了条件表达式。最后一个示例可以重新编写如下：\n\nval answerString: String = if (count == 42) {\n    \"I have the answer.\"\n} else if (count > 35) {\n    \"The answer is close.\"\n} else {\n    \"The answer eludes me.\"\n}\nprintln\n\n(answerString)\n每个条件分支都隐式地返回其最后一行的表达式的结果，因此无需使用 return 关键字。由于全部三个分支的结果都是 String 类型，因此 if-else 表达式的结果也是 String 类型。在本例中，根据 if-else 表达式的结果为 answerString 赋予了一个初始值。利用类型推断可以省略 answerString 的显式类型声明，但为了清楚起见，通常最好添加该声明。\n\n随着条件语句的复杂性不断增加，您可以考虑将 if-else 表达式替换为 when 表达式，如以下示例所示：\n\nval answerString = when {\n    count == 42 -> \"I have the answer.\"\n    count > 35 -> \"The answer is close.\"\n    else -> \"The answer eludes me.\"\n}\nprintln\n\n(answerString)\nwhen 表达式中每个分支都由一个条件、一个箭头 (->) 和一个结果来表示。如果箭头左侧的条件求值为 true，则会返回右侧的表达式结果。请注意，执行并不是从一个分支跳转到下一个分支。when 表达式示例中的代码在功能上与上一个示例中的代码等效，但可能更易懂。\n\nKotlin 的条件语句彰显了它的一项更强大的功能，即智能类型转换。您不必使用安全调用运算符或非 null 断言运算符来处理可为 null 的值，而可以使用条件语句来检查变量是否包含对 null 值的引用，如以下示例所示：\n\nval languageName: String? = null\nif (languageName != null) {\n    // No need to write languageName?.toUpperCase()\n    println(languageName.toUpperCase())\n}\n在条件分支中，languageName 可能会被视为不可为 null。Kotlin 非常智能，能够识别执行分支的条件是 languageName 不持有 null 值，因此您不必在该分支中将 languageName 视为可为 null。这种智能类型转换适用于 null 检查、类型检查，或符合合约的任何条件。\n\n函数\n您可以将一个或多个表达式归入一个函数。您可以将相应的表达式封装在一个函数中并调用该函数，而不必在每次需要某个结果时都重复同一系列的表达式。\n\n要声明函数，请使用 fun 关键字，后跟函数名称。接下来，定义函数接受的输入类型（如果有），并声明它返回的输出类型。函数的主体用于定义在调用函数时调用的表达式。\n\n以前面的示例为基础，下面给出了一个完整的 Kotlin 函数：\n\nfun generateAnswerString(): String {\n    val answerString = if (count == 42) {\n        \"I have the answer.\"\n    } else {\n        \"The answer eludes me\"\n    }return answerString\n}\n上面示例中的函数名为 generateAnswerString。它不接受任何输入。它会输出 String 类型的结果。要调用函数，请使用函数名称，后跟调用运算符 (())。在下面的示例中，使用 generateAnswerString() 的结果对 answerString 变量进行了初始化。\n\nval answerString = generateAnswerString()\n函数可以接受参数输入，如以下示例所示：\n\nfun generateAnswerString(countThreshold: Int): String {\n    val answerString = if (count > countThreshold) {\n        \"I have the answer.\"\n    } else {\n        \"The answer eludes me.\"\n    }return answerString\n}\n在声明函数时，可以指定任意数量的参数及其类型。在上面的示例中，generateAnswerString() 接受一个名为 countThreshold 的 Int 类型的参数。在函数中，可以使用参数的名称来引用参数。\n\n调用此函数时，必须在函数调用的圆括号内添加一个参数：\n\nval answerString = generateAnswerString(42)\n简化函数声明\ngenerateAnswerString() 是一个相当简单的函数。该函数声明一个变量，然后立即返回结果。函数返回单个表达式的结果时，可以通过直接返回函数中包含的 if-else 表达式的结果来跳过声明局部变量，如以下示例所示：\n\nfun generateAnswerString(countThreshold: Int): String {\n    return if (count > countThreshold) {\n        \"I have the answer.\"\n    } else {\n        \"The answer eludes me.\"\n    }\n}\n您还可以将 return 关键字替换为赋值运算符：\n\nfun generateAnswerString(countThreshold: Int): String = if (count > countThreshold) {\n        \"I have the answer\"\n    } else {\n        \"The answer eludes me\"\n    }\n匿名函数\n并非每个函数都需要一个名称。某些函数通过输入和输出更直接地进行标识。这些函数称为“匿名函数”。您可以保留对某个匿名函数的引用，以便日后使用此引用来调用该匿名函数。与其他引用类型一样，您也可以在应用中传递引用。\n\nval stringLengthFunc: (String) -> Int = { input ->\n    input.length\n}\n与命名函数一样，匿名函数也可以包含任意数量的表达式。 函数的返回值是最终表达式的结果。\n\n在上面的示例中，stringLengthFunc 包含对一个匿名函数的引用，该函数将 String 当作输入，并将输入 String 的长度作为 Int 类型的输出返回。因此，该函数的类型表示为 (String) -> Int。不过，此代码不会调用该函数。要检索该函数的结果，您必须像调用命名函数一样调用该函数。调用 stringLengthFunc 时，必须提供 String，如以下示例所示：\n\nval stringLengthFunc: (String) -> Int = { input ->\n    input.length\n}val stringLength: Int = stringLengthFunc(\"Android\")\n高阶函数\n一个函数可以将另一个函数当作参数。将其他函数用作参数的函数称为“高阶函数”。此模式对组件之间的通信（其方式与在 Java 中使用回调接口相同）很有用。\n\n下面是一个高阶函数的示例：\n\nfun stringMapper(str: String, mapper: (String) -> Int): Int {\n    // Invoke function\n    return mapper(str)\n}\nstringMapper() 函数接受一个 String 以及一个函数，该函数根据您传递给它的 String 来推导 Int 值。\n\n要调用 stringMapper()，可以传递一个 String 和一个满足其他输入参数的函数（即，一个将 String 当作输入并输出 Int 的函数），如以下示例所示：\n\nstringMapper(\"Android\", { input ->\n    input.length\n})\n如果匿名函数是在某个函数上定义的最后一个参数，则您可以在用于调用该函数的圆括号之外传递它，如以下示例所示：\n\nstringMapper(\"Android\") { input ->\n    input.length\n}\n在整个 Kotlin 标准库中可以找到很多匿名函数。如需了解详情，请参阅高阶函数和 Lambda。\n\n类\n到目前为止提到的所有类型都已内置在 Kotlin 编程语言中。如果您希望添加自己的自定义类型，可以使用 class 关键字来定义类，如以下示例所示：\n\nclass Car\n属性\n类使用属性来表示状态。属性是类级变量，可以包含 getter、setter 和后备字段。由于汽车需要轮子来驱动，因此您可以添加 Wheel 对象的列表作为 Car 的属性，如以下示例所示：\n\nclass Car {\n    val wheels = listOf<Wheel>()\n}\n请注意，wheels 是一个 public val，这意味着，可以从 Car 类外部访问 wheels，并且不能为其重新赋值。如果要获取 Car 的实例，必须先调用其构造函数。这样，您便可以访问它的任何可访问属性。\n\nval car = Car() // construct a Car\nval wheels = car.wheels // retrieve the wheels value from the Car\n如果希望自定义轮子，可以定义一个自定义构造函数，用来指定如何初始化类属性：\n\nclass Car(val wheels: List<Wheel>)\n在以上示例中，类构造函数将 List<Wheel> 当作构造函数参数，并使用该参数来初始化其 wheels 属性。\n\n类函数和封装\n类使用函数对行为建模。函数可以修改状态，从而帮助您只公开希望公开的数据。这种访问控制机制属于一个面向对象的更大概念，称为“封装”。\n\n在以下示例中，doorLock 属性对 Car 类外部的一切都不公开。要解锁汽车，必须调用 unlockDoor() 函数并传入有效的“钥匙”，如以下示例所示：\n\nclass Car(val wheels: List<Wheel>) {private val doorLock: DoorLock = ...fun unlockDoor(key: Key): Boolean {\n        // Return true if key is valid for door lock, false otherwise\n    }\n}\n如果希望自定义属性的引用方式，则可以提供自定义的 getter 和 setter。例如，如果希望公开属性的 getter 而限制访问其 setter，则可以将该 setter 指定为 private：\n\nclass Car(val wheels: List<Wheel>) {private val doorLock: DoorLock = ...val gallonsOfFuelInTank: Int = 15\n        private setfun unlockDoor(key: Key): Boolean {\n        // Return true if key is valid for door lock, false otherwise\n    }\n}\n通过结合使用属性和函数，可以创建能够对所有类型的对象建模的类。\n\n互操作性\nKotlin 最重要的功能之一就是它与 Java 之间流畅的互操作性。由于 Kotlin 代码可编译为 JVM 字节码，因此 Kotlin 代码可直接调用 Java 代码，反之亦然。这意味着，您可以直接从 Kotlin 利用现有的 Java 库。此外，绝大多数 Android API 都是用 Java 编写的，因此可以直接从 Kotlin 调用它们。\n\n后续步骤\nKotlin 是一种灵活而实用的语言，它的支持力量和发展势头日益强劲。如果您还没有尝试过，我们建议您试一下。对于后续操作，请查看 Kotlin 官方文档以及关于如何在 Android 应用中运用常见 Kotlin 模式的指南。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397413936},"updatedAt":{"$$date":1597398594102},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"NWNeF4YYNzRjzno2"}
{"name":"ad-build.gradle工程的","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\napply plugin: 'com.alibaba.arouter'\n\n\nbuildscript {\n\n    repositories {\n        apply from: 'dependencies.gradle'\n        // jcenter 由JFrog公司提供的Bintray中的Java仓库,是GoovyGrape内的默认仓库，Gradle内建支持\n        jcenter()\n\n        maven {\n//             All of React Native (JS, Obj-C sources, Android binaries) is installed from npm\n//            url \"$rootDir/../ksandroid/ks-rn-theme/node_modules/react-native/android\"\n            url \"$rootDir/../ksandroid/react-native/0.59.9\"\n        }\n\n        // maven centeral 由Sonatype公司提供的服务，它是ApacheMaven、SBT和其他构建系统的默认仓库\n        mavenCentral()\n        // 私有，或者国内镜像仓库配置方法\n        maven { url 'https://jitpack.io' }\n        // gralde 4.0 以后出现，访问仓库为 https://dl.google.com/dl/android/maven2/\n        // google()\n        google()\n//        maven { url \"http://nexus2.tingyun.com/nexus/content/repositories/snapshots/\" }\n//        maven { url \"http://nexus2.tingyun.com/nexus/content/repositories/snapshots/\" }\n        maven { url 'https://dl.bintray.com/kaishustory/maven' }\n        maven { url \"http://10.0.20.167:8081/repository/ks_kt_lib_public/\" }\n        maven { url 'https://jitpack.io' }\n        maven { url \"https://plugins.gradle.org/m2/\" }\n    }\n\n    dependencies {\n        classpath project_plugin.gradle_plugin\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n\n        classpath project_plugin.packer_np_plugin\n        classpath project_plugin.grale_retrolambda\n        classpath project_plugin.arouter_plugin\n        classpath project_plugin.kotlin_plugin\n        classpath project_plugin.tingyun_plugin\n        classpath project_plugin.growingio\n        if (TraceMethod.toBoolean()) {\n            classpath \"gradle.plugin.cn.cxzheng.methodTracePlugin:tracemanplugin:1.0.4\"\n        }\n        classpath project_plugin.aspectjx\n//        classpath 'com.huawei.agconnect:agcp:1.0.0.300'\n\n    }\n}\n\nprintln \"============================== kaishustory build info ============================== \\n\"\nprintln \"INFO: PROP_TARGET_SDK_VERSION:  ${PROP_TARGET_SDK_VERSION}\\n\"\nprintln \"INFO: PROP_APP_ABI:  ${PROP_APP_ABI}\\n\"\nprintln \"INFO: BUILD_COCOS:  ${BUILD_COCOS}\\n\"\nprintln \"INFO: TINGYUN_SCAN:  ${TINGYUN_SCAN}\\n\"\nprintln \"INFO: BUILD_TYPE:  ${BUILD_TYPE}\\n\"\nprintln \"INFO: RN_Dependencies:  ${getRnVersion()}\\n\"\n//println \"INFO: WEB_MD5:  ${fileToMd5(new File(\"$rootDir/ks_main_center/src/main/assets/app.zip\"))}\\n\"\n\nprintln \"INFO: isLiveModule:  ${isLiveModule}\\n\"\nprintln \"INFO: isAnalysis:  ${isAnalysis}\\n\"\n\nprintln \"============================== kaishustory build info ============================== \\n\"\n\n\nallprojects {\n\n    configurations.all {\n        resolutionStrategy.force \"com.facebook.fresco:fresco:1.11.0\"\n        resolutionStrategy.force \"com.facebook.fresco:imagepipeline-okhttp3:1.11.0\"\n        resolutionStrategy.force \"com.google.code.findbugs:jsr305:3.0.2\"\n        resolutionStrategy.force \"com.squareup.okhttp3:okhttp:3.12.12\"\n        resolutionStrategy.force \"com.facebook.react:react-native:0.2.13\"\n        // 采用动态版本声明的依赖缓存5分钟\n//        resolutionStrategy.cacheDynamicVersionsFor(5, 'minutes')\n//        // 每隔24小时检查远程依赖是否存在更新\n//        resolutionStrategy.cacheChangingModulesFor(24, 'hours')\n    }\n\n    repositories {\n        google()\n        jcenter()\n//        maven { url \"https://www.jitpack.io\" }\n//        maven { url 'http://developer.huawei.com/repo/' }\n//        maven { url \"https://maven.google.com\" }\n//        maven { url \"https://dl.google.com/dl/android/maven2/\" }\n        // jcenter 私有库\n//        maven { url 'https://dl.bintray.com/kaishustory/maven' }\n//        maven { url 'https://dl.bintray.com/umsdk/release' }\n//        maven { url \"http://nexus2.tingyun.com/nexus/content/repositories/snapshots/\" }\n        maven {\n//             All of React Native (JS, Obj-C sources, Android binaries) is installed from npm\n//            url \"$rootDir/../ksandroid/ks-rn-theme/node_modules/react-native/android\"\n            url \"$rootDir/../ksandroid/react-native/0.59.9\"\n        }\n//        maven { url \"http://mvn.gt.igexin.com/nexus/content/repositories/releases/\" }\n        flatDir {\n            dirs 'libs'\n        }\n\n        maven { url 'https://dl.bintray.com/kaishustory/maven' }\n        maven { url 'http://10.0.20.167:8081/repository/ks_kt_lib_public/' }\n     //   maven { url 'http://10.0.20.167:8081/repository/ksandroidx_public/' }\n\n        maven {\n            url \"https://maven.aliyun.com/repository/google\"\n        }\n\n        maven {\n            url \"https://maven.aliyun.com/repository/jcenter\"\n        }\n\n        maven { url 'https://jitpack.io' }\n        maven { url \"https://plugins.gradle.org/m2/\" }\n\n\n        //保利威 maven url\n//        repositories {\n//            maven {\n//                url 'http://maven.aliyun.com/nexus/content/repositories/releases/'\n//            }\n//            maven { url 'https://dl.bintray.com/polyv/android' }\n//        }\n    }\n}\n\ndef getRnVersion() {\n    // 【0 测试库】 【1 开发库】 【2gama】 【3 上线库】\n    def RnResult\n    if (RN_FULL_PATH != 'NULL') {\n        RnResult = \"com.ks.reactnative\" + \":\" + RN_FULL_PATH\n        return RnResult\n    }\n\n    def RnPre = 'com.ks.reactnative:ks-rn-story-center-androidx'\n    if (BUILD_TYPE == '1') {\n        RnResult = RnPre + \"-dapi\" + \":\" + RN_DAPI_VERSION\n    } else if (BUILD_TYPE == '0') {\n        RnResult = RnPre + \"-debug\" + \":\" + RN_DEBUG_VERSION\n    } else if (BUILD_TYPE == '2') {\n        RnResult = RnPre + \"-gama\" + \":\" + RN_GAMA_VERSION\n    } else if (BUILD_TYPE == '3') {\n        RnResult = RnPre + \":\" + RN_RELEASE_VERSION\n    }\n\n    return RnResult\n}\n\n///**\n// * 获取文件的md5\n// * @param aFile\n// * @return\n// */\n//def fileToMd5(File aFile) {\n//    def digest = java.security.MessageDigest.getInstance(\"MD5\")\n//    aFile.withInputStream { inpStream ->\n//        byte[] buffer = new byte[8192]\n//        int read = 0\n//        while ((read = inpStream.read(buffer)) > 0) {\n//            digest.update(buffer, 0, read)\n//        }\n//    }\n//    byte[] md5sumByteArray = digest.digest()\n//    def bigInt = new BigInteger(1, md5sumByteArray)\n//    return bigInt.toString(16).padLeft(32, '0')\n//}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515780149},"updatedAt":{"$$date":1598517265912},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"NY0E9WhZen1gj0SX"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975706240},"updatedAt":{"$$date":1598975706240},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"NcRItxTNfhfYIPxi"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975865256},"updatedAt":{"$$date":1598975865256},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"NuRzi93DaWibU3Ey"}
{"name":"ad-kswheelpicker","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\n\nversion = \"1.0.3\"\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 4\n        versionName version\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\nOnlyYearMonthWheelDatePicker\nShoppingWheelDatePicker\nShoppingWheelDayPicker\nShoppingWheelExpressPicker\nShoppingWheelMonthPicker\nWheel5MultiplePicker\nWheelCustomNumPicker\nWheelDatePicker\nWheelDayHalfPicker\nWheelDayPicker\nWheelExpressPicker\nWheelHourAnd5MultipleMinutePicker\nWheelHourPicker\nWheelMinutePicker\nWheelMonthPicker\nWheelNumPicker\nWheelTimePicker\nWheelTimeWithHalfDayPicker\nWheelTwelveHourPicker\nWheelYearPicker"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598519918904},"updatedAt":{"$$date":1598520227528},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"O14u4B9L8UlHgrNF"}
{"name":"py-字符串","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n字符串是以单引号'或双引号\"括起来的任意文本，比如'abc'，\"xyz\"等等。请注意，''或\"\"本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用\"\"括起来，比如\"I'm OK\"包含的字符是I，'，m，空格，O，K这6个字符。\n\n如果字符串内部既包含'又包含\"怎么办？可以用转义字符\\来标识，比如：\n\n'I\\'m \\\"OK\\\"!'\n表示的字符串内容是：\n\nI'm \"OK\"!\n转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\，可以在Python的交互式命令行用print()打印字符串看看：\n\n>>> print('I\\'m ok.')\nI'm ok.\n>>> print('I\\'m learning\\nPython.')\nI'm learning\nPython.\n>>> print('\\\\\\n\\\\')\n\\\n\\\n如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：\n\n>>> print('\\\\\\t\\\\')\n\\       \\\n>>> print(r'\\\\\\t\\\\')\n\\\\\\t\\\\\n如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：\n\n>>> print('''line1\n... line2\n... line3''')\nline1\nline2\nline3\n上面是在交互式命令行内输入，注意在输入多行内容时，提示符由>>>变为...，提示你可以接着上一行输入，注意...是提示符，不是代码的一部分：\n\n┌────────────────────────────────────────────────────────┐\n│Command Prompt - python                           _ □ x │\n├────────────────────────────────────────────────────────┤\n│>>> print('''line1                                      │\n│... line2                                               │\n│... line3''')                                           │\n│line1                                                   │\n│line2                                                   │\n│line3                                                   │\n│                                                        │\n│>>> _                                                   │\n│                                                        │\n│                                                        │\n│                                                        │\n└────────────────────────────────────────────────────────┘\n当输入完结束符```和括号)后，执行该语句并打印结果。\n\n如果写成程序并存为.py文件，就是：\n\nprint('''line1\nline2\nline3''')\n多行字符串'''...'''还可以在前面加上r使用，请自行测试：\n\n# -*- coding: utf-8 -*-\n\n\n\n\n\nprint(r'''hello,\\n\nworld''')\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973924013},"updatedAt":{"$$date":1594974078078},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"O1P0JH2AIN3WHAhZ"}
{"name":"py-格式化","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n\n\n在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：\n\n>>> 'Hello, %s' % 'world'\n'Hello, world'\n>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)\n'Hi, Michael, you have $1000000.'\n你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。\n\n常见的占位符有：\n\n占位符\t替换内容\n%d\t整数\n%f\t浮点数\n%s\t字符串\n%x\t十六进制整数\n其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：\n\n# -*- coding: utf-8 -*-\n\n\n\n\n\n\nprint('%2d-%02d' % (3, 1))\nprint('%.2f' % 3.1415926)\n\n\n\n如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：\n\n>>> 'Age: %s. Gender: %s' % (25, True)\n'Age: 25. Gender: True'\n有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：\n\n>>> 'growth rate: %d %%' % 7\n'growth rate: 7 %'\n\n\n\n\n\n\nformat()\n另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：\n\n>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)\n'Hello, 小明, 成绩提升了 17.1%'\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973933509},"updatedAt":{"$$date":1594974749861},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"O6UN8TC8mI9NiOWQ"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\njarsigner -verbose -keystore ylc.jks -storepass 111111 -signedjar b.apk -digestalg SHA1 -sigalg MD5withRSA a.apk 111111"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594980154109},"updatedAt":{"$$date":1598157833423},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"O7iTy6LhhSbSz6Ty"}
{"name":"图片加载库使用说明","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"为解决项目中fresco、fresco等图片加载库在项目中强依赖问题，统一对图片加载库进行封装\n目的：解决图片加载框架的代码侵入，无需改变加载图片相关代码切换图片加载框架\n图片加载库结构图\n1.接入\ngradle中配置 \n    //图片加载核心库\n    api ('com.ks.frame:imageload-core:0.0.1.1-SNAPSHOT'){changing = true}\n    // glide\n    api 'com.ks.frame:imageload-glide:0.0.1.1-SNAPSHOT'\n    // fresco\n    api 'com.ks.frame:imageload-fresco:0.0.1.1-SNAPSHOT'\n    // picasso\n    api 'com.ks.frame:imageload-picasso:0.0.1.1-SNAPSHOT'\n根据app中使用的图片加载框架引入，可以单独引入glide、fresco、picasso或同时引入2个或全部\n2.初始化\nApplication onCreate中初始化\n     // 构建图片加载库参数 缓存路径、缓存大小等配置参数\n        val config = ImageLoaderConfig.Builder()\n                //添加glide\n                .addImageLodaer(LoaderEnum.GLIDE,GlideLoader())\n                // 添加fresco\n                .addImageLodaer(LoaderEnum.FRESCO,FrescoLoader())\n                // 添加picasso\n                .addImageLodaer(LoaderEnum.PICASSO,PicassoLoad())\n                // 图片缓存文件夹\n                .diskCacheDir(cacheDir.absolutePath)\n                // 配置磁盘缓存大小\n                .maxDiskSize(100*1024*1024)\n                // 配置最大内存缓存大小\n                .maxMemorySize(50*1024*1024)\n                .build()\n        //初始化\n        KsLoader.init(this,config)\n如果已经执行过初始化，可以直接调用 regist方法注册图片加载器\n  // 直接注册 图片加载器  此处为使用Fresco 加载器\nKsLoader.registLoader(LoaderEnum.FRESCO,FrescoLoader())\n3.使用：加载图片\n         // 方式1：构建加载图片参数  初始化 高斯模糊、圆角、gif、圆形、灰色 等参数\n        KsLoader.loadImage(LoadOptions.Builder(iv_pic,ImageUrlsDatas.urls[1])\n                .error(R.drawable.ic_action_name).placeholder(R.drawable.ic_action_error)\n                .owner(this).build()\n        )\n       // 方式2  调用方法 加载Gif\n        KsLoader.loadGif(this, iv_gif,ImageUrlsDatas.urls[0],R.drawable.ic_action_error,R.drawable.ic_action_error,null)\n        // 方式2 调用方法 加载.9图 加载成功后将.9图设置为View的background\n        KsLoader.loadNinePatch(tv_text,ImageUrlsDatas.urls[2],R.drawable.ic_action_error)\n        // 方式2 调用方法加载圆图\n        KsLoader.loadCircle(this,iv_circle,ImageUrlsDatas.urls[5],R.drawable.ic_stat_name,R.drawable.ic_action_error)\n备注：.9仅暴露方法，内部未实现实质转换和加载\n切换默认图片加载器（前提添加注册了多个加载器）\n        // 切换当前默认图片加载器\n        KsLoader.switchLoad(LoaderEnum.FRESCO)\n        //指定图片加载器加载 目前仅支持参数对象方式\n        KsLoader.loadImage(LoaderEnum.GLIDE,LoadOptions())"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598547658868},"updatedAt":{"$$date":1598547659848},"_id":"OIj2FCww0E2BSKxy","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"qk-ks_lib_proguard","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 100\n        versionName \"100\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n    }\n\n    buildTypes {\n        // 遍历所有的混淆文件\n        release {\n            consumerProguardFiles file('.').listFiles(new FilenameFilter() {\n                @Override\n                boolean accept(File file, String s) {\n                    return s.endsWith('.pro')\n                }\n            })\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n\n\n\n}\n\ndependencies {\n\n}\n\nrepositories {\n    mavenCentral()\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\nproguard-AliPay.pro\nproguard-AndFix.pro\nproguard-AndroidCommon.pro\nproguard-AndroidEventBus.pro\nproguard-AndroidUniversalImageLoader.pro\nproguard-ARouter.pro\nproguard-BaiduMap.pro\nproguard-BaseRecyclerViewAdapterHelper.pro\nproguard-Bugly.pro\nproguard-ButterKnife.pro\nproguard-Dagger.pro\nproguard-EventBus.pro\nproguard-Fastjson.pro\nproguard-Fresco.pro\nproguard-GaoDeMap.pro\nproguard-Getui.pro\nproguard-Glide.pro\nproguard-GreenDAO.pro\nproguard-Gson.pro\nproguard-Guava.pro\nproguard-Ijkplayer.pro\nproguard-ImmersionBar.pro\nproguard-Jackson.pro\nproguard-JPush.pro\nproguard-KotlinxCoroutines.pro\nproguard-LitePal.pro\nproguard-Mars.pro\nproguard-MiPush.pro\nproguard-Msa.pro\nproguard-Nuwa.pro\nproguard-OkHttp.pro\nproguard-PingPlusPlus.pro\nproguard-push.pro\nproguard-Realm.pro\nproguard-Retrofit.pro\nproguard-Retrolambda.pro\nproguard-RongCloud.pro\nproguard-RxJava.pro\nproguard-ShareSDK.pro\nproguard-SinaWeiboSDK.pro\nproguard-Stetho.pro\nproguard-Tencent.pro\nproguard-Tingyun.pro\nproguard-UMeng.pro\nproguard-UnionPay.pro\nproguard-Volley.pro\nproguard-XinGe.pro\nproguard-XunFei.pro\nproguard-xUtils.pro\nproguard-ZXing.pro\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580904604},"updatedAt":{"$$date":1598582069970},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"OMpjQ5LI31UNAlFs"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":true,"createdAt":{"$$date":1597386565710},"updatedAt":{"$$date":1597386565710},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"OSsh3kvshTbEPD4N"}
{"name":"css-CSS 提示工具(Tooltip)","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 提示工具(Tooltip)\n本文我们为大家介绍如何使用 HTML 与 CSS 来创建提示工具。\n\n提示工具在鼠标移动到指定元素后触发，先看以下四个实例：\n\n头部显示\t右边显示\t底部显示\t左边显示\n基础提示框(Tooltip)\n提示框在鼠标移动到指定元素上显示：\n\nHTML 代码：\n<style>\n/* Tooltip 容器 */\n.tooltip {\n    position: relative;\n    display: inline-block;\n    border-bottom: 1px dotted black; /* 悬停元素上显示点线 */\n}\n \n/* Tooltip 文本 */\n.tooltip .tooltiptext {\n    visibility: hidden;\n    width: 120px;\n    background-color: black;\n    color: #fff;\n    text-align: center;\n    padding: 5px 0;\n    border-radius: 6px;\n \n    /* 定位 */\n    position: absolute;\n    z-index: 1;\n}\n \n/* 鼠标移动上去后显示提示框 */\n.tooltip:hover .tooltiptext {\n    visibility: visible;\n}\n</style>\n \n<div class=\"tooltip\">鼠标移动到这\n  <span class=\"tooltiptext\">提示文本</span>\n</div>\n\n尝试一下 »\n实例解析\nHTML) 使用容器元素 (like <div>) 并添加 \"tooltip\" 类。在鼠标移动到 <div> 上时显示提示信息。\n\n提示文本放在内联元素上(如 <span>) 并使用class=\"tooltiptext\"。\n\nCSS)tooltip 类使用 position:relative, 提示文本需要设置定位值 position:absolute。 注意: 接下来的实例会显示更多的定位效果。\n\ntooltiptext 类用于实际的提示文本。模式是隐藏的，在鼠标移动到元素显示 。设置了一些宽度、背景色、字体色等样式。\n\nCSS3 border-radius 属性用于为提示框添加圆角。\n\n:hover 选择器用于在鼠标移动到到指定元素 <div> 上时显示的提示。\n\n定位提示工具\n以下实例中，提示工具显示在指定元素的右侧(left:105%) 。\n\n注意 top:-5px 同于定位在容器元素的中间。使用数字 5 因为提示文本的顶部和底部的内边距（padding）是 5px。\n\n如果你修改 padding 的值，top 值也要对应修改，这样才可以确保它是居中对齐的。\n\n在提示框显示在左边的情况也是这个原理。\n\n显示在右侧：\n.tooltip .tooltiptext {\n    top: -5px;\n    left: 105%; \n}\n\n尝试一下 »\n\n显示在左侧：\n.tooltip .tooltiptext {\n    top: -5px;\n    right: 105%; \n}\n\n尝试一下 »\n如果你想要提示工具显示在头部和底部。我们需要使用 margin-left 属性，并设置为 -60px。 这个数字计算来源是使用宽度的一半来居中对齐，即： width/2 (120/2 = 60)。\n\n显示在头部：\n.tooltip .tooltiptext {\n    width: 120px;\n    bottom: 100%;\n    left: 50%; \n    margin-left: -60px; /* 使用一半宽度 (120/2 = 60) 来居中提示工具 */\n}\n\n尝试一下 »\n\n显示在底部：\n.tooltip .tooltiptext {\n    width: 120px;\n    top: 100%;\n    left: 50%; \n    margin-left: -60px; /* 使用一半宽度 (120/2 = 60) 来居中提示工具 */\n}\n\n尝试一下 »\n添加箭头\n我们可以用CSS 伪元素 ::after 及 content 属性为提示工具创建一个小箭头标志，箭头是由边框组成的，但组合起来后提示工具像个语音信息框。\n\n以下实例演示了如何为显示在顶部的提示工具添加底部箭头：\n\n顶部提示框/底部箭头：\n.tooltip .tooltiptext::after {\n    content: \" \";\n    position: absolute;\n    top: 100%; /* 提示工具底部 */\n    left: 50%;\n    margin-left: -5px;\n    border-width: 5px;\n    border-style: solid;\n    border-color: black transparent transparent transparent;\n}\n\n尝试一下 »\n实例解析\n在提示工具内定位箭头: top: 100% , 箭头将显示在提示工具的底部。left: 50% 用于居中对齐箭头。\n\n注意：border-width 属性指定了箭头的大小。如果你修改它，也要修改 margin-left 值。这样箭头在能居中显示。\n\nborder-color 用于将内容转换为箭头。设置顶部边框为黑色，其他是透明的。如果设置了其他的也是黑色则会显示为一个黑色的四边形。\n\n以下实例演示了如何在提示工具的头部添加箭头，注意设置边框颜色：\n\n底部提示框/顶部箭头：\n.tooltip .tooltiptext::after {\n    content: \" \";\n    position: absolute;\n    bottom: 100%;  /* 提示工具头部 */\n    left: 50%;\n    margin-left: -5px;\n    border-width: 5px;\n    border-style: solid;\n    border-color: transparent transparent black transparent;\n}\n\n尝试一下 »\n以下两个实例是左右两边的箭头实例：\n\n右侧提示框/左侧箭头：\n.tooltip .tooltiptext::after {\n    content: \" \";\n    position: absolute;\n    top: 50%;\n    right: 100%; /* 提示工具左侧 */\n    margin-top: -5px;\n    border-width: 5px;\n    border-style: solid;\n    border-color: transparent black transparent transparent;\n}\n\n尝试一下 »\n\n左侧提示框/右侧箭头：\n.tooltip .tooltiptext::after {\n    content: \" \";\n    position: absolute;\n    top: 50%;\n    left: 100%; /* 提示工具右侧 */\n    margin-top: -5px;\n    border-width: 5px;\n    border-style: solid;\n    border-color: transparent transparent transparent black;\n}\n\n尝试一下 »\n淡入效果\n我们可以使用 CSS3 transition 属性及 opacity 属性来实现提示工具的淡入效果:\n\n左侧提示框/右侧箭头：\n.tooltip .tooltiptext {\n    opacity: 0;\n    transition: opacity 1s;\n}\n \n.tooltip:hover .tooltiptext {\n    opacity: 1;\n}\n\n尝试一下 »\n更多实例\n漂亮的 CSS 提示框"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973618010},"updatedAt":{"$$date":1598974215386},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Oh7Im0gEIJZlGq7c"}
{"name":"HTML5 表单属性","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\nHTML5 表单属性\nHTML5 新的表单属性\nHTML5 的 <form> 和 <input>标签添加了几个新属性.\n\n<form>新属性：\n\nautocomplete\nnovalidate\n<input>新属性：\n\nautocomplete\nautofocus\nform\nformaction\nformenctype\nformmethod\nformnovalidate\nformtarget\nheight 与 width\nlist\nmin 与 max\nmultiple\npattern (regexp)\nplaceholder\nrequired\nstep\n<form> / <input> autocomplete 属性\nautocomplete 属性规定 form 或 input 域应该拥有自动完成功能。\n\n当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。\n\n提示: autocomplete 属性有可能在 form元素中是开启的，而在input元素中是关闭的。\n\n注意: autocomplete 适用于 <form> 标签，以及以下类型的 <input> 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\nHTML form 中开启 autocomplete (一个 input 字段关闭 autocomplete ):\n\n<form action=\"demo-form.php\" autocomplete=\"on\">\n  First name:<input type=\"text\" name=\"fname\"><br>\n  Last name: <input type=\"text\" name=\"lname\"><br>\n  E-mail: <input type=\"email\" name=\"email\" autocomplete=\"off\"><br>\n  <input type=\"submit\">\n</form>\n\n尝试一下 »\n提示:某些浏览器中，您可能需要启用自动完成功能，以使该属性生效。\n\n<form> novalidate 属性\nnovalidate 属性是一个 boolean(布尔) 属性.\n\nnovalidate 属性规定在提交表单时不应该验证 form 或 input 域。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n无需验证提交的表单数据\n\n<form action=\"demo-form.php\" novalidate>\n  E-mail: <input type=\"email\" name=\"user_email\">\n  <input type=\"submit\">\n</form>\n\n尝试一下 »\n\n<input> autofocus 属性\nautofocus 属性是一个 boolean 属性.\n\nautofocus 属性规定在页面加载时，域自动地获得焦点。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n让 \"First name\" input 输入域在页面载入时自动聚焦：\n\nFirst name:<input type=\"text\" name=\"fname\" autofocus>\n\n尝试一下 »\n\n<input> form 属性\nform 属性规定输入域所属的一个或多个表单。\n\n提示:如需引用一个以上的表单，请使用空格分隔的列表。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n位于form表单外的 input 字段引用了 HTML form (该 input 表单仍然属于form表单的一部分):\n\n<form action=\"demo-form.php\" id=\"form1\">\n  First name: <input type=\"text\" name=\"fname\"><br>\n  <input type=\"submit\" value=\"提交\">\n</form>\n \nLast name: <input type=\"text\" name=\"lname\" form=\"form1\">\n\n尝试一下 »\n\n<input> formaction 属性\nThe formaction 属性用于描述表单提交的URL地址.\n\nThe formaction 属性会覆盖<form> 元素中的action属性.\n\n注意: The formaction 属性用于 type=\"submit\" 和 type=\"image\".\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n以下HTMLform表单包含了两个不同地址的提交按钮：\n\n<form action=\"demo-form.php\">\n  First name: <input type=\"text\" name=\"fname\"><br>\n  Last name: <input type=\"text\" name=\"lname\"><br>\n  <input type=\"submit\" value=\"提交\"><br>\n  <input type=\"submit\" formaction=\"demo-admin.php\"\n  value=\"提交\">\n</form>\n\n尝试一下 »\n\n<input> formenctype 属性\nformenctype 属性描述了表单提交到服务器的数据编码 (只对form表单中 method=\"post\" 表单)\n\nformenctype 属性覆盖 form 元素的 enctype 属性。\n\n主要: 该属性与 type=\"submit\" 和 type=\"image\" 配合使用。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n第一个提交按钮已默认编码发送表单数据，第二个提交按钮以 \"multipart/form-data\" 编码格式发送表单数据:\n\n<form action=\"demo-post_enctype.php\" method=\"post\">\n  First name: <input type=\"text\" name=\"fname\"><br>\n  <input type=\"submit\" value=\"提交\">\n  <input type=\"submit\" formenctype=\"multipart/form-data\"\n  value=\"以 Multipart/form-data 提交\">\n</form>\n\n尝试一下 »\n\n<input> formmethod 属性\nformmethod 属性定义了表单提交的方式。\n\nformmethod 属性覆盖了 <form> 元素的 method 属性。\n\n注意: 该属性可以与 type=\"submit\" 和 type=\"image\" 配合使用。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n重新定义表单提交方式实例:\n\n<form action=\"demo-form.php\" method=\"get\">\n  First name: <input type=\"text\" name=\"fname\"><br>\n  Last name: <input type=\"text\" name=\"lname\"><br>\n  <input type=\"submit\" value=\"提交\">\n  <input type=\"submit\" formmethod=\"post\" formaction=\"demo-post.php\"\n  value=\"使用 POST 提交\">\n</form>\n\n尝试一下 »\n\n<input> formnovalidate 属性\nnovalidate 属性是一个 boolean 属性.\n\nnovalidate属性描述了 <input> 元素在表单提交时无需被验证。\n\nformnovalidate 属性会覆盖 <form> 元素的novalidate属性.\n\n注意: formnovalidate 属性与type=\"submit一起使用\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n两个提交按钮的表单(使用与不适用验证 ):\n\n<form action=\"demo-form.php\">\n  E-mail: <input type=\"email\" name=\"userid\"><br>\n  <input type=\"submit\" value=\"提交\"><br>\n  <input type=\"submit\" formnovalidate value=\"不验证提交\">\n</form>\n\n尝试一下 »\n\n<input> formtarget 属性\nformtarget 属性指定一个名称或一个关键字来指明表单提交数据接收后的展示。\n\nThe formtarget 属性覆盖 <form>元素的target属性.\n\n注意: formtarget 属性与type=\"submit\" 和 type=\"image\"配合使用.\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n两个提交按钮的表单, 在不同窗口中显示:\n\n<form action=\"demo-form.php\">\n  First name: <input type=\"text\" name=\"fname\"><br>\n  Last name: <input type=\"text\" name=\"lname\"><br>\n  <input type=\"submit\" value=\"正常提交\">\n  <input type=\"submit\" formtarget=\"_blank\"\n  value=\"提交到一个新的页面上\">\n</form>\n\n尝试一下 »\n\n<input> height 和 width 属性\nheight 和 width 属性规定用于 image 类型的 <input> 标签的图像高度和宽度。\n\n注意: height 和 width 属性只适用于 image 类型的<input> 标签。\n\n提示:图像通常会同时指定高度和宽度属性。如果图像设置高度和宽度，图像所需的空间 在加载页时会被保留。如果没有这些属性， 浏览器不知道图像的大小，并不能预留 适当的空间。图片在加载过程中会使页面布局效果改变 （尽管图片已加载）。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义了一个图像提交按钮, 使用了 height 和 width 属性:\n\n<input type=\"image\" src=\"img_submit.gif\" alt=\"Submit\" width=\"48\" height=\"48\">\n\n尝试一下 »\n\n<input> list 属性\nlist 属性规定输入域的 datalist。datalist 是输入域的选项列表。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n在 <datalist>中预定义 <input> 值:\n\n<input list=\"browsers\">\n\n<datalist id=\"browsers\">\n  <option value=\"Internet Explorer\">\n  <option value=\"Firefox\">\n  <option value=\"Chrome\">\n  <option value=\"Opera\">\n  <option value=\"Safari\">\n</datalist>\n\n尝试一下 »\n\n<input> min 和 max 属性\nmin、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。\n\n注意: min、max 和 step 属性适用于以下类型的 <input> 标签：date pickers、number 以及 range。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n<input> 元素最小值与最大值设置:\n\nEnter a date before 1980-01-01:\n<input type=\"date\" name=\"bday\" max=\"1979-12-31\">\n\nEnter a date after 2000-01-01:\n<input type=\"date\" name=\"bday\" min=\"2000-01-02\">\n\nQuantity (between 1 and 5):\n<input type=\"number\" name=\"quantity\" min=\"1\" max=\"5\">\n\n尝试一下 »\n\n<input> multiple 属性\nmultiple 属性是一个 boolean 属性.\n\nmultiple 属性规定<input> 元素中可选择多个值。\n\n注意: multiple 属性适用于以下类型的 <input> 标签：email 和 file:\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n上传多个文件:\n\nSelect images: <input type=\"file\" name=\"img\" multiple>\n\n尝试一下 »\n\n<input> pattern 属性\npattern 属性描述了一个正则表达式用于验证 <input> 元素的值。\n\n注意:pattern 属性适用于以下类型的 <input> 标签: text, search, url, tel, email, 和 password.\n\n提示： 是用来全局 title 属性描述了模式.\n\n提示： 您可以在我们的 JavaScript 教程中学习到有关正则表达式的内容\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n下面的例子显示了一个只能包含三个字母的文本域（不含数字及特殊字符）：\n\nCountry code: <input type=\"text\" name=\"country_code\" pattern=\"[A-Za-z]{3}\" title=\"Three letter country code\">\n\n尝试一下 »\n\n<input> placeholder 属性\nplaceholder 属性提供一种提示（hint），描述输入域所期待的值。\n\n简短的提示在用户输入值前会显示在输入域上。\n\n注意: placeholder 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email 以及 password。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\ninput 字段提示文本t:\n\n<input type=\"text\" name=\"fname\" placeholder=\"First name\">\n\n尝试一下 »\n\n<input> required 属性\nrequired 属性是一个 boolean 属性.\n\nrequired 属性规定必须在提交之前填写输入域（不能为空）。\n\n注意:required 属性适用于以下类型的 <input> 标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n不能为空的input字段:\n\nUsername: <input type=\"text\" name=\"usrname\" required>\n\n尝试一下 »\n\n<input> step 属性\nstep 属性为输入域规定合法的数字间隔。\n\n如果 step=\"3\"，则合法的数是 -3,0,3,6 等\n\n提示： step 属性可以与 max 和 min 属性创建一个区域值.\n\n注意: step 属性与以下type类型一起使用: number, range, date, datetime, datetime-local, month, time 和 week.\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n规定input step步长为3:\n\n<input type=\"number\" name=\"points\" step=\"3\">\n\n尝试一下 »\n\nHTML5 <input> 标签\n标签\t描述\n<form>\t定义一个form表单\n<input>\t定义一个 input 域\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887690837},"updatedAt":{"$$date":1598887885579},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"P0gYxjzuIhUg0UzM"}
{"name":"ad-kswebview","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName version\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    //testImplementation 只在单元测试代码的编译以及最终打包测试apk时有效。\n    testImplementation deps.androidx.junit\n    //androidTestImplementation 只在Android相关单元测试代码的编译以及最终打包测试apk时有效。\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    //为了解决 kotlin data class ,fastjson 解析报 defalut constructor not found错误\n    implementation deps.kotlin.kotlin_reflect\n    api deps.tecentX5\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nExtendedWebView\n\n\npublic class ExtendedWebView extends WebView implements KsWebController {\n\n    private boolean isScrollX = false;\n\n    public ExtendedWebView(Context context) {\n        super(getFixedContext(context));\n    }\n\n    public ExtendedWebView(Context context, AttributeSet attrs) {\n        super(getFixedContext(context), attrs);\n    }\n\n    public ExtendedWebView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(getFixedContext(context), attrs, defStyleAttr);\n    }\n\n    public ExtendedWebView(Context context, AttributeSet attrs, int defStyleAttr, boolean privateBrowsing) {\n        super(getFixedContext(context), attrs, defStyleAttr, privateBrowsing);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        if (event.getPointerCount() == 1) {\n            switch (event.getAction()) {\n                case MotionEvent.ACTION_DOWN:\n                    isScrollX = false;\n                    //事件由webview处理\n                    getParent().getParent()\n                            .requestDisallowInterceptTouchEvent(true);\n                    break;\n                case MotionEvent.ACTION_MOVE:\n                    //嵌套Viewpager时\n                    getParent().getParent()\n                            .requestDisallowInterceptTouchEvent(!isScrollX);\n                    break;\n                default:\n                    getParent().getParent()\n                            .requestDisallowInterceptTouchEvent(false);\n            }\n        } else {\n            //使webview可以双指缩放（前提是webview必须开启缩放功能，并且加载的网页也支持缩放）\n            getParent().getParent().\n                    requestDisallowInterceptTouchEvent(true);\n        }\n        return super.onTouchEvent(event);\n    }\n\n    //当webview滚动到边界时执行\n    @Override\n    protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY) {\n        super.onOverScrolled(scrollX, scrollY, clampedX, clampedY);\n        isScrollX = clampedX;\n    }\n\n    public static  Context getFixedContext(Context context) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {\n            return context.createConfigurationContext(new Configuration());\n        } else {\n            return context;\n        }\n    }\n\n\n    /**\n     * kscontroller  方法\n     *\n     * @param js\n     */\n    @Override\n    public void evaluateJavascript(@Nullable String js) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n            evaluateJavascript(js, null);\n        }\n    }\n}\n\n\n\n\n\n\n\n\npublic class ExtendedWebViewX5 extends com.tencent.smtt.sdk.WebView implements KsWebController {\n\n    private boolean isScrollX = false;\n\n    public ExtendedWebViewX5(Context context) {\n        super(context);\n    }\n\n    public ExtendedWebViewX5(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        touchDealWith(event);\n        return super.onTouchEvent(event);\n    }\n\n    @Override\n    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {\n        boolean ret = super.drawChild(canvas, child, drawingTime);\n        if (BuildConfig.DEBUG) {\n            canvas.save();\n            Paint paint = new Paint();\n            paint.setColor(0x7fff0000);\n            paint.setTextSize(24.f);\n            paint.setAntiAlias(true);\n            if (getX5WebViewExtension() != null) {\n                canvas.drawText(this.getContext().getPackageName() + \"-pid:\"\n                        + android.os.Process.myPid(), 10, 50, paint);\n                canvas.drawText(\n                        \"X5  Core:\" + QbSdk.getTbsVersion(this.getContext()), 10,\n                        100, paint);\n            } else {\n                canvas.drawText(this.getContext().getPackageName() + \"-pid:\"\n                        + android.os.Process.myPid(), 10, 50, paint);\n                canvas.drawText(\"Sys Core\", 10, 100, paint);\n            }\n            canvas.drawText(Build.MANUFACTURER, 10, 150, paint);\n            canvas.drawText(Build.MODEL, 10, 200, paint);\n            canvas.restore();\n        }\n        return ret;\n    }\n\n    private void touchDealWith(MotionEvent event) {\n        if (event.getPointerCount() == 1) {\n            switch (event.getAction()) {\n                case MotionEvent.ACTION_DOWN:\n                    isScrollX = false;\n                    //事件由webview处理\n                    getParent().getParent()\n                            .requestDisallowInterceptTouchEvent(true);\n                    break;\n                case MotionEvent.ACTION_MOVE:\n                    //嵌套Viewpager时\n                    getParent().getParent()\n                            .requestDisallowInterceptTouchEvent(!isScrollX);\n                    break;\n                default:\n                    getParent().getParent()\n                            .requestDisallowInterceptTouchEvent(false);\n            }\n        } else {\n            //使webview可以双指缩放（前提是webview必须开启缩放功能，并且加载的网页也支持缩放）\n            getParent().getParent().\n                    requestDisallowInterceptTouchEvent(true);\n        }\n    }\n\n    //当webview滚动到边界时执行\n    @Override\n    protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY) {\n        super.onOverScrolled(scrollX, scrollY, clampedX, clampedY);\n        isScrollX = clampedX;\n    }\n\n    @Override\n    public void evaluateJavascript(@Nullable String js) {\n        evaluateJavascript(js, null);\n    }\n}\n\n\n\n\n\n\n\n\n\n\npackage com.ks.kaishustory.webviews\n\ninterface KsWebController {\n\n    fun canGoBack(): Boolean\n\n    fun goBack()\n\n    fun setBackgroundColor(color: Int)\n\n    fun setVisibility(visibility: Int)\n\n    fun loadUrl(url: String?)\n\n    fun reload()\n\n    fun evaluateJavascript(js: String?)\n\n    fun removeAllViews();\n\n    fun destroy();\n\n    fun loadDataWithBaseURL(baseUrl: String?, data: String?, mimeType: String?, encoding: String?, historyUrl: String?);\n\n    fun loadUrl(url: String?, additionalHttpHeaders: Map<String?, String?>?)\n\n    fun getUrl(): String?\n\n    fun clearCache(includeDiskFiles: Boolean)\n}\n\n\n\n\n\n\n\n\npackage com.ks.kaishustory.webviews;\n\nimport android.content.Context;\nimport android.util.Log;\n\nimport com.tencent.smtt.export.external.TbsCoreSettings;\nimport com.tencent.smtt.sdk.QbSdk;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class WebViewX5Manager {\n\n\n    private static volatile WebViewX5Manager singletonLazy;\n\n    private WebViewX5Manager() {\n    }\n\n    public static WebViewX5Manager getInstance() {\n        if (null == singletonLazy) {\n            synchronized (WebViewX5Manager.class) {\n                if (null == singletonLazy) {\n                    singletonLazy = new WebViewX5Manager();\n                }\n            }\n        }\n        return singletonLazy;\n    }\n\n    /**\n     * x5 内核初始化\n     */\n    public void initX5Core(Context context) {\n        Map<String, Object> map = new HashMap<>();\n        map.put(TbsCoreSettings.TBS_SETTINGS_USE_SPEEDY_CLASSLOADER, true);\n        map.put(TbsCoreSettings.TBS_SETTINGS_USE_DEXLOADER_SERVICE, true);\n        QbSdk.initTbsSettings(map);\n        QbSdk.setDownloadWithoutWifi(true);\n        QbSdk.PreInitCallback cb = new QbSdk.PreInitCallback() {\n\n            @Override\n            public void onViewInitFinished(boolean arg0) {\n                //x5內核初始化完成的回调，为true表示x5内核加载成功，否则表示x5内核加载失败，会自动切换到系统内核。\n                Log.e(\"x5\", \" onViewInitFinished is \" + arg0);\n            }\n\n            @Override\n            public void onCoreInitFinished() {\n                Log.e(\"x5\", \" onCoreInitFinished is \");\n            }\n        };\n        //x5内核初始化接口\n        QbSdk.initX5Environment(context, cb);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598517294667},"updatedAt":{"$$date":1598518372809},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"PTN8E1fv1b3qUaQE"}
{"name":"kotlin-序列 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/sequences.html\n序列 - Kotlin 语言中文站\n12-14 minutes\n改进翻译\n除了集合之外，Kotlin 标准库还包含另一种容器类型——序列（Sequence<T>）。 序列提供与 Iterable 相同的函数，但实现另一种方法来进行多步骤集合处理。\n\n当 Iterable 的处理包含多个步骤时，它们会优先执行：每个处理步骤完成并返回其结果——中间集合。 在此集合上执行以下步骤。反过来，序列的多步处理在可能的情况下会延迟执行：仅当请求整个处理链的结果时才进行实际计算。\n\n操作执行的顺序也不同：Sequence 对每个元素逐个执行所有处理步骤。 反过来，Iterable 完成整个集合的每个步骤，然后进行下一步。\n\n因此，这些序列可避免生成中间步骤的结果，从而提高了整个集合处理链的性能。 但是，序列的延迟性质增加了一些开销，这些开销在处理较小的集合或进行更简单的计算时可能很重要。 因此，应该同时考虑使用 Sequence 与 Iterable，并确定在哪种情况更适合。\n\n要创建一个序列，请调用 sequenceOf() 函数，列出元素作为其参数。\n\n如果已经有一个 Iterable 对象（例如 List 或 Set），则可以通过调用 asSequence() 从而创建一个序列。\n\n创建序列的另一种方法是通过使用计算其元素的函数来构建序列。 要基于函数构建序列，请以该函数作为参数调用 generateSequence()。 （可选）可以将第一个元素指定为显式值或函数调用的结果。 当提供的函数返回 null 时，序列生成停止。因此，以下示例中的序列是无限的。\n\nfun main() {\n//sampleStart\n    val oddNumbers = generateSequence(1) { it + 2 } // `it` 是上一个元素\n    println(oddNumbers.take(5).toList())\n    //println(oddNumbers.count())     // 错误：此序列是无限的。\n//sampleEnd\n}\n要使用 generateSequence() 创建有限序列，请提供一个函数，该函数在需要的最后一个元素之后返回 null。\n\nfun main() {\n//sampleStart\n    val oddNumbersLessThan10 = generateSequence(1) { if (it < 10) it + 2 else null }\n    println(oddNumbersLessThan10.count())\n//sampleEnd\n}\n最后，有一个函数可以逐个或按任意大小的组块生成序列元素——sequence() 函数。 此函数采用一个 lambda 表达式，其中包含 yield() 与 yieldAll() 函数的调用。 它们将一个元素返回给序列使用者，并暂停 sequence() 的执行，直到使用者请求下一个元素。 yield() 使用单个元素作为参数；yieldAll() 中可以采用 Iterable 对象、Iterable 或其他 Sequence。yieldAll() 的 Sequence 参数可以是无限的。 当然，这样的调用必须是最后一个：之后的所有调用都永远不会执行。\n\nfun main() {\n//sampleStart\n    val oddNumbers = sequence {\n        yield(1)\n        yieldAll(listOf(3, 5))\n        yieldAll(generateSequence(7) { it + 2 })\n    }\n    println(oddNumbers.take(5).toList())\n//sampleEnd\n}\n关于序列操作，根据其状态要求可以分为以下几类：\n\n无状态 操作不需要状态，并且可以独立处理每个元素，例如 map() 或 filter()。 无状态操作还可能需要少量常数个状态来处理元素，例如 take() 与 drop()。\n有状态 操作需要大量状态，通常与序列中元素的数量成比例。\n如果序列操作返回延迟生成的另一个序列，则称为 中间序列。 否则，该操作为 末端 操作。 末端操作的示例为 toList() 或 sum()。只能通过末端操作才能检索序列元素。\n\n序列可以多次迭代；但是，某些序列实现可能会约束自己仅迭代一次。其文档中特别提到了这一点。\n\n我们通过一个示例来看 Iterable 与 Sequence 之间的区别。\n\n假定有一个单词列表。下面的代码过滤长于三个字符的单词，并打印前四个单词的长度。\n\nfun main() {    \n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    val lengthsList = words.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars:\")\n    println(lengthsList)\n//sampleEnd\n}\n运行此代码时，会看到 filter() 与 map() 函数的执行顺序与代码中出现的顺序相同。 首先，将看到 filter：对于所有元素，然后是 length：对于在过滤之后剩余的元素，然后是最后两行的输出。 列表处理如下图：\n\nList processing\n\n现在用序列写相同的逻辑：\n\nfun main() {\n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    // 将列表转换为序列\n    val wordsSequence = words.asSequence()\n\n    val lengthsSequence = wordsSequence.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars\")\n    // 末端操作：以列表形式获取结果。\n    println(lengthsSequence.toList())\n//sampleEnd\n}\n此代码的输出表明，仅在构建结果列表时才调用 filter() 与 map() 函数。 因此，首先看到文本 “Lengths of..” 的行，然后开始进行序列处理。 请注意，对于过滤后剩余的元素，映射在过滤下一个元素之前执行。 当结果大小达到 4 时，处理将停止，因为它是 take(4) 可以返回的最大大小。\n\n序列处理如下图：\n\nSequences processing\n\n在此示例中，序列处理需要 18 个步骤，而不是 23 个步骤来执行列表操作。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308433775},"updatedAt":{"$$date":1597377586640},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"PUXVQiLpwgam4dbd"}
{"name":"ad-kszxing","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n}\n\ndependencies {\n    api fileTree(include: ['*.jar'], dir: 'libs')\n//    androidTestCompile(deps.spresso_core, {\n//        exclude group: 'com.android.support', module: 'support-annotations'\n//    })\n    implementation files('libs/zxing.jar')\n    implementation deps.androidx.app_compat\n    implementation deps.androidx.support_v4\n    testImplementation deps.androidx.junit\n}\n\next {\n    PUBLISH_GROUP_ID = 'cn.yipianfengye.android'\n    PUBLISH_ARTIFACT_ID = 'zxing-library'\n    PUBLISH_VERSION = '2.1'\n}\n\n//apply from: 'https://raw.githubusercontent.com/blundell/release-android-library/master/android-release-aar.gradle'\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 自定义实现的扫描Fragment\n */\npublic class CaptureFragment extends Fragment implements SurfaceHolder.Callback {\n\n    private CaptureActivityHandler handler;\n    private ViewfinderView viewfinderView;\n    private boolean hasSurface;\n    private Vector<BarcodeFormat> decodeFormats;\n    private String characterSet;\n    private InactivityTimer inactivityTimer;\n    private MediaPlayer mediaPlayer;\n    private boolean playBeep;\n    private static final float BEEP_VOLUME = 0.10f;\n    private boolean vibrate;\n    private SurfaceView surfaceView;\n    private SurfaceHolder surfaceHolder;\n    private CodeUtils.AnalyzeCallback analyzeCallback;\n    private Camera camera;\n    private boolean isLight;\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n\n        CameraManager.init(getActivity().getApplication());\n\n        hasSurface = false;\n        inactivityTimer = new InactivityTimer(this.getActivity());\n    }\n\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n\n        Bundle bundle = getArguments();\n        View view = null;\n        if (bundle != null) {\n            int layoutId = bundle.getInt(CodeUtils.LAYOUT_ID);\n            if (layoutId != -1) {\n                view = inflater.inflate(layoutId, null);\n            }\n        }\n\n\n        if (view == null) {\n            view = inflater.inflate(R.layout.fragment_capture, null);\n        }\n\n        viewfinderView = (ViewfinderView) view.findViewById(R.id.viewfinder_view);\n        surfaceView = (SurfaceView) view.findViewById(R.id.preview_view);\n        View back = view.findViewById(R.id.tvBack);\n        View tvLight = view.findViewById(R.id.tvLight);\n        if (null != back) {\n            back.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    if (null != getActivity()) {\n                        getActivity().finish();\n                    }\n                }\n            });\n        }\n        if (null != tvLight) {\n            tvLight.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    isLight = !isLight;\n                    CodeUtils.isLightEnable(isLight);\n\n                }\n            });\n        }\n        surfaceHolder = surfaceView.getHolder();\n\n        return view;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        if (hasSurface) {\n            initCamera(surfaceHolder);\n        } else {\n            surfaceHolder.addCallback(this);\n            surfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);\n        }\n        decodeFormats = null;\n        characterSet = null;\n\n        playBeep = true;\n        AudioManager audioService = (AudioManager) getActivity().getSystemService(getActivity().AUDIO_SERVICE);\n        if (audioService.getRingerMode() != AudioManager.RINGER_MODE_NORMAL) {\n            playBeep = false;\n        }\n        initBeepSound();\n        vibrate = true;\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        if (handler != null) {\n            handler.quitSynchronously();\n            handler = null;\n        }\n        CameraManager.get().closeDriver();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        inactivityTimer.shutdown();\n        super.onDestroy();\n    }\n\n\n    /**\n     * Handler scan result\n     *\n     * @param result\n     * @param barcode\n     */\n    public void handleDecode(Result result, Bitmap barcode) {\n        inactivityTimer.onActivity();\n        playBeepSoundAndVibrate();\n\n        if (result == null || TextUtils.isEmpty(result.getText())) {\n            if (analyzeCallback != null) {\n                analyzeCallback.onAnalyzeFailed();\n            }\n        } else {\n            if (analyzeCallback != null) {\n                analyzeCallback.onAnalyzeSuccess(barcode, result.getText());\n            }\n        }\n    }\n\n    private void initCamera(SurfaceHolder surfaceHolder) {\n        try {\n            CameraManager.get().openDriver(surfaceHolder);\n            camera = CameraManager.get().getCamera();\n        } catch (IOException ioe) {\n            return;\n        } catch (RuntimeException e) {\n            return;\n        }\n        if (handler == null) {\n            handler = new CaptureActivityHandler(this, decodeFormats, characterSet, viewfinderView);\n        }\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width,\n                               int height) {\n\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {\n        if (!hasSurface) {\n            hasSurface = true;\n            initCamera(holder);\n        }\n\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        try {\n            hasSurface = false;\n            if (camera != null) {\n                if (camera != null && CameraManager.get().isPreviewing()) {\n                    if (!CameraManager.get().isUseOneShotPreviewCallback()) {\n                        camera.setPreviewCallback(null);\n                    }\n\n                    holder.removeCallback(this);\n                    camera.stopPreview();\n                    CameraManager.get().getPreviewCallback().setHandler(null, 0);\n                    CameraManager.get().getAutoFocusCallback().setHandler(null, 0);\n                    CameraManager.get().setPreviewing(false);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public Handler getHandler() {\n        return handler;\n    }\n\n    public void drawViewfinder() {\n        viewfinderView.drawViewfinder();\n\n    }\n\n    private void initBeepSound() {\n        if (playBeep && mediaPlayer == null) {\n            // The volume on STREAM_SYSTEM is not adjustable, and users found it\n            // too loud,\n            // so we now play on the music stream.\n            getActivity().setVolumeControlStream(AudioManager.STREAM_MUSIC);\n            mediaPlayer = new MediaPlayer();\n            mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n            mediaPlayer.setOnCompletionListener(beepListener);\n\n            AssetFileDescriptor file = getResources().openRawResourceFd(\n                    R.raw.beep);\n            try {\n                mediaPlayer.setDataSource(file.getFileDescriptor(),\n                        file.getStartOffset(), file.getLength());\n                file.close();\n                mediaPlayer.setVolume(BEEP_VOLUME, BEEP_VOLUME);\n                mediaPlayer.prepare();\n            } catch (IOException e) {\n                mediaPlayer = null;\n            }\n        }\n    }\n\n    private static final long VIBRATE_DURATION = 200L;\n\n    private void playBeepSoundAndVibrate() {\n        if (playBeep && mediaPlayer != null) {\n            mediaPlayer.start();\n        }\n        if (vibrate) {\n            Vibrator vibrator = (Vibrator) getActivity().getSystemService(getActivity().VIBRATOR_SERVICE);\n            vibrator.vibrate(VIBRATE_DURATION);\n        }\n    }\n\n    /**\n     * When the beep has finished playing, rewind to queue up another one.\n     */\n    private final MediaPlayer.OnCompletionListener beepListener = new MediaPlayer.OnCompletionListener() {\n        public void onCompletion(MediaPlayer mediaPlayer) {\n            mediaPlayer.seekTo(0);\n        }\n    };\n\n    public CodeUtils.AnalyzeCallback getAnalyzeCallback() {\n        return analyzeCallback;\n    }\n\n    public void setAnalyzeCallback(CodeUtils.AnalyzeCallback analyzeCallback) {\n        this.analyzeCallback = analyzeCallback;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\npublic class ZXingLibrary {\n\n    public static void initDisplayOpinion(Context context) {\n        if (context == null) {\n            return;\n        }\n        DisplayMetrics dm = context.getResources().getDisplayMetrics();\n        DisplayUtil.density = dm.density;\n        DisplayUtil.densityDPI = dm.densityDpi;\n        DisplayUtil.screenWidthPx = dm.widthPixels;\n        DisplayUtil.screenhightPx = dm.heightPixels;\n        DisplayUtil.screenWidthDip = DisplayUtil.px2dip(context, dm.widthPixels);\n        DisplayUtil.screenHightDip = DisplayUtil.px2dip(context, dm.heightPixels);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * Initial the camera\n *\n * 默认的二维码扫描Activity\n */\npublic class CaptureActivity extends AppCompatActivity {\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.camera);\n        CaptureFragment captureFragment = new CaptureFragment();\n        captureFragment.setAnalyzeCallback(analyzeCallback);\n        getSupportFragmentManager().beginTransaction().replace(R.id.fl_zxing_container, captureFragment).commit();\n    }\n\n    /**\n     * 二维码解析回调函数\n     */\n    CodeUtils.AnalyzeCallback analyzeCallback = new CodeUtils.AnalyzeCallback() {\n        @Override\n        public void onAnalyzeSuccess(Bitmap mBitmap, String result) {\n            Intent resultIntent = new Intent();\n            Bundle bundle = new Bundle();\n            bundle.putInt(CodeUtils.RESULT_TYPE, CodeUtils.RESULT_SUCCESS);\n            bundle.putString(CodeUtils.RESULT_STRING, result);\n            resultIntent.putExtras(bundle);\n            CaptureActivity.this.setResult(RESULT_OK, resultIntent);\n            CaptureActivity.this.finish();\n        }\n\n        @Override\n        public void onAnalyzeFailed() {\n            Intent resultIntent = new Intent();\n            Bundle bundle = new Bundle();\n            bundle.putInt(CodeUtils.RESULT_TYPE, CodeUtils.RESULT_FAILED);\n            bundle.putString(CodeUtils.RESULT_STRING, \"\");\n            resultIntent.putExtras(bundle);\n            CaptureActivity.this.setResult(RESULT_OK, resultIntent);\n            CaptureActivity.this.finish();\n        }\n    };\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class DisplayUtil\n{\n\n    public static int screenWidthPx; //屏幕宽 px\n    public static int screenhightPx; //屏幕高 px\n    public static float density;//屏幕密度\n    public static int densityDPI;//屏幕密度\n    public static float screenWidthDip;//  dp单位\n    public static float screenHightDip;//  dp单位\n\n\n//\n//    /**\n//     * 根据手机的分辨率从 dp 的单位 转成为 px(像素)\n//     */\n//    public static int dip2px(Context context, float dpValue) {\n//        final float scale = context.getResources().getDisplayMetrics().density;\n//        return (int) (dpValue * scale + 0.5f);\n//    }\n\n    /**\n     * 根据手机的分辨率从 px(像素) 的单位 转成为 dp\n     */\n    public static int px2dip(Context context, float pxValue) {\n        final float scale = context.getResources().getDisplayMetrics().density;\n        return (int) (pxValue / scale + 0.5f);\n    }\n\n}\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598517305862},"updatedAt":{"$$date":1598520099909},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"PZmsfzNMwtjBZxj8"}
{"name":"andr-资源类型概览","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/available-resources\n资源类型概览  |  Android 开发者  |  Android Developers\n2-2 minutes\n本部分中的每个页面介绍了一种您可以在项目资源目录 (res/) 中提供的应用资源的用法、格式和语法。\n\n以下是对每个页面的简要说明：\n\n动画资源\n定义预先确定的动画。\n补间动画保存在 res/anim/ 中并通过 R.anim 类访问。\n帧动画保存在 res/drawable/ 中并通过 R.drawable 类访问。\n颜色状态列表资源\n定义根据 View 状态而变化的颜色资源。\n保存在 res/color/ 中并通过 R.color 类访问。\n可绘制资源\n使用位图或 XML 定义各种图形。\n保存在 res/drawable/ 中并通过 R.drawable 类访问。\n布局资源\n定义应用界面的布局。\n保存在 res/layout/ 中并通过 R.layout 类访问。\n菜单资源\n定义应用菜单的内容。\n保存在 res/menu/ 中并通过 R.menu 类访问。\n字符串资源\n定义字符串、字符串数组和复数形式（并包括字符串格式和样式）。\n保存在 res/values/ 中，并通过 R.string、R.array 和 R.plurals 类访问。\n样式资源\n定义界面元素的外观和格式。\n保存在 res/values/ 中并通过 R.style 类访问。\n字体资源\n在 XML 中定义字体系列并包含自定义字体。\n保存在 res/font/ 中并通过 R.font 类访问。\n更多资源类型\n将其他原始值定义为静态资源，具体包括：\nBool\n包含布尔值的 XML 资源。\n颜色\n包含颜色值（十六进制颜色）的 XML 资源。\n维度\n包含维度值（及度量单位）的 XML 资源。\nID\n为应用资源和组件提供唯一标识符的 XML 资源。\n整数\n包含整数值的 XML 资源。\n整数数组\n提供整数数组的 XML 资源。\n类型化数组\n提供 TypedArray（可用于可绘制对象数组）的 XML 资源。\nContent and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2020-01-07 UTC."}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242328605},"updatedAt":{"$$date":1597242364810},"_id":"Paf5uvbk5k9KKmfg","folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-添加构建依赖项 ","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\ndeveloper.android.com /studio/build/dependencies\n添加构建依赖项  |  Android 开发者  |  Android Developers\n20-25 minutes\n利用 Android Studio 中的 Gradle 构建系统，您可以轻松地将外部二进制文件或其他库模块作为依赖项添加到您的 build 中。这些依赖项可位于您的计算机上或远程代码库中，并且它们声明的所有传递依赖项也会自动包含在内。本页介绍了如何在您的 Android 项目中使用依赖项，包括有关 Android Plugin for Gradle 特有的行为和配置的详细信息。如需更深入地了解 Gradle 依赖项的概念，您还应该参阅 Gradle 依赖项管理指南。但请注意，您的 Android 项目只能使用本页上定义的依赖项配置。\n\n依赖项类型\n如需向您的项目添加依赖项，请在 build.gradle 文件的 dependencies 代码块中指定依赖项配置，如 implementation。\n\n例如，应用模块的以下 build.gradle 文件包含三种不同类型的依赖项：\n\napply plugin: 'com.android.application'\nandroid \n\n{ ... }\ndependencies \n\n{\n    // Dependency on a local library module\n    implementation project(\":mylibrary\")// Dependency on local binaries\n    implementation fileTree(dir: 'libs', include: ['*.jar'])// Dependency on a remote binary\n    implementation 'com.example.android:app-magic:12.3'\n}\n其中每种依赖项配置都请求不同种类的库依赖项，如下所示：\n\n本地库模块依赖项\nimplementation project(':mylibrary')\n这声明了对一个名为“mylibrary”（此名称必须与在您的 settings.gradle 文件中使用 include: 定义的库名称相符）的 Android 库模块的依赖关系。在构建您的应用时，构建系统会编译该库模块，并将生成的编译内容打包到 APK 中。\n\n本地二进制文件依赖项\nimplementation fileTree(dir: 'libs', include: ['*.jar'])\nGradle 声明了对项目的 module_name/libs/ 目录中 JAR 文件的依赖关系（因为 Gradle 会读取 build.gradle 文件的相对路径）。\n\n或者，您也可以按如下方式指定各个文件：\n\nimplementation files('libs/foo.jar', 'libs/bar.jar')\n远程二进制文件依赖项\nimplementation 'com.example.android:app-magic:12.3'\n这实际上是以下代码的简写形式：\n\nimplementation group: 'com.example.android', name: 'app-magic', version: '12.3'\n这声明了对“com.example.android”命名空间组内的 12.3 版“app-magic”库的依赖关系。\n\n注意：此类远程依赖项要求您声明适当的远程代码库，Gradle 应在其中查找相应的库。如果本地不存在相应的库，那么当 build 需要它时（例如，当您点击 Sync Project with Gradle Files 图标  或运行 build 时），Gradle 会从远程站点提取它。\n\n原生依赖项\n从 Android Gradle 插件 4.0 开始，也可以按照本文档所述的方式导入原生依赖项。\n\n根据公开原生库的 AAR，原生依赖项将自动提供给 externalNativeBuild 所使用的构建系统。如要从代码访问这些库，您必须在原生构建脚本中链接到这些库。如需了解详情，请参阅使用原生依赖项。\n\n依赖项配置\n在 dependencies 代码块内，您可以从多种不同的依赖项配置中选择其一（如上面所示的 implementation）来声明库依赖项。每种依赖项配置都向 Gradle 提供了有关如何使用该依赖项的不同说明。下表介绍了您可以对 Android 项目中的依赖项使用的各种配置。此表还将这些配置与自 Android Gradle 插件 3.0.0 起弃用的配置进行了比较。\n\n新配置\t已弃用配置\t行为\nimplementation\tcompile\tGradle 会将依赖项添加到编译类路径，并将依赖项打包到构建输出。不过，当您的模块配置 implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。\n使用此依赖项配置代替 api 或 compile（已弃用）可以显著缩短构建时间，因为这样可以减少构建系统需要重新编译的模块数。例如，如果 implementation 依赖项更改了其 API，Gradle 只会重新编译该依赖项以及直接依赖于它的模块。大多数应用和测试模块都应使用此配置。\n\napi\tcompile\tGradle 会将依赖项添加到编译类路径和构建输出。当一个模块包含 api 依赖项时，会让 Gradle 了解该模块要以传递方式将该依赖项导出到其他模块，以便这些模块在运行时和编译时都可以使用该依赖项。\n此配置的行为类似于 compile（现已弃用），但使用它时应格外小心，只能对您需要以传递方式导出到其他上游消费者的依赖项使用它。这是因为，如果 api 依赖项更改了其外部 API，Gradle 会在编译时重新编译所有有权访问该依赖项的模块。因此，拥有大量的 api 依赖项会显著增加构建时间。除非要将依赖项的 API 公开给单独的模块，否则库模块应改用 implementation 依赖项。\n\ncompileOnly\tprovided\tGradle 只会将依赖项添加到编译类路径（也就是说，不会将其添加到构建输出）。如果您创建 Android 模块时在编译期间需要相应依赖项，但它在运行时可有可无，此配置会很有用。\n如果您使用此配置，那么您的库模块必须包含一个运行时条件，用于检查是否提供了相应依赖项，然后适当地改变该模块的行为，以使该模块在未提供相应依赖项的情况下仍可正常运行。这样做不会添加不重要的瞬时依赖项，因而有助于减小最终 APK 的大小。此配置的行为类似于 provided（现已弃用）。\n\n注意：您不能将 compileOnly 配置与 AAR 依赖项配合使用。\n\nruntimeOnly\tapk\tGradle 只会将依赖项添加到构建输出，以便在运行时使用。也就是说，不会将其添加到编译类路径。此配置的行为类似于 apk（现已弃用）。\nannotationProcessor\tcompile\t如需添加对作为注释处理器的库的依赖关系，您必须使用 annotationProcessor 配置将其添加到注释处理器类路径。这是因为，使用此配置可以将编译类路径与注释处理器类路径分开，从而提高构建性能。如果 Gradle 在编译类路径上找到注释处理器，则会禁用避免编译功能，这样会对构建时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注释处理器）。 如果 JAR 文件包含以下文件，则 Android Gradle 插件会假定依赖项是注释处理器：\nMETA-INF/services/javax.annotation.processing.Processor。如果插件检测到编译类路径上包含注释处理器，则会生成构建错误。\nlintChecks\t\t使用此配置可以添加您希望 Gradle 在构建项目时执行的 lint 检查。\n注意：使用 Android Gradle 插件 3.4.0 及更高版本时，此依赖项配置不再将 lint 检查打包在 Android 库项目中。如需将 lint 检查依赖项包含在 AAR 库中，请使用下面介绍的 lintPublish 配置。\n\nlintPublish\t\t在 Android 库项目中使用此配置可以添加您希望 Gradle 编译成 lint.jar 文件并打包在 AAR 中的 lint 检查。这会使得使用 AAR 的项目也应用这些 lint 检查。如果您之前使用 lintChecks 依赖项配置将 lint 检查包含在已发布的 AAR 中，则需要迁移这些依赖项以改用 lintPublish 配置。\ndependencies {\n  // Executes lint checks from the ':checks' project\n  // at build time.\n  lintChecks project(':checks')\n  // Compiles lint checks from the ':checks-to-publish'\n  // into a lint.jar file and publishes it to your\n  // Android library.\n  lintPublish project(':checks-to-publish')\n}\n以上配置会将依赖项应用于所有构建变体。如果您只想为特定的构建变体源代码集或测试源代码集声明依赖项，则必须将配置名称的首字母大写，并在其前面加上构建变体或测试源代码集的名称作为前缀。\n\n例如，如需只向“free”产品变种添加 implementation 依赖项（使用远程二进制文件依赖项），请使用如下所示的代码：\n\ndependencies {\n    freeImplementation 'com.google.firebase:firebase-ads:9.8.0'\n}\n不过，如果您想为将产品变种和构建类型组合在一起的变体添加依赖项，就必须在 configurations 代码块中初始化配置名称。以下示例向“freeDebug”构建变体添加了 runtimeOnly 依赖项（使用本地二进制文件依赖项）：\n\nconfigurations {\n    // Initializes a placeholder for the freeDebugRuntimeOnly dependency\n    // configuration.\n    freeDebugRuntimeOnly {}\n}\ndependencies \n\n{\n    freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])\n}\n如需为本地测试和插桩测试添加 implementation 依赖项，请使用如下所示的代码：\n\ndependencies {\n    // Adds a remote binary dependency only for local tests.\n    testImplementation 'junit:junit:4.12'// Adds a remote binary dependency only for the instrumented test APK.\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n}\n不过，某些配置在这种情况下没有意义。例如，因为其他模块不能依赖于 androidTest，所以如果您使用 androidTestApi 配置，会收到以下警告：\n\nWARNING: Configuration 'androidTestApi' is obsolete and has been replaced with\n'androidTestImplementation'.\n添加注释处理器\n如果将注释处理器添加到编译类路径，您将看到一条与以下内容类似的错误消息：\n\nError: Annotation processors must be explicitly declared now.\n如需解决此错误，请使用 annotationProcessor 配置依赖项，以将注释处理器添加到您的项目，如下所示：\n\ndependencies {\n    // Adds libraries defining annotations to only the compile classpath.\n    compileOnly 'com.google.dagger:dagger:version-number'\n    // Adds the annotation processor dependency to the annotation processor classpath.\n    annotationProcessor 'com.google.dagger:dagger-compiler:version-number'\n}\n注意：Android Plugin for Gradle 3.0.0 及更高版本不再支持 android-apt 插件。\n\n向注释处理器传递参数\n如果需要向注释处理器传递参数，您可以使用模块构建配置中的 AnnotationProcessorOptions 代码块执行此操作。例如，如果要以键值对形式传递基元数据类型，您可以使用 argument 属性，如下所示：\n\nandroid {\n    ...\n    defaultConfig {\n        ...\n        javaCompileOptions {\n            annotationProcessorOptions {\n                argument \"key1\", \"value1\"\n                argument \"key2\", \"value2\"\n            }\n        }\n    }\n}\n不过，在使用 Android Gradle 插件 3.2.0 及更高版本时，您需要使用 Gradle 的 CommandLineArgumentProvider 接口传递表示文件或目录的处理器参数。\n\n使用 CommandLineArgumentProvider 可让您或注释处理器作者将增量构建属性类型注释应用于每个参数，从而提高增量构建和缓存整洁构建的正确性和性能。\n\n例如，下面的类实现了 CommandLineArgumentProvider 并注释了处理器的每个参数。此外，此示例还使用了 Groovy 语言语法，并且直接包含在模块的 build.gradle 文件中。\n\nclass MyArgsProvider implements CommandLineArgumentProvider {// Annotates each directory as either an input or output for the\n    // annotation processor.\n    @InputFiles\n    // Using this annotation helps Gradle determine which part of the file path\n    // should be considered during up-to-date checks.\n    @PathSensitive(PathSensitivity.RELATIVE)\n    FileCollection inputDir@OutputDirectory\n    File outputDir// The class constructor sets the paths for the input and output directories.\n    MyArgsProvider(FileCollection input, File output) {\n        inputDir = input\n        outputDir = output\n    }// Specifies each directory as a command line argument for the processor.\n    // The Android plugin uses this method to pass the arguments to the\n    // annotation processor.\n    @Override\n    Iterable<String> asArguments() {\n        // Use the form '-Akey[=value]' to pass your options to the Java compiler.\n        [\"-AinputDir=${inputDir.singleFile.absolutePath}\",\n         \"-AoutputDir=${outputDir.absolutePath}\"]\n    }\n}\nandroid \n\n{...}\n创建一个实现 CommandLineArgumentProvider 的类后，您需要对其进行初始化并使用 annotationProcessorOptions.compilerArgumentProvider 属性将其传递给 Android 插件，如下所示。\n\n// This is in your module's build.gradle file.\nandroid {\n    defaultConfig {\n        javaCompileOptions {\n            annotationProcessorOptions {\n                // Creates a new MyArgsProvider object, specifies the input and\n                // output paths for the constructor, and passes the object\n                // to the Android plugin.\n                compilerArgumentProvider new MyArgsProvider(files(\"input/path\"),\n                                         new File(\"output/path\"))\n            }\n        }\n    }\n}\n如需详细了解实现 CommandLineArgumentProvider 如何帮助提高构建性能，请阅读缓存 Java 项目。\n\n停用注释处理器错误检查\n如果编译类路径中的依赖项包含您不需要的注释处理器，您可以通过将以下代码添加到 build.gradle 文件来停用错误检查。请注意，您添加到编译类路径中的注释处理器仍不会被添加到处理器类路径中。\n\nandroid {\n    ...\n    defaultConfig {\n        ...\n        javaCompileOptions {\n            annotationProcessorOptions {\n                includeCompileClasspath false\n            }\n        }\n    }\n}\n如果在将项目的注释处理器迁移到处理器类路径后遇到问题，您可以通过将 includeCompileClasspath 设为 true，允许编译类路径中包含注释处理器。不过，不建议将此属性设为 true，在 Android 插件的未来更新中将会移除用来执行此操作的选项。\n\n排除传递依赖项\n随着应用的范围不断扩大，它可能会包含许多依赖项，包括直接依赖项和传递依赖项（应用中导入的库所依赖的库）。如需排除不再需要的传递依赖项，您可以使用 exclude 关键字，如下所示：\n\ndependencies {\n    implementation('some-library') {\n        exclude group: 'com.example.imgtools', module: 'native'\n    }\n}\n从测试配置中排除传递依赖项\n如果您需要从测试中排除某些传递依赖项，上面所示的代码示例可能无法按预期发挥作用。这是因为，测试配置（例如 androidTestImplementation）扩展了模块的 implementation 配置。也就是说，当 Gradle 解析配置时，测试配置始终包含 implementation 依赖项。\n\n因此，如需从测试中排除传递依赖项，必须在执行代码时执行此操作，如下所示：\n\nandroid.testVariants.all { variant ->\n    variant.getCompileConfiguration().exclude group: 'com.jakewharton.threetenabp', module: 'threetenabp'\n    variant.getRuntimeConfiguration().exclude group: 'com.jakewharton.threetenabp', module: 'threetenabp'\n}\n注意：您仍可在依赖项代码块中使用 exclude 关键字（如排除依赖项部分的原始代码示例所示），以省略测试配置特有的传递依赖项，也就是其他配置不包含的传递依赖项。\n\n使用变体感知型依赖项管理机制\nAndroid 插件 3.0.0 及更高版本包含一种新的依赖项机制，该机制可在使用库时自动匹配变体。这意味着，应用的 debug 变体会自动使用库的 debug 变体，依此类推。在使用变种时，这种机制也同样适用 - 应用的 freeDebug 变体将使用库的 freeDebug 变体。\n\n为了让插件准确匹配变体，您需要在无法进行直接匹配的情况下提供匹配回退机制。不妨假设您的应用配置了一个名为“staging”的构建类型，但该应用的一个库依赖项没有进行相应配置。当插件尝试构建“staging”版本的应用时，它不知道要使用哪个版本的库，因此您将看到一条与以下内容类似的错误消息：\n\nError:Failed to resolve: Could not resolve project :mylibrary.\nRequired by:\n    project :app\n解决与变体匹配相关的构建错误\n插件包含一些 DSL 元素，这些元素有助于控制 Gradle 应如何解决应用与依赖项之间无法进行直接变体匹配的问题。请参阅下表，以确定应使用哪个 DSL 属性来解决与变体感知依赖项匹配相关的特定编译错误。\n\n编译错误原因\t解决方案\n您的应用包含库依赖项不包含的构建类型。\n\n例如，您的应用包含“staging”版本类型，但依赖项仅包含“debug”和“release”版本类型。\n\n请注意，如果库依赖项包含您的应用不包含的编译类型，这不会引发问题。这是因为，插件在任何时候都不会从依赖项请求该构建类型。\n\n使用 matchingFallbacks 为给定的构建类型指定替代匹配，如下所示：\n\n\n// In the app's build.gradle file.\nandroid {\n    buildTypes {\n        debug {}\n        release {}\n        staging {\n            // Specifies a sorted list of fallback build types that the\n            // plugin should try to use when a dependency does not include a\n            // \"staging\" build type. You may specify as many fallbacks as you\n            // like, and the plugin selects the first build type that's\n            // available in the dependency.\n            matchingFallbacks = ['debug', 'qa', 'release']\n        }\n    }\n}\n对于应用及其库依赖项中均存在的给定变种维度，您的应用包含库不包含的变种。\n\n例如，您的应用及其库依赖项都包含“tier”变种维度。不过，应用中的“tier”维度包含“free”和“paid”变种，但依赖项中的同一维度仅包含“demo”和“paid”变种。\n\n请注意，对于应用及其库依赖项中均存在的给定变种维度，如果库包含您的应用不包含的产品变种，这不会引发问题。这是因为，插件在任何时候都不会从依赖项请求该变种。\n\n使用 matchingFallbacks 为应用的“free”产品变种指定替代匹配，如下所示：\n\n\n// In the app's build.gradle file.\nandroid {\n    defaultConfig{\n    // Do not configure matchingFallbacks in the defaultConfig block.\n    // Instead, you must specify fallbacks for a given product flavor in the\n    // productFlavors block, as shown below.\n  }\n    flavorDimensions 'tier'\n    productFlavors {\n        paid {\n            dimension 'tier'\n            // Because the dependency already includes a \"paid\" flavor in its\n            // \"tier\" dimension, you don't need to provide a list of fallbacks\n            // for the \"paid\" flavor.\n        }\n        free {\n            dimension 'tier'\n            // Specifies a sorted list of fallback flavors that the plugin\n            // should try to use when a dependency's matching dimension does\n            // not include a \"free\" flavor. You may specify as many\n            // fallbacks as you like, and the plugin selects the first flavor\n            // that's available in the dependency's \"tier\" dimension.\n            matchingFallbacks = ['demo', 'trial']\n        }\n    }\n}\n库依赖项包含您的应用不包含的变种维度。\n\n例如，库依赖项包含“minApi”维度的变种，但您的应用仅包含“tier”维度的变种。因此，当您要构建“freeDebug”版本的应用时，插件不知道是使用“minApi23Debug”还是“minApi18Debug”版本的依赖项。\n\n请注意，如果您的应用包含库依赖项不包含的变种维度，这不会引发问题。这是因为，插件只会匹配依赖项中存在的维度的变种。例如，如果依赖项不包含 ABI 的维度，“freeX86Debug”版本的应用将直接使用“freeDebug”版本的依赖项。\n\n在 defaultConfig 代码块中使用 missingDimensionStrategy 指定插件应从每个缺失维度中选择的默认变种，如以下示例所示。您也可以替换在 productFlavors 代码块中的选择，让每一个变种都可以为缺失维度指定一个不同的匹配策略。\n\n\n// In the app's build.gradle file.\nandroid {\n    defaultConfig{\n    // Specifies a sorted list of flavors that the plugin should try to use from\n    // a given dimension. The following tells the plugin that, when encountering\n    // a dependency that includes a \"minApi\" dimension, it should select the\n    // \"minApi18\" flavor. You can include additional flavor names to provide a\n    // sorted list of fallbacks for the dimension.\n    missingDimensionStrategy 'minApi', 'minApi18', 'minApi23'\n    // You should specify a missingDimensionStrategy property for each\n    // dimension that exists in a local dependency but not in your app.\n    missingDimensionStrategy 'abi', 'x86', 'arm64'\n    }\n    flavorDimensions 'tier'\n    productFlavors {\n        free {\n            dimension 'tier'\n            // You can override the default selection at the product flavor\n            // level by configuring another missingDimensionStrategy property\n            // for the \"minApi\" dimension.\n            missingDimensionStrategy 'minApi', 'minApi23', 'minApi18'\n        }\n        paid {}\n    }\n}\n配置 Wear OS 应用依赖项\n配置 Wear OS 模块的依赖项与配置其他任何模块的依赖项相似。也就是说，它们使用相同的依赖项配置，如 implementation 和 compileOnly。\n\nWear 模块还支持变体感知型依赖项管理机制。因此，如果您的基础应用模块依赖于一个 Wear 模块，则基础模块的每个变体都会使用该 Wear 模块的匹配变体。如果您构建的是一个简单应用，它只依赖于一个 Wear 模块，而该模块配置的变体与您的基础模块相同，那么您需要在基础模块的 build.gradle 文件中指定 wearApp 配置，如下所示：\n\ndependencies {\n    // If the main and Wear app modules have the same variants,\n    // variant-aware dependency management automatically matches\n    // variants of the main app module with that of the wear module.\n    wearApp project(':wearable')\n}\n如果您拥有多个 Wear 模块并且要为每个应用变种指定不同的 Wear 模块，您可以使用 flavorWearApp 配置执行此操作，如下所示（不过，您不能添加使用 wearApp 配置的其他依赖项）：\n\ndependencies {\n    paidWearApp project(':wear1')\n    demoWearApp project(':wear1')\n    freeWearApp project(':wear2')\n}\n远程代码库\n当您的依赖项不是本地库或文件树时，Gradle 会在 build.gradle 文件的 repositories 代码块中指定的所有在线代码库中查找相关文件。各个代码库的列出顺序决定了 Gradle 在这些代码库中搜索各个项目依赖项的顺序。例如，如果从代码库 A 和 B 均可获得某个依赖项，而您先列出了代码库 A，则 Gradle 会从代码库 A 下载该依赖项。\n\n默认情况下，新的 Android Studio 项目会将 Google 的 Maven 代码库和 JCenter 指定为项目的顶级 build.gradle 文件中的代码库位置，如下所示：\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n如果您要从 Maven 中央代码库获取某些内容，则添加 mavenCentral()；对于本地代码库，则使用 mavenLocal()：\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n        mavenCentral()\n        mavenLocal()\n    }\n}\n或者，您也可以按如下方式声明特定的 Maven 或 Ivy 代码库：\n\nallprojects {\n    repositories {\n        maven {\n            url \"https://repo.example.com/maven2\"\n        }\n        maven {\n            url \"file://local/repo/\"\n        }\n        ivy {\n            url \"https://repo.example.com/ivy\"\n        }\n    }\n}\n如需了解详情，请参阅 Gradle 代码库指南。\n\nGoogle 的 Maven 代码库\nGoogle 的 Maven 代码库中提供了以下 Android 库的最新版本：\n\nAndroid 支持库\n架构组件库\n约束布局库\nAndroidX 测试\n数据绑定库\nAndroid 免安装应用库\nWear OS\nGoogle Play 服务\nFirebase\n您可以在 Google 的 Maven 代码库索引中查看所有可用的工件（如需了解以编程方式访问，请参阅下文）。\n\n如需将其中某个库添加到您的 build 中，请在顶级 build.gradle 文件中包含 Google 的 Maven 代码库：\n\nallprojects {\n    repositories {\n        google()// If you're using a version of Gradle lower than 4.1, you must instead use:\n        // maven {\n        //     url 'https://maven.google.com'\n        // }\n        // An alternative URL is 'https://dl.google.com/dl/android/maven2/'\n    }\n}\n然后，将所需的库添加到模块的 dependencies 代码块中。例如，appcompat 库如下所示：\n\ndependencies {\n    implementation 'com.android.support:appcompat-v7:28.0.0'\n}\n不过，如果您在尝试使用旧版上述库时依赖项失败，则表明 Maven 代码库中未提供该版本，您必须从离线代码库获取该库。\n\n以编程方式访问\n如需以编程方式访问 Google 的 Maven 工件，您可以从 maven.google.com/master-index.xml 获取工件组的 XML 列表。然后，您可以从以下位置查看任意组的库名称和版本信息：\n\nmaven.google.com/group_path/group-index.xml\n\n例如，android.arch.lifecycle 组中的库就列在 maven.google.com/android/arch/lifecycle/group-index.xml 中。\n\n您也可以从以下位置下载 POM 和 JAR 文件：\n\nmaven.google.com/group_path/library/version/library-version.ext\n\n例如：maven.google.com/android/arch/lifecycle/compiler/1.0.0/compiler-1.0.0.pom。\n\nSDK 管理器中的离线代码库\n对于无法从 Google Maven 代码库中获得的库（通常是旧版库），您必须从 SDK 管理器下载离线 Google 代码库软件包。\n\n然后，您可以照常将这些库添加到 dependencies 代码块中。\n\n离线库保存在 android_sdk/extras/ 中。\n\n依赖项顺序\n依赖项的列出顺序指明了每个库的优先级：第一个库的优先级高于第二个，第二个库的优先级高于第三个，依此类推。在合并资源或将清单元素从库中合并到应用中时，此顺序很重要。\n\n例如，如果您的项目声明以下内容：\n\n依赖 LIB_A 和 LIB_B（按此顺序）\nLIB_A 依赖于 LIB_C 和 LIB_D（按此顺序）\nLIB_B 也依赖于 LIB_C\n那么，扁平型依赖项顺序将如下所示：\n\nLIB_A\nLIB_D\nLIB_B\nLIB_C\n这可以确保 LIB_A 和 LIB_B 都可以替换 LIB_C；并且 LIB_D 的优先级仍高于 LIB_B，因为 LIB_A（依赖前者）的优先级高于 LIB_B。\n\n如需详细了解如何合并不同项目来源/依赖项的清单，请参阅合并多个清单文件。\n\n查看模块依赖项\n一些直接依赖项可能具有自己的依赖项。此类依赖项称为“传递依赖项”。Gradle 将会自动为您收集并添加这些传递依赖项，无需您手动逐一加以声明。Android Plugin for Gradle 提供了一项任务，用来列出 Gradle 为给定模块解析的依赖项。\n\n对于每个模块，报告还会根据构建变体、测试源代码集和类路径对依赖项进行分组。下面是一个应用模块的依赖项示例报告，其中按该模块的调试构建变体的运行时类路径和该模块的插桩测试源代码集的编译类路径对依赖项进行了分组。\n\ndebugRuntimeClasspath - Dependencies for runtime/packaging\n+--- :mylibrary (variant: debug)\n+--- com.google.android.material:material:1.0.0@aar\n+--- androidx.appcompat:appcompat:1.0.2@aar\n+--- androidx.constraintlayout:constraintlayout:1.1.3@aar\n+--- androidx.fragment:fragment:1.0.0@aar\n+--- androidx.vectordrawable:vectordrawable-animated:1.0.0@aar\n+--- androidx.recyclerview:recyclerview:1.0.0@aar\n+--- androidx.legacy:legacy-support-core-ui:1.0.0@aar\n...\n\ndebugAndroidTest\ndebugAndroidTestCompileClasspath - Dependencies for compilation\n+--- androidx.test.ext:junit:1.1.0@aar\n+--- androidx.test.espresso:espresso-core:3.1.1@aar\n+--- androidx.test:runner:1.1.1@aar\n+--- junit:junit:4.12@jar\n...\n如需运行该任务，请按以下步骤操作：\n\n依次选择 View > Tool Windows > Gradle（或点击工具窗口栏中的 Gradle 图标 ）。\n依次展开 AppName > Tasks > android，然后双击 androidDependencies。Gradle 执行该任务后，系统应该会打开 Run 窗口以显示输出。\n如需详细了解如何管理 Gradle 中的依赖项，请参阅 Gradle 用户指南中的依赖项管理基础知识。\n\n修复依赖项解析错误\n当您向应用项目添加多个依赖项时，这些直接和传递依赖项可能会相互冲突。Android Gradle 插件会尝试妥善解决这些冲突，但有些冲突可能会导致编译时或运行时错误。\n\n为帮助您调查是哪些依赖项导致了错误，请检查您的应用的依赖项树，从中查找多次出现的依赖项或版本冲突的依赖项。\n\n如果无法轻松识别重复的依赖项，请尝试使用 Android Studio 的界面搜索包含重复类的依赖项，具体操作步骤如下：\n\n从菜单栏中依次选择 Navigate > Class。\n在弹出式搜索对话框中，确保已勾选 Include non-project items 旁边的框。\n输入出现在构建错误中的类的名称。\n检查结果以查找包含该类的依赖项。\n下面几部分介绍您可能会遇到的不同类型的依赖项解析错误及其修复方法。\n\n修复重复类错误\n如果某个类多次出现在运行时类路径上，您会收到一条与以下内容类似的错误：\n\nProgram type already present com.example.MyClass\n此错误通常是下列其中一种情况所致：\n\n二进制文件依赖项包含一个库，该库也作为直接依赖项包含在您的应用中。例如，您的应用声明直接依赖于库 A 和库 B，但库 A 已在其二进制文件中包含库 B。\n如需解决此问题，请取消将库 B 作为直接依赖项。\n您的应用的本地二进制文件依赖项和远程二进制文件依赖项是同一个库。\n如需解决此问题，请移除其中一个二进制文件依赖项。\n解决类路径之间的冲突\n当 Gradle 解析编译类路径时，会先解析运行时类路径，然后使用所得结果确定应添加到编译类路径的依赖项版本。换句话说，运行时类路径决定了下游类路径上完全相同的依赖项所需的版本号。\n\n应用的运行时类路径还决定了 Gradle 需要对应用的测试 APK 的运行时类路径中的匹配依赖项使用的版本号。图 1 说明了类路径的层次结构。\n\n\n\n图 1. 必须根据此层次结构匹配出现在多个类路径中的依赖项的版本号。\n\n例如，当应用使用 implementation 依赖项配置加入某个依赖项的一个版本，而库模块使用 runtimeOnly 配置加入该依赖项的另一个版本时，就可能会发生多个类路径中出现同一依赖项的不同版本的冲突。\n\n在解析对运行时和编译时类路径的依赖关系时，Android Gradle 插件 3.3.0 及更高版本会尝试自动解决某些下游版本冲突。例如，如果运行时类路径包含库 A 版本 2.0，而编译类路径包含库 A 版本 1.0，则插件会自动将对编译类路径的依赖关系更新为库 A 版本 2.0，以避免错误。\n\n不过，如果运行时类路径包含库 A 版本 1.0，而编译类路径包含库 A 版本 2.0，插件不会将对编译类路径的依赖关系降级为库 A 版本 1.0，您仍会收到一条与以下内容类似的错误：\n\nConflict with dependency 'com.example.library:some-lib:2.0' in project 'my-library'.\nResolved versions for runtime classpath (1.0) and compile classpath (2.0) differ.\n如需解决此问题，请执行以下某项操作：\n\n将所需版本的依赖项作为 api 依赖项添加到库模块。也就是说，只有库模块声明相应依赖项，但应用模块也能以传递方式访问其 API。\n或者，您也可以同时在两个模块中声明相应依赖项，但应确保每个模块使用的版本相同。不妨考虑配置项目全局属性，以确保每个依赖项的版本在整个项目中保持一致。\n应用自定义构建逻辑\n本部分介绍的高级主题在您要扩展 Android Gradle 插件或编写自己的插件时很有用。\n\n向自定义逻辑发布变体依赖项\n库可以包含其他项目或子项目可能要使用的功能。发布库是向其消费者提供库的过程。库可以控制其消费者在编译时和运行时可访问的依赖项。\n\n有两种不同的配置，它们包含每个类路径的传递依赖项，消费者为了使用相应库而必须使用这些依赖项，具体说明如下：\n\nvariant_nameApiElements：此配置包含编译时消费者可使用的传递依赖项。\nvariant_nameRuntimeElements：此配置包含运行时消费者可使用的传递依赖项。\n如需详细了解不同配置之间的关系，请参阅 Java 库插件配置。\n\n自定义依赖项解析策略\n一个项目可能会依赖于同一个库的两个不同版本，这样会导致依赖项冲突。例如，如果您的项目依赖于模块 A 的版本 1 和模块 B 的版本 2，而模块 A 以传递方式依赖于模块 B 的版本 3，则会出现依赖项版本冲突。\n\n为了解决此冲突，Android Gradle 插件使用以下依赖项解析策略：当插件检测到依赖项关系图中存在同一模块的不同版本时，默认情况下，它会选择版本号最高的一个。\n\n不过，此策略可能并不总是如您所愿。如需自定义依赖项解析策略，请使用以下配置解析任务所需的特定变体依赖项：\n\nvariant_nameCompileClasspath：此配置包含适用于给定变体编译类路径的解析策略。\nvariant_nameRuntimeClasspath：此配置包含适用于给定变体运行时类路径的解析策略。\nAndroid Gradle 插件包含可用于访问每个变体的配置对象的 getter。因此，您可以使用变体 API 查询依赖项解析，如以下示例所示：\n\nandroid {\n    applicationVariants.all { variant ->\n        // Return compile configuration objects of a variant.\n        variant.getCompileConfiguration().resolutionStrategy {\n        // Use Gradle's ResolutionStrategy API\n        // to customize how this variant resolves dependencies.\n            ...\n        }\n        // Return runtime configuration objects of a variant.\n        variant.getRuntimeConfiguration().resolutionStrategy {\n            ...\n        }\n        // Return annotation processor configuration of a variant.\n        variant.getAnnotationProcessorConfiguration().resolutionStrategy {\n            ...\n        }\n    }\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515688539},"updatedAt":{"$$date":1598516408632},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Pj0IjEwoCO1nM44e"}
{"name":"kotlin-取消与超时 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/coroutines/cancellation-and-timeouts.html\n取消与超时 - Kotlin 语言中文站\n21-26 minutes\n改进翻译\n目录\n\n取消与超时\n取消协程的执行\n取消是协作的\n使计算代码可取消\n在 finally 中释放资源\n运行不能取消的代码块\n超时\n这一部分包含了协程的取消与超时。\n\n在一个长时间运行的应用程序中，你也许需要对你的后台协程进行细粒度的控制。 比如说，一个用户也许关闭了一个启动了协程的界面，那么现在协程的执行结果已经不再被需要了，这时，它应该是可以被取消的。 该 launch 函数返回了一个可以被用来取消运行中的协程的 Job：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        repeat(1000) { i ->\n            println(\"job: I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // 延迟一段时间\n    println(\"main: I'm tired of waiting!\")\n    job.cancel() // 取消该作业\n    job.join() // 等待作业执行结束\n    println(\"main: Now I can quit.\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n程序执行后的输出如下：\n\njob: I'm sleeping 0 ...\njob: I'm sleeping 1 ...\njob: I'm sleeping 2 ...\nmain: I'm tired of waiting!\nmain: Now I can quit.\n一旦 main 函数调用了 job.cancel，我们在其它的协程中就看不到任何输出，因为它被取消了。 这里也有一个可以使 Job 挂起的函数 cancelAndJoin 它合并了对 cancel 以及 join 的调用。\n\n协程的取消是 协作 的。一段协程代码必须协作才能被取消。 所有 kotlinx.coroutines 中的挂起函数都是 可被取消的 。它们检查协程的取消， 并在取消时抛出 CancellationException。 然而，如果协程正在执行计算任务，并且没有检查取消的话，那么它是不能被取消的，就如如下示例代码所示：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val startTime = System.currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (i < 5) { // 一个执行计算的循环，只是为了占用 CPU\n            // 每秒打印消息两次\n            if (System.currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // 等待一段时间\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // 取消一个作业并且等待它结束\n    println(\"main: Now I can quit.\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n运行示例代码，并且我们可以看到它连续打印出了“I'm sleeping”，甚至在调用取消后， 作业仍然执行了五次循环迭代并运行到了它结束为止。\n\n我们有两种方法来使执行计算的代码可以被取消。第一种方法是定期调用挂起函数来检查取消。对于这种目的 yield 是一个好的选择。 另一种方法是显式的检查取消状态。让我们试试第二种方法。\n\n将前一个示例中的 while (i < 5) 替换为 while (isActive) 并重新运行它。\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val startTime = System.currentTimeMillis()\n    val job = launch(Dispatchers.Default) {\n        var nextPrintTime = startTime\n        var i = 0\n        while (isActive) { // 可以被取消的计算循环\n            // 每秒打印消息两次\n            if (System.currentTimeMillis() >= nextPrintTime) {\n                println(\"job: I'm sleeping ${i++} ...\")\n                nextPrintTime += 500L\n            }\n        }\n    }\n    delay(1300L) // 等待一段时间\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // 取消该作业并等待它结束\n    println(\"main: Now I can quit.\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n你可以看到，现在循环被取消了。isActive 是一个可以被使用在 CoroutineScope 中的扩展属性。\n\n我们通常使用如下的方法处理在被取消时抛出 CancellationException 的可被取消的挂起函数。比如说，try {……} finally {……} 表达式以及 Kotlin 的 use 函数一般在协程被取消的时候执行它们的终结动作：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            println(\"job: I'm running finally\")\n        }\n    }\n    delay(1300L) // 延迟一段时间\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // 取消该作业并且等待它结束\n    println(\"main: Now I can quit.\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\njoin 和 cancelAndJoin 等待了所有的终结动作执行完毕， 所以运行示例得到了下面的输出：\n\njob: I'm sleeping 0 ...\njob: I'm sleeping 1 ...\njob: I'm sleeping 2 ...\nmain: I'm tired of waiting!\njob: I'm running finally\nmain: Now I can quit.\n在前一个例子中任何尝试在 finally 块中调用挂起函数的行为都会抛出 CancellationException，因为这里持续运行的代码是可以被取消的。通常，这并不是一个问题，所有良好的关闭操作（关闭一个文件、取消一个作业、或是关闭任何一种通信通道）通常都是非阻塞的，并且不会调用任何挂起函数。然而，在真实的案例中，当你需要挂起一个被取消的协程，你可以将相应的代码包装在 withContext(NonCancellable) {……} 中，并使用 withContext 函数以及 NonCancellable 上下文，见如下示例所示：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = launch {\n        try {\n            repeat(1000) { i ->\n                println(\"job: I'm sleeping $i ...\")\n                delay(500L)\n            }\n        } finally {\n            withContext(NonCancellable) {\n                println(\"job: I'm running finally\")\n                delay(1000L)\n                println(\"job: And I've just delayed for 1 sec because I'm non-cancellable\")\n            }\n        }\n    }\n    delay(1300L) // 延迟一段时间\n    println(\"main: I'm tired of waiting!\")\n    job.cancelAndJoin() // 取消该作业并等待它结束\n    println(\"main: Now I can quit.\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n在实践中绝大多数取消一个协程的理由是它有可能超时。 当你手动追踪一个相关 Job 的引用并启动了一个单独的协程在延迟后取消追踪，这里已经准备好使用 withTimeout 函数来做这件事。 来看看示例代码：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    withTimeout(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n运行后得到如下输出：\n\nI'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\nException in thread \"main\" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms\nwithTimeout 抛出了 TimeoutCancellationException，它是 CancellationException 的子类。 我们之前没有在控制台上看到堆栈跟踪信息的打印。这是因为在被取消的协程中 CancellationException 被认为是协程执行结束的正常原因。 然而，在这个示例中我们在 main 函数中正确地使用了 withTimeout。\n\n由于取消只是一个例外，所有的资源都使用常用的方法来关闭。 如果你需要做一些各类使用超时的特别的额外操作，可以使用类似 withTimeout 的 withTimeoutOrNull 函数，并把这些会超时的代码包装在 try {...} catch (e: TimeoutCancellationException) {...} 代码块中，而 withTimeoutOrNull 通过返回 null 来进行超时操作，从而替代抛出一个异常：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val result = withTimeoutOrNull(1300L) {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n        \"Done\" // 在它运行得到结果之前取消它\n    }\n    println(\"Result is $result\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n运行这段代码时不再抛出异常：\n\nI'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\nResult is null"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382142141},"updatedAt":{"$$date":1597387399601},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"PjjXFL2gdwbHVg8w"}
{"name":"CSS3 渐变（Gradients）","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 渐变（Gradients）\n渐变效果\nCSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。\n\n以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的时间和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。\n\nCSS3 定义了两种类型的渐变（gradients）：\n\n线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向\n径向渐变（Radial Gradients）- 由它们的中心定义\n线性渐变相关属性：background-image。\n\n浏览器支持\n表中的数字指定了完全支持该属性的第一个浏览器版本。\n\n属性\t\t\t\t\t\nbackground-image\t1.0\t4.0\t1.0\t1.0\t3.5\n注意：IE8 及更早版本的 IE 浏览器不支持该属性。\n\n\nCSS3 线性渐变\n为了创建一个线性渐变，你必须至少定义两种颜色节点。颜色节点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。\n\n线性渐变的实例：\n\n线性渐变\n语法\nbackground-image: linear-gradient(direction, color-stop1, color-stop2, ...);\n线性渐变 - 从上到下（默认情况下）\n\n下面的实例演示了从顶部开始的线性渐变。起点是红色，慢慢过渡到蓝色：\n\n实例\n从上到下的线性渐变：\n\n#grad {\n    background-image: linear-gradient(#e66465, #9198e5);\n}\n\n尝试一下 »\n线性渐变 - 从左到右\n\n下面的实例演示了从左边开始的线性渐变。起点是红色，慢慢过渡到蓝色：\n\n实例\n从左到右的线性渐变：\n\n#grad {\n  height: 200px;\n  background-image: linear-gradient(to right, red , yellow);\n}\n\n尝试一下 »\n线性渐变 - 对角\n\n你可以通过指定水平和垂直的起始位置来制作一个对角渐变。\n\n下面的实例演示了从左上角开始（到右下角）的线性渐变。起点是红色，慢慢过渡到黄色：\n\n实例\n从左上角到右下角的线性渐变：\n\n#grad {\n  height: 200px;\n  background-image: linear-gradient(to bottom right, red, yellow);\n}\n\n尝试一下 »\n\n使用角度\n如果你想要在渐变的方向上做更多的控制，你可以定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）。\n\n语法\nbackground-image: linear-gradient(angle, color-stop1, color-stop2);\n角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。\n\n\n\n但是，请注意很多浏览器（Chrome、Safari、firefox等）的使用了旧的标准，即 0deg 将创建一个从左到右的渐变，90deg 将创建一个从下到上的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度。\n\n下面的实例演示了如何在线性渐变上使用角度：\n\n实例\n带有指定的角度的线性渐变：\n\n#grad {\n  background-image: linear-gradient(-90deg, red, yellow);\n}\n\n尝试一下 »\n\n使用多个颜色节点\n下面的实例演示了如何设置多个颜色节点：\n\n实例\n带有多个颜色节点的从上到下的线性渐变：\n\n#grad {\n  background-image: linear-gradient(red, yellow, green);\n}\n\n尝试一下 »\n下面的实例演示了如何创建一个带有彩虹颜色和文本的线性渐变：\n\n实例\n#grad {\n  /* 标准的语法 */\n  background-image: linear-gradient(to right, red,orange,yellow,green,blue,indigo,violet);\n}\n\n尝试一下 »\n\n使用透明度（transparent）\nCSS3 渐变也支持透明度（transparent），可用于创建减弱变淡的效果。\n\n为了添加透明度，我们使用 rgba() 函数来定义颜色节点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。\n\n下面的实例演示了从左边开始的线性渐变。起点是完全透明，慢慢过渡到完全不透明的红色：\n\n实例\n从左到右的线性渐变，带有透明度：\n\n#grad {\n  background-image: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1));\n}\n\n尝试一下 »\n\n重复的线性渐变\nrepeating-linear-gradient() 函数用于重复线性渐变：\n\n实例\n一个重复的线性渐变：\n\n#grad {\n  /* 标准的语法 */\n  background-image: repeating-linear-gradient(red, yellow 10%, green 20%);\n}\n\n尝试一下 »\n\nCSS3 径向渐变\n径向渐变由它的中心定义。\n\n为了创建一个径向渐变，你也必须至少定义两种颜色节点。颜色节点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。\n\n径向渐变的实例：\n\nRadial gradient\n语法\nbackground-image: radial-gradient(shape size at position, start-color, ..., last-color);\n径向渐变 - 颜色节点均匀分布（默认情况下）\n\n实例\n颜色节点均匀分布的径向渐变：\n\n#grad {\n  background-image: radial-gradient(red, yellow, green);\n}\n\n尝试一下 »\n径向渐变 - 颜色节点不均匀分布\n\n实例\n颜色节点不均匀分布的径向渐变：\n\n#grad {\n  background-image: radial-gradient(red 5%, yellow 15%, green 60%);\n}\n\n尝试一下 »\n\n设置形状\nshape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。\n\n实例\n形状为圆形的径向渐变：\n\n#grad {\n  background-image: radial-gradient(circle, red, yellow, green);\n}\n\n尝试一下 »\n\n不同尺寸大小关键字的使用\nsize 参数定义了渐变的大小。它可以是以下四个值：\n\nclosest-side\nfarthest-side\nclosest-corner\nfarthest-corner\n实例\n带有不同尺寸大小关键字的径向渐变：\n\n#grad1 {\n  background-image: radial-gradient(closest-side at 60% 55%, red, yellow, black);\n}\n \n#grad2 {\n  background-image: radial-gradient(farthest-side at 60% 55%, red, yellow, black);\n}\n\n尝试一下 »\n\n重复的径向渐变\nrepeating-radial-gradient() 函数用于重复径向渐变：\n\n实例\n一个重复的径向渐变：\n\n#grad {\n  background-image: repeating-radial-gradient(red, yellow 10%, green 15%);\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974613053},"updatedAt":{"$$date":1598974807819},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Q4wGLrlwttUFHo5v"}
{"name":"kotlin-vivo oppo 相机权限处理","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nblog.csdn.net /u010897392/article/details/82661495\nvivo oppo 相机权限处理_u010897392的专栏-CSDN博客_android vivo手机 相机权限申请问题\n7-8 minutes\n最近写权限图片上传功能用到了相机权限申请，发现vivo，oppo很多机型不管授权与否都返回\n\nPackageManager.PERMISSION_GRANTED（已授权），研究下了下源码发现有个mHasPermission 字段跟授权后的状态有关，已授权则返回true,否则返回false;既然已找到突破口，那处理起来就就简单了，直接上代码：\n\n新建一个权限工具类PermissionUtils 跟rom工具类RomUtils ：\n\npackage com.app.shanjiang.util;\n\nimport android.Manifest;\n\nimport android.content.Context;\n\nimport android.hardware.Camera;\n\nimport android.os.Build;\n\nimport java.lang.reflect.Field;\n\nimport pub.devrel.easypermissions.EasyPermissions;\n\n/**\n\n * @Title 权限工具类\n\n * @Description\n\n * @Author xuefeng.zhu\n\n * @Since 2018/9/3\n\n * @Version 2.7.0\n\n */\n\npublic class PermissionUtils {\n\nprivate static Boolean mCameraCanUse = true; //缓存上次的查询结果\n\nprivate static Camera mCamera = null;\n\n/**\n\n     * 检测相机权限\n\n     *\n\n     * @param context\n\n     * @return\n\n     */\n\npublic static boolean hasCameraPermissions(Context context) {\n\ntry {\n\nif (RomUtils.isOppo() || RomUtils.isVivo()) {\n\nif (!isCameraCanUse()) {\n\nreturn false;\n\n                }\n\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n\nif (!isHasCameraPermission()) {\n\nreturn false;\n\n                    }\n\n                }\n\n            }\n\n        } catch (Exception ex) {\n\n            ex.printStackTrace();\n\nreturn false;\n\n        }\n\nreturn EasyPermissions.hasPermissions(context, Manifest.permission.CAMERA);\n\n    }\n\n/**\n\n     * 相机是否可用\n\n     * ps:有些手机即使禁掉拍照权限获取到的camera也不为null（比如魅族，oppoR9s）\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isCameraCanUse() {\n\nboolean canUse = true;\n\ntry {\n\n            mCamera = getCamera();\n\n            Camera.Parameters mParameters = mCamera.getParameters();\n\n            mCamera.setParameters(mParameters);\n\n        } catch (Exception e) {\n\n            canUse = false;\n\n        }\n\n        mCameraCanUse = canUse;\n\nreturn canUse;\n\n    }\n\n/**\n\n     * 是否拿到相机权限\n\n     * ps: vivo ，opo手机不管授权与否都会\n\n     * 返回PackageManager.PERMISSION_GRANTED（已授权）故作特殊处理\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isHasCameraPermission() {\n\n        Field fieldPassword;\n\ntry {\n\n            mCamera = getCamera();\n\n//通过反射去拿相机是否获得了权限\n\n            fieldPassword = mCamera.getClass().getDeclaredField(\"mHasPermission\");\n\n            fieldPassword.setAccessible(true);\n\nBoolean result = (Boolean) fieldPassword.get(mCamera);\n\nif (mCamera != null) {\n\n                mCamera.release();\n\n            }\n\n            mCamera = null;\n\nreturn result;\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n            mCamera = null;\n\nreturn true;\n\n        }\n\n    }\n\n/**\n\n     * 相机是否可使用\n\n     *\n\n     * @return\n\n     */\n\npublic static Boolean getCameraCanUse() {\n\nreturn mCameraCanUse;\n\n    }\n\n/**\n\n     * 获取相机实例\n\n     *\n\n     * @return\n\n     */\n\npublic static Camera getCamera() {\n\nif (mCamera == null) {\n\nreturn Camera.open();\n\n        }\n\nreturn mCamera;\n\n    }\n\n}\n\npackage com.app.shanjiang.util;\n\nimport android.os.Build;\n\nimport android.text.TextUtils;\n\nimport android.util.Log;\n\nimport java.io.BufferedReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\n/**\n\n * @Title Rom工具类\n\n * @Description\n\n * @Author xuefeng.zhu\n\n * @Since 2018/9/3\n\n * @Version 2.7.0\n\n */\n\npublic class RomUtils {\n\nprivate static final String TAG = \"Rom\";\n\npublic static final String ROM_MIUI = \"MIUI\";\n\npublic static final String ROM_EMUI = \"EMUI\";\n\npublic static final String ROM_FLYME = \"FLYME\";\n\npublic static final String ROM_OPPO = \"OPPO\";\n\npublic static final String ROM_SMARTISAN = \"SMARTISAN\";\n\npublic static final String ROM_VIVO = \"VIVO\";\n\npublic static final String ROM_QIKU = \"QIKU\";\n\nprivate static final String KEY_VERSION_MIUI = \"ro.miui.ui.version.name\";\n\nprivate static final String KEY_VERSION_EMUI = \"ro.build.version.emui\";\n\nprivate static final String KEY_VERSION_OPPO = \"ro.build.version.opporom\";\n\nprivate static final String KEY_VERSION_SMARTISAN = \"ro.smartisan.version\";\n\nprivate static final String KEY_VERSION_VIVO = \"ro.vivo.os.version\";\n\nprivate static String sName;//当前系统名称\n\nprivate static String sVersion;//当前系统版本号\n\n/**\n\n     * 是否为华为系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isEmui() {\n\nreturn check(ROM_EMUI);\n\n    }\n\n/**\n\n     * 是否为小米系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isMiui() {\n\nreturn check(ROM_MIUI);\n\n    }\n\n/**\n\n     * 是否为vivo系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isVivo() {\n\nreturn check(ROM_VIVO);\n\n    }\n\n/**\n\n     * 是否为oppo系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isOppo() {\n\nreturn check(ROM_OPPO);\n\n    }\n\n/**\n\n     * 是否为魅族系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isFlyme() {\n\nreturn check(ROM_FLYME);\n\n    }\n\n/**\n\n     * 是否为360系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean is360() {\n\nreturn check(ROM_QIKU) || check(\"360\");\n\n    }\n\n/**\n\n     * 是否为锤子系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isSmartisan() {\n\nreturn check(ROM_SMARTISAN);\n\n    }\n\npublic static String getName() {\n\nif (sName == null) {\n\n            check(\"\");\n\n        }\n\nreturn sName;\n\n    }\n\npublic static String getVersion() {\n\nif (sVersion == null) {\n\n            check(\"\");\n\n        }\n\nreturn sVersion;\n\n    }\n\n/**\n\n     * 获取手机的rom类型\n\n     *\n\n     * @param rom\n\n     * @return\n\n     */\n\npublic static boolean check(String rom) {\n\nif (sName != null) {\n\nreturn sName.equals(rom);\n\n        }\n\nif (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_MIUI))) {\n\n            sName = ROM_MIUI;\n\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_EMUI))) {\n\n            sName = ROM_EMUI;\n\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_OPPO))) {\n\n            sName = ROM_OPPO;\n\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_VIVO))) {\n\n            sName = ROM_VIVO;\n\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_SMARTISAN))) {\n\n            sName = ROM_SMARTISAN;\n\n        } else {\n\n            sVersion = Build.DISPLAY;\n\nif (sVersion.toUpperCase().contains(ROM_FLYME)) {\n\n                sName = ROM_FLYME;\n\n            } else {\n\n                sVersion = Build.UNKNOWN;\n\n                sName = Build.MANUFACTURER.toUpperCase();\n\n            }\n\n        }\n\nreturn sName.equals(rom);\n\n    }\n\npublic static String getProp(String name) {\n\nString line = null;\n\n        BufferedReader input = null;\n\ntry {\n\n            Process p = Runtime.getRuntime().exec(\"getprop \" + name);\n\n            input = new BufferedReader(new InputStreamReader(p.getInputStream()), 1024);\n\n            line = input.readLine();\n\n            input.close();\n\n        } catch (IOException ex) {\n\n            Log.e(TAG, \"Unable to read prop \" + name, ex);\n\nreturn null;\n\n        } finally {\n\nif (input != null) {\n\ntry {\n\n                    input.close();\n\n                } catch (IOException e) {\n\n                    e.printStackTrace();\n\n                }\n\n            }\n\n        }\n\nreturn line;\n\n    }\n\n}\n\n在用到相机权限的地方作相关处理：\n\n@AfterPermissionGranted(RECOMMEND_CAMERA)\n\nprivate void requestRecommend() {\n\nif (PermissionUtils.hasCameraPermissions(this)) {\n\n            RecommendScanActivity.start(this, REFERENCE_REQUEST_CODE);\n\n        } else {\n\nif (!(RomUtils.isOppo() || RomUtils.isVivo()))\n\n                EasyPermissions.requestPermissions(this, getString(R.string.scan_permission), RECOMMEND_CAMERA, RECOMMEND_PERMISSION);\n\n        }\n\n    }\n\n这样相相当于对oppo，vivo系列的手机做了特殊处理；到此相机权限兼容完毕；\n\nps：代码中用到的EasyPermissions是一个github上面的权限申请库；"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382129894},"updatedAt":{"$$date":1597383306208},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Q72bBn1di0sP1tdU"}
{"name":"ad-ks_media_preview","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    android {\n        lintOptions {\n            abortOnError false\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    testImplementation deps.androidx.junit\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    implementation deps.kotlin.kotlin_reflect\n    implementation deps.kotlin.kotlin_core\n\n    implementation deps.androidx.viewpager2\n    implementation deps.androidx.fragment\n    implementation deps.androidx.recyclerview_v7\n    implementation deps.androidx.constraint_layout\n    implementation deps.androidx.app_compat\n\n    if(rootProject.ext.isUseMediaModle) {\n        implementation project(':ks_media_core')\n    }else {\n        implementation ks.mediacore\n    }\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\npreview\nui\nDelDialogFragment\nview\nBasePreviewFragment\nImageUtils\nwight\nBezierBannerView\nSmoothImageView\nPreviewActivity\nPreviewConfig\nphotoview2\n\n\n\n\n\n\n\nclass PreviewConfig constructor() : Parcelable {\n     var isScale: Boolean = false\n    // 最大可选数量 默认9张\n      var maxSelect: Int = 9\n     var isFullScreen: Boolean = true\n     var previewMode: Int ?=PreviewType.MODE_NORMAL\n     var duration: Int  = 100\n     var isSingleFling: Boolean?=false\n     var sensitivity: Float ?=null\n     var isDrag: Boolean? =true\n   //  var intent: Intent? = null\n//     var datas:MutableList<MediaData>? = null\n//     var selectedDatas:MutableList<MediaData>? = null\n     var className:Class<out BasePreviewFragment?>? =null\n     var position:Int=0\n     var indicatorType:Int? =IndicatorType.Number\n     var isShowIndicates:Boolean = true\n    //解压路径\n        var compressDir:String ?=null\n    /**默认-1 视频文件个数  */\n    var maxCanSelectVideoCount = -1\n\n    /**是否压缩*/\n    var isCompress: Boolean = false\n    /**\n     * 是否在删除图片时展示删除弹窗\n     * 默认展示删除弹窗\n     * */\n    var isShowDelConfirmDialog: Boolean = true\n\n    constructor(parcel: Parcel) : this() {\n        isScale = parcel.readByte() != 0.toByte()\n        maxSelect = parcel.readInt()\n        isFullScreen = parcel.readByte() != 0.toByte()\n        previewMode = parcel.readValue(Int::class.java.classLoader) as? Int\n        duration = parcel.readInt()\n        isSingleFling = parcel.readValue(Boolean::class.java.classLoader) as? Boolean\n        sensitivity = parcel.readValue(Float::class.java.classLoader) as? Float\n        isDrag = parcel.readValue(Boolean::class.java.classLoader) as? Boolean\n        position = parcel.readInt()\n        indicatorType = parcel.readValue(Int::class.java.classLoader) as? Int\n        isShowIndicates = parcel.readByte() != 0.toByte()\n        compressDir = parcel.readString()\n//        datas = parcel.readArrayList(MediaData::class.java.classLoader)?.toMutableList() as? MutableList<MediaData>\n//        selectedDatas = parcel.readArrayList(MediaData::class.java.classLoader)?.toMutableList() as? MutableList<MediaData>\n        className = parcel.readSerializable() as? Class<out BasePreviewFragment?>?\n        maxCanSelectVideoCount = parcel.readInt()\n    }\n\n\n\n    /***\n     * 设置数据源\n     * @param imgUrls 数据\n     * @param   <T>    你的实体类类型\n     * @return GPreviewBuilder\n    </T> */\n//    fun setData(imgUrls: MutableList<MediaData>?): PreviewConfig {\n//        datas = imgUrls\n//        return this\n//    }\n\n    /***\n     * 设置 选中数据源\n     * @param imgUrls 数据\n     * @param   <T>    你的实体类类型\n     * @return PreviewConfig\n    </T> */\n//    fun setSelectDatas(selectedDatas: MutableList<MediaData>?): PreviewConfig {\n//        this.selectedDatas = selectedDatas\n//        return this\n//    }\n\n\n\n    /***\n     * 设置数据源\n     * @param className 你的Fragment类 集成自\n     * @return PreviewConfig\n     */\n    fun setUserFragment(className: Class<out BasePreviewFragment?>): PreviewConfig {\n        this.className = className\n        return this\n    }\n\n    /***\n     * 设置默认索引\n     * @param currentIndex 数据\n     * @return PreviewConfig\n     */\n    fun setCurrentIndex(currentIndex: Int): PreviewConfig {\n        position = currentIndex\n        return this\n    }\n\n    /***\n     * 设置指示器类型\n     * @param indicatorType 枚举\n     * @return PreviewConfig\n     */\n    fun setType( @IndicatorType indicatorType:Int): PreviewConfig {\n        //intent?.putExtra(\"type\", indicatorType)\n        this.indicatorType = indicatorType\n        return this\n    }\n\n    /***\n     * 设置图片禁用拖拽返回\n     * @param isDrag  true  可以 false 默认 true\n     * @return PreviewConfig\n     */\n    fun setDrag(isDrag: Boolean): PreviewConfig {\n        //intent?.putExtra(\"isDrag\", isDrag)\n        this.isDrag = isDrag\n        return this\n    }\n\n    /***\n     * 设置图片禁用拖拽返回\n     * @param isDrag  true  可以 false 默认 true\n     * @param sensitivity   sensitivity MAX_TRANS_SCALE 的值来控制灵敏度。\n     * @return PreviewConfig\n     */\n    fun setDrag(isDrag: Boolean, sensitivity: Float): PreviewConfig {\n       this.isDrag =  isDrag\n        this.sensitivity =  sensitivity\n        return this\n    }\n\n    /***\n     * 是否设置为一张图片时 显示指示器  默认显示\n     * @param isShow   true  显示 false 不显示\n     * @return PreviewConfig\n     */\n    fun setSingleShowType(isShow: Boolean): PreviewConfig {\n        this.isShowIndicates =  isShow\n        return this\n    }\n\n    /***\n     * 设置超出内容点击退出（黑色区域）\n     * @param isSingleFling  true  可以 false\n     * @return PreviewConfig\n     */\n    fun setSingleFling(isSingleFling: Boolean): PreviewConfig {\n        this.isSingleFling = isSingleFling\n        return this\n    }\n\n    /***\n     * 设置动画的时长\n     * @param setDuration  单位毫秒\n     * @return PreviewConfig\n     */\n    fun setDuration(setDuration: Int): PreviewConfig {\n        this.duration =  setDuration\n        return this\n    }\n\n\n\n\n    /**\n     * 设置模式\n     *\n     * @param mode  模式\n     *  {@link }\n     *\n     */\n    fun setPreviewType(@PreviewType mode: Int):PreviewConfig {\n        this.previewMode =  mode\n        return this\n    }\n\n      /***\n     * 设置是否全屏\n     * @param isFullscreen  单位毫秒\n     * @return PreviewConfig\n     */\n    fun setFullscreen(isFullscreen: Boolean): PreviewConfig {\n        this.isFullScreen =  isFullscreen\n        return this\n    }\n\n\n    /**\n     *  最多可选择图片 或视频数量\n     */\n    fun maxCanselect(maxSelect:Int): PreviewConfig {\n        this.maxSelect = maxSelect\n        return this\n    }\n\n    /**\n     * 最多视频文件选择数量\n     */\n    fun setMaxSelectvideoCount(maxVideo:Int): PreviewConfig {\n        this.maxCanSelectVideoCount = maxVideo\n        return this\n    }\n\n    /***\n     * 设置只有图片没有放大或者的缩小状态触退出\n     * @param isScale    true false\n     * @return PreviewConfig\n     */\n    fun setIsScale(isScale: Boolean): PreviewConfig {\n        this.isScale = isScale\n        return this\n    }\n    /***\n     * 是否压缩\n     * @param isScale    true false\n     * @return PreviewConfig\n     */\n    fun setIsCompress(isCompress: Boolean): PreviewConfig {\n        this.isCompress = isCompress\n        return this\n    }\n\n    fun compressDir(path:String?):PreviewConfig{\n        compressDir = path;\n        return this;\n    }\n\n    /**\n     * 设置是否展示删除弹窗\n     */\n    fun setIsShowDelConfirmDialog(isshow:Boolean):PreviewConfig{\n        isShowDelConfirmDialog = isshow;\n        return this;\n\n    }\n\n\n    /***\n     * 指示器类型\n     */\n    @IntDef(IndicatorType.No, IndicatorType.Dot, IndicatorType.Number)\n    @Retention(AnnotationRetention.SOURCE)\n    annotation class IndicatorType {\n        companion object {\n            const val No = 0 // 什么也没有\n            const val Dot = 0x10//点方式\n            const val Number = 0x11// 数字方式 2/10\n        }\n    }\n\n    override fun writeToParcel(parcel: Parcel, flags: Int) {\n        parcel.writeByte(if (isScale) 1 else 0)\n        parcel.writeInt(maxSelect)\n        parcel.writeByte(if (isFullScreen) 1 else 0)\n        parcel.writeValue(previewMode)\n        parcel.writeInt(duration)\n        parcel.writeValue(isSingleFling)\n        parcel.writeValue(sensitivity)\n        parcel.writeValue(isDrag)\n        parcel.writeInt(position)\n        parcel.writeValue(indicatorType)\n        parcel.writeByte(if (isShowIndicates) 1 else 0)\n        parcel.writeString(compressDir)\n//         parcel.writeList(datas as List<*>?)\n//         parcel.writeList(selectedDatas as List<*>?)\n        parcel.writeSerializable(className)\n       parcel.writeInt(maxCanSelectVideoCount)\n    }\n\n    override fun describeContents(): Int {\n        return 0\n    }\n\n\n    fun setData(mDatas: MutableList<MediaData>?): PreviewConfig? {\n        MediaHodle.routDatas = mDatas\n        return this\n    }\n\n\n\n    companion object CREATOR : Parcelable.Creator<PreviewConfig> {\n        override fun createFromParcel(parcel: Parcel): PreviewConfig {\n            return PreviewConfig(parcel)\n        }\n\n        override fun newArray(size: Int): Array<PreviewConfig?> {\n            return arrayOfNulls(size)\n        }\n        fun from():PreviewConfig{\n            return PreviewConfig()\n        }\n\n    }\n\n\n}\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522802839},"updatedAt":{"$$date":1598524612953},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"QLLFZ5g9ixjweUxD"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977484727},"updatedAt":{"$$date":1594977484727},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"QPGyrZNG1M79YRlg"}
{"name":"ad-imageload_fresco","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    implementation project(path: ':frame_imageload')\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n//    api deps.fresco.fresco\n//    api deps.fresco.imagepipeline_okhttp\n//    api deps.fresco.animated_gif\n\n    api 'com.facebook.fresco:fresco:2.2.0'\n    //implementation 'om.facebook.fresco:webpsupport:1.3.0'\n    // http\n    api 'com.facebook.fresco:imagepipeline-okhttp3:2.2.0'\n    api 'com.facebook.fresco:animated-webp:2.2.0'\n    api 'com.facebook.fresco:animated-gif:2.2.0'\n\n}\n\n\n\n\n\n\n\n\n\n\npublic class FrescoLoader implements ILoad {\n    private Context mContex;\n    @Override\n    public void init(Context appContext , ImageLoaderConfig config) {\n        this.mContex = appContext.getApplicationContext();\n        Fresco.initialize(appContext, getPipelineConfig(appContext,config));\n    }\n\n    @Override\n    public void loadImage(@NonNull LoadOptions options)   {\n        load(options);\n    }\n\n    @Override\n    public Bitmap getBitmap(String url) {\n        return null;\n    }\n\n    @Override\n    public File getFileFromDiskCache(String url) {\n        return null;\n    }\n\n    @Override\n    public boolean hasCache(String url) {\n        return false;\n    }\n\n\n\n    @Override\n    public void clearAllCache() {\n        Fresco.getImagePipeline().clearCaches();\n    }\n\n    @Override\n    public void clearDiskCache() {\n        Fresco.getImagePipeline().clearDiskCaches();\n    }\n\n    @Override\n    public void clearMemoryCache() {\n        Fresco.getImagePipeline().clearMemoryCaches();\n    }\n\n    @Override\n    public void onTrim(int level) {\n        clearMemoryCache();\n    }\n\n    @Override\n    public void removeCache(String url) {\n        try {\n            Fresco.getImagePipeline().evictFromCache(Uri.parse(url));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void pause(Object context) {\n        Fresco.getImagePipeline().pause();\n    }\n\n    @Override\n    public void resume(Object context) {\n        Fresco.getImagePipeline().resume();\n    }\n\n    private static final int IMAGETAG=1;\n    private void load(final LoadOptions options) {\n        ImageView imageView= (ImageView) options.getTargetView();\n\n        ViewGroup.LayoutParams params=imageView.getLayoutParams();\n        if (params==null) {\n            params=new ViewGroup.LayoutParams(200,200);\n        }\n\n        if (params.width==WRAP_CONTENT){\n            params.width=MATCH_PARENT;\n        }\n        if (params.height==WRAP_CONTENT){\n            params.height=MATCH_PARENT;\n        }\n        imageView.setLayoutParams(params);\n        GenericDraweeHierarchy hierarchy=null;\n        GenericDraweeHierarchyBuilder hierarchyBuilder = GenericDraweeHierarchyBuilder.newInstance(imageView.getContext().getResources());\n        DraweeHolder draweeHolder= (DraweeHolder) imageView.getTag(R.id.fresco_drawee);\n        Uri uri= null;\n        if (options.getResource()!=-1){\n            // 加载本地drawable 资源\n            uri= Uri.parse(\"res://\"+mContex.getPackageName()+\"/\"+options.getResource());\n        }else if (!TextUtils.isEmpty(options.getUrl()) && !options.getUrl().contains(\"http\")) {\n            // 本地文件\n            uri= Uri.parse(\"file://\"+options.getUrl());\n        }else{\n            uri=Uri.parse(options.getUrl());\n        }\n        if (uri == null) {\n            return;\n        }\n\n        if (options.placeholder()!=-1) {\n            hierarchyBuilder.setPlaceholderImage(options.placeholder());\n        }\n        if (options.errorDrawable()!=-1) {\n            hierarchyBuilder.setFailureImage(options.errorDrawable());\n        }\n        if (options.isCircle()) {\n            RoundingParams roundingParams = new RoundingParams();\n            hierarchyBuilder.setRoundingParams(roundingParams.setRoundAsCircle(true));\n        }\n\n        if (options.needImageRadius()) {\n            RoundingParams roundingParams = RoundingParams.fromCornersRadius(options.getImageRadius());\n            hierarchyBuilder.setRoundingParams(roundingParams);\n        }\n        if (options.getProgressCallback()!=null){\n            hierarchyBuilder.setProgressBarImage(new LoaderDrawable(options.getProgressCallback()));\n        }\n        if (hierarchy == null) {\n            hierarchy= hierarchyBuilder.build();\n\n        }\n        PipelineDraweeControllerBuilder controllerBuilder=Fresco.newDraweeControllerBuilder().setUri(uri).setAutoPlayAnimations(true);\n        ImageRequestBuilder imageRequestBuilder= ImageRequestBuilder.newBuilderWithSource(uri);\n        CombinePostProcessors.Builder processBuilder = new CombinePostProcessors.Builder();\n        //渐变图\n        if (options.isBlurImage()) {\n            processBuilder.add(new BlurPostProcessor(options.getBlurValue(),mContex));\n        }\n        //灰色图\n        if(options.isGray()){\n            processBuilder.add(new GrayscalePostprocessor());\n        }\n\n        if (options.getImageSize() != null) {\n            imageRequestBuilder.setResizeOptions(new ResizeOptions(options.getImageSize().getWidth(), options.getImageSize().getWidth()));\n        }\n        if (! options.isAsGif()) {\n            // 解决有些gif格式的头像的展示问题，因为我们需要展示一个静态的圆形图片\n            imageRequestBuilder.setImageDecodeOptions(ImageDecodeOptions.newBuilder().setForceStaticImage(true).build());\n        }\n        if(processBuilder.hasProcessor()) {\n            imageRequestBuilder.setPostprocessor(processBuilder.build());\n        }\n\n        ImageRequest request =imageRequestBuilder.build();\n        controllerBuilder.setImageRequest(request);\n\n\n        if (options.getLoaderCallBack() != null||options.getGifCallback()!=null) {\n            controllerBuilder.setControllerListener(new ControllerListener<ImageInfo>() {\n                @Override\n                public void onSubmit(String id, Object callerContext) {\n\n                }\n\n                @Override\n                public void onFinalImageSet(String id, @Nullable ImageInfo imageInfo, @Nullable Animatable animatable) {\n                    if (options.getLoaderCallBack() != null) {\n                        options.getLoaderCallBack().onSucc();\n\n                    }\n                    //gif动画\n                    if(options.isAsGif()&&options.getGifCallback()!=null&&animatable!=null){\n                        options.getGifCallback().onGetGif(new FrescoGif(animatable));\n                    }\n                }\n\n                @Override\n                public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {\n\n                }\n\n                @Override\n                public void onIntermediateImageFailed(String id, Throwable throwable) {\n\n                }\n\n                @Override\n                public void onFailure(String id, Throwable throwable) {\n                    LoaderCallBack callBack =options.getLoaderCallBack();\n                    if (callBack != null) {\n                        callBack.onFail();\n\n                    }\n                    if(options.isAsGif()&&options.getGifCallback()!=null){\n                        options.getGifCallback().onError(throwable);\n                    }\n\n                }\n\n                @Override\n                public void onRelease(String id) {\n\n                }\n            });\n        }\n        DraweeController controller;\n\n        if (draweeHolder == null) {\n            draweeHolder=DraweeHolder.create(hierarchy,options.getTargetView().getContext());\n            controller=controllerBuilder.build();\n\n        }else {\n            controller= controllerBuilder.setOldController(draweeHolder.getController()).build();\n\n        }\n\n\n        // 请求\n        draweeHolder.setController(controller);\n\n\n        ViewStatesListener mStatesListener=new ViewStatesListener(draweeHolder);\n\n        imageView.addOnAttachStateChangeListener(mStatesListener);\n\n        // 判断是否ImageView已经 attachToWindow\n        if (ViewCompat.isAttachedToWindow(imageView)) {\n            draweeHolder.onAttach();\n        }\n\n//        if (ViewC.isAttachedToWindow()) {\n//            draweeHolder.onAttach();\n//        }\n        // 保证每一个ImageView中只存在一个draweeHolder\n        imageView.setTag(R.id.fresco_drawee,draweeHolder);\n        // 拿到数据\n        imageView.setImageDrawable(draweeHolder.getTopLevelDrawable());\n\n    }\n\n\n\n    /**\n     * 加载本地图片（assets图片）\n     * @param context\n     * @param simpleDraweeView\n     * @param nameWithSuffix 带后缀的名称\n     */\n    public static void loadAssetsPic(Context context, SimpleDraweeView simpleDraweeView, String nameWithSuffix) {\n        Uri uri = Uri.parse(\"asset:///\" +\n                nameWithSuffix);\n        simpleDraweeView.setImageURI(uri);\n\n    }\n\n\n\n    public class ViewStatesListener implements View.OnAttachStateChangeListener{\n\n        private DraweeHolder holder;\n        public ViewStatesListener(DraweeHolder holder){\n            this.holder=holder;\n        }\n\n        @Override\n        public void onViewAttachedToWindow(View v) {\n            this.holder.onAttach();\n        }\n\n        @Override\n        public void onViewDetachedFromWindow(View v) {\n            this.holder.onDetach();\n        }\n    }\n\n\n    public ImagePipelineConfig getPipelineConfig(Context context,ImageLoaderConfig config) {\n        // set the cache file path\n        DiskCacheConfig.Builder diskBuilder = DiskCacheConfig.newBuilder(context)\n                .setMaxCacheSize(config.getMaxDisk())\n                .setMaxCacheSizeOnLowDiskSpace(config.getMaxMemory() / 5);\n        if(config.getDiskCacheDir()!=null){\n            diskBuilder.setBaseDirectoryPath(new File(config.getDiskCacheDir()));\n        }\n        DiskCacheConfig diskCacheConfig= diskBuilder.build();\n        OkHttpClient client =null;\n        if(config.getHttpClient()!=null && config.getHttpClient() instanceof OkHttpClient){\n            client = (OkHttpClient) config.getHttpClient();\n        }else {\n            client = getClient();\n        }\n\n        return ImagePipelineConfig.newBuilder(context)\n                .setDownsampleEnabled(true)\n                .setNetworkFetcher(new OkHttpNetworkFetcher(client))\n                .setMainDiskCacheConfig(diskCacheConfig)\n                .setBitmapsConfig(config.getOption())\n                // 保证缓存达到一定条件就及时清除缓存\n                .setBitmapMemoryCacheParamsSupplier(\n                        new BitmapMemoryCacheParamsSupplier((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE),config))\n\n                .build();\n    }\n\n    private OkHttpClient getClient() {\n            try {\n                final TrustManager[] trustAllCerts = new TrustManager[]{\n                        new X509TrustManager() {\n                            @Override\n                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {\n                            }\n\n                            @Override\n                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {\n                            }\n\n                            @Override\n                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                                return new X509Certificate[0];\n                            }\n                        }\n                };\n                final SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                final javax.net.ssl.SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n                OkHttpClient.Builder builder = new OkHttpClient().newBuilder();\n                builder.connectTimeout(15, TimeUnit.SECONDS)\n                        .readTimeout(30, TimeUnit.SECONDS);\n                builder.sslSocketFactory(sslSocketFactory);\n                builder.hostnameVerifier(new HostnameVerifier() {\n                    @Override\n                    public boolean verify(String hostname, SSLSession session) {\n                        return true;\n                    }\n                });\n                return builder.build();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n\n\n    }\n\n\n}\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598525721587},"updatedAt":{"$$date":1598537411993},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"QYPYARGpqa7l33eG"}
{"name":"qk-ks_lib_route","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'lib-route-consumer-rules.pro'\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    api deps.kotlin.stdlib_jdk\n    api deps.androidx.core_ktx\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    api deps.router.arouter_api\n}\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A container that contains the roadmap 二次封装\n * ，所有的方法均来自于 Postcard\n */\npublic class KsPostcard {\n    private Postcard postcard;\n\n    KsPostcard(String path) {\n        this.postcard = KsRouter.getThirdRouter().build(path);\n    }\n\n    public ARouter getRouter() {\n        return KsRouter.getThirdRouter();\n    }\n\n    public KsPostcard withString(@Nullable String key, @Nullable String value) {\n        postcard.withString(key, value);\n        return this;\n    }\n\n    public KsPostcard withBoolean(@Nullable String key, boolean value) {\n        postcard.withBoolean(key, value);\n        return this;\n    }\n\n    public KsPostcard withShort(@Nullable String key, short value) {\n        postcard.withShort(key, value);\n        return this;\n    }\n\n    public KsPostcard withInt(@Nullable String key, int value) {\n        postcard.withInt(key, value);\n        return this;\n    }\n\n    public Object navigation() {\n        //加上来源，下个页面可以用来统计使用\n        return withString(RouterDelegate.INSTANCE.getCurrentActivityStatisticKey(), RouterDelegate.INSTANCE.getCurrentActivityStatisticName())\n                .navigation(null);\n//        return navigation(null);\n    }\n\n    public Object navigation(Context context) {\n//        withString(GlobalConstant.KEY_FROM_ACTIVITY, BridgeDelegate.getInstance().currentActivityStatisticName());\n        return postcard.navigation(context, null);\n    }\n\n    public KsPostcard withSerializable(@Nullable String key, @Nullable Serializable value) {\n        postcard.withSerializable(key, value);\n        return this;\n    }\n\n    public KsPostcard withLong(@Nullable String key, long value) {\n        postcard.withLong(key, value);\n        return this;\n    }\n\n    public KsPostcard withParcelable(@Nullable String key, @Nullable Parcelable value) {\n        postcard.withParcelable(key, value);\n        return this;\n    }\n\n\n    public KsPostcard withFlags( int flag) {\n        postcard.withFlags(flag);\n        return this;\n    }\n\n    public KsPostcard withTransition(int enterAnim, int exitAnim) {\n        postcard.withTransition(enterAnim, exitAnim);\n        return this;\n    }\n\n    public void navigation(Context mContext, int requestCode) {\n        navigation(mContext, requestCode, null);\n    }\n\n    public void navigation(Context mContext, NavigationCallback navigationCallback){\n        postcard.navigation(mContext, navigationCallback);\n    }\n\n    public void navigation(Context mContext, int requestCode, NavigationCallback callback) {\n//        withString(GlobalConstant.KEY_FROM_ACTIVITY, BridgeDelegate.getInstance().currentActivityStatisticName());\n        getRouter().navigation(mContext, postcard, requestCode, callback);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class KsRouter {\n\n\n    private static class KsRouterSingletonHolder {\n        private static final KsRouter KS_ROUTER_INSTANCE = new KsRouter();\n    }\n\n    private KsRouter() {\n        //no instance\n    }\n    public static KsRouter getInstance() {\n        return KsRouterSingletonHolder.KS_ROUTER_INSTANCE;\n    }\n\n    public KsPostcard build(String path) {\n        return new KsPostcard(path);\n    }\n\n    /**\n     * 第三方的router\n     *\n     * @return 第三方路由\n     */\n    static ARouter getThirdRouter() {\n        return ARouter.getInstance();\n    }\n}\n\n\n\n\n\n\n\n\n\n\n@Keep\nobject RouterDelegate {\n\n    private var config: RouterConfig? = null\n    private var isInit: Boolean = false\n\n    fun init(config: RouterConfig) {\n        if (isInit) {\n            return\n        }\n        RouterDelegate.config = config\n        isInit = true\n    }\n\n    fun getCurrentActivityStatisticName(): String? {\n        return checkConfig().getCurrentActivityStatisticName()\n    }\n\n    fun getCurrentActivityStatisticKey(): String? {\n        return checkConfig().getCurrentActivityStatisticKey()\n    }\n\n    interface RouterConfig {\n        fun getCurrentActivityStatisticKey(): String?\n        fun getCurrentActivityStatisticName(): String?\n    }\n\n\n    fun checkConfig(): RouterConfig {\n        if (config == null) {\n            throw RuntimeException(\"请先调用 RouterDelegate.init(config: RouterConfig) 初始化路由代理\")\n        }\n\n        return config!!\n    }\n\n}\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580901083},"updatedAt":{"$$date":1598581638500},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"QcPYDZQMWhEdoWH0"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977489742},"updatedAt":{"$$date":1594977489742},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Qp3aCt5X3TFPnMCo"}
{"name":"kotlin-迭代器 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/iterators.html\n迭代器 - Kotlin 语言中文站\n9-11 minutes\n改进翻译\n对于遍历集合元素， Kotlin 标准库支持 迭代器 的常用机制——对象可按顺序提供对元素的访问权限，而不会暴露集合的底层结构。 当需要逐个处理集合的所有元素（例如打印值或对其进行类似更新）时，迭代器非常有用。\n\nIterable<T> 接口的继承者（包括 Set 与 List）可以通过调用 iterator() 函数获得迭代器。 一旦获得迭代器它就指向集合的第一个元素；调用 next() 函数将返回此元素，并将迭代器指向下一个元素（如果下一个元素存在）。 一旦迭代器通过了最后一个元素，它就不能再用于检索元素；也无法重新指向到以前的任何位置。要再次遍历集合，请创建一个新的迭代器。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val numbersIterator = numbers.iterator()\n    while (numbersIterator.hasNext()) {\n        println(numbersIterator.next())\n    }\n//sampleEnd\n}\n遍历 Iterable 集合的另一种方法是众所周知的 for 循环。在集合中使用 for 循环时，将隐式获取迭代器。因此，以下代码与上面的示例等效：\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    for (item in numbers) {\n        println(item)\n    }\n//sampleEnd\n}\n最后，有一个好用的 forEach() 函数，可自动迭代集合并为每个元素执行给定的代码。因此，等效的示例如下所示：\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    numbers.forEach {\n        println(it)\n    }\n//sampleEnd\n}\n对于列表，有一个特殊的迭代器实现： ListIterator 它支持列表双向迭代：正向与反向。 反向迭代由 hasPrevious() 和 previous() 函数实现。 此外， ListIterator 通过 nextIndex() 与 previousIndex() 函数提供有关元素索引的信息。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val listIterator = numbers.listIterator()\n    while (listIterator.hasNext()) listIterator.next()\n    println(\"Iterating backwards:\")\n    while (listIterator.hasPrevious()) {\n        print(\"Index: ${listIterator.previousIndex()}\")\n        println(\", value: ${listIterator.previous()}\")\n    }\n//sampleEnd\n}\n具有双向迭代的能力意味着 ListIterator 在到达最后一个元素后仍可以使用。\n\n为了迭代可变集合，于是有了 MutableIterator 来扩展 Iterator 使其具有元素删除函数 remove() 。因此，可以在迭代时从集合中删除元素。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\") \n    val mutableIterator = numbers.iterator()\n    \n    mutableIterator.next()\n    mutableIterator.remove()    \n    println(\"After removal: $numbers\")\n//sampleEnd\n}\n除了删除元素， MutableListIterator 还可以在迭代列表时插入和替换元素。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"four\", \"four\") \n    val mutableListIterator = numbers.listIterator()\n    \n    mutableListIterator.next()\n    mutableListIterator.add(\"two\")\n    mutableListIterator.next()\n    mutableListIterator.set(\"three\")   \n    println(numbers)\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308430780},"updatedAt":{"$$date":1597314006134},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Qs3zJoAOyXYrkzeg"}
{"name":"css-CSS 表单","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 表单\n一个表单案例，我们使用 CSS 来渲染 HTML 的表单元素：\n\nCSS 实例\ninput[type=text], select {\n  width: 100%;\n  padding: 12px 20px;\n  margin: 8px 0;\n  display: inline-block;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  box-sizing: border-box;\n}\n \ninput[type=submit] {\n  width: 100%;\n  background-color: #4CAF50;\n  color: white;\n  padding: 14px 20px;\n  margin: 8px 0;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n \ninput[type=submit]:hover {\n  background-color: #45a049;\n}\n \ndiv {\n  border-radius: 5px;\n  background-color: #f2f2f2;\n  padding: 20px;\n}\n\n尝试一下 »\n输入框(input) 样式\n使用 width 属性来设置输入框的宽度：\n\nCSS 实例\ninput {\n  width: 100%;\n}\n\n尝试一下 »\n以上实例中设置了所有 <input> 元素的宽度为 100%，如果你只想设置指定类型的输入框可以使用以下属性选择器：\n\ninput[type=text] - 选取文本输入框\ninput[type=password] - 选择密码的输入框\ninput[type=number] - 选择数字的输入框\n...\n输入框填充\n使用 padding 属性可以在输入框中添加内边距。\n\nCSS 实例\ninput[type=text] {\n  width: 100%;\n  padding: 12px 20px;\n  margin: 8px 0;\n  box-sizing: border-box;\n}\n\n尝试一下 »\n注意我们设置了 box-sizing 属性为 border-box。这样可以确保浏览器呈现出带有指定宽度和高度的输入框是把边框和内边距一起计算进去的。\n更多内容可以阅读 CSS3 框大小 。\n\n输入框(input) 边框\n使用 border 属性可以修改 input 边框的大小或颜色，使用 border-radius 属性可以给 input 添加圆角：\n\nCSS 实例\ninput[type=text] {\n  border: 2px solid red;\n  border-radius: 4px;\n}\n\n尝试一下 »\n如果你只想添加底部边框可以使用 border-bottom 属性:\n\nCSS 实例\ninput[type=text] {\n  border: none;\n  border-bottom: 2px solid red;\n}\n\n尝试一下 »\n输入框(input) 颜色\n可以使用 background-color 属性来设置输入框的背景颜色，color 属性用于修改文本颜色：\n\nCSS 实例\ninput[type=text] {\n  background-color: #3CBC8D;\n  color: white;\n}\n\n尝试一下 »\n输入框(input) 聚焦\n默认情况下，一些浏览器在输入框获取焦点时（点击输入框）会有一个蓝色轮廓。我们可以设置 input 样式为 outline: none; 来忽略该效果。\n\n使用 :focus 选择器可以设置输入框在获取焦点时的样式：\n\nCSS 实例\ninput[type=text]:focus {\n  background-color: lightblue;\n}\n\n尝试一下 »\nCSS 实例\ninput[type=text]:focus {\n  border: 3px solid #555;\n}\n\n尝试一下 »\n输入框(input) 图标\n如果你想在输入框中添加图标，可以使用 background-image 属性和用于定位的background-position 属性。注意设置图标的左边距，让图标有一定的空间：\n\nCSS 实例\ninput[type=text] {\n  background-color: white;\n  background-image: url('searchicon.png');\n  background-position: 10px 10px; \n  background-repeat: no-repeat;\n  padding-left: 40px;\n}\n\n尝试一下 »\n带动画的搜索框\n以下实例使用了 CSS transition 属性，该属性设置了输入框在获取焦点时会向右延展。你可以在 CSS 动画 章节查看更多内容。\n\nCSS 实例\ninput[type=text] {\n  -webkit-transition: width 0.4s ease-in-out;\n  transition: width 0.4s ease-in-out;\n}\n \ninput[type=text]:focus {\n  width: 100%;\n}\n\n尝试一下 »\n文本框（textarea）样式\n注意: 使用 resize 属性来禁用文本框可以重置大小的功能（一般拖动右下角可以重置大小）。\n\nCSS 实例\ntextarea {\n  width: 100%;\n  height: 150px;\n  padding: 12px 20px;\n  box-sizing: border-box;\n  border: 2px solid #ccc;\n  border-radius: 4px;\n  background-color: #f8f8f8;\n  resize: none;\n}\n\n尝试一下 »\n下拉菜单（select）样式\nCSS 实例\nselect {\n  width: 100%;\n  padding: 16px 20px;\n  border: none;\n  border-radius: 4px;\n  background-color: #f1f1f1;\n}\n\n尝试一下 »\n按钮样式\nCSS 实例\ninput[type=button], input[type=submit], input[type=reset] {\n  background-color: #4CAF50;\n  border: none;\n  color: white;\n  padding: 16px 32px;\n  text-decoration: none;\n  margin: 4px 2px;\n  cursor: pointer;\n}\n \n/* 提示: 使用 width: 100% 设置全宽按钮 */\n\n尝试一下 »\n更多内容可以参考我们的 CSS 按钮 教程。\n\n响应式表单\n响应式表单可以根据浏览器窗口的大小重新布局各个元素，我们可以通过重置浏览器窗口大小来查看效果：\n\n高级: 以下实例使用了CSS3 多媒体查询 来创建一个响应式表单。\n\nCSS 实例\n* {\n  box-sizing: border-box;\n}\n \ninput[type=text], select, textarea {\n  width: 100%;\n  padding: 12px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  resize: vertical;\n}\n \nlabel {\n  padding: 12px 12px 12px 0;\n  display: inline-block;\n}\n \ninput[type=submit] {\n  background-color: #4CAF50;\n  color: white;\n  padding: 12px 20px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  float: right;\n}\n \ninput[type=submit]:hover {\n  background-color: #45a049;\n}\n \n.container {\n  border-radius: 5px;\n  background-color: #f2f2f2;\n  padding: 20px;\n}\n \n.col-25 {\n  float: left;\n  width: 25%;\n  margin-top: 6px;\n}\n \n.col-75 {\n  float: left;\n  width: 75%;\n  margin-top: 6px;\n}\n \n/* 清除浮动 */\n.row:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n \n/* 响应式布局 layout - 在屏幕宽度小于 600px 时， 设置为上下堆叠元素 */\n@media screen and (max-width: 600px) {\n  .col-25, .col-75, input[type=submit] {\n    width: 100%;\n    margin-top: 0;\n  }\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973628337},"updatedAt":{"$$date":1598974471838},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Qu1uJdkFSDdO8Ra5"}
{"name":"ad-ksseekbar","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"/*\n * Copyright (c) Gustavo Claramunt (AnderWeb) 2014.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\napply plugin: 'com.android.library'\n//apply plugin: 'bintray-release' // must be applied after your artifact generating plugin (eg. java / com.android.library)\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n//    dependencies {\n//        classpath 'com.novoda:bintray-release:0.2.10'\n//    }\n}\n\n/**\n * Properties for versioning\n */\ndef libVersionCode = 2\ndef libVersion = '1.0.1'\n\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n\n        versionCode libVersionCode\n        versionName libVersion\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n}\n//\n//publish {\n//    /**\n//     * Properties for BinTray upload\n//     */\n//    Properties properties = new Properties()\n//    File bintrayPropertiesFile = project.file('bintray.properties');\n//    if (bintrayPropertiesFile.exists()) {\n//        properties.load(bintrayPropertiesFile.newDataInputStream())\n//    }\n//    def btrayUser = properties.getProperty(\"bintray.user\", \"\")\n//    def btrayKey = properties.getProperty(\"bintray.apikey\", \"\")\n//\n//    bintrayUser = btrayUser\n//    bintrayKey = btrayKey\n//    userOrg = btrayUser\n//    groupId = 'org.adw.library'\n//    artifactId = 'discrete-seekbar'\n//    licences = \"['Apache-2.0']\"\n//    publishVersion = libVersion\n//    description = 'DiscreteSeekbar is my poor attempt to develop an android implementation of the Discrete Slider component from the Google Material Design Guidelines'\n//    website = 'https://github.com/AnderWeb/discreteSeekBar'\n//    issueTracker = 'https://github.com/AnderWeb/discreteSeekBar/issues'\n//    repository = 'https://github.com/AnderWeb/discreteSeekBar.git'\n//    autoPublish = false\n//    dryRun = false\n//}\n\ndependencies {\n    implementation deps.androidx.support_v4\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\nAnimatorCompat\nAnimatorCompatV11\nSeekBarCompat\nSeekBarCompatDontCrash\ndrawable\nAlmostRippleDrawable\nMarkerDrawable\nStateDrawable\nThumbDrawable\nTrackOvalDrawable\nTrackRectDrawable\nMarker\nPopupIndicator\nDiscreteSeekBar\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598519924612},"updatedAt":{"$$date":1598521184766},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"QvuYStURrhI8adV0"}
{"name":"ad-polyv_chat","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 5\n\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n\n}\nrepositories {\n    maven {\n        url 'http://maven.aliyun.com/nexus/content/repositories/releases/'\n    }\n    maven { url 'https://dl.bintray.com/polyv/android' }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    \n    testImplementation deps.androidx.junit\n    api (deps.polyv){\n        exclude group:'com.easefun.polyv',module:'polyvPlayerABI'\n        exclude group:'tv.danmaku.ijk.media'\n        exclude group:'com.aliyun.ams'\n        exclude group:'pl.droidsonroids.gif'\n        exclude group:'com.tencent.bugly'\n        }\n    implementation deps.eventbus\n    api ks.kschatframe\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\npublic class PolyvChatConfig {\n    /**appId */\n    public static String appId = \"fmx98hdagr\";\n    /**保利威 userId  名字怪异 有位置是account id*/\n    public static String polyAccountID = \"9ee6528764\";\n    /**保利威 加密key*/\n    public static String secretKey = \"7d7e86a7d27946758e44073dab461b42\";\n\n// 测试key\n//    private String userId = \"9ee6528764\";\n//    private String appId = \"fmx98hdagr\";\n//    private String appSecret = \"7d7e86a7d27946758e44073dab461b42\";\n//    private String channelId = \"1407116\";\n}\n\n\n\n\n\n\n\n\n\n\n\npublic class PolyvApiRequestUtils {\n\n    //上报观看热度\n    public static Disposable increasePageViewer(String channelId, PolyvrResponseCallback<Integer> callback) {\n        String appId = PolyvLiveSDKClient.getInstance().getAppId();\n        String appSecret = PolyvLiveSDKClient.getInstance().getAppSecret();\n        int times = 1;\n        long ts = System.currentTimeMillis();\n        Map<String, String> paramMap = new ArrayMap<>();\n        paramMap.put(\"channelId\", channelId);\n        paramMap.put(\"appId\", appId);\n        paramMap.put(\"timestamp\", String.valueOf(ts));\n        paramMap.put(\"times\", String.valueOf(times));\n        String sign = PolyvSignCreator.createSign(appSecret, paramMap);\n        return PolyvResponseExcutor.excuteDataBean(\n                PolyvApiManager.getPolyvLiveStatusApi().increasePageViewer(Integer.valueOf(channelId), appId, ts, sign, times),\n                Integer.class, callback);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 保利威Im 聊天室 实现\n */\npublic class PolyvChatroom extends AbsImManager {\n    public static final String TAG = \"PLVECChatroom\";\n    PolyvConnectStatusListener listener;\n    PolyvNewMessageListener2 msgListener;\n    private String channelID;\n    private Disposable disposable;\n\n    public PolyvChatroom() {\n        mMsgDispatch = new PolyvDisPatch();\n    }\n\n    /**\n     * 设置消息监听\n     */\n    private void setListener() {\n        if (listener == null)\n            listener = new PolyvConnectStatusListener() {\n                @Override\n                public void onConnectStatusChange(int status, Throwable t) {\n                    if (mConnectListener != null) {//回调连接事件\n                        switch (status) {\n                            case PolyvConnectStatusListener.STATUS_LOGINING:\n                                mConnectListener.onConnecting();\n                                break;\n                            case PolyvConnectStatusListener.STATUS_LOGINSUCCESS:\n                                mConnectListener.onConnected(status + \"\");\n                                break;\n                            case PolyvConnectStatusListener.STATUS_DISCONNECT:\n                                mConnectListener.onConnectFail(\"连接失败\" + t == null ? \"\" : t.getMessage());\n                                break;\n                            case PolyvConnectStatusListener.STATUS_RECONNECTING:\n                                mConnectListener.onReConnect();\n                                break;\n                            case PolyvConnectStatusListener.STATUS_RECONNECTSUCCESS:\n                                mConnectListener.onReConnectSuccess();\n                                break;\n\n                        }\n                    } else if (eventBus != null) {//通过EventBus 发送连接事件\n\n                        switch (status) {\n                            case STATUS_LOGINING:\n                                eventBus.post(new RoomEvent(EventConfig.CONNECTING));\n                                Log.i(TAG, \"event=STATUS_LOGINING\");\n                                break;\n                            case STATUS_LOGINSUCCESS:\n                                String loginRoomId = PolyvChatManager.getInstance().getLoginRoomId();\n                                //获取真正RoomId\n                                eventBus.post(new RoomEvent(EventConfig.CONNECTED,PolyvChatManager.getInstance().getLoginRoomId()));\n                                if (PolyvChatManager.getInstance().isBanIp) {\n                                    eventBus.post(new RoomEvent(EventConfig.EVENT_ROOM_MUTE));\n                                }\n\n                                break;\n                            case STATUS_DISCONNECT:\n                                Log.i(TAG, \"event=STATUS_DISCONNECT\");\n                                eventBus.post(new RoomEvent(EventConfig.DISCONNECT));\n                                break;\n                            case STATUS_RECONNECTING:\n                                Log.i(TAG, \"event=STATUS_RECONNECTING\");\n                                eventBus.post(new RoomEvent(EventConfig.RECONNECTING));\n                                break;\n                            case STATUS_RECONNECTSUCCESS:\n                                Log.i(TAG, \"event=STATUS_RECONNECTSUCCESS\");\n                                eventBus.post(new RoomEvent(EventConfig.RECONNECTSUCCESS,PolyvChatManager.getInstance().getLoginRoomId()));\n                                if (PolyvChatManager.getInstance().isBanIp) {\n                                    eventBus.post(new RoomEvent(EventConfig.EVENT_ROOM_MUTE));\n                                }\n                                break;\n\n                        }\n                    }\n                }\n            };\n        PolyvChatManager.getInstance().addConnectStatusListener(listener);\n        if (msgListener == null)\n            //设置消息监听F\n            msgListener = new PolyvNewMessageListener2() {\n\n                @Override\n                public void onNewMessage(String message, String event, String type) {\n                    if (mMsgDispatch != null) {\n                        mMsgDispatch.onDispatchMsg(type, event, message);\n                    }\n                }\n\n                @Override\n                public void onDestroy() {\n                    if (mMsgDispatch != null) {\n                        mMsgDispatch.destroy();\n                        mMsgDispatch = null;\n                    }\n                }\n            };\n        //true 子线程回调消息\n        PolyvChatManager.getInstance().addNewMessageListener(msgListener,true);\n    }\n\n    private void initPolyvInfo(String channelID) {\n        if(disposable!=null){\n            disposable.dispose();\n        }\n        disposable = PolyvApiRequestUtils.increasePageViewer(channelID, null);\n\n    }\n\n    /**\n     * 发送空数据 只发Event\n     *\n     * @param event\n     */\n    private void sendEventEmptyMsg(String event) {\n        PolyvCustomEvent<EmptyMsg> customEvent = new PolyvCustomEvent<EmptyMsg>(event/*自定义信息事件名*/, new EmptyMsg());\n        customEvent.setEmitMode(PolyvBaseCustomEvent.EMITMODE_OTHERS);//设置广播方式，EMITMODE_ALL为广播给包括自己的所有用户，EMITMODE_OTHERS为广播给不包括自己的所有用户\n        customEvent.setVersion(PolyvCustomEvent.VERSION_1);//设置信息的版本号，对该版本号的信息才进行处理\n        PolyvChatManager.getInstance().sendCustomMsg(customEvent);\n    }\n\n    /**\n     * 登录\n     *\n     * @param channelId\n     */\n    @Override\n    public void login(String channelId) {\n        setListener();\n        initPolyvInfo(channelId);\n        this.channelID = channelId;\n//             * 登录，登录参数均不能为空\n//                *\n//     * @param accountId  直播账号id\n//     * @param viewerId   聊天室用户id\n//     * @param roomId     房间号\n//     * @param viewerName 聊天室用户昵称\n//     * @param avatarUrl  头像地址，需为url格式\n\n        //设置连接转台监听\n        PolyvChatManager.getInstance().setAccountId(PolyvChatConfig.polyAccountID);\n        PolyvChatManager.getInstance().userType = PolyvChatManager.USERTYPE_STUDENT;\n        PolyvChatManager.getInstance().login(userInfo.userId, channelId, userInfo.name,\n                TextUtils.isEmpty(userInfo.avatar) ? PolyvChatManager.DEFAULT_AVATARURL : userInfo.avatar,\n                new PolyvChatAuthorization(userInfo.isVip + \"\", PolyvChatAuthorization.BGCOLOR_DEFAULT, PolyvChatAuthorization.FCOLOR_DEFAULT)\n        );\n    }\n\n    /**\n     * 获取用户 前几个排名\n     *\n     * @param num 0 返回全部\n     * @return\n     */\n    @Override\n    public List<SimpleUserInfo> getPreUsers(int num) {\n        return null;\n    }\n\n    /**\n     * 获取在线人数\n     *\n     * @return\n     */\n    @Override\n    public int getOnlineNum() {\n        return PolyvChatManager.getInstance().getOnlineCount();\n    }\n\n\n    /**\n     * 发送文字消息 （分享/文字）\n     *\n     * @param msg\n     */\n    @Override\n    public void sendMsg(TextMsg msg) {\n        if (msg == null) {\n            return;\n        }\n        if (TextUtils.isEmpty(msg.getType()) || msg.getType().equals(EventConfig.TYPE_MSG)) {\n            //文字消息\n            PolyvChatManager.getInstance().sendChatMessage(new PolyvLocalMessage(msg.getMsg()));\n        } else if (msg.getType().equals(EventConfig.TYPE_SHARE_LIVE)) {\n            //Share 类型发布\n            sendEventEmptyMsg(EventConfig.TYPE_SHARE_LIVE);\n\n        }\n        //** 去购物\n        else if (EventConfig.TYPE_GO_SHOP.equals(msg.getType())) {\n            sendEventEmptyMsg(EventConfig.TYPE_GO_SHOP);\n        }\n    }\n\n    /**\n     * 发送礼物\n     *\n     * @param gift\n     */\n    @Override\n    public void sendGift(GiftMsg gift) {\n\n        PolyvCustomEvent<GiftMsg> event = new PolyvCustomEvent<>(PolyvConfig.TYPE_GIFT, gift);\n        event.setEmitMode(PolyvBaseCustomEvent.EMITMODE_ALL);//设置广播方式，EMITMODE_ALL为广播给包括自己的所有用户，EMITMODE_OTHERS为广播给不包括自己的所有用户\n        event.setVersion(PolyvCustomEvent.VERSION_1);\n        PolyvChatManager.getInstance().sendCustomMsg(event);\n    }\n\n    @Override\n    public void quitRoom() {\n        PolyvChatManager.getInstance().disconnect();\n    }\n\n    /**\n     * 连接状态\n     *\n     * @return true 连接 ，false 未连接\n     */\n    @Override\n    public boolean isConnect() {\n        return PolyvChatManager.getInstance().isOnline();\n    }\n\n    /**\n     * 断开连接\n     */\n    @Override\n    public void disConnect() {\n        PolyvChatManager.getInstance().disconnect();\n        //释放保利威上报\n\n    }\n\n\n    @Override\n    public void setUserInfo(SimpleUserInfo info) {\n        super.setUserInfo(info);\n        PolyvDisPatch.userInfo = info;\n    }\n\n    @Override\n    public void setEventBus(EventBus bus) {\n        super.setEventBus(bus);\n        PolyvDisPatch.eventbus = bus;\n    }\n\n    /**\n     * 销毁，退出页面时需要销毁聊天室，销毁后会把所有监听器都清空掉\n     */\n    @Override\n    public void destory() {\n        //释放保利威上报\n        if(disposable!=null){\n            disposable.dispose();\n        }\n        PolyvChatManager.getInstance().removeNewMessageListener(msgListener);\n        PolyvChatManager.getInstance().removeConnectStatusListener(listener);\n        msgListener = null;\n        listener = null;\n        super.destory();\n        PolyvChatManager.getInstance().disconnect();\n        PolyvChatManager.getInstance().destroy();\n\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * **************************************\n * 项目名称:kaishustory\n *\n * @Author fenghl\n * 邮箱：hilofeng@homail.com\n * 创建时间: 2020/5/6    2:42 PM\n * 用途：\n * **************************************\n */\npublic interface PolyvConfig {\n    /**\n     * 服务端调用保利威 发送的自定义消息类型\n     */\n    String TYPE_SERVER = \"CUSTOMER_MESSGAE\";\n\n\n    /**\n     * 礼物\n     */\n    String TYPE_GIFT = \"KSGift\";\n\n    /**\n     * 商品\n     */\n    String TYPE_SHOP = \"KSCommodity\";\n\n\n    /**\n     * 系统公告消息\n     */\n    String TYPE_SYTEM = \"system\";\n\n\n    /**\n     * 标签\n     */\n    String TYPE_SERVER_STICKER = \"sticker-message\";\n\n    /**\n     * 服务端推送礼物\n     */\n    String TYPE_SERVER_GIFT = \"gift-message\";\n    /**\n     * 服务端推送 ** 去购买\n     */\n    String TYPE_SERVER_GO_SHOP = \"buy-message\";\n    /**\n     * 服务端推送 正在讲解商品\n     */\n    String TYPE_SERVER_GUIDE_GOODS = \"product-list-explaining\";\n    /**\n     * 服务器推送 更新商品\n     */\n    String TYPE_SERVER_UPDATE_GOODS = \"product-update\";\n    /**\n     * 服务器推送 更新礼物列表\n     */\n    String TYPE_SERVER_FRESH_GIFT = \"gift-refresh-message\";\n    /**\n     * 服务器推送 更新礼物列表\n     */\n    String TYPE_SERVER_SHARE_LIVE = \"share-message\";\n\n    /**\n     * 服务器推送 直播结束\n     */\n    String TYPE_SERVER_LIVE_END = \"live-end\";\n\n    /**\n     * 服务器推送 实时房间人数 每隔几秒一次\n     */\n    String TYPE_SERVER_ONLINE_No = \"live-online-no\";\n    /**\n     * 服务器推送 切换房间\n     */\n    String TYPE_SERVER_SWITCH_CHANNEL = \"live-channel-switch\";\n\n    /**\n     * 服务器推送 刷新发言文字颜色\n     */\n    String TYPE_SERVER_FRESH_FONT_COLOR = \"live-comment-colour\";\n\n    /**\n     * 服务器推送 文字发言间隔\n     */\n    String TYPE_SERVER_FRESH_SPEAK_INTERVAL = \"live-color-interval\";\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n class PolyvGiftBean {\n     /**\n      * giftId : 13\n      * giftCount : 10\n      * userId : 123\n      * nickName : 测试\n      * nickIconUrl : asd\n      */\n    public  String giftName;\n     public String giftId;\n     public int giftCount;\n     public String userId;\n     public String nickName;\n     public String giftUrl;\n     public String nickIconUrl;\n\n\n }\n\n\n\n\npublic class PolyvMsg {\n\n\n    String type;\n    String event;\n    String message;\n\n    public PolyvMsg(String type, String event, String message) {\n        this.type = type;\n        this.event = event;\n        this.message = message;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\nclass PolyvServerEvent  {\n\n //   {\"EVENT\":\"CUSTOMER_MESSAGE\",\"content\":{\"data\":{\"id\":1,\"liveId\":2343355454,\"stickerName\":\"贴纸1\",\"stickerSite\":\"top\",\"stickerImgUrl\":\"www.baidu.com\",\"isPublish\":\"0\"},\"messageType\":\"sticker-message\"},\"id\":\"66a5b010-91c9-11ea-b844-7d36f3ae1f84\",\"roomId\":\"1410021\",\"user\":{\"clientIp\":\"\",\"nick\":\"系统\",\"pic\":\"http://live.videocc.net/assets/wimages/pc_images/ds80x80.png\",\"roomId\":\"1410021\",\"uid\":\"2\"}}\n    /**\n     * EVENT : CUSTOMER_MESSAGE\n     * content : {\"data\":{\"id\":1,\"liveId\":2343355454,\"stickerName\":\"贴纸1\",\"stickerSite\":\"top\",\"stickerImgUrl\":\"www.baidu.com\",\"isPublish\":\"0\"},\"messageType\":\"sticker-message\"}\n     * id : 66a5b010-91c9-11ea-b844-7d36f3ae1f84\n     * roomId : 1410021\n     * user : {\"clientIp\":\"\",\"nick\":\"系统\",\"pic\":\"http://live.videocc.net/assets/wimages/pc_images/ds80x80.png\",\"roomId\":\"1410021\",\"uid\":\"2\"}\n     */\n\n    private String EVENT;\n    private String content;\n    private String id;\n    private String roomId;\n    private UserBean user;\n\n    public String getEVENT() {\n        return EVENT;\n    }\n\n    public void setEVENT(String EVENT) {\n        this.EVENT = EVENT;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getRoomId() {\n        return roomId;\n    }\n\n    public void setRoomId(String roomId) {\n        this.roomId = roomId;\n    }\n\n    public UserBean getUser() {\n        return user;\n    }\n\n    public void setUser(UserBean user) {\n        this.user = user;\n    }\n\n    public static class ContentBean {\n        /**\n         * data : {\"id\":1,\"liveId\":2343355454,\"stickerName\":\"贴纸1\",\"stickerSite\":\"top\",\"stickerImgUrl\":\"www.baidu.com\",\"isPublish\":\"0\"}\n         * messageType : sticker-message\n         */\n\n        private DataBean data;\n        private String messageType;\n\n        public DataBean getData() {\n            return data;\n        }\n\n        public void setData(DataBean data) {\n            this.data = data;\n        }\n\n        public String getMessageType() {\n            return messageType;\n        }\n\n        public void setMessageType(String messageType) {\n            this.messageType = messageType;\n        }\n\n        public static class DataBean {\n            /**\n             * id : 1\n             * liveId : 2343355454\n             * stickerName : 贴纸1\n             * stickerSite : top\n             * stickerImgUrl : www.baidu.com\n             * isPublish : 0\n             */\n\n            private int id;\n            private long liveId;\n            private String stickerName;\n            private String stickerSite;\n            private String stickerImgUrl;\n            private String isPublish;\n\n            public int getId() {\n                return id;\n            }\n\n            public void setId(int id) {\n                this.id = id;\n            }\n\n            public long getLiveId() {\n                return liveId;\n            }\n\n            public void setLiveId(long liveId) {\n                this.liveId = liveId;\n            }\n\n            public String getStickerName() {\n                return stickerName;\n            }\n\n            public void setStickerName(String stickerName) {\n                this.stickerName = stickerName;\n            }\n\n            public String getStickerSite() {\n                return stickerSite;\n            }\n\n            public void setStickerSite(String stickerSite) {\n                this.stickerSite = stickerSite;\n            }\n\n            public String getStickerImgUrl() {\n                return stickerImgUrl;\n            }\n\n            public void setStickerImgUrl(String stickerImgUrl) {\n                this.stickerImgUrl = stickerImgUrl;\n            }\n\n            public String getIsPublish() {\n                return isPublish;\n            }\n\n            public void setIsPublish(String isPublish) {\n                this.isPublish = isPublish;\n            }\n        }\n    }\n\n    public static class UserBean {\n        /**\n         * clientIp :\n         * nick : 系统\n         * pic : http://live.videocc.net/assets/wimages/pc_images/ds80x80.png\n         * roomId : 1410021\n         * uid : 2\n         */\n\n        private String clientIp;\n        private String nick;\n        private String pic;\n        private String roomId;\n        private String uid;\n\n        public String getClientIp() {\n            return clientIp;\n        }\n\n        public void setClientIp(String clientIp) {\n            this.clientIp = clientIp;\n        }\n\n        public String getNick() {\n            return nick;\n        }\n\n        public void setNick(String nick) {\n            this.nick = nick;\n        }\n\n        public String getPic() {\n            return pic;\n        }\n\n        public void setPic(String pic) {\n            this.pic = pic;\n        }\n\n        public String getRoomId() {\n            return roomId;\n        }\n\n        public void setRoomId(String roomId) {\n            this.roomId = roomId;\n        }\n\n        public String getUid() {\n            return uid;\n        }\n\n        public void setUid(String uid) {\n            this.uid = uid;\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n class GoodsBean  {\n  /**\n   * messageType : product-list-explaining\n   * data : {\"productId\":\"1\"}\n   */\n\n  private String messageType;\n  private DataBean data;\n\n  public String getMessageType() {\n   return messageType;\n  }\n\n  public void setMessageType(String messageType) {\n   this.messageType = messageType;\n  }\n\n  public DataBean getData() {\n   return data;\n  }\n\n  public void setData(DataBean data) {\n   this.data = data;\n  }\n\n\n  public static class DataBean {\n   /**\n    * productId : 1\n    */\n\n   private String productId;\n\n   public String getProductId() {\n    return productId;\n   }\n\n   public void setProductId(String productId) {\n    this.productId = productId;\n   }\n  }\n }\n\n\n\n\n\n\n\n class BaseBean {\n    String messageType;\n    private String data;\n\n     public String getMessageType() {\n         return messageType;\n     }\n\n     public void setMessageType(String messageType) {\n         this.messageType = messageType;\n     }\n\n     public String getData() {\n         return data;\n     }\n\n     public void setData(String data) {\n         this.data = data;\n     }\n }\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598517303772},"updatedAt":{"$$date":1598518915188},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"R3OJVcSyEgZlmjMk"}
{"name":"kotlin-内联函数与具体化的类型参数 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/inline-functions.html\n内联函数与具体化的类型参数 - Kotlin 语言中文站\n13-17 minutes\n改进翻译\n使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。 即那些在函数体内会访问到的变量。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。\n\n但是在许多情况下通过内联化 lambda 表达式可以消除这类的开销。 下述函数是这种情况的很好的例子。即 lock() 函数可以很容易地在调用处内联。 考虑下面的情况：\n\n编译器没有为参数创建一个函数对象并生成一个调用。取而代之，编译器可以生成以下代码：\n\nl.lock()\ntry {\n    foo()\n}\nfinally {\n    l.unlock()\n}\n这个不是我们从一开始就想要的吗？\n\n为了让编译器这么做，我们需要使用 inline 修饰符标记 lock() 函数：\n\ninline fun <T> lock(lock: Lock, body: () -> T): T { …… }\ninline 修饰符影响函数本身和传给它的 lambda 表达式：所有这些都将内联到调用处。\n\n内联可能导致生成的代码增加；不过如果我们使用得当（即避免内联过大函数），性能上会有所提升，尤其是在循环中的“超多态（megamorphic）”调用处。\n\n如果希望只内联一部分传给内联函数的 lambda 表达式参数，那么可以用 noinline 修饰符标记不希望内联的函数参数：\n\ninline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) { …… }\n可以内联的 lambda 表达式只能在内联函数内部调用或者作为可内联的参数传递， 但是 noinline 的可以以任何我们喜欢的方式操作：存储在字段中、传送它等等。\n\n需要注意的是，如果一个内联函数没有可内联的函数参数并且没有具体化的类型参数，编译器会产生一个警告，因为内联这样的函数很可能并无益处（如果你确认需要内联，则可以用 @Suppress(\"NOTHING_TO_INLINE\") 注解关掉该警告）。\n\n在 Kotlin 中，我们只能对具名或匿名函数使用正常的、非限定的 return 来退出。 这意味着要退出一个 lambda 表达式，我们必须使用一个标签，并且在 lambda 表达式内部禁止使用裸 return，因为 lambda 表达式不能使包含它的函数返回：\n\nfun ordinaryFunction(block: () -> Unit) {\n    println(\"hi!\")\n}\n//sampleStart\nfun foo() {\n    ordinaryFunction {\n        return // 错误：不能使 `foo` 在此处返回\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n但是如果 lambda 表达式传给的函数是内联的，该 return 也可以内联，所以它是允许的：\n\ninline fun inlined(block: () -> Unit) { println(\"hi!\") }\n\n//sampleStart\nfun foo() {\n    inlined {\n        return // OK：该 lambda 表达式是内联的\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n这种返回（位于 lambda 表达式中，但退出包含它的函数）称为非局部返回。 我们习惯了在循环中用这种结构，其内联函数通常包含：\n\nfun hasZeros(ints: List<Int>): Boolean {\n    ints.forEach {\n        if (it == 0) return true // 从 hasZeros 返回\n    }\n    return false\n}\n请注意，一些内联函数可能调用传给它们的不是直接来自函数体、而是来自另一个执行上下文的 lambda 表达式参数，例如来自局部对象或嵌套函数。在这种情况下，该 lambda 表达式中也不允许非局部控制流。为了标识这种情况，该 lambda 表达式参数需要用 crossinline 修饰符标记:\n\ninline fun f(crossinline body: () -> Unit) {\n    val f = object: Runnable {\n        override fun run() = body()\n    }\n    // ……\n}\nbreak 和 continue 在内联的 lambda 表达式中还不可用，但我们也计划支持它们。\n\n有时候我们需要访问一个作为参数传给我们的一个类型：\n\nfun <T> TreeNode.findParentOfType(clazz: Class<T>): T? {\n    var p = parent\n    while (p != null && !clazz.isInstance(p)) {\n        p = p.parent\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return p as T?\n}\n在这里我们向上遍历一棵树并且检测每个节点是不是特定的类型。 这都没有问题，但是调用处不是很优雅：\n\ntreeNode.findParentOfType(MyTreeNode::class.java)\n我们真正想要的只是传一个类型给该函数，即像这样调用它：\n\ntreeNode.findParentOfType<MyTreeNode>()\n为能够这么做，内联函数支持具体化的类型参数，于是我们可以这样写：\n\ninline fun <reified T> TreeNode.findParentOfType(): T? {\n    var p = parent\n    while (p != null && p !is T) {\n        p = p.parent\n    }\n    return p as T?\n}\n我们使用 reified 修饰符来限定类型参数，现在可以在函数内部访问它了， 几乎就像是一个普通的类一样。由于函数是内联的，不需要反射，正常的操作符如 !is 和 as 现在都能用了。此外，我们还可以按照上面提到的方式调用它：myTree.findParentOfType<MyTreeNodeType>()。\n\n虽然在许多情况下可能不需要反射，但我们仍然可以对一个具体化的类型参数使用它：\n\ninline fun <reified T> membersOf() = T::class.members\n\nfun main(s: Array<String>) {\n    println(membersOf<StringBuilder>().joinToString(\"\\n\"))\n}\n普通的函数（未标记为内联函数的）不能有具体化参数。 不具有运行时表示的类型（例如非具体化的类型参数或者类似于Nothing的虚构类型） 不能用作具体化的类型参数的实参。\n\n相关底层描述，请参见规范文档。\n\ninline 修饰符可用于没有幕后字段的属性的访问器。 你可以标注独立的属性访问器：\n\nval foo: Foo\n    inline get() = Foo()\n\nvar bar: Bar\n    get() = ……\n    inline set(v) { …… }\n你也可以标注整个属性，将它的两个访问器都标记为内联：\n\ninline var bar: Bar\n    get() = ……\n    set(v) { …… }\n在调用处，内联访问器如同内联函数一样内联。\n\n当一个内联函数是 public 或 protected 而不是 private 或 internal 声明的一部分时，就会认为它是一个模块级的公有 API。可以在其他模块中调用它，并且也可以在调用处内联这样的调用。\n\n这带来了一些由模块做这样变更时导致的二进制兼容的风险——声明一个内联函数但调用它的模块在它修改后并没有重新编译。\n\n为了消除这种由非公有 API 变更引入的不兼容的风险，公有 API 内联函数体内不允许使用非公有声明，即，不允许使用 private 与 internal 声明以及其部件。\n\n一个 internal 声明可以由 @PublishedApi 标注，这会允许它在公有 API 内联函数中使用。当一个 internal 内联函数标记有 @PublishedApi 时，也会像公有函数一样检测其函数体。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308427675},"updatedAt":{"$$date":1597313799408},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"R4mR4ncbyKm9CVd6"}
{"name":"ad-ksflycotablayout","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\n//apply plugin: 'com.github.dcendents.android-maven'\n//apply plugin: 'com.jfrog.bintray'\n\n// 这个version是区分library版本的，因此当我们需要更新library时记得修改这个version\nversion = \"2.1.2\"\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 212\n        versionName version\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.support_v4\n    implementation deps.fresco.fresco\n    implementation ks.ksloadpic\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\nCustomTabEntity\nDoubleClickListener\nOnTabSelectListener\nutils\nFragmentChangeManager\nUnreadMsgUtils\nwidget\nMsgView\nCommonTabLayout\nSegmentTabLayout\nSlidingTabLayout\n\n\n\n\n\n\n\n\n\n/** 用于需要圆角矩形框背景的TextView的情况,减少直接使用TextView时引入的shape资源文件 */\npublic class MsgView extends TextView {\n    private Context context;\n    private GradientDrawable gd_background = new GradientDrawable();\n    private int backgroundColor;\n    private int cornerRadius;\n    private int strokeWidth;\n    private int strokeColor;\n    private boolean isRadiusHalfHeight;\n    private boolean isWidthHeightEqual;\n\n    public MsgView(Context context) {\n        this(context, null);\n    }\n\n    public MsgView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public MsgView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        this.context = context;\n        obtainAttributes(context, attrs);\n    }\n\n    private void obtainAttributes(Context context, AttributeSet attrs) {\n        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.MsgView);\n        backgroundColor = ta.getColor(R.styleable.MsgView_mv_backgroundColor, Color.TRANSPARENT);\n        cornerRadius = ta.getDimensionPixelSize(R.styleable.MsgView_mv_cornerRadius, 0);\n        strokeWidth = ta.getDimensionPixelSize(R.styleable.MsgView_mv_strokeWidth, 0);\n        strokeColor = ta.getColor(R.styleable.MsgView_mv_strokeColor, Color.TRANSPARENT);\n        isRadiusHalfHeight = ta.getBoolean(R.styleable.MsgView_mv_isRadiusHalfHeight, false);\n        isWidthHeightEqual = ta.getBoolean(R.styleable.MsgView_mv_isWidthHeightEqual, false);\n\n        ta.recycle();\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        if (isWidthHeightEqual() && getWidth() > 0 && getHeight() > 0) {\n            int max = Math.max(getWidth(), getHeight());\n            int measureSpec = MeasureSpec.makeMeasureSpec(max, MeasureSpec.EXACTLY);\n            super.onMeasure(measureSpec, measureSpec);\n            return;\n        }\n\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        if (isRadiusHalfHeight()) {\n            setCornerRadius(getHeight() / 2);\n        } else {\n            setBgSelector();\n        }\n    }\n\n\n    public void setBackgroundColor(int backgroundColor) {\n        this.backgroundColor = backgroundColor;\n        setBgSelector();\n    }\n\n    public void setCornerRadius(int cornerRadius) {\n        this.cornerRadius = dp2px(cornerRadius);\n        setBgSelector();\n    }\n\n    public void setStrokeWidth(int strokeWidth) {\n        this.strokeWidth = dp2px(strokeWidth);\n        setBgSelector();\n    }\n\n    public void setStrokeColor(int strokeColor) {\n        this.strokeColor = strokeColor;\n        setBgSelector();\n    }\n\n    public void setIsRadiusHalfHeight(boolean isRadiusHalfHeight) {\n        this.isRadiusHalfHeight = isRadiusHalfHeight;\n        setBgSelector();\n    }\n\n    public void setIsWidthHeightEqual(boolean isWidthHeightEqual) {\n        this.isWidthHeightEqual = isWidthHeightEqual;\n        setBgSelector();\n    }\n\n    public int getBackgroundColor() {\n        return backgroundColor;\n    }\n\n    public int getCornerRadius() {\n        return cornerRadius;\n    }\n\n    public int getStrokeWidth() {\n        return strokeWidth;\n    }\n\n    public int getStrokeColor() {\n        return strokeColor;\n    }\n\n    public boolean isRadiusHalfHeight() {\n        return isRadiusHalfHeight;\n    }\n\n    public boolean isWidthHeightEqual() {\n        return isWidthHeightEqual;\n    }\n\n    protected int dp2px(float dp) {\n        final float scale = context.getResources().getDisplayMetrics().density;\n        return (int) (dp * scale + 0.5f);\n    }\n\n    protected int sp2px(float sp) {\n        final float scale = this.context.getResources().getDisplayMetrics().scaledDensity;\n        return (int) (sp * scale + 0.5f);\n    }\n\n    private void setDrawable(GradientDrawable gd, int color, int strokeColor) {\n        gd.setColor(color);\n        gd.setCornerRadius(cornerRadius);\n        gd.setStroke(strokeWidth, strokeColor);\n    }\n\n    public void setBgSelector() {\n        StateListDrawable bg = new StateListDrawable();\n\n        setDrawable(gd_background, backgroundColor, strokeColor);\n        bg.addState(new int[]{-android.R.attr.state_pressed}, gd_background);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {//16\n            setBackground(bg);\n        } else {\n            //noinspection deprecation\n            setBackgroundDrawable(bg);\n        }\n    }\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521316700},"updatedAt":{"$$date":1598522651545},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"R6dbbzQTEirIqtfK"}
{"name":"kotlin-我们通常会定义这样的回调接口来实现异步数据的请求，我们可以很方便的将它转换成协程的接口：","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n异步代码的异常处理通常都比较让人头疼，而协程则再一次展现了它的威力。\n\n1. 引子\n我们在前面一篇文章当中提到了这样一个例子：\n\ntypealias Callback = (User) -> Unit\n\nfun getUser(callback: Callback){\n    ...\n}\n我们通常会定义这样的回调接口来实现异步数据的请求，我们可以很方便的将它转换成协程的接口：\n\nsuspend fun getUserCoroutine() = suspendCoroutine<User> {\n    continuation ->\n    getUser {\n        continuation.resume(it)\n    }\n}\n并最终交给按钮点击事件或者其他事件去触发这个异步请求：\n\ngetUserBtn.setOnClickListener {\n    GlobalScope.launch(Dispatchers.Main) {\n        userNameView.text = getUserCoroutine().name\n    }\n}\n那么问题来了，既然是请求，总会有失败的情形，而我们这里并没有对错误的处理，接下来我们就完善这个例子。\n\n2. 添加异常处理逻辑\n首先我们加上异常回调接口函数：\n\ninterface Callback<T> {\n    fun onSuccess(value: T)\n\n    fun onError(t: Throwable)\n}\n接下来我们在改造一下我们的 getUserCoroutine：\n\nsuspend fun getUserCoroutine() = suspendCoroutine<User> { continuation ->\n    getUser(object : Callback<User> {\n        override fun onSuccess(value: User) {\n            continuation.resume(value)\n        }\n\n        override fun onError(t: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })\n}\n大家可以看到，我们似乎就是完全把 Callback 转换成了一个 Continuation，在调用的时候我们只需要：\n\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        userNameView.text = getUserCoroutine().name\n    } catch (e: Exception) {\n        userNameView.text = \"Get User Error: $e\"\n    }\n}\n是的，你没看错，一个异步的请求异常，我们只需要在我们的代码中捕获就可以了，这样做的好处就是，请求的全流程异常都可以在一个 try ... catch ... 当中捕获，那么我们可以说真正做到了把异步代码变成了同步的写法。\n\n如果你一直在用 RxJava 处理这样的逻辑，那么你的请求接口可能是这样的：\n\nfun getUserObservable(): Single<User> {\n    return Single.create<User> { emitter ->\n        getUser(object : Callback<User> {\n            override fun onSuccess(value: User) {\n                emitter.onSuccess(value)\n            }\n\n            override fun onError(t: Throwable) {\n                emitter.onError(t)\n            }\n        })\n    }\n}\n调用时大概是这样的：\n\ngetUserObservable()\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe ({ user ->\n            userNameView.text = user.name\n        }, {\n            userNameView.text = \"Get User Error: $it\"\n        })\n其实你很容易就能发现在这里 RxJava 做的事儿跟协程的目的是一样的，只不过协程用了一种更自然的方式。\n\n也许你已经对 RxJava 很熟悉并且感到很自然，但相比之下，RxJava 的代码比协程的复杂度更高，更让人费解，这一点我们后面的文章中也会持续用例子来说明这一点。\n\n3. 全局异常处理\n线程也好、RxJava 也好，都有全局处理异常的方式，例如：\n\nfun main() {\n    Thread.setDefaultUncaughtExceptionHandler {t: Thread, e: Throwable ->\n        //handle exception here\n        println(\"Thread '${t.name}' throws an exception with message '${e.message}'\")\n    }\n\n    throw ArithmeticException(\"Hey!\")\n}\n我们可以为线程设置全局的异常捕获，当然也可以为 RxJava 来设置全局异常捕获：\n\nRxJavaPlugins.setErrorHandler(e -> {\n        //handle exception here\n        println(\"Throws an exception with message '${e.message}'\")\n});\n协程显然也可以做到这一点。类似于通过 Thread.setUncaughtExceptionHandler 为线程设置一个异常捕获器，我们也可以为每一个协程单独设置 CoroutineExceptionHandler，这样协程内部未捕获的异常就可以通过它来捕获：\n\nprivate suspend fun main(){\n    val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable ->\n        log(\"Throws an exception with message: ${throwable.message}\")\n    }\n\n    log(1)\n    GlobalScope.launch(exceptionHandler) {\n        throw ArithmeticException(\"Hey!\")\n    }.join()\n    log(2)\n}\n运行结果：\n\n19:06:35:087 [main] 1\n19:06:35:208 [DefaultDispatcher-worker-1 @coroutine#1] Throws an exception with message: Hey!\n19:06:35:211 [DefaultDispatcher-worker-1 @coroutine#1] 2\nCoroutineExceptionHandler 竟然也是一个上下文，协程的这个上下文可真是灵魂一般的存在，这倒是一点儿也不让人感到意外。\n\n当然，这并不算是一个全局的异常捕获，因为它只能捕获对应协程内未捕获的异常，如果你想做到真正的全局捕获，在 Jvm 上我们可以自己定义一个捕获类实现：\n\nclass GlobalCoroutineExceptionHandler: CoroutineExceptionHandler {\n    override val key: CoroutineContext.Key<*> = CoroutineExceptionHandler\n\n    override fun handleException(context: CoroutineContext, exception: Throwable) {\n        println(\"Coroutine exception: $exception\")\n    }\n}\n然后在 classpath 中创建 META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler，文件名实际上就是 CoroutineExceptionHandler 的全类名，文件内容就写我们的实现类的全类名：\n\ncom.bennyhuo.coroutines.sample2.exceptions.GlobalCoroutineExceptionHandler\n这样协程中没有被捕获的异常就会最终交给它处理。\n\nJvm 上全局 CoroutineExceptionHandler 的配置，本质上是对 ServiceLoader 的应用，之前我们在讲 Dispatchers.Main 的时候提到过，Jvm 上它的实现也是通过 ServiceLoader 来加载的。\n\n需要明确的一点是，通过 async 启动的协程出现未捕获的异常时会忽略 CoroutineExceptionHandler，这与 launch 的设计思路是不同的。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597400501625},"updatedAt":{"$$date":1597402813702},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"RHzJHyixYZbOZu7o"}
{"name":"kotlin-Kotlin 数据类与密封类 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-data-sealed-classes.html\nKotlin 数据类与密封类 | 菜鸟教程\n2-3 minutes\n数据类\nKotlin 可以创建一个只包含数据的类，关键字为 data：\n\ndata class User(val name: String, val age: Int)\n编译器会自动的从主构造函数中根据所有声明的属性提取以下函数：\n\nequals() / hashCode()\ntoString() 格式如 \"User(name=John, age=42)\"\ncomponentN() functions 对应于属性，按声明顺序排列\ncopy() 函数\n如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。\n\n为了保证生成代码的一致性以及有意义，数据类需要满足以下条件：\n\n主构造函数至少包含一个参数。\n\n所有的主构造函数的参数必须标识为val 或者 var ;\n\n数据类不可以声明为 abstract, open, sealed 或者 inner;\n\n数据类不能继承其他类 (但是可以实现接口)。\n\n复制\n复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样：\n\nfun copy(name: String = this.name, age: Int = this.age) = User(name, age)\n实例\n使用 copy 类复制 User 数据类，并修改 age 属性:\n\ndata class User(val name: String, val age: Int)\n\n\nfun main(args: Array<String>) {\n    val jack = User(name = \"Jack\", age = 1)\n    val olderJack = jack.copy(age = 2)\n    println(jack)\n    println(olderJack)\n\n}\n输出结果为：\n\nUser(name=Jack, age=1)\nUser(name=Jack, age=2)\n数据类以及解构声明\n组件函数允许数据类在解构声明中使用：\n\nval jane = User(\"Jane\", 35)\nval (name, age) = jane\nprintln(\"$name, $age years of age\") // prints \"Jane, 35 years of age\"\n标准数据类\n标准库提供了 Pair 和 Triple 。在大多数情形中，命名数据类是更好的设计选择，因为这样代码可读性更强而且提供了有意义的名字和属性。\n\n密封类\n密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。\n\n声明一个密封类，使用 sealed 修饰类，密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。\n\nsealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误)\n\nsealed class Expr\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n\nfun eval(expr: Expr): Double = when (expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n}\n使用密封类的关键好处在于使用 when 表达式 的时候，如果能够 验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。\n\nfun eval(expr: Expr): Double = when(expr) {\n    is Expr.Const -> expr.number\n    is Expr.Sum -> eval(expr.e1) + eval(expr.e2)\n    Expr.NotANumber -> Double.NaN\n    // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304145626},"updatedAt":{"$$date":1597304236287},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"RP2Z1l128IanzfZi"}
{"name":"qk-ks_component_sobot","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    libraryVariants.all {\n        it.getGenerateBuildConfigProvider()\n    }\n\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    android {\n        lintOptions {\n            abortOnError false\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    implementation deps.dialogplus\n    implementation 'com.squareup.picasso:picasso:2.5.2'\n    implementation 'com.sobot.chat:sobotsupport-glidev4:1.0.8'\n    implementation deps.support.app_compat\n    implementation deps.support.design, {\n        exclude group: \"com.android.support\", module: \"multidex\"\n    }\n    implementation kaishu.kprogresshud\n    implementation deps.kotlin.coroutines_core\n    implementation deps.kotlin.coroutines_android\n\n    if (develop) {\n        implementation project(':ks_lib_picture')\n        implementation project(':ks_lib_xtablayout')\n        implementation project(':ks_component_net')\n    } else {\n        implementation ks.lib_picture\n        implementation ks.lib_xtablayout\n        implementation ks.component_net\n    }\n}\n\n////这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n<!-- 访问权限 -->\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    <uses-permission android:name=\"com.google.android.apps.photos.permission.GOOGLE_PHOTOS\" />\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n    <uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\n    <uses-permission android:name=\"android.permission.GET_TASKS\" />\n    <uses-permission android:name=\"android.permission.VIBRATE\" />\n    <uses-permission android:name=\"android.permission.CAMERA\" />\n    <uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598585024114},"updatedAt":{"$$date":1598585699415},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"RWDMEPydvoZZrXRW"}
{"name":"html-HTML 脚本","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\nJavaScript 使 HTML 页面具有更强的动态和交互性。\n\nExamples\n在线实例\n插入一段脚本\n如何将脚本插入 HTML 文档。\n\n使用 <noscript> 标签\n如何应对不支持脚本或禁用脚本的浏览器。\n\nHTML <script> 标签\n<script> 标签用于定义客户端脚本，比如 JavaScript。\n\n<script> 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件。\n\nJavaScript 最常用于图片操作、表单验证以及内容动态更新。\n\n下面的脚本会向浏览器输出\"Hello World!\"：\n\n实例\n<script>\ndocument.write(\"Hello World!\");\n</script>\n\n尝试一下 »\nRemarkTip: 学习更多关于Javascript教程，请查看JavaScript 教程!\nHTML<noscript> 标签\n<noscript> 标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时。\n\n<noscript>元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。\n\n只有在浏览器不支持脚本或者禁用脚本时，才会显示 <noscript> 元素中的内容：\n\n实例\n<script>\ndocument.write(\"Hello World!\")\n</script>\n<noscript>抱歉，你的浏览器不支持 JavaScript!</noscript>\n\n尝试一下 »\n\nJavaScript体验(来自本站javascript教程)\nJavaScript实例代码:\n\nJavaScript可以直接在HTML输出:\ndocument.write(\"<p>这是一个段落。</p>\");\n\n尝试一下 »\n\nJavaScript事件响应:\n<button type=\"button\" onclick=\"myFunction()\">点我！</button>\n\n尝试一下 »\n\nJavaScript处理 HTML 样式:\ndocument.getElementById(\"demo\").style.color=\"#ff0000\";\n\n尝试一下 »\n\nHTML 脚本标签\n标签\t描述\n<script>\t定义了客户端脚本\n<noscript>\t定义了不支持脚本浏览器输出的文本\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886140099},"updatedAt":{"$$date":1598886874643},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"RkrOOR09Gyyg0a5J"}
{"name":"kotlin-Kotlin 循环控制 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-loop-control.html\nKotlin 循环控制 | 菜鸟教程\n3-4 minutes\nFor 循环\nfor 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下:\n\nfor (item in collection) print(item)\n循环体可以是一个代码块:\n\nfor (item: Int in ints) {\n    // ……\n}\n如上所述，for 可以循环遍历任何提供了迭代器的对象。\n\n如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：\n\nfor (i in array.indices) {\n    print(array[i])\n}\n注意这种\"在区间上遍历\"会编译成优化的实现而不会创建额外对象。\n\n或者你可以用库函数 withIndex：\n\nfor ((index, value) in array.withIndex()) {\n    println(\"the element at $index is $value\")\n}\n实例\n对集合进行迭代：\n\nfun main(args: Array<String>) {\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (item in items) {\n        println(item)\n    }\n\n    for (index in items.indices) {\n        println(\"item at $index is ${items[index]}\")\n    }\n}\n输出结果：\n\napple\nbanana\nkiwi\nitem at 0 is apple\nitem at 1 is banana\nitem at 2 is kiwi\nwhile 与 do...while 循环\nwhile是最基本的循环，它的结构为：\n\nwhile( 布尔表达式 ) {\n  //循环内容\n}\ndo…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\n\ndo…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。\n\ndo {\n       //代码语句\n}while(布尔表达式);\n实例\nfun main(args: Array<String>) {\n    println(\"----while 使用-----\")\n    var x = 5\n    while (x > 0) {\n        println( x--)\n    }\n    println(\"----do...while 使用-----\")\n    var y = 5\n    do {\n        println(y--)\n    } while(y>0)\n}\n输出结果：\n\n5\n4\n3\n2\n1\n----do...while 使用-----\n5\n4\n3\n2\n1\n返回和跳转\nKotlin 有三种结构化跳转表达式：\n\nreturn。默认从最直接包围它的函数或者匿名函数返回。\nbreak。终止最直接包围它的循环。\ncontinue。继续下一次最直接包围它的循环。\n在循环中 Kotlin 支持传统的 break 和 continue 操作符。\n\nfun main(args: Array<String>) {\n    for (i in 1..10) {\n        if (i==3) continue  // i 为 3 时跳过当前循环，继续下一次循环\n        println(i)\n        if (i>5) break   // i 为 6 时 跳出循环\n    }\n}\n输出结果：\n\n1\n2\n4\n5\n6\nBreak 和 Continue 标签\n在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可。\n\nloop@ for (i in 1..100) {\n    // ……\n}\n现在，我们可以用标签限制 break 或者continue：\n\nloop@ for (i in 1..100) {\n    for (j in 1..100) {\n        if (……) break@loop\n    }\n}\n标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。\n\n标签处返回\nKotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：\n\nfun foo() {\n    ints.forEach {\n        if (it == 0) return\n        print(it)\n    }\n}\n这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。\n\nfun foo() {\n    ints.forEach lit@ {\n        if (it == 0) return@lit\n        print(it)\n    }\n}\n现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。\n\nfun foo() {\n    ints.forEach {\n        if (it == 0) return@forEach\n        print(it)\n    }\n}\n或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回\n\nfun foo() {\n    ints.forEach(fun(value: Int) {\n        if (value == 0) return\n        print(value)\n    })\n}\n当要返一个回值的时候，解析器优先选用标签限制的 return，即\n\nreturn@a 1\n意为\"从标签 @a 返回 1\"，而不是\"返回一个标签标注的表达式 (@a 1)\"。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303690944},"updatedAt":{"$$date":1597303936638},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"RorDcFmMQNVAFMzs"}
{"name":"常用软件下载","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"常用软件下载\n一、必备软件\nVPN和配置文件\n账号密码见企业邮箱的邮件 !!!\n• 配置文件\n• Tunnelblick\n抓包工具\niOS/Android抓包需要找徐海缘寻求证书密码\nNDU5ODQwNzgwMDRmZGY3OTk4ZTcyOTA2NzI3OGYyZjcxOGQ4ZTA1ZmkwZDBmMGE=\n• Charles\n• 证书文件\nTips:提示文件已损坏\nsudo xattr -rd com.apple.quarantine 空格 软件的路径\neg: sudo xattr -rd com.apple.quarantine /Applications/Charles.app\n图片压缩工具\n• ImageOptim\n代码管理工具\n• SourseTree\n二、推荐软件\n开发辅助工具\n• SublimeText\n• InjectionIII\n• PerfDog\n文档写作画图工具\n• MWeb\n• XMind\n• MacDown\n• StarUML\n• CornerStone\n• Mac_office_2019\n其他工具\n• ShadowsocksX-NG（节点可找徐海缘申请福利）\n• CleanMyMac\n• Doxygen\n• LSUnusedResources\n• Things\n• iPhone 配置实用工具\n附录：\nMac安装软件时提示已损坏的解决方法"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598545329489},"updatedAt":{"$$date":1598545359382},"_id":"S9oMqEOZRchH2enh","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"CSS3 圆角","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 圆角\nCSS3 圆角\n使用 CSS3 border-radius 属性，你可以给任何元素制作 \"圆角\"。\n\nCSS3 圆角制作器\n\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器的版本号。\n\n-webkit- 或 -moz- 前面的数字表示支持该前缀的第一个版本。\n\n属性\t\t\t\t\t\nborder-radius\t9.0\t5.0\n4.0 -webkit-\t4.0\n3.0 -moz-\t5.0\n3.1 -webkit-\t10.5\nCSS3 border-radius 属性\n使用 CSS3 border-radius 属性，你可以给任何元素制作 \"圆角\"。\n\n以下为三个实例：\n\n1. 指定背景颜色的元素圆角：\n\n圆角！\n\n2. 指定边框的元素圆角:\n\n圆角！\n\n3. 指定背景图片的元素圆角:\n\n圆角！\n\n代码如下:\n\n实例\n#rcorners1 {\n    border-radius: 25px;\n    background: #8AC007;\n    padding: 20px;\n    width: 200px;\n    height: 150px;\n}\n\n#rcorners2 {\n    border-radius: 25px;\n    border: 2px solid #8AC007;\n    padding: 20px;\n    width: 200px;\n    height: 150px;\n}\n\n#rcorners3 {\n    border-radius: 25px;\n    background: url(paper.gif);\n    background-position: left top;\n    background-repeat: repeat;\n    padding: 20px;\n    width: 200px;\n    height: 150px;\n}\n\n尝试一下 »\nCSS3 border-radius - 指定每个圆角\n如果你在 border-radius 属性中只指定一个值，那么将生成 4 个 圆角。\n\n但是，如果你要在四个角上一一指定，可以使用以下规则：\n\n四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。\n三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角\n两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角\n一个值： 四个圆角值相同\n以下为三个实例:\n\n1. 四个值 - border-radius: 15px 50px 30px 5px:\n\n2. 三个值 - border-radius: 15px 50px 30px:\n\n3. 两个值 - border-radius: 15px 50px:\n\n以下为源代码:\n\n实例\n#rcorners4 {\n    border-radius: 15px 50px 30px 5px;\n    background: #8AC007;\n    padding: 20px;\n    width: 200px;\n    height: 150px;\n}\n\n#rcorners5 {\n    border-radius: 15px 50px 30px;\n    background: #8AC007;\n    padding: 20px;\n    width: 200px;\n    height: 150px;\n}\n\n#rcorners6 {\n    border-radius: 15px 50px;\n    background: #8AC007;\n    padding: 20px;\n    width: 200px;\n    height: 150px;\n}\n\n尝试一下 »\n您还可以创建椭圆边角:\n\n实例\n#rcorners7 {\n    border-radius: 50px/15px;\n    background: #8AC007;\n    padding: 20px;\n    width: 200px;\n    height: 150px;\n}\n\n#rcorners8 {\n    border-radius: 15px/50px;\n    background: #8AC007;\n    padding: 20px;\n    width: 200px;\n    height: 150px;\n}\n\n#rcorners9 {\n    border-radius: 50%;\n    background: #8AC007;\n    padding: 20px;\n    width: 200px;\n    height: 150px;\n}\n\n尝试一下 »\nCSS3 圆角属性\n属性\t描述\nborder-radius\t所有四个边角 border-*-*-radius 属性的缩写\nborder-top-left-radius\t定义了左上角的弧度\nborder-top-right-radius\t定义了右上角的弧度\nborder-bottom-right-radius\t定义了右下角的弧度\nborder-bottom-left-radius\t定义了左下角的弧度\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974609767},"updatedAt":{"$$date":1598974722668},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"SDE9IJ7M6FkcwiW8"}
{"name":"CSS3 过渡","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 过渡\nCSS3 过渡\nCSS3中，我们为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript。用鼠标移过下面的元素：\n\n用鼠标移过下面的元素：\n\nCSS3\n过渡\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器版本号。\n\n紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号。\n\n属性\t\t\t\t\t\ntransition\t26.0\n4.0 -webkit-\t10.0\t16.0\n4.0 -moz-\t6.1\n3.1 -webkit-\t12.1\n10.5 -o-\ntransition-delay\t26.0\n4.0 -webkit-\t10.0\t16.0\n4.0 -moz-\t6.1\n3.1 -webkit-\t12.1\n10.5 -o-\ntransition-duration\t26.0\n4.0 -webkit-\t10.0\t16.0\n4.0 -moz-\t6.1\n3.1 -webkit-\t12.1\n10.5 -o-\ntransition-property\t26.0\n4.0 -webkit-\t10.0\t16.0\n4.0 -moz-\t6.1\n3.1 -webkit-\t12.1\n10.5 -o-\ntransition-timing-function\t26.0\n4.0 -webkit-\t10.0\t16.0\n4.0 -moz-\t6.1\n3.1 -webkit-\t12.1\n10.5 -o-\n它是如何工作？\nCSS3 过渡是元素从一种样式逐渐改变为另一种的效果。\n\n要实现这一点，必须规定两项内容：\n\n指定要添加效果的CSS属性\n指定效果的持续时间。\nOperaSafariChromeFirefoxInternet Explorer\n实例\n应用于宽度属性的过渡效果，时长为 2 秒：\n\ndiv\n{\n    transition: width 2s;\n    -webkit-transition: width 2s; /* Safari */\n}\n\n注意： 如果未指定的期限，transition将没有任何效果，因为默认值是0。\n\n指定的CSS属性的值更改时效果会发生变化。一个典型CSS属性的变化是用户鼠标放在一个元素上时：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n规定当鼠标指针悬浮(:hover)于 <div>元素上时：\n\ndiv:hover\n{\n    width:300px;\n}\n\n尝试一下 »\n注意： 当鼠标光标移动到该元素时，它逐渐改变它原有样式\n\n多项改变\n要添加多个样式的变换效果，添加的属性由逗号分隔：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n添加了宽度，高度和转换效果：\n\ndiv\n{\n    transition: width 2s, height 2s, transform 2s;\n    -webkit-transition: width 2s, height 2s, -webkit-transform 2s;\n}\n\n尝试一下 »\n\n过渡属性\n下表列出了所有的过渡属性:\n\n属性\t描述\tCSS\ntransition\t简写属性，用于在一个属性中设置四个过渡属性。\t3\ntransition-property\t规定应用过渡的 CSS 属性的名称。\t3\ntransition-duration\t定义过渡效果花费的时间。默认是 0。\t3\ntransition-timing-function\t规定过渡效果的时间曲线。默认是 \"ease\"。\t3\ntransition-delay\t规定过渡效果何时开始。默认是 0。\t3\n下面的两个例子设置所有过渡属性：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n在一个例子中使用所有过渡属性：\n\ndiv\n{\n    transition-property: width;\n    transition-duration: 1s;\n    transition-timing-function: linear;\n    transition-delay: 2s;\n    /* Safari */\n    -webkit-transition-property:width;\n    -webkit-transition-duration:1s;\n    -webkit-transition-timing-function:linear;\n    -webkit-transition-delay:2s;\n}\n\n尝试一下 »\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n与上面的例子相同的过渡效果，但是使用了简写的 transition 属性：\n\ndiv\n{\n    transition: width 1s linear 2s;\n    /* Safari */\n    -webkit-transition:width 1s linear 2s;\n}\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974619615},"updatedAt":{"$$date":1598974970509},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"SFNo67bsmL7yBUqg"}
{"name":"Charles添加自定义证书验证","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"Charles添加自定义证书验证\n目的：实现抓取Https数据。\n现状：由于客户端开启了证书验证，导致抓包工具证书不能通过验证。\n目标：只有内部工作人员才可以进行抓取，其他人不可以抓取Https数据。\n开整\n一、通过Charles获取SSL Certificates Keystore Password\nCharles菜单中选择Help > SSLProxying > View Generated SSL Certificates Keystore Password，将显示的密码记下来。这个是在每个Charles安装的时候自动生成的，和你本机的Charles Root Certificates相对应。\n二、通过Charles获取p12文件\nCharles菜单中选择Help > SSLProxying > Export Charles Root Certificate and Private Key...，然后输入刚才的密码，将生成的p12文件保存好。\n三、通过Charles新建证书pem文件\nCharles菜单中选择Help > SSLProxying > Save Charles Root Certificate...，将pem文件保存下来\n四、通过pem文件生成cer证书文件\n打开终端，进入pem所在文件夹\nopenssl x509 -outform der -in 生成的pem文件名.pem -out 导出的文件名.cer\n五、在Charles中添加RootCertificate\nCharles菜单中选择Proxy > SSL Porxying Setting\n弹出界面中选择 SSL Proxying 选项卡 add （* 443）\n选择Root Certificate选项卡 choose 添加P12文件\n弹出界面中填入密码（第一步中的密码）\n六、在项目中添加第四步中的Cer文件（或者二进制数据字符串）\n具体验证方式每个开发做法不同，在你验证其他证书的位置加一份验证这个Cer的代码即可\n七、使用真机连接Charles进行抓包\n连接方法自行百度，并且勾选最基础的一些配置，这里就不再重复说明了\n密码一定要保护好，避免外泄"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598544473942},"updatedAt":{"$$date":1598544656105},"_id":"SRqA57uR8v3FSu45","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"css-CSS 属性 选择器","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 属性 选择器\n具有特定属性的HTML元素样式\n具有特定属性的HTML元素样式不仅仅是class和id。\n\n注意：IE7和IE8需声明!DOCTYPE才支持属性选择器！IE6和更低的版本不支持属性选择器。\n\n属性选择器\n下面的例子是把包含标题（title）的所有元素变为蓝色：\n\n实例\n[title]\n{\n    color:blue;\n}\n\n尝试一下 »\n\n属性和值选择器\n下面的实例改变了标题title='runoob'元素的边框样式:\n\n实例\n[title=runoob]\n{\n    border:5px solid green;\n}\n\n尝试一下 »\n\n属性和值的选择器 - 多值\n下面是包含指定值的title属性的元素样式的例子，使用（~）分隔属性和值:\n\n实例\n[title~=hello] { color:blue; }\n\n尝试一下 »\n下面是包含指定值的lang属性的元素样式的例子，使用（|）分隔属性和值:\n\n实例\n[lang|=en] { color:blue; }\n\n尝试一下 »\n\n表单样式\n属性选择器样式无需使用class或id的形式:\n\n实例\ninput[type=\"text\"]\n{\n    width:150px;\n    display:block;\n    margin-bottom:10px;\n    background-color:yellow;\n}\ninput[type=\"button\"]\n{\n    width:120px;\n    margin-left:35px;\n    display:block;\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973626497},"updatedAt":{"$$date":1598974442450},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"SSZDizDdPGUacvfj"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980158049},"updatedAt":{"$$date":1594980158049},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"SSnxaz5MuV2n69Bf"}
{"name":"部署一个新版本到凯叔app发布平台","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"#-------------------部署一个新版本到凯叔app发布平台-----------\nlane :UploadToKSAppDistribution do\n  apphoster(\n      api_host: \"https://appdown.kaishustory.com\", \n      token: \"9ff58ff3acea5a60855e46cdfca7d4e45ce5a92f\", \n      plat_id:\"5\", \n      ipa_host:\"https://appdown.kaishustory.com/pkgs/\"\n    )\nend"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598545980506},"updatedAt":{"$$date":1598545981519},"_id":"SStsMrQzaIl3IAdm","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980167316},"updatedAt":{"$$date":1594980167316},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"SrfFtoHY94KWFPOi"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598974376658},"updatedAt":{"$$date":1598974376658},"_id":"SsGNFkV5oD23GYfv"}
{"name":"kqapp-buildSrc","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n\n\nplugins {\n    `kotlin-dsl`\n}\nrepositories {\n    jcenter()\n}\n\n\n\n\nDependencies.kt\n\n\n\nobject Versions {\n    val gradle_plugin = \"4.0.1\"\n    val kotlin_version = \"1.4.0\"\n    val retrofit = \"2.7.1\"\n    val okhttp3 = \"4.2.0\"\n    val multidex = \"2.0.0\"\n    val junit = \"4.12\"\n    val fresco = \"1.11.0\"\n    val kotlin_coroutines = \"1.3.9\"\n    val androidx = \"1.2.0-alpha03\"\n    val constraintlayout = \"2.0.0-beta7\"\n    val arouter_compiler = \"1.2.2\"\n    val arouter_api = \"1.5.0\"\n    val arouter_register = \"1.0.2\"\n    val support = \"28.0.0\"\n    val packer_np_plugin = \"2.0.1\"\n    val tingyun_plugin = \"2.14.2\"\n\n    val roomVersion = \"2.2.1\"\n    val archLifecycleVersion = \"2.3.0-alpha05\"\n    val koin_version = \"2.1.6\"\n    val cardview = \"1.0.0\"\n    val MagicIndicator = \"1.6.0\"\n    val lottie = \"3.4.0\"\n    val zip = \"0.0.1\"\n    val navigation = \"2.2.1\"\n    val photodraweeview = \"2.0.0\"\n    val gifdrawable = \"1.2.19\"\n    val AppStartFaster = \"1.0.1\"\n    val glide = \"4.11.0\"\n    val permission_version = \"4.7.0\"\n}\n\n\nval booster_version = \"2.1.0\"\n\n\nval app_id = \"com.ks.lightlearn\"\nval useLibrary = \"org.apache.http.legacy\"   //兼容httpclient\n\nval testInstrumentationRunner = \"android.support.test.runner.AndroidJUnitRunner\"\n\nobject SignConfig {\n    val storeFile = \"../../config/kaishustory.jks\"\n    val storePassword = \"kaishu2099\"\n    val keyAlias = \"kaishustory\"\n    val keyPassword = \"kaishu2099\"\n}\n\n\nobject signAloneConfig {\n    val storeFile = \"../../../config/kaishustory.jks\"\n    val storePassword = \"kaishu2099\"\n    val keyAlias = \"kaishustory\"\n    val keyPassword = \"kaishu2099\"\n}\n\n//三方的appid\nobject Placeholder {\n\n    val UMENG_APPKEY = \"5e4664fb0cafb24c060000c3\"\n    val JPUSH_PKGNAME = \"${app_id}\"\n\n    //JPush上注册的包名对应的appkey.\n    val JPUSH_CHANNEL = \"ks\" //暂时填写默认值即可.\n    val XIAOMI_APPKEY = \"MI-5441833953491\"\n    val XIAOMI_APPID = \"MI-2882303761518339491\"\n    val MEIZU_APPKEY = \"MZ-b3b1528025e14048b5d539265c8a9a34\"\n    val MEIZU_APPID = \"MZ-128796\"\n    val HUAWEI_APPID = \"101863489\"\n    val OPPO_APPKEY = \"OP-e63e9260cf304f1d9d8683f9bc319f6a\" // OPPO平台注册的appkey\n    val OPPO_APPID = \"OP-30252581\" // OPPO平台注册的appid\n    val OPPO_APPSECRET = \"OP-5bf2eb1ca61a4c1587dbe41ff9f1edd8\"//OPPO平台注册的appsecret\n\n    //未替换\n    val VIVO_APPKEY = \"990cab12-0dda-4875-92eb-9e54402098bd\" // VIVO平台注册的appkey\n    val VIVO_APPID = \"18372\" // VIVO平台注册的appid\n\n\n}\n\nobject JPUSH_APPKEY {\n    val RELEASE = \"15819198d47f83d2b838b3a6\"\n    val DEBUG = \"2c74ee14fa17dc922c986911\"\n}\n\n\nobject BuildVersion {\n    const val compile_sdk = 28\n    const val min_sdk = 21\n    const val target_sdk = 28\n    const val tool_version = \"29.0.2\"\n\n    const val versionCode = 200\n    const val versionName = \"2.0.0\"\n}\n\nobject ProjectPlugin {\n    val gradle_plugin = \"com.android.tools.build:gradle:${Versions.gradle_plugin}\"\n    val kotlin_plugin = \"org.jetbrains.kotlin:kotlin-gradle-plugin:${Versions.kotlin_version}\"\n    val arouter_plugin = \"com.alibaba:arouter-register:${Versions.arouter_register}\"\n    val packer_np_plugin = \"com.mcxiaoke.packer-ng:plugin:${Versions.packer_np_plugin}\"\n    val tingyun_plugin =\n            \"com.networkbench.newlens.agent.android:agent-gradle-plugin:${Versions.tingyun_plugin}\"\n    val booster_plugin = \"com.didiglobal.booster:booster-gradle-plugin:${booster_version}\"\n\n}\n\nobject Deps {\n\n    //            lottie 动画\n    val lottie = \"com.airbnb.android:lottie:${Versions.lottie}\"\n    val zip = \"com.leo618:zip:${Versions.zip}\"\n\n    //多线程通讯\n    val eventbus = \"org.greenrobot:eventbus:3.1.1\"\n\n    //友盟统计\n    val analytics = \"com.umeng.umsdk:analytics:8.1.3\"\n\n    //多渠道打包\n    val packer_ng = \"com.mcxiaoke.packer-ng:helper:${Versions.packer_np_plugin}\"\n\n    // https=//github.com/CymChad/BaseRecyclerViewAdapterHelper\n    val ksladapter = \"com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.4\"\n\n    // https=//github.com/orhanobut/dialogplus\n    val dialogplus = \"com.orhanobut:dialogplus:1.11@aar\"\n\n    //阿里云oss上传和下载库\n    val oss_android_sdk = \"com.aliyun.dpa:oss-android-sdk:2.9.3\"\n\n    //图片剪裁库\n    val ucrop = \"com.yalantis:ucrop:2.2.0\"\n\n    //图片缩放库\n    val photodraweeview = \"me.relex:photodraweeview:${Versions.photodraweeview}\"\n    val andrpermission = \"com.yanzhenjie:permission:2.0.3\"\n    val gifdrawable = \"pl.droidsonroids.gif:android-gif-drawable:${Versions.gifdrawable}\"\n\n    val appStartFaster = \"com.github.NoEndToLF:AppStartFaster:${Versions.AppStartFaster}\"\n\n    val glide = \"com.github.bumptech.glide:glide:${Versions.glide}\"\n    val glide_compile = \"com.github.bumptech.glide:compiler:${Versions.glide}\"\n\n    // 新的权限 permissionDispatcher https://github.com/permissions-dispatcher/PermissionsDispatcher\n    val permissionDispatcher = \"org.permissionsdispatcher:permissionsdispatcher:${Versions.permission_version}\"\n    val permissionDispatcher_compile = \"org.permissionsdispatcher:permissionsdispatcher-processor:${Versions.permission_version}\"\n\n}\n\n\n//kotlin\nobject Kotlin {\n    val stdlib_jdk = \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:${Versions.kotlin_version}\"\n\n    val coroutines_core =\n            \"org.jetbrains.kotlinx:kotlinx-coroutines-core:${Versions.kotlin_coroutines}\"\n    val coroutines_android =\n            \"org.jetbrains.kotlinx:kotlinx-coroutines-android:${Versions.kotlin_coroutines}\"\n}\n\n\n/**\n * kotlin 依赖注入 库\n */\nobject Koin {\n\n    // Koin for Android\n    val android = \"org.koin:koin-android:${Versions.koin_version}\"\n\n    //// Koin Android Scope features\n    val android_scope = \"org.koin:koin-android-scope:${Versions.koin_version}\"\n\n    //// Koin Android ViewModel features\n    val android_viewmodel = \"org.koin:koin-android-viewmodel:${Versions.koin_version}\"\n}\n\n//androidx 系统库\nobject Androidx {\n    val appcompat = \"androidx.appcompat:appcompat:${Versions.androidx}\"\n    val recyclerview = \"androidx.recyclerview:recyclerview:${Versions.androidx}\"\n    val constraintlayout = \"androidx.constraintlayout:constraintlayout:${Versions.constraintlayout}\"\n    val core_ktx = \"androidx.core:core-ktx:${Versions.androidx}\"\n    val cardview = \"androidx.cardview:cardview:${Versions.cardview}\"\n    val multidex = \"androidx.multidex:multidex:${Versions.multidex}\"\n    val navigation = \"androidx.navigation:navigation-fragment:${Versions.navigation}\"\n}\n\n/**\n * lifecycle 相关库\n */\nobject ArchLifecycle {\n\n    val lifecycle_viewmodel_ktx =\n            \"androidx.lifecycle:lifecycle-viewmodel-ktx:${Versions.archLifecycleVersion}\"\n    val lifecycle_livedata_ktx =\n            \"androidx.lifecycle:lifecycle-livedata-ktx:${Versions.archLifecycleVersion}\"\n    val lifecycle_compiler =\n            \"androidx.lifecycle:lifecycle-compiler:${Versions.archLifecycleVersion}\"\n    val lifecycle_extensions =\n            \"androidx.lifecycle:lifecycle-extensions:${Versions.archLifecycleVersion}\"\n\n    /**\n     * 2.3.0-alpha* 无法使用 暂时使用稳定版 2.2.0\n     */\n    val lifecycle_runtime_ktx=\"androidx.lifecycle:lifecycle-runtime-ktx:2.2.0\"\n}\n\n\n//听云相关依赖\nobject Tingyun {\n    val newlens_agent = \"com.networkbench.newlens.agent.android:nbs.newlens.agent:2.14.2\"\n    val newlens_nativecrash = \"com.networkbench.newlens.agent.android:nbs.newlens.nativecrash:1.0.0\"\n}\n\n\nobject Bugly {\n    val crashreport = \"com.tencent.bugly:crashreport:2.1.5\"\n    val nativecrashreport = \"com.tencent.bugly:nativecrashreport:2.2.0\"\n}\n\n\n//kaishu jcenter库，暂时没用到\nobject Ks {\n    val ksui = \"com.ks.ksui:ksui:1.2.0\"\n    val ksutils = \"com.ks.ksutils:ksutils:1.2.2\"\n    val kscityselector = \"com.ks.kscityselector:kscityselector:1.1.1\"\n    val kszxing = \"com.ks.kszxing:kszxing:1.0.1\"\n    val kstoast = \"com.ks.kstoast:kstoast:1.0.0\"\n    val kprogresshud = \"com.ks.kprogresshud:kprogresshud:1.0.0\"\n    val kswebview = \"com.ks.kswebview:kswebview:0.0.4\"\n}\n\n//router相关依赖--路由跳转\nobject Router {\n    val arouter_api = \"com.alibaba:arouter-api:${Versions.arouter_api}\"\n    val arouter_compiler = \"com.alibaba:arouter-compiler:${Versions.arouter_compiler}\"\n}\n\n/**\n * 凯叔插件平台\n */\nobject Ks_plugin {\n    // 插件相关，transform开头的是transformer，task开头的是gradle task\n    val transform_relinker = \"com.ks.plugin:ks-transform-relinker:1.2.5\"\n    val task_robust_encoder = \"com.ks.plugin:ks-task-robust-encoder:1.4.2-SNAPSHOT\"\n}\n\n\n/**\n * 功能性组件版本\n */\nprivate object ks_component_version {\n    val ks_component_payment_version = \"1.0.4\"\n    val ks_component_login_version = \"1.1.0\"\n    val ks_component_net_version = \"1.2.0.4\"\n    val ks_component_resource_version = \"1.0.0\"\n    val ks_component_sobot_version = \"1.0.14.2-SNAPSHOT\"\n    val ks_component_mediaplayer_version = \"1.1.8.17\"\n    val ks_component_push_version = \"1.0.14.9\"\n    val ks_component_tracker_version = \"1.0.6.9\"\n    val ks_component_share_version = \"1.0.6\"\n    val ks_component_download_version = \"1.0.3.1\"\n    val ks_component_voicerecorder_version = \"1.0.3.2-SNAPSHOT\"\n    val ks_component_theforcesystem = \"0.0.13.5\"\n}\n\n/**\n * 功能性组件\n */\n\nobject Ks_component {\n    val component_net =\n            \"com.ks.kotlin:ks-component-net:${ks_component_version.ks_component_net_version}\"\n    val component_login =\n            \"com.ks.kotlin:ks-component-login:${ks_component_version.ks_component_login_version}\"\n    val component_payment =\n            \"com.ks.kotlin:ks-component-payment:${ks_component_version.ks_component_payment_version}\"\n    val component_resource =\n            \"com.ks.kotlin:ks-component-resource:${ks_component_version.ks_component_resource_version}\"\n    val component_sobot =\n            \"com.ks.kotlin:ks-component-sobot:${ks_component_version.ks_component_sobot_version}\"\n    val component_mediaplayer =\n            \"com.ks.kotlin:ks-component-mediaplayer:${ks_component_version.ks_component_mediaplayer_version}\"\n    val component_push =\n            \"com.ks.kotlin:ks-component-push:${ks_component_version.ks_component_push_version}\"\n    val component_tracker =\n            \"com.ks.kotlin:ks-component-tracker:${ks_component_version.ks_component_tracker_version}\"\n    val component_share =\n            \"com.ks.kotlin:ks-component-share:${ks_component_version.ks_component_share_version}\"\n    val component_download =\n            \"com.ks.kotlin:ks-component-download:${ks_component_version.ks_component_download_version}\"\n    val component_voicerecorder =\n            \"com.ks.kotlin:ks-component-voicerecorder:${ks_component_version.ks_component_voicerecorder_version}\"\n    val component_theforcesystem =\n            \"com.ks.kotlin:ks_component_theforcesystem:${ks_component_version.ks_component_theforcesystem}\"\n}\n\nprivate object KsLibVersions {\n\n    val ks_lib_net_version = \"1.0.7.9\"\n    val ks_lib_share_version = \"1.0.1\"\n    val ks_lib_route_version = \"1.0.5.2\"\n    val ks_lib_ktx_version = \"1.0.10\"\n    val ks_lib_persistence_version = \"1.0.4.2-SNAPSHOT\"\n    val ks_lib_autosize_version = \"1.0.0\"\n    val ks_lib_picture_version = \"1.0.3.3\"\n    val ks_lib_proguard_version = \"1.0.1\"\n    val ks_lib_wheel_picker_version = \"1.0.5\"\n    val ks_lib_magic_indicator = \"1.0.5\"\n    val ks_lib_xtablayout_version = \"1.0.1\"\n    val ks_lib_appmerge_version = \"1.0.6\"\n    val ks_lib_appmerge_plugin_version = \"1.0.7.2\"\n    val ks_lib_address_selector_version = \"1.1.1\"\n    val ks_lib_pull_refresh_version = \"1.0.5\"\n    val ks_lib_loading_version = \"1.0.2\"\n    val ks_lib_disk_version =\"0.0.6\"\n    val ks_lib_media_version =\"0.0.1\"\n}\n\n/**\n * kt-base-lib 的lib 库\n */\nobject Ks_lib {\n    val lib_net = \"com.ks.kotlin:ks-lib-net:${KsLibVersions.ks_lib_net_version}\"\n    val lib_share = \"com.ks.kotlin:ks-lib-share:${KsLibVersions.ks_lib_share_version}\"\n    val lib_ktx = \"com.ks.kotlin:ks-lib-ktx:${KsLibVersions.ks_lib_ktx_version}\"\n    val lib_persistence =\n            \"com.ks.kotlin:ks-lib-persistence:${KsLibVersions.ks_lib_persistence_version}\"\n    val lib_route = \"com.ks.kotlin:ks-lib-route:${KsLibVersions.ks_lib_route_version}\"\n    val lib_autosize = \"com.ks.kotlin:ks-lib-autosize:${KsLibVersions.ks_lib_autosize_version}\"\n    val lib_picture = \"com.ks.kotlin:ks-lib-picture:${KsLibVersions.ks_lib_picture_version}\"\n    val lib_proguard = \"com.ks.kotlin:ks-lib-proguard:${KsLibVersions.ks_lib_proguard_version}\"\n    val lib_wheel_picker =\n            \"com.ks.kotlin:ks-lib-wheel-picker:${KsLibVersions.ks_lib_wheel_picker_version}\"\n    val lib_magic_indicator =\n            \"com.ks.kotlin:ks-lib-magicindicator:${KsLibVersions.ks_lib_magic_indicator}\"\n    val lib_xtablayout =\n            \"com.ks.kotlin:ks-lib-xtablayout:${KsLibVersions.ks_lib_xtablayout_version}\"\n    val lib_appmerge = \"com.ks.kotlin:ks-lib-appmerge:${KsLibVersions.ks_lib_appmerge_version}\"\n    val lib_appmerge_plugin =\n            \"com.ks.kotlin:ks-lib-appmerge-plugin:${KsLibVersions.ks_lib_appmerge_plugin_version}\"\n    val lib_address_selector =\n            \"com.ks.kotlin:ks-lib-address-selector:${KsLibVersions.ks_lib_address_selector_version}\"\n    val lib_pull_refresh =\n            \"com.ks.kotlin:ks-lib-pull-refresh:${KsLibVersions.ks_lib_pull_refresh_version}\"\n    val lib_loading = \"com.ks.kotlin:ks-lib-loadinglayout:${KsLibVersions.ks_lib_loading_version}\"\n    val lib_disk = \"com.ks.ksdiskframe:ksdiskframe:${KsLibVersions.ks_lib_disk_version}\"\n    val lib_media=\"com.ks.media:wrap:${KsLibVersions.ks_lib_media_version}\"\n\n}\n\n/**\n * 各个业务module\n */\nobject Submodule_Source {\n    //登录模块\n    val login = \":lightlearn_module_login\"\n\n    //我的模块\n    val mine = \":lightlearn_module_mine\"\n\n    //支付模块\n    val payment = \":lightlearn_module_payment\"\n\n    //课程模块\n    val course = \":lightlearn_module_course\"\n\n    //产品模块\n    val product = \":lightlearn_module_product\"\n\n    //首页模块\n    val home = \":lightlearn_module_home\"\n\n    //图片选择模块\n    val pictureSelect = \":lightlearn_module_pictureselect\"\n\n    val base = \":lightlearn_module_base\"\n\n    val component_ui = \":ks_component_ui\"\n}\n\n\n//    本地业务module 打成jar包 的版本号\nobject Submodule_Aar {\n    val course = \"com.ks.lightlearn:lightlearn_module_course:1.0.0-SNAPSHOT\"\n    val home = \"com.ks.lightlearn:lightlearn_module_home:1.0.0-SNAPSHOT\"\n    val login = \"com.ks.lightlearn:lightlearn_module_login:1.0.0-SNAPSHOT\"\n    val mine = \"com.ks.lightlearn:lightlearn_module_mine:1.0.0-SNAPSHOT\"\n    val payment = \"com.ks.lightlearn:lightlearn_module_payment:1.0.0-SNAPSHOT\"\n    val picture_select = \"com.ks.lightlearn:lightlearn_module_picture_select:1.0.0-SNAPSHOT\"\n    val product = \"com.ks.lightlearn:lightlearn_module_product:1.0.0-SNAPSHOT\"\n}\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593260849},"updatedAt":{"$$date":1598593888216},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Su5u9TQNfMHLLHXR"}
{"name":"ad-liveimpl","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\n\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 5\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n\n}\nrepositories {\n    maven {\n        url 'http://maven.aliyun.com/nexus/content/repositories/releases/'\n    }\n    maven { url 'https://dl.bintray.com/polyv/android' }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    testImplementation deps.androidx.junit\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n    api ks.ksliveframe\n    api ks.kschatframe\n    api ks.kspolyvplayer\n    api ks.kspolyvchat\n    api(deps.polyv) {\n        exclude group: 'com.easefun.polyv', module: 'polyvPlayerABI'\n        exclude group: 'tv.danmaku.ijk.media'\n        exclude group: 'com.aliyun.ams'\n        exclude group: 'pl.droidsonroids.gif'\n        exclude group: 'com.tencent.bugly'\n    }\n    implementation deps.eventbus\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic interface IPolyvCloudClassLoginManager {\n\n    /**\n     * 登陆直播\n     *\n     * @param userId\n     * @param appSecret\n     * @param channelId\n     * @param appId\n     * @param loginListener\n     */\n    void loginLive(String userId, String appSecret,\n                   String channelId, String appId,\n                   OnLoginListener<PolyvLiveLoginResult> loginListener);\n\n    /**\n     * 登陆回放\n     *\n     * @param playbackUserId\n     * @param playbackChannelId\n     * @param playbackVideoId\n     * @param playbackAppId\n     * @param loginListener\n     */\n    void loginPlayback(String playbackUserId, String playbackAppSecret, String playbackChannelId,\n                       String playbackVideoId, String playbackAppId,\n                       OnLoginListener<PolyvPlaybackLoginResult> loginListener);\n\n    /**\n     * 销毁\n     */\n    void destroy();\n\n    /**\n     * 登录监听器\n     */\n    interface OnLoginListener<T> {\n        /**\n         * 登录成功\n         */\n        void onLoginSuccess(T t);\n\n        /**\n         * 登录失败\n         *\n         * @param msg       错误消息\n         * @param throwable throwable\n         */\n        void onLoginFailed(String msg, Throwable throwable);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class LiveComponent extends AbsImManager {\n    final String TAG = \"LiveComponent\";\n    public static String appId = \"fmx9ur1za7\";\n    /**\n     * 保利威 userId  名字怪异 有位置是account id\n     */\n    public static String polyAccountID = \"c61d784484\";\n    /**\n     * 保利威 加密key\n     */\n    public static String secretKey = \"63a22fe822bb4b7da1a6b048e13cdc8d\";\n\n    private static LiveComponent component;\n    private static EventBus eventBus;\n    private static Context mContext;\n    private String channelId;\n    /**\n     * 播放器是咧\n     */\n    private IPlayer player;\n    /**\n     * Im实例\n     */\n    private IManager manager;\n\n    //    private SimpleUserInfo userInfo;\n    private IPolyvCloudClassLoginManager polyvCloudClassLoginManager;\n\n    public static void init(Context ctx) {\n        PolyvLiveSDKClient liveSDKClient = PolyvLiveSDKClient.getInstance();\n        liveSDKClient.initContext((Application) ctx);\n        liveSDKClient.enableHttpDns(false);\n        mContext = ctx;\n    }\n\n    public static LiveComponent getInstance() {\n        if (component == null) {\n            synchronized (LiveComponent.class) {\n                if (component == null)\n                    component = new LiveComponent();\n            }\n        }\n        return component;\n    }\n\n    private LiveComponent() {\n    }\n\n    /**\n     * 初始化，将播放器View add\n     *\n     * @param playerContainer\n     * @param simpleUserInfo\n     */\n    public void init(ViewGroup playerContainer, SimpleUserInfo simpleUserInfo) {\n        if (player == null) {\n            player = new PolyvPlayer(mContext == null ?\n                    playerContainer.getContext().getApplicationContext() : mContext);\n        } else {\n            if (((PolyvPlayer) player).getPlayerView() != null) {\n                ViewGroup group = (ViewGroup) ((PolyvPlayer) player).getPlayerView().getParent();\n                if (group != null) {\n                    group.removeView(((PolyvPlayer) player).getPlayerView());\n                }\n            }\n        }\n        if (manager == null)\n            manager = new PolyvChatroom();\n        userInfo = simpleUserInfo;\n        manager.setUserInfo(simpleUserInfo);\n        playerContainer.removeAllViews();\n        playerContainer.addView(((PolyvPlayer) player).getPlayerView(),\n                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n        setPlayerListener();\n    }\n\n    private void setPlayerListener() {\n        player.setOnPlayerEventListener(new OnPlayerEventListener() {\n            @Override\n            public void onPlayerEvent(int eventCode, Bundle bundle) {\n                switch (eventCode) {\n                    //没有直播流 或者直播未开始\n                    case OnPlayerEventListener.PLAYER_EVENT_NO_LIVE:\n                        if (eventBus != null) {\n                            eventBus.post(new PlayerEvent(OnPlayerEventListener.PLAYER_EVENT_NO_LIVE));\n                        }\n                        break;\n                    //直播结束\n                    case OnPlayerEventListener.PLAYER_EVENT_LIVE_END:\n                        //暂不发消息\n//                        if(eventBus!=null){\n//                            eventBus.post(new PlayerEvent(OnPlayerEventListener.PLAYER_EVENT_LIVE_END));\n//                        }\n                        break;\n                    //开始直播\n                    case OnPlayerEventListener.PLAYER_EVENT_ON_PREPARED:\n                        if (eventBus != null) {\n                            eventBus.post(new PlayerEvent(OnPlayerEventListener.PLAYER_EVENT_ON_PREPARED));\n                        }\n                        break;\n                }\n            }\n        });\n    }\n\n    /**\n     * 登陆直播间\n     *\n     * @param channelId 频道ID 后台接口处得到\n     *                  保利威登陆逻辑 登陆接口（检测直播间状态） -->IM登陆 （\n     */\n    public void login(final String channelId) {\n        if (!TextUtils.isEmpty(channelId) && !channelId.equals(this.channelId)) {\n            this.channelId = channelId;\n        }\n        //切换直播间 使用备用房间\n        if (isConnect()) {\n            //\n            manager.disConnect();\n            player.pause();\n        }\n        //这3个参数来自保利威后台\n        //保利威接口\n        if (polyvCloudClassLoginManager == null)\n            polyvCloudClassLoginManager = new PolyvCloudClassLoginManager();\n        polyvCloudClassLoginManager.loginLive(polyAccountID, secretKey, channelId, appId, new IPolyvCloudClassLoginManager.OnLoginListener<PolyvLiveLoginResult>() {\n\n            //验证房间和授权key 成功\n            @Override\n            public void onLoginSuccess(PolyvLiveLoginResult polyvLiveLoginResult) {\n\n                //启动播放器\n                DataSource dataSource = new DataSource();\n                HashMap<String, String> data = new HashMap<>(5);\n                data.put(\"polyAccountID\", polyAccountID);\n                data.put(\"secret\", secretKey);\n                data.put(\"channelId\", channelId);\n                data.put(\"appid\", appId);\n                data.put(\"name\", userInfo.name);\n                data.put(\"userId\", userInfo.userId);\n                dataSource.setExtra(data);\n                player.setDataSource(dataSource);\n                player.start();\n\n                PolyvChatConfig.appId = appId;\n                PolyvChatConfig.secretKey = secretKey;\n                PolyvChatConfig.polyAccountID = polyAccountID;\n                //登陆聊天室\n                manager.login(channelId);\n            }\n\n            @Override\n            public void onLoginFailed(String msg, Throwable throwable) {\n                Log.e(TAG, \"onLoginPolyvError msg is =\" + msg +\n                        \" --错误信息 \" + (throwable == null ? \"\" : throwable.getMessage()));\n            }\n        });\n\n    }\n\n    /**\n     * 用户从游客模式 到登陆状态\n     * 更新用户信息\n     * IM根据Id 重新登陆\n     */\n\n    public void updateUserInfo(SimpleUserInfo userInfo) {\n\n        if (userInfo == null)\n            return;\n        if (this.userInfo == null || !this.userInfo.userId.equals(userInfo.userId))\n            this.setUserInfo(userInfo);\n        if (manager != null) {\n            manager.setUserInfo(userInfo);\n            //      manager.disConnect();\n            if (polyvCloudClassLoginManager == null)\n                polyvCloudClassLoginManager = new PolyvCloudClassLoginManager();\n            polyvCloudClassLoginManager.loginLive(polyAccountID, secretKey, channelId, appId, new IPolyvCloudClassLoginManager.OnLoginListener<PolyvLiveLoginResult>() {\n\n                //验证房间和授权key 成功\n                @Override\n                public void onLoginSuccess(PolyvLiveLoginResult polyvLiveLoginResult) {\n                    PolyvChatConfig.appId = appId;\n                    PolyvChatConfig.secretKey = secretKey;\n                    PolyvChatConfig.polyAccountID = polyAccountID;\n                    //登陆聊天室\n                    manager.login(channelId);\n                }\n\n                //保利威验证失败\n                @Override\n                public void onLoginFailed(String msg, Throwable throwable) {\n                    Log.e(TAG, \"onLoginPolyvError msg is =\" + msg +\n                            \" --错误信息 \" + (throwable == null ? \"\" : throwable.getMessage()));\n                }\n            });\n        }\n    }\n\n    /**\n     * 发送文本 消息\n     *\n     * @param msg\n     */\n    @Override\n    public void sendMsg(TextMsg msg) {\n        if (manager != null) {\n            manager.sendMsg(msg);\n        }\n    }\n\n    /**\n     * 发送礼物\n     *\n     * @param gift\n     */\n    @Override\n    public void sendGift(GiftMsg gift) {\n        if (manager != null) {\n            manager.sendGift(gift);\n        }\n    }\n\n    /**\n     * 退出房间\n     */\n    @Override\n    public void quitRoom() {\n        if (manager != null) {\n            manager.quitRoom();\n        }\n    }\n\n    /**\n     * 获取当前连接状态\n     *\n     * @return true 连接 false 未连接\n     */\n    @Override\n    public boolean isConnect() {\n        if (manager != null) {\n            return manager.isConnect();\n\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * 断开连接Im\n     */\n    @Override\n    public void disConnect() {\n        if (manager != null) {\n            manager.disConnect();\n        }\n    }\n\n    public IPlayer getPlayer() {\n        return player;\n    }\n\n    public IManager getMessage() {\n        return manager;\n    }\n\n    @Override\n    public void destory() {\n        super.destory();\n        if (player != null) {\n            player.stop();\n            player.setOnPlayerEventListener(null);\n            player.destroy();\n        }\n        if (manager != null)\n            manager.destory();\n        userInfo = null;\n        player = null;\n        manager = null;\n\n        if (polyvCloudClassLoginManager != null)\n            polyvCloudClassLoginManager.destroy();\n        polyvCloudClassLoginManager = null;\n        component = null;\n    }\n\n    /**\n     * 获取在线人数\n     *\n     * @return\n     */\n    @Override\n    public int getOnlineNum() {\n        if (manager != null) {\n            return manager.getOnlineNum();\n        }\n        return 0;\n    }\n\n    public void setEventBus(EventBus bus) {\n        eventBus = bus;\n        if (manager != null)\n            manager.setEventBus(bus);\n    }\n\n    public EventBus getEventBus() {\n        return eventBus;\n    }\n\n    /**\n     * 推送消息入口 ， 最后由dispath 集中处理分发\n     *\n     * @param event\n     * @param content\n     */\n    @Override\n    public void onReceivPush(String event, String content) {\n        if (manager != null) {\n            manager.onReceivPush(event, content);\n        }\n    }\n\n    /**\n     * 获取当前房间Id\n     */\n    public String getChannelId() {\n        return channelId;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\npackage com.ks.base.liveimpl;\n\nimport com.easefun.polyv.businesssdk.PolyvChatDomainManager;\nimport com.easefun.polyv.businesssdk.model.chat.PolyvChatDomain;\nimport com.easefun.polyv.businesssdk.model.video.PolyvPlayBackVO;\nimport com.easefun.polyv.businesssdk.service.PolyvLoginManager;\nimport com.easefun.polyv.businesssdk.vodplayer.PolyvVodSDKClient;\nimport com.easefun.polyv.cloudclass.config.PolyvLiveSDKClient;\nimport com.easefun.polyv.cloudclass.model.PolyvLiveStatusVO;\nimport com.easefun.polyv.cloudclass.net.PolyvApiManager;\nimport com.easefun.polyv.foundationsdk.net.PolyvResponseBean;\nimport com.easefun.polyv.foundationsdk.net.PolyvResponseExcutor;\nimport com.easefun.polyv.foundationsdk.net.PolyvrResponseCallback;\n\nimport io.reactivex.Observable;\nimport io.reactivex.ObservableEmitter;\nimport io.reactivex.ObservableOnSubscribe;\nimport io.reactivex.android.schedulers.AndroidSchedulers;\nimport io.reactivex.disposables.Disposable;\nimport io.reactivex.functions.Action;\nimport io.reactivex.functions.BiFunction;\nimport io.reactivex.functions.Consumer;\n\n/**\n * date: 2020-04-17\n * author: hwj\n * description:\n */\npublic class PolyvCloudClassLoginManager implements IPolyvCloudClassLoginManager {\n    //登录直播\n    private Disposable loginLiveDisposable;\n    private Disposable getLiveStatusDisposable;\n    private Disposable getLiveDetailDisposable;\n\n    //登录回放\n    private Disposable loginPlaybackDisposable;\n    private Disposable getPlaybackStatusDisposable;\n\n    //共用\n    private Disposable verifyDisposable;\n\n//    public PolyvCloudClassLoginManager(IPlayer player , IManager manager){\n//\n//    }\n\n    // <editor-fold defaultstate=\"collapsed\" desc=\"登陆直播\">\n\n    @Override\n    public void loginLive(final String userId, final String appSecret, final String channelId, final String appId,\n                          final OnLoginListener<PolyvLiveLoginResult> loginListener) {\n        dispose(loginLiveDisposable);\n        loginLiveDisposable = Observable.zip(\n                verify(userId, appSecret, channelId, \"\", appId),\n                requestLiveStatus(channelId),\n                new BiFunction<PolyvChatDomain, PolyvLiveStatusVO, PolyvLiveLoginResult>() {\n                    @Override\n                    public PolyvLiveLoginResult apply(PolyvChatDomain polyvChatDomain, PolyvLiveStatusVO polyvLiveStatusVO) throws Exception {\n                        //处理verifyLive的结果\n                        PolyvLiveSDKClient.getInstance().setAppIdSecret(appId, appSecret);\n                        PolyvVodSDKClient.getInstance().initConfig(appId, appSecret);\n                        PolyvChatDomainManager.getInstance().setChatDomain(polyvChatDomain);\n\n                        //处理requestLiveStatus的结果\n                        String data = polyvLiveStatusVO.getData();\n                        String[] dataArr = data.split(\",\");\n                        //是否有ppt。要将改结果回调上去\n                        final boolean isAlone = \"alone\".equals(dataArr[1]);\n\n                        return new PolyvLiveLoginResult(isAlone);\n                    }\n                }\n        ).observeOn(AndroidSchedulers.mainThread()).subscribe(new Consumer<PolyvLiveLoginResult>() {\n            @Override\n            public void accept(PolyvLiveLoginResult result) throws Exception {\n                //回调结果\n                loginListener.onLoginSuccess(result);\n            }\n        }, new Consumer<Throwable>() {\n            @Override\n            public void accept(Throwable throwable) throws Exception {\n                loginListener.onLoginFailed(throwable.getMessage(), throwable);\n            }\n        });\n    }\n\n    private Observable<PolyvLiveStatusVO> requestLiveStatus(final String channelId) {\n        dispose(getLiveStatusDisposable);\n        return Observable.create(new ObservableOnSubscribe<PolyvLiveStatusVO>() {\n            @Override\n            public void subscribe(final ObservableEmitter<PolyvLiveStatusVO> emitter) throws Exception {\n                getLiveStatusDisposable = PolyvResponseExcutor.excuteUndefinData(PolyvApiManager.getPolyvLiveStatusApi().geLiveStatusJson(channelId)\n                        , new PolyvResponseCallbackAdapter<>(emitter));\n            }\n        }).doOnDispose(new Action() {\n            @Override\n            public void run() throws Exception {\n                dispose(getLiveStatusDisposable);\n            }\n        });\n\n    }\n// </editor-fold>\n\n    // <editor-fold defaultstate=\"collapsed\" desc=\"登录回放\">\n    @Override\n    public void loginPlayback(final String playbackUserId, final String playbackAppSecret, final String playbackChannelId, String playbackVideoId,\n                              final String playbackAppId, final OnLoginListener<PolyvPlaybackLoginResult> loginListener) {\n        dispose(loginPlaybackDisposable);\n        loginPlaybackDisposable = Observable.zip(\n                verify(playbackUserId, \"\", playbackChannelId, playbackVideoId, playbackAppId),\n                requestPlaybackStatus(playbackVideoId),\n                new BiFunction<PolyvChatDomain, PolyvPlayBackVO, PolyvPlaybackLoginResult>() {\n                    @Override\n                    public PolyvPlaybackLoginResult apply(PolyvChatDomain polyvChatDomain, PolyvPlayBackVO polyvPlayBackVO) throws Exception {\n                        PolyvLiveSDKClient.getInstance().setAppIdSecret(playbackAppId, playbackAppSecret);\n                        PolyvVodSDKClient.getInstance().initConfig(playbackAppId, playbackAppSecret);\n                        boolean isNormal = polyvPlayBackVO.getLiveType() == 0;\n                        return new PolyvPlaybackLoginResult(isNormal);\n                    }\n                }\n        ).subscribe(new Consumer<PolyvPlaybackLoginResult>() {\n            @Override\n            public void accept(PolyvPlaybackLoginResult result) throws Exception {\n                loginListener.onLoginSuccess(result);\n            }\n        }, new Consumer<Throwable>() {\n            @Override\n            public void accept(Throwable throwable) throws Exception {\n                loginListener.onLoginFailed(throwable.getMessage(), throwable);\n            }\n        });\n    }\n\n    @Override\n    public void destroy() {\n        dispose(loginLiveDisposable);\n        dispose(loginPlaybackDisposable);\n    }\n\n    private Observable<PolyvPlayBackVO> requestPlaybackStatus(final String vid) {\n        dispose(getPlaybackStatusDisposable);\n        return Observable.create(new ObservableOnSubscribe<PolyvPlayBackVO>() {\n            @Override\n            public void subscribe(final ObservableEmitter<PolyvPlayBackVO> emitter) throws Exception {\n                getPlaybackStatusDisposable = PolyvLoginManager.getPlayBackType(vid, new PolyvResponseCallbackAdapter<>(emitter));\n            }\n        }).doOnDispose(new Action() {\n            @Override\n            public void run() throws Exception {\n                dispose(getPlaybackStatusDisposable);\n            }\n        });\n    }\n    // </editor-fold>\n\n    // <editor-fold defaultstate=\"collapsed\" desc=\"共用\">\n    private Observable<PolyvChatDomain> verify(final String userId, final String appSecret, final String channelId, final String vid, final String appId) {\n        dispose(verifyDisposable);\n        return Observable.create(new ObservableOnSubscribe<PolyvChatDomain>() {\n            @Override\n            public void subscribe(final ObservableEmitter<PolyvChatDomain> emitter) throws Exception {\n                verifyDisposable = PolyvLoginManager.checkLoginToken(userId, appSecret, appId, channelId, vid,\n                        new PolyvResponseCallbackAdapter<>(emitter));\n\n            }\n        }).doOnDispose(new Action() {\n\n            @Override\n            public void run() throws Exception {\n                dispose(verifyDisposable);\n            }\n        });\n    }\n// </editor-fold>\n\n    private void dispose(Disposable disposable) {\n        if (disposable != null) {\n            disposable.dispose();\n        }\n    }\n\n    /**\n     * Polyv请求回调转成RxJava Observable的适配器\n     *\n     * @param <Bean> 携带的数据\n     */\n    private static class PolyvResponseCallbackAdapter<Bean> extends PolyvrResponseCallback<Bean> {\n        private ObservableEmitter<Bean> emitter;\n\n        PolyvResponseCallbackAdapter(ObservableEmitter<Bean> emitter) {\n            this.emitter = emitter;\n        }\n\n        @Override\n        public void onSuccess(Bean bean) {\n            emitter.onNext(bean);\n        }\n\n        @Override\n        public void onFailure(PolyvResponseBean<Bean> responseBean) {\n            super.onFailure(responseBean);\n            emitter.onError(new Throwable(responseBean.toString()));\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            super.onError(e);\n            emitter.onError(e);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class PolyvLiveLoginResult {\n    private boolean isNormal;\n\n    public PolyvLiveLoginResult(boolean isNormal) {\n        this.isNormal = isNormal;\n    }\n\n    public boolean isNormal() {\n        return isNormal;\n    }\n\n    public void setNormal(boolean normal) {\n        isNormal = normal;\n    }\n\n}\n\n\n\n\npublic class PolyvPlaybackLoginResult {\n    private boolean isNormal;\n\n    public PolyvPlaybackLoginResult(boolean isNormal) {\n        this.isNormal = isNormal;\n    }\n\n    public boolean isNormal() {\n        return isNormal;\n    }\n\n    public void setNormal(boolean normal) {\n        isNormal = normal;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598517304849},"updatedAt":{"$$date":1598519686927},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"T0Ef9BdlzMgUn7jH"}
{"name":"ad-ksmediahandler 音视频合成 压缩","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        ndk {\n            //设置支持的SO库架构\n            abiFilters 'armeabi-v7a'\n        }\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n            java {\n                srcDirs += []\n            }\n        }\n    }\n\n    splits {\n        abi {\n            enable true\n            reset()\n            include 'armeabi-v7a'\n            universalApk false\n        }\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nffmpeg\nFFmpegCmd\nksmediahandler\nhandler\nFFmpegHandler\nlistener\nOnHandleListener\nOnKsMediaHandleListener\nmodel\nAudioBean\nMediaBean\nVideoBean\ntool\nJsonParseTool\nThreadUtils\nKsMediaHandlerManager\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class FFmpegHandler {\n\n    private final static String TAG = FFmpegHandler.class.getSimpleName();\n\n    public final static int MSG_BEGIN = 9012;\n\n    public final static int MSG_FINISH = 1112;\n\n    public final static int MSG_CONTINUE = 2012;\n\n    public final static int MSG_TOAST = 4562;\n\n    private Handler mHandler;\n\n    private boolean isContinue = false;\n\n    public FFmpegHandler(Handler mHandler) {\n        this.mHandler = mHandler;\n    }\n\n    public void isContinue(boolean isContinue) {\n        this.isContinue = isContinue;\n    }\n\n    /**\n     * execute the command of FFmpeg\n     *\n     * @param commandLine commandLine\n     */\n    public void executeFFmpegCmd(final String[] commandLine) {\n        if (commandLine == null) {\n            return;\n        }\n        FFmpegCmd.execute(commandLine, new OnHandleListener() {\n            @Override\n            public void onBegin() {\n                Log.i(TAG, \"handle onBegin...\");\n                if (mHandler != null) {\n                    mHandler.obtainMessage(MSG_BEGIN).sendToTarget();\n                }\n            }\n\n            @Override\n            public void onEnd(int resultCode, String resultMsg) {\n                Log.i(TAG, \"handle onEnd...\");\n                if (mHandler != null) {\n                    if (isContinue) {\n                        mHandler.obtainMessage(MSG_CONTINUE).sendToTarget();\n                    } else {\n                        mHandler.obtainMessage(MSG_FINISH).sendToTarget();\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * execute multi commands of FFmpeg\n     *\n     * @param commandList the list of command\n     */\n    public void executeFFmpegCmds(final List<String[]> commandList) {\n        if (commandList == null) {\n            return;\n        }\n        FFmpegCmd.execute(commandList, new OnHandleListener() {\n            @Override\n            public void onBegin() {\n                Log.i(TAG, \"handle onBegin...\");\n                if (mHandler != null) {\n                    mHandler.obtainMessage(MSG_BEGIN).sendToTarget();\n                }\n            }\n\n            @Override\n            public void onEnd(int resultCode, String resultMsg) {\n                Log.i(TAG, \"handle onEnd...\");\n                if (mHandler != null) {\n                    if (isContinue) {\n                        mHandler.obtainMessage(MSG_CONTINUE).sendToTarget();\n                    } else {\n                        mHandler.obtainMessage(MSG_FINISH).sendToTarget();\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * execute the command of FFprobe\n     *\n     * @param commandLine commandLine\n     */\n    public void executeFFprobeCmd(final String[] commandLine) {\n        if (commandLine == null) {\n            return;\n        }\n        FFmpegCmd.executeProbe(commandLine, new OnHandleListener() {\n            @Override\n            public void onBegin() {\n                Log.i(TAG, \"handle ffprobe onBegin...\");\n                if (mHandler != null) {\n                    mHandler.obtainMessage(MSG_BEGIN).sendToTarget();\n                }\n            }\n\n            @Override\n            public void onEnd(int resultCode, String resultMsg) {\n                Log.i(TAG, \"handle ffprobe onEnd result=\" + resultMsg);\n                MediaBean mediaBean = null;\n                if (resultMsg != null && !resultMsg.isEmpty()) {\n                    mediaBean = JsonParseTool.parseMediaFormat(resultMsg);\n                }\n                if (mHandler != null) {\n                    mHandler.obtainMessage(MSG_FINISH, mediaBean).sendToTarget();\n                }\n            }\n        });\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic final class ThreadUtils {\n    public static final ThreadUtils INST = new ThreadUtils();\n\n    private ExecutorService executors;\n\n    private ThreadUtils(){\n    }\n\n    /**\n     * 在线程中执行\n     * @param runnable 要执行的runnable\n     */\n    public void excute(Runnable runnable) {\n        ExecutorService executorService = getExecutorService();\n        if (executorService != null && !executorService.isShutdown()) {\n            // 优先使用线程池，提高效率\n            executorService.execute(runnable);\n        } else {\n            // 线程池获取失败，则直接使用线程\n            new Thread(runnable).start();\n        }\n    }\n\n    /**\n     * 在主线程中执行\n     * @param runnable 要执行的runnable\n     */\n    public void excuteInMainThread(Runnable runnable){\n        new Handler(Looper.getMainLooper()).post(runnable);\n    }\n\n    /**\n     * 获取缓存线程池\n     * @return 缓存线程池服务\n     */\n    private ExecutorService getExecutorService(){\n        if (executors == null) {\n            try {\n                executors = Executors.newCachedThreadPool();\n            } catch (Exception e) {\n            }\n        }\n        return executors;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class KsMediaHandlerManager {\n\n    private String TAG = \"FFmpegCmd\";\n\n    public static final int STATUS_INITIALIZE = 0; //初始化\n    public static final int STATUS_CUT_BG = 100; //提取视频音频\n    public static final int STATUS_MIX_AUDIO_AND_VIDEO = 101; //\n    public static final int STATUS_MIX_AUDIO_AND_VIDEO_FINISH = 102; //音视频合成完成\n\n    public static final int STATUE_VIDEO_GET_INFO = 103; //获取音视频信息\n    public static final int STATUE_COMPRESS_OK = 104; //视频压缩完成\n\n    /**\n     * 源视频路径\n     */\n    private String m_srcMP4File = \"\";\n    /**\n     * 源音频路径\n     */\n    private String m_srcMP3File = \"\";\n    /**\n     * 目标路径\n     */\n    private String m_tarMP4File = \"\";\n    //从视频剥去的音频\n    private String m_tmpAACFile = \"\";\n    //剪切的音频\n    private String m_tmpAACFile_cut = \"\";\n    //合并之后的音频\n    private String m_tmpMP3File = \"\";\n\n    private static volatile KsMediaHandlerManager singletonLazy;\n    private Date curDate;\n    private Date endDate;\n    private FFmpegHandler ffmpegHandler;\n    private int nStatus;\n    private OnKsMediaHandleListener listener;\n\n    private KsMediaHandlerManager() {\n    }\n\n    /**\n     * 生成单例\n     *\n     * @return\n     */\n    public static KsMediaHandlerManager getInstance() {\n        if (null == singletonLazy) {\n            synchronized (KsMediaHandlerManager.class) {\n                if (null == singletonLazy) {\n                    singletonLazy = new KsMediaHandlerManager();\n                }\n            }\n        }\n        return singletonLazy;\n    }\n\n    @SuppressLint(\"HandlerLeak\")\n    private Handler mHandler = new Handler(Looper.getMainLooper()) {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n\n            switch (msg.what) {\n                case FFmpegHandler.MSG_BEGIN:\n                    break;\n                case FFmpegHandler.MSG_FINISH:\n//                    //初始化完成之后\n                    if (nStatus == STATUS_INITIALIZE) {\n                        getUserAudioDurationAndCat();\n                    } else if (nStatus == STATUS_CUT_BG) {\n                        concatUserAudeoAndBgMusic();\n                    } else if (nStatus == STATUS_MIX_AUDIO_AND_VIDEO) {\n                        muxAudioAndVideo(m_srcMP4File, m_tmpMP3File, m_tarMP4File);\n                    } else if (nStatus == STATUS_MIX_AUDIO_AND_VIDEO_FINISH) {\n                        deleteFile(m_tmpAACFile);\n                        deleteFile(m_tmpAACFile_cut);\n                        deleteFile(m_tmpMP3File);\n                        doFinish();\n                    } else if (nStatus == STATUE_VIDEO_GET_INFO) {\n                        MediaBean mediaBean = (MediaBean) msg.obj;\n                        if (mediaBean != null) {\n                            doRealCompress(mediaBean);\n                        }\n                    } else if (nStatus == STATUE_COMPRESS_OK) {\n                        doFinish();\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n\n\n    /**\n     * 开始音视频合成\n     *\n     * @param context\n     * @param m_srcMP4File 源视频文件路径\n     * @param m_srcMP3File 源音频文件路径\n     * @param m_tarMP4File 目标合成文件路径\n     */\n    public void startHandler(Context context, String m_srcMP4File, String m_srcMP3File, String m_tarMP4File, OnKsMediaHandleListener listener) {\n        if (TextUtils.isEmpty(m_srcMP4File)\n                || TextUtils.isEmpty(m_srcMP3File)\n                || TextUtils.isEmpty(m_tarMP4File)) {\n            return;\n        }\n\n        this.m_srcMP4File = m_srcMP4File;\n        this.m_srcMP3File = m_srcMP3File;\n        this.m_tarMP4File = m_tarMP4File;\n        //初始化\n        init(context, listener);\n\n        //1.先从视频里面获取音频\n        getBkMusic(m_srcMP4File, m_tmpAACFile);\n    }\n\n\n    /**\n     * 获取原视频的背景音\n     *\n     * @param srcMP4File 原视频\n     * @param tmpAACFile 背景音\n     */\n    public void getBkMusic(String srcMP4File, String tmpAACFile) {\n        nStatus = STATUS_INITIALIZE;\n        String command = String.format(\"ffmpeg -i %s -vn -acodec mp3 -ar 44100 -ac 2 -ab 128000 -y %s\", srcMP4File, tmpAACFile);\n        String[] cmd = command.split(\" \");\n        if (ffmpegHandler != null) {\n            ffmpegHandler.executeFFmpegCmd(cmd);\n        }\n    }\n\n    private void concatUserAudeoAndBgMusic() {\n        nStatus = STATUS_MIX_AUDIO_AND_VIDEO;\n        String commandStr = \"ffmpeg -i concat:%s|%s -acodec mp3 -ar 44100 -ac 2 -ab 128000 -y %s\";\n        String command = String.format(commandStr, m_srcMP3File, m_tmpAACFile_cut, m_tmpMP3File);\n        String[] cmd = command.split(\" \");\n        if (ffmpegHandler != null) {\n            ffmpegHandler.executeFFmpegCmd(cmd);\n        }\n    }\n\n    //截取原视频的剩余的音频\n    private void cutBgMusic(long startTime, long durationTime) {\n        nStatus = STATUS_CUT_BG;\n        float start = (float) (startTime * 1.0 / 1000);\n        float duration = (float) (durationTime * 1.0 / 1000);\n\n        String command = String.format(\"ffmpeg -i %s -acodec copy -ss %f -t %f -y %s\", m_tmpAACFile, start, duration, m_tmpAACFile_cut);\n        String[] cmd = command.split(\" \");\n        if (ffmpegHandler != null) {\n            ffmpegHandler.executeFFmpegCmd(cmd);\n        }\n    }\n\n    /**\n     * 对比原始音频和录音音频的市场\n     */\n    private void getUserAudioDurationAndCat() {\n        //录音音频\n        Long userAudioDuration = getAudioFileVoiceTime(m_srcMP3File);\n        //原视频音频\n        Long videoInlineAudiioDuration = getAudioFileVoiceTime(m_tmpAACFile);\n\n//        //如果录音时长小于背景音时长，需要进行裁剪\n        if (userAudioDuration <= videoInlineAudiioDuration) {\n            long duration = videoInlineAudiioDuration - userAudioDuration;\n            cutBgMusic(userAudioDuration, duration);\n        } else {\n            //如果录音大于背景音，则直接进行合成\n            muxAudioAndVideo(m_srcMP4File, m_srcMP3File, m_tarMP4File);\n        }\n    }\n\n\n    /**\n     * 拼接的视频或者是录音音频直接合视频进行合成\n     *\n     * @param srcMP4File 原始视频\n     * @param tmpMP3File 临时音频\n     * @param tarMP4File 目标视频\n     */\n    public void muxAudioAndVideo(String srcMP4File, String tmpMP3File, String tarMP4File) {\n        nStatus = STATUS_MIX_AUDIO_AND_VIDEO_FINISH;\n        String command = String.format(\"ffmpeg -i %s -i %s -c:v copy -c:a copy -strict experimental -map 0:v:0 -map 1:a:0 -y %s\", srcMP4File, tmpMP3File, tarMP4File);\n        Log.d(TAG, \"muxAudioAndVideo \" + command);\n        String[] cmd = command.split(\" \");\n        if (ffmpegHandler != null) {\n            ffmpegHandler.executeFFmpegCmd(cmd);\n        }\n    }\n\n\n    /**\n     * 获取音频文件的总时长大小\n     *\n     * @param filePath 音频文件路径\n     * @return 返回时长大小\n     */\n    public Long getAudioFileVoiceTime(String filePath) {\n        long mediaPlayerDuration = 0L;\n        if (filePath == null || filePath.isEmpty()) {\n            return mediaPlayerDuration;\n        }\n        MediaPlayer mediaPlayer = new MediaPlayer();\n        try {\n            mediaPlayer.setDataSource(filePath);\n            mediaPlayer.prepare();\n            mediaPlayerDuration = mediaPlayer.getDuration();\n        } catch (IOException ioException) {\n        }\n        if (mediaPlayer != null) {\n            mediaPlayer.stop();\n            mediaPlayer.reset();\n            mediaPlayer.release();\n        }\n        return mediaPlayerDuration;\n    }\n\n    /**\n     * 视频压缩：\n     * 1.完成视频信息获取，比如视频的比例\n     * 2.根据比例完成压缩\n     *\n     * @param context\n     * @param m_srcMP4File 原始视频\n     * @param m_tarMP4File 压缩视频\n     * @param listener\n     */\n    public void doVideoCompress(Context context, String m_srcMP4File, String m_tarMP4File, OnKsMediaHandleListener listener) {\n        this.m_srcMP4File = m_srcMP4File;\n        this.m_tarMP4File = m_tarMP4File;\n\n        //初始化\n        init(context, listener);\n        getMediaInfo(m_srcMP4File);\n    }\n\n    private void getMediaInfo(String m_srcMP4File) {\n        nStatus = STATUE_VIDEO_GET_INFO;\n        String command = \"ffprobe -i %s -show_streams -show_format -print_format json\";\n        command = String.format(Locale.getDefault(), command, m_srcMP4File);\n        String[] cmd = command.split(\" \");\n        if (ffmpegHandler != null) {\n            ffmpegHandler.executeFFprobeCmd(cmd);\n        }\n    }\n\n\n    /**\n     * 操作完成\n     */\n    private void doFinish() {\n        endDate = new Date(System.currentTimeMillis());\n        long diff = endDate.getTime() - curDate.getTime();\n        Log.d(TAG, \"finished, cost time: \" + diff + \" ms\");\n        if (listener != null) {\n            listener.onFinish(m_tarMP4File);\n        }\n    }\n\n    /**\n     * 视频压缩\n     *\n     * @param mediaBean 视频信息\n     */\n    private void doRealCompress(MediaBean mediaBean) {\n        nStatus = STATUE_COMPRESS_OK;\n        String displayAspectRatio = mediaBean.getVideoBean().getDisplayAspectRatio();\n        String command;\n        String stc;\n        if (\"9:16\".equals(displayAspectRatio)) {\n            stc = \"720x1280\";\n        } else {\n            stc = \"1280x720\";\n        }\n        command = \"ffmpeg -i %s -threads %s -vcodec libx264 -b:v 1200k -bufsize 1200k -maxrate 1500k -profile:v baseline -level 3.0 -preset superfast -g 50 -r 25 -s %s -qmin 25 -qmax 30 -acodec aac -ar 44100 -ac 2 -ab 128000 -write_tmcd 0 -y %s\";\n        command = String.format(Locale.getDefault(), command, m_srcMP4File, Runtime.getRuntime().availableProcessors(), stc, m_tarMP4File);\n        String[] cmd = command.split(\" \");\n        if (ffmpegHandler != null) {\n            ffmpegHandler.executeFFmpegCmd(cmd);\n        }\n    }\n\n\n    /**\n     * 初始化公共参数\n     *\n     * @param context\n     * @param listener\n     */\n    private void init(Context context, OnKsMediaHandleListener listener) {\n        this.listener = listener;\n        this.listener.onStart();\n        createTempFile(context);\n        ffmpegHandler = new FFmpegHandler(mHandler);\n        curDate = new Date(System.currentTimeMillis());\n\n    }\n\n    /**\n     * 创建临时文件\n     *\n     * @param context\n     */\n    private void createTempFile(Context context) {\n        String baseDir;\n        String state = Environment.getExternalStorageState();\n        if (Environment.MEDIA_MOUNTED.equals(state)) {\n            File baseDirFile = context.getExternalFilesDir(null);\n            if (baseDirFile == null) {\n                baseDir = context.getFilesDir().getAbsolutePath();\n            } else {\n                baseDir = baseDirFile.getAbsolutePath();\n            }\n        } else {\n            baseDir = context.getFilesDir().getAbsolutePath();\n        }\n\n        //从视频获取的音频\n        m_tmpAACFile = new File(baseDir, \"tmp-out.mp3\").getAbsolutePath();\n        m_tmpAACFile_cut = new File(baseDir, \"tmp-out-cut.mp3\").getAbsolutePath();\n        m_tmpMP3File = new File(baseDir, \"tmp-mix.mp3\").getAbsolutePath();\n    }\n\n    /**\n     * 删除中间问题件\n     *\n     * @param filePath\n     * @return\n     */\n    private boolean deleteFile(String filePath) {\n        File file = new File(filePath);\n        if (file.isFile() && file.exists()) {\n            return file.delete();\n        }\n        return false;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521308422},"updatedAt":{"$$date":1598521932826},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"T4zB8pxXWD3LJ5Xg"}
{"name":"kotlin-Parcelize","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\npackage com.ks.lightlearn.base.bean.course\n\nimport android.os.Parcelable\nimport kotlinx.android.parcel.Parcelize\n\n\n@Parcelize\ndata class KeepPetBean(\n        val picUrl: String,\n        val audioUrl: String,\n        val picUrlLocalPath: String? =\"\",\n        val audioUrlLocalPath: String? =\"\"\n) : Parcelable"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403213070},"updatedAt":{"$$date":1597404243116},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TAyoQPfh3k9MRGpU"}
{"name":"kotlin-控制流：if、when、for、while - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/control-flow.html\n控制流：if、when、for、while - Kotlin 语言中文站\n12-14 minutes\n改进翻译\n在 Kotlin 中，if是一个表达式，即它会返回一个值。 因此就不需要三元运算符（条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。\n\n// 传统用法\nvar max = a \nif (a < b) max = b\n\n// With else \nvar max: Int\nif (a > b) {\n    max = a\n} else {\n    max = b\n}\n \n// 作为表达式\nval max = if (a > b) a else b\nif 的分支可以是代码块，最后的表达式作为该块的值：\n\nval max = if (a > b) {\n    print(\"Choose a\")\n    a\n} else {\n    print(\"Choose b\")\n    b\n}\n如果你使用 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支。\n\n参见 if 语法。\n\nwhen 取代了类 C 语言的 switch 操作符。其最简单的形式如下：\n\nwhen (x) {\n    1 -> print(\"x == 1\")\n    2 -> print(\"x == 2\")\n    else -> { // 注意这个块\n        print(\"x is neither 1 nor 2\")\n    }\n}\nwhen 将它的参数与所有的分支条件顺序比较，直到某个分支满足条件。 when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式， 符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。（像 if 一样，每一个分支可以是一个代码块，它的值是块中最后的表达式的值。）\n\n如果其他分支都不满足条件将会求值 else 分支。 如果 when 作为一个表达式使用，则必须有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了［例如，对于 枚举（enum）类条目与密封（sealed）类子类型］。\n\n如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：\n\nwhen (x) {\n    0, 1 -> print(\"x == 0 or x == 1\")\n    else -> print(\"otherwise\")\n}\n我们可以用任意表达式（而不只是常量）作为分支条件\n\nwhen (x) {\n    parseInt(s) -> print(\"s encodes x\")\n    else -> print(\"s does not encode x\")\n}\n我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：\n\nwhen (x) {\n    in 1..10 -> print(\"x is in the range\")\n    in validNumbers -> print(\"x is valid\")\n    !in 10..20 -> print(\"x is outside the range\")\n    else -> print(\"none of the above\")\n}\n另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法与属性而无需任何额外的检测。\n\nfun hasPrefix(x: Any) = when(x) {\n    is String -> x.startsWith(\"prefix\")\n    else -> false\n}\nwhen 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：\n\nwhen {\n    x.isOdd() -> print(\"x is odd\")\n    y.isEven() -> print(\"y is even\")\n    else -> print(\"x+y is even.\")\n}\n自 Kotlin 1.3 起，可以使用以下语法将 when 的主语（subject，译注：指 when 所判断的表达式）捕获到变量中：\n\nfun Request.getBody() =\n        when (val response = executeRequest()) {\n            is Success -> response.body\n            is HttpError -> throw HttpException(response.status)\n        }\n在 when 主语中引入的变量的作用域仅限于 when 主体。\n\n参见 when 语法。\n\nfor 循环可以对任何提供迭代器（iterator）的对象进行遍历，这相当于像 C# 这样的语言中的 foreach 循环。语法如下：\n\nfor (item in collection) print(item)\n循环体可以是一个代码块。\n\nfor (item: Int in ints) {\n    // ……\n}\n如上所述，for 可以循环遍历任何提供了迭代器的对象。即：\n\n有一个成员函数或者扩展函数 iterator()，它的返回类型\n有一个成员函数或者扩展函数 next()，并且\n有一个成员函数或者扩展函数 hasNext() 返回 Boolean。\n这三个函数都需要标记为 operator。\n\n如需在数字区间上迭代，请使用区间表达式:\n\nfun main() {\n//sampleStart\n    for (i in 1..3) {\n        println(i)\n    }\n    for (i in 6 downTo 0 step 2) {\n        println(i)\n    }\n//sampleEnd\n}\n对区间或者数组的 for 循环会被编译为并不创建迭代器的基于索引的循环。\n\n如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：\n\nfun main() {\nval array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for (i in array.indices) {\n        println(array[i])\n    }\n//sampleEnd\n}\n或者你可以用库函数 withIndex：\n\nfun main() {\n    val array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for ((index, value) in array.withIndex()) {\n        println(\"the element at $index is $value\")\n    }\n//sampleEnd\n}\n参见 for 语法。\n\nwhile 与 do..while 照常使用\n\nwhile (x > 0) {\n    x--\n}\n\ndo {\n  val y = retrieveData()\n} while (y != null) // y 在此处可见\n参见 while 语法.\n\n在循环中 Kotlin 支持传统的 break 与 continue 操作符。参见返回与跳转。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306176632},"updatedAt":{"$$date":1597307698061},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TM24xOKldv9P7wbX"}
{"name":"ad-ksconvenientbanner","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\n\nversion = \"0.0.1\"\n\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName version\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    implementation deps.androidx.design, {\n        exclude group: \"com.android.support\", module: \"multidex\"\n    }\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\nCBPageAdapter\nCBPageAdapterHelper\nhelper\nCBLoopScaleHelper\nholder\nCBViewHolderCreator\nHolder\nlistener\nCBPageChangeListener\nOnItemClickListener\nOnPageChangeListener\nutils\nScreenUtil\nview\nCBLoopViewPager\nConvenientBanner\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522791042},"updatedAt":{"$$date":1598523135527},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TMar0RNCkbPoF1y8"}
{"name":"andr-属性动画概览","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/graphics/prop-animation\n属性动画概览  |  Android 开发者  |  Android Developers\n22-28 minutes\n属性动画系统是一个强健的框架，用于为几乎任何内容添加动画效果。您可以定义一个随时间更改任何对象属性的动画，无论其是否绘制到屏幕上。属性动画会在指定时长内更改属性（对象中的字段）的值。要添加动画效果，请指定要添加动画效果的对象属性，例如对象在屏幕上的位置、动画效果持续多长时间以及要在哪些值之间添加动画效果。\n\n借助属性动画系统，您可以定义动画的以下特性：\n\n时长：您可以指定动画的时长。默认时长为 300 毫秒。\n时间插值：您可以指定如何根据动画的当前已播放时长来计算属性的值。\n重复计数和行为：您可以指定是否在某个时长结束后重复播放动画以及重复播放动画多少次。您还可以指定是否要反向播放动画。如果将其设置为反向播放，则会先播放动画，然后反向播放动画，直到达到重复次数。\nAnimator 集：您可以将动画分成多个逻辑集，它们可以一起播放、按顺序播放或者在指定的延迟时间后播放。\n帧刷新延迟：您可以指定动画帧的刷新频率。默认设置为每 10 毫秒刷新一次，但应用刷新帧的速度最终取决于整个系统的繁忙程度以及系统为底层计时器提供服务的速度。\n要查看属性动画的完整示例，请参阅 GitHub 上 CustomTransition 示例中的 ChangeColor 类。\n\n属性动画的工作原理\n首先，让我们通过一个简单的示例来了解动画的工作原理。图 1 描绘了一个假设的对象，该对象的 x 属性（表示其在屏幕上的水平位置）添加了动画效果。动画时长设置为 40 毫秒，要移动的距离为 40 像素。该对象每隔 10 毫秒（这是默认的帧刷新频率）会水平移动 10 像素。在 40 毫秒时，动画停止，同时对象在水平位置 40 处停止。这是使用线性插值（表示对象以恒定速度移动）的动画示例。\n\n\n\n图 1. 线性动画示例\n\n您也可以指定动画使用非线性插值。图 2 展示了一个假设的对象，它在动画开始时加速，在动画结束前减速。该对象仍在 40 毫秒内移动了 40 像素，但这种移动是非线性的。开始时，此动画加速移动到中间点，然后从中间点减速移动，直至动画结束。如图 2 所示，动画在开头和结尾移动的距离小于在中间移动的距离。\n\n\n\n图 2. 非线性动画示例\n\n我们来详细了解一下属性动画系统的重要组成部分将如何计算如上所示的动画。图 3 描绘了主类之间是如何相互协作的。\n\n\n\n图 3. 如何计算动画\n\nValueAnimator 对象跟踪动画的时间，例如动画的已运行时长以及正在添加动画效果的属性的当前值。\n\nValueAnimator 包含 TimeInterpolator 和 TypeEvaluator；前者用于定义动画插值，后者用于定义如何计算正在添加动画效果的属性的值。例如，在图 2 中，所用的 TimeInterpolator 为 AccelerateDecelerateInterpolator，所用的 TypeEvaluator 为 IntEvaluator。\n\n要开始动画，请创建一个 ValueAnimator，并为您想要添加动画效果的属性赋予起始值和结束值，以及动画时长。当您调用 start() 时，动画即会开始播放。在整个动画播放期间，ValueAnimator 将基于动画时长和已播放时长计算已完成动画分数（在 0 和 1 之间）。已完成动画分数表示动画已完成时间的百分比，0 表示 0%，1 表示 100%。以图 1 为例，在 t = 10ms 处，已完成动画分数将为 0.25，因为总时长 t = 40ms。\n\n在 ValueAnimator 计算完已完成动画分数后，它会调用当前设置的 TimeInterpolator 来计算插值分数。插值分数会将已完成动画分数映射为一个新分数，该分数会考虑已设置的时间插值。例如，在图 2 中，由于动画缓慢加速，t = 10ms 时的插值分数（约 0.15）小于已完成动画分数 (0.25)。在图 1 中，插值分数始终等于已完成动画分数。\n\n计算插值分数后，ValueAnimator 会调用相应的 TypeEvaluator，以根据动画的插值分数、起始值和结束值来计算要添加动画效果的属性的值。例如，在图 2 中，t = 10ms 时的插值分数为 0.15，因此，此时属性的值为 0.15 × (40 - 0)，即 6。\n\n属性动画与视图动画的区别\n视图动画系统仅提供为 View 对象添加动画效果的功能，因此，如果您想为非 对象添加动画效果，则必须实现自己的代码才能做到。视图动画系统也存在一些限制，因为它仅公开 对象的部分方面来供您添加动画效果；例如，您可以对视图的缩放和旋转添加动画效果，但无法对背景颜色这样做。\n\n视图动画系统的另一个缺点是它只会在绘制视图的位置进行修改，而不会修改实际的视图本身。例如，如果您为某个按钮添加了动画效果，使其可以在屏幕上移动，该按钮会正确绘制，但能够点击按钮的实际位置并不会更改，因此您必须通过实现自己的逻辑来处理此事件。\n\n有了属性动画系统，您就可以完全摆脱这些束缚，还可以为任何对象（视图和非视图）的任何属性添加动画效果，并且实际修改的是对象本身。属性动画系统在执行动画方面也更为强健。概括地讲，您可以为要添加动画效果的属性（例如颜色、位置或大小）分配 Animator，还可以定义动画的各个方面，例如多个 Animator 的插值和同步。\n\n不过，视图动画系统的设置需要的时间较短，需要编写的代码也较少。如果视图动画可以完成您需要执行的所有操作，或者现有代码已按照您需要的方式运行，则无需使用属性动画系统。在某些用例中，也可以针对不同的情况同时使用这两种动画系统。\n\nAPI 概览\n您可以在 android.animation 中找到属性动画系统的大多数 API。视图动画系统已经在 android.view.animation 中定义了许多插值器，因此，您也可以在属性动画系统中使用这些插值器。下表描述了属性动画系统的主要组成部分。\n\nAnimator 类提供了创建动画的基本结构。您通常不会直接使用此类，因为它只提供极少的功能，这些功能必须经过扩展才能全面支持为值添加动画效果。以下子类可扩展 Animator：\n\n表 1. Animator\n\n评估程序负责告知属性动画系统如何计算指定属性的值。它们使用由 Animator 类提供的计时数据（即动画的起始值和结束值），并根据这些数据计算属性添加动画效果之后的值。属性动画系统可提供以下评估程序：\n\n表 2. 评估程序\n\n时间插值器指定了如何根据时间计算动画中的特定值。例如，您可以指定动画在整个动画中以线性方式播放，即动画在整个播放期间匀速移动；也可以指定动画使用非线性时间，例如动画在开始后加速并在结束前减速。表 3 介绍了 android.view.animation 中包含的插值器。如果下表提供的插值器都不能满足您的需求，请实现 TimeInterpolator 接口并创建您自己的插值器。如需详细了解如何编写自定义插值器，请参阅使用插值器。\n\n表 3. 插值器\n\n使用 ValueAnimator 添加动画效果\n借助 ValueAnimator 类，您可以为动画播放期间某些类型的值添加动画效果，只需指定一组要添加动画效果的 int、float 或颜色值即可。您可以通过调用 ValueAnimator 的任一工厂方法来获取它：ofInt()、ofFloat() 或 ofObject()。例如：\n\n    ValueAnimator.ofFloat(0f, 100f).apply {\n        duration = 1000\n        start()\n    }\n    \n    ValueAnimator animation = ValueAnimator.ofFloat(0f, 100f);\n    animation.setDuration(1000);\n    animation.start();\n    \n在上述代码中，当 start() 方法运行时，ValueAnimator 会开始计算 1000ms 时长内 0 和 100 之间的动画的值。\n\n您还可以通过执行以下操作来指定要添加动画效果的自定义类型：\n\n    ValueAnimator.ofObject(MyTypeEvaluator(), startPropertyValue, endPropertyValue).apply {\n        duration = 1000\n        start()\n    }\n    \n    ValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue);\n    animation.setDuration(1000);\n    animation.start();\n    \n在上述代码中，当 start() 方法运行时，ValueAnimator 会开始使用 MyTypeEvaluator 提供的逻辑计算 1000ms 时长内 startPropertyValue 和 endPropertyValue 之间的动画的值。\n\n您可以通过向 ValueAnimator 对象添加 AnimatorUpdateListener 来使用动画的值，如以下代码所示：\n\n    ValueAnimator.ofObject(...).apply {\n        ...\n        addUpdateListener { updatedAnimation ->\n            // You can use the animated value in a property that uses the\n            // same type as the animation. In this case, you can use the\n            // float value in the translationX property.\n            textView.translationX = updatedAnimation.animatedValue as Float\n        }\n        ...\n    }\n    \n    animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator updatedAnimation) {\n            // You can use the animated value in a property that uses the\n            // same type as the animation. In this case, you can use the\n            // float value in the translationX property.\n            float animatedValue = (float)updatedAnimation.getAnimatedValue();\n            textView.setTranslationX(animatedValue);\n        }\n    });\n    \n在 onAnimationUpdate() 方法中，您可以访问更新后的动画值，并将其用在您的某个视图的属性中。如需详细了解监听器，请参阅动画监听器部分。\n\n使用 ObjectAnimator 添加动画效果\nObjectAnimator 是上一部分中讨论的 ValueAnimator 的子类，它融合了 ValueAnimator 的计时引擎和值计算以及为目标对象的命名属性添加动画效果这一功能。这可以极大地简化为任何对象添加动画效果的过程，因为动画属性会自动更新，因此您也无需再实现 ValueAnimator.AnimatorUpdateListener 了。\n\n实例化 ObjectAnimator 与 ValueAnimator 的过程类似，但您也可以指定对象和该对象属性的名称（以字符串形式），以及要在哪些值之间添加动画效果：\n\n    ObjectAnimator.ofFloat(textView, \"translationX\", 100f).apply {\n        duration = 1000\n        start()\n    }\n    \n    ObjectAnimator animation = ObjectAnimator.ofFloat(textView, \"translationX\", 100f);\n    animation.setDuration(1000);\n    animation.start();\n    \n要使 ObjectAnimator 正确更新属性，您必须执行以下操作：\n\n要添加动画效果的对象属性必须具有 set<PropertyName>() 形式的 setter 函数（采用驼峰式大小写形式）。由于 ObjectAnimator 会在动画过程中自动更新属性，它必须能够使用此 setter 方法访问该属性。例如，如果属性名称为 foo，则需要使用 setFoo() 方法。如果此 setter 方法不存在，您有三个选择：\n如果您有权限，可将 setter 方法添加到类中。\n使用您有权更改的封装容器类，让该封装容器使用有效的 setter 方法接收值并将其转发给原始对象。\n改用 ValueAnimator。\n如果您在 ObjectAnimator 的一个工厂方法中仅为 values... 参数指定了一个值，则系统会假定它是动画的结束值。因此，要添加动画效果的对象属性必须具有用于获取动画起始值的 getter 函数。getter 函数必须采用 get<PropertyName>() 形式。例如，如果属性名称为 foo，则需要使用 getFoo() 方法。\n要添加动画效果的属性的 getter（如果需要）和 setter 方法的操作对象必须与您为 ObjectAnimator 指定的起始值和结束值的类型相同。例如，如果构建以下 ObjectAnimator，则必须具有 targetObject.setPropName(float) 和 targetObject.getPropName(float)：\n    ObjectAnimator.ofFloat(targetObject, \"propName\", 1f)\n    \n根据您要添加动画效果的属性或对象，您可能需要对视图调用 invalidate() 方法，以强制屏幕使用添加动画效果之后的值重新绘制自身。您可以在 onAnimationUpdate() 回调中执行此操作。例如，如果为可绘制对象的颜色属性添加动画效果，则仅当该对象重新绘制自身时，屏幕才会刷新。视图的所有属性 setter（如 setAlpha() 和 setTranslationX()）都会使视图失效，因此，在使用新值调用这些方法时，您无需使视图失效。如需详细了解监听器，请参阅动画监听器部分。\n使用 AnimatorSet 编排多个动画\n在许多情况下，您需要根据一个动画开始或结束的时间来播放另一个动画。借助 Android 系统，您可以将动画捆绑到一个 AnimatorSet 中，以便指定是同时播放动画、按顺序播放还是在指定的延迟时间后播放。您还可以相互嵌套 AnimatorSet 对象。\n\n以下代码段通过以下方式播放相应的 Animator 对象：\n\n播放 bounceAnim。\n同时播放 squashAnim1、squashAnim2、stretchAnim1 和 stretchAnim2。\n播放 bounceBackAnim。\n播放 fadeAnim。\n    val bouncer = AnimatorSet().apply {\n        play(bounceAnim).before(squashAnim1)\n        play(squashAnim1).with(squashAnim2)\n        play(squashAnim1).with(stretchAnim1)\n        play(squashAnim1).with(stretchAnim2)\n        play(bounceBackAnim).after(stretchAnim2)\n    }\n    val fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f).apply {\n        duration = 250\n    }\n    AnimatorSet().apply {\n        play(bouncer).before(fadeAnim)\n        start()\n    }\n    \n    AnimatorSet bouncer = new AnimatorSet();\n    bouncer.play(bounceAnim).before(squashAnim1);\n    bouncer.play(squashAnim1).with(squashAnim2);\n    bouncer.play(squashAnim1).with(stretchAnim1);\n    bouncer.play(squashAnim1).with(stretchAnim2);\n    bouncer.play(bounceBackAnim).after(stretchAnim2);\n    ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f);\n    fadeAnim.setDuration(250);\n    AnimatorSet animatorSet = new AnimatorSet();\n    animatorSet.play(bouncer).before(fadeAnim);\n    animatorSet.start();\n    \n动画监听器\n您可以使用下述监听器来监听动画播放期间的重要事件。\n\nAnimator.AnimatorListener\nonAnimationStart() - 在动画开始播放时调用。\nonAnimationEnd() - 在动画结束播放时调用。\nonAnimationRepeat() - 在动画重复播放时调用。\nonAnimationCancel() - 在动画取消播放时调用。取消的动画也会调用 onAnimationEnd()，无论它们以何种方式结束。\nValueAnimator.AnimatorUpdateListener\nonAnimationUpdate() - 对动画的每一帧调用。监听此事件即可使用 ValueAnimator 在动画播放期间生成的计算值。要使用该值，请查询传递到事件中的 ValueAnimator 对象，以使用 getAnimatedValue() 方法获取当前添加动画效果之后的值。如果使用了 ValueAnimator，则必须实现此监听器。\n\n根据您要添加动画效果的属性或对象，您可能需要对视图调用 invalidate()，以强制屏幕上的相应区域使用添加动画效果之后的新值重新绘制自身。例如，如果为可绘制对象的颜色属性添加动画效果，则仅当该对象重新绘制自身时，屏幕才会刷新。视图的所有属性 setter（如 setAlpha() 和 setTranslationX()）都会使视图失效，因此，在使用新值调用这些方法时，您无需使视图失效。\n\n如果您不一定需要实现 Animator.AnimatorListener 接口的所有方法，则可以扩展 AnimatorListenerAdapter 类，而非实现 接口。AnimatorListenerAdapter 类提供了方法的空实现，可供您选择替换。\n\n例如，以下代码段可仅为 onAnimationEnd() 回调创建 AnimatorListenerAdapter：\n\n    ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f).apply {\n        duration = 250\n        addListener(object : AnimatorListenerAdapter() {\n            override fun onAnimationEnd(animation: Animator) {\n                balls.remove((animation as ObjectAnimator).target)\n            }\n        })\n    }\n    \n    ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f);\n    fadeAnim.setDuration(250);\n    fadeAnim.addListener(new AnimatorListenerAdapter() {\n    public void onAnimationEnd(Animator animation) {\n        balls.remove(((ObjectAnimator)animation).getTarget());\n    }\n    \n为 ViewGroup 对象的布局更改添加动画效果\n属性动画系统提供对 ViewGroup 对象的更改添加动画效果的功能，还可轻松为视图对象本身添加动画效果。\n\n您可使用 LayoutTransition 类为 ViewGroup 内的布局更改添加动画效果。当您向 ViewGroup 添加视图或删除其中的视图时，或当您使用 VISIBLE、INVISIBLE 或 GONE 调用视图的 setVisibility() 方法时，这些视图可能会经历出现和消失动画。向 ViewGroup 添加视图或删除其中的视图时，其中剩余的视图还可能以动画形式移动到新位置。您可以调用 setAnimator() 并使用以下任一 LayoutTransition 常量传入 Animator 对象，从而在 LayoutTransition 对象中定义相应动画：\n\nAPPEARING - 该标记表示动画在容器中出现的项上运行。\nCHANGE_APPEARING - 该标记表示动画在因某个新项目在容器中出现而变化的项上运行。\nDISAPPEARING - 该标记表示动画在从容器中消失的项上运行。\nCHANGE_DISAPPEARING - 该标记表示动画在因某个项从容器中消失而变化的项上运行。\n您可以为这四类事件定义您自己的自定义动画，从而自定义布局转换的外观，或者告诉动画系统使用默认动画。\n\nAPI 演示中的 LayoutAnimations 示例介绍了如何为布局转换定义动画，然后在要添加动画效果的视图对象上设置动画。\n\nLayoutAnimationsByDefault 及其对应的 layout_animations_by_default.xml 布局资源文件介绍了如何在 XML 中为 ViewGroup 启用默认布局转换。您唯一需要做的就是将 ViewGroup 的 android:animateLayoutchanges 属性设置为 true。例如：\n\n    <LinearLayout\n        android:orientation=\"vertical\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"match_parent\"\n        android:id=\"@+id/verticalContainer\"\n        android:animateLayoutChanges=\"true\" />\n    \n将此属性设置为 true 可自动为添加到 ViewGroup 或从中删除的视图以及该 ViewGroup 中剩余的视图添加动画效果。\n\n使用 StateListAnimator 为视图状态更改添加动画效果\n通过 StateListAnimator 类，您可以定义在视图状态更改时运行的 Animator。此对象充当 Animator 对象的封装容器，只要指定的视图状态（例如“按下”或“聚焦”）发生更改，就会调用该动画。\n\n可使用根 <selector> 元素和子 <item> 元素在 XML 资源中定义 StateListAnimator，每个元素都指定一个由 StateListAnimator 类定义的不同视图状态。每个 <item> 都包含一个属性动画集的定义。\n\n例如，以下文件创建了一个状态列表 Animator，可在按下后更改视图的 x 和 y 比例：\n\nres/xml/animate_scale.xml\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n        <!-- the pressed state; increase x and y size to 150% -->\n        <item android:state_pressed=\"true\">\n            <set>\n                <objectAnimator android:propertyName=\"scaleX\"\n                    android:duration=\"@android:integer/config_shortAnimTime\"\n                    android:valueTo=\"1.5\"\n                    android:valueType=\"floatType\"/>\n                <objectAnimator android:propertyName=\"scaleY\"\n                    android:duration=\"@android:integer/config_shortAnimTime\"\n                    android:valueTo=\"1.5\"\n                    android:valueType=\"floatType\"/>\n            </set>\n        </item>\n        <!-- the default, non-pressed state; set x and y size to 100% -->\n        <item android:state_pressed=\"false\">\n            <set>\n                <objectAnimator android:propertyName=\"scaleX\"\n                    android:duration=\"@android:integer/config_shortAnimTime\"\n                    android:valueTo=\"1\"\n                    android:valueType=\"floatType\"/>\n                <objectAnimator android:propertyName=\"scaleY\"\n                    android:duration=\"@android:integer/config_shortAnimTime\"\n                    android:valueTo=\"1\"\n                    android:valueType=\"floatType\"/>\n            </set>\n        </item>\n    </selector>\n    \n要将状态列表 Animator 附加到视图，请添加 android:stateListAnimator 属性，如下所示：\n\n    <Button android:stateListAnimator=\"@xml/animate_scale\"\n            ... />\n    \n现在，当此按钮的状态发生变化时，会使用 animate_scale.xml 中定义的动画。\n\n或者，如果要转为在代码中将状态列表 Animator 分配给视图，则可使用 AnimatorInflater.loadStateListAnimator() 方法，然后使用 View.setStateListAnimator() 方法将 Animator 分配给相应视图。\n\n您还可以使用 AnimatedStateListDrawable 在状态更改间播放可绘制动画，而不是为视图的属性添加动画效果。Android 5.0 中的一些系统微件默认会使用这些动画。以下示例展示了如何将 AnimatedStateListDrawable 定义为 XML 资源：\n\n    <!-- res/drawable/myanimstatedrawable.xml -->\n    <animated-selector\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"><!-- provide a different drawable for each state-->\n        <item android:id=\"@+id/pressed\" android:drawable=\"@drawable/drawableP\"\n            android:state_pressed=\"true\"/>\n        <item android:id=\"@+id/focused\" android:drawable=\"@drawable/drawableF\"\n            android:state_focused=\"true\"/>\n        <item android:id=\"@id/default\"\n            android:drawable=\"@drawable/drawableD\"/><!-- specify a transition -->\n        <transition android:fromId=\"@+id/default\" android:toId=\"@+id/pressed\">\n            <animation-list>\n                <item android:duration=\"15\" android:drawable=\"@drawable/dt1\"/>\n                <item android:duration=\"15\" android:drawable=\"@drawable/dt2\"/>\n                ...\n            </animation-list>\n        </transition>\n        ...\n    </animated-selector>\n    \n使用 TypeEvaluator\n如果要为 Android 系统无法识别的类型添加动画效果，则可以通过实现 TypeEvaluator 接口来创建您自己的评估程序。Android 系统可以识别的类型为 int、float 或颜色，分别由 IntEvaluator、FloatEvaluator 和 ArgbEvaluator 类型评估程序提供支持。\n\nTypeEvaluator 接口中只有一种要实现的方法，那就是 evaluate() 方法。这样，您使用的 Animator 就会在动画的当前点为添加动画效果之后的属性返回适当的值。FloatEvaluator 类演示了如何做到这一点：\n\n    private class FloatEvaluator : TypeEvaluator<Any> {override fun evaluate(fraction: Float, startValue: Any, endValue: Any): Any {\n            return (startValue as Number).toFloat().let { startFloat ->\n                startFloat + fraction * ((endValue as Number).toFloat() - startFloat)\n            }\n        }}\n    \n    public class FloatEvaluator implements TypeEvaluator {public Object evaluate(float fraction, Object startValue, Object endValue) {\n            float startFloat = ((Number) startValue).floatValue();\n            return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);\n        }\n    }\n    \n注意：当 ValueAnimator（或 ObjectAnimator）运行时，它会计算动画当前的已完成动画分数（一个介于 0 和 1 之间的值），然后根据您正在使用的插值器来计算该分数的插值版本。插值分数是 TypeEvaluator 通过 fraction 参数接收的，因此您在计算添加动画效果之后的值时无需考虑插值器。\n\n使用插值器\n插值器指定了如何根据时间计算动画中的特定值。例如，您可以指定动画在整个动画中以线性方式播放，即动画在整个播放期间匀速移动；也可以指定动画使用非线性时间，例如动画在开始后加速并在结束前减速。\n\n动画系统中的插值器会接收来自 Animator 的分数，该分数表示动画的已播放时间。插值器会修改此分数，使其与要提供的动画类型保持一致。Android 系统在 android.view.animation package 中提供了一组常用的插值器。如果这些插值器都不能满足您的需求，您可以实现 TimeInterpolator 接口并创建您自己的插值器。\n\n以下示例对比了默认插值器 AccelerateDecelerateInterpolator 和 LinearInterpolator 计算插值分数的方式。LinearInterpolator 对已完成动画分数没有任何影响。AccelerateDecelerateInterpolator 会在动画开始后加速，并在动画结束前减速。以下方法定义了这些插值器的逻辑：\n\nAccelerateDecelerateInterpolator\n\n    override fun getInterpolation(input: Float): Float =\n            (Math.cos((input + 1) * Math.PI) / 2.0f).toFloat() + 0.5f\n    \n    @Override\n    public float getInterpolation(float input) {\n        return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;\n    }\n    \nLinearInterpolator\n\n    override fun getInterpolation(input: Float): Float = input\n    \n    @Override\n    public float getInterpolation(float input) {\n        return input;\n    }\n    \n下表表示这些插值器为时长 1000ms 的动画计算的近似值：\n\n已完成毫秒数\t已完成动画分数/插值分数（线性）\t插值分数（加速/减速）\n0\t0\t0\n200\t0.2\t0.1\n400\t0.4\t0.345\n600\t0.6\t0.8\n800\t0.8\t0.9\n1000\t1\t1\n如上表所示，LinearInterpolator 以相同的速度更改值，每 200ms 变化 0.2。AccelerateDecelerateInterpolator 在 200ms 到 600ms 之间更改值的速度会快于 LinearInterpolator，在 600ms 到 1000ms 之间会慢一些。\n\n指定关键帧\nKeyframe 对象由时间值对组成，用于在动画的特定时间定义特定的状态。每个关键帧还可以用自己的插值器控制动画在上一关键帧时间和此关键帧时间之间的时间间隔内的行为。\n\n要实例化 Keyframe 对象，您必须使用它的任一工厂方法（ofInt()、ofFloat() 或 ofObject()）来获取类型合适的 。然后，通过调用 ofKeyframe() 工厂方法来获取 PropertyValuesHolder 对象。获取对象后，您可以通过传入 PropertyValuesHolder 对象以及要添加动画效果的对象来获取 Animator。以下代码段演示了如何做到这一点：\n\n    val kf0 = Keyframe.ofFloat(0f, 0f)\n    val kf1 = Keyframe.ofFloat(.5f, 360f)\n    val kf2 = Keyframe.ofFloat(1f, 0f)\n    val pvhRotation = PropertyValuesHolder.ofKeyframe(\"rotation\", kf0, kf1, kf2)\n    ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation).apply {\n        duration = 5000\n    }\n    \n    Keyframe kf0 = Keyframe.ofFloat(0f, 0f);\n    Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);\n    Keyframe kf2 = Keyframe.ofFloat(1f, 0f);\n    PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(\"rotation\", kf0, kf1, kf2);\n    ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation);\n    rotationAnim.setDuration(5000);\n    \n为视图添加动画效果\n属性动画系统支持为视图对象添加经过简化的动画，与视图动画系统相比，它具有一定的优势。视图动画系统通过更改绘制视图对象的方式来转换视图对象。这是在每个视图的容器中处理的，因为视图本身没有可操控的属性。这会导致视图在表面上添加了动画效果，但视图对象本身没有任何变化。这会产生不好的效果，例如，某个对象已经在屏幕的其他位置绘制，但它仍位于其原始位置。在 Android 3.0 中，我们添加了新的属性以及相应的 getter 和 setter 方法来消除此缺陷。\n\n属性动画系统可以通过更改视图对象中的实际属性来为屏幕上的视图添加动画效果。此外，当视图的属性发生更改时，视图还会自动调用 invalidate() 方法来刷新屏幕。View 类中有利于属性动画的新属性包括：\n\ntranslationX 和 translationY：这些属性用于控制视图所在的位置，值为视图的布局容器所设置的左侧坐标和顶部坐标的增量。\nrotation、rotationX 和 rotationY：这些属性用于控制视图围绕轴心点进行的 2D（ 属性）和 3D 旋转。\nscaleX 和 scaleY：这些属性用于控制视图围绕其轴心点进行的 2D 缩放。\npivotX 和 pivotY：这些属性用于控制旋转和缩放转换所围绕的轴心点的位置。默认情况下，轴心点位于对象的中心。\nx 和 y：这些是简单的实用属性，用于描述视图在容器中的最终位置，值分别为左侧值与 translationX 值的和以及顶部值与 translationY 值的和。\nalpha：表示视图的 Alpha 透明度。此值默认为 1（不透明），值为 0 则表示完全透明（不可见）。\n要为视图对象的属性（例如其颜色或旋转值）添加动画效果，您只需创建一个属性 Animator 并指定要添加动画效果的视图属性即可。例如：\n\n    ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f)\n    \n    ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f);\n    \n如需详细了解如何创建 Animator，请参阅介绍如何使用 ValueAnimator 和 ObjectAnimator 添加动画效果的部分。\n\n使用 ViewPropertyAnimator 添加动画效果\nViewPropertyAnimator 有助于使用单个底层 Animator 对象轻松为 View 的多个属性并行添加动画效果。它的行为方式与 ObjectAnimator 非常相似，因为它会修改视图属性的实际值，但在同时为多个属性添加动画效果时，它更为高效。此外，使用 ViewPropertyAnimator 的代码更加简洁，也更易读。以下代码段展示了在同时为视图的 x 和 y 属性添加动画效果时，使用多个 ObjectAnimator 对象、使用单个 ObjectAnimator 对象以及使用 ViewPropertyAnimator 的区别。\n\n多个 ObjectAnimator 对象\n\n    val animX = ObjectAnimator.ofFloat(myView, \"x\", 50f)\n    val animY = ObjectAnimator.ofFloat(myView, \"y\", 100f)\n    AnimatorSet().apply {\n        playTogether(animX, animY)\n        start()\n    }\n    \n    ObjectAnimator animX = ObjectAnimator.ofFloat(myView, \"x\", 50f);\n    ObjectAnimator animY = ObjectAnimator.ofFloat(myView, \"y\", 100f);\n    AnimatorSet animSetXY = new AnimatorSet();\n    animSetXY.playTogether(animX, animY);\n    animSetXY.start();\n    \n一个 ObjectAnimator\n\n    val pvhX = PropertyValuesHolder.ofFloat(\"x\", 50f)\n    val pvhY = PropertyValuesHolder.ofFloat(\"y\", 100f)\n    ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvhY).start()\n    \n    PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"x\", 50f);\n    PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"y\", 100f);\n    ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvhY).start();\n    \nViewPropertyAnimator\n\n    myView.animate().x(50f).y(100f)\n    \n    myView.animate().x(50f).y(100f);\n    \n如需详细了解 ViewPropertyAnimator，请参阅相应的 Android 开发者博文。\n\n在 XML 中声明动画\n属性动画系统支持您使用 XML 声明属性动画，而不是以编程方式进行声明。通过在 XML 中定义动画，您可以轻松地在多个 Activity 中重复使用动画，还能更轻松地修改动画序列。\n\n为了将使用新属性动画 API 的动画文件与使用旧版视图动画框架的动画文件区分开来，从 Android 3.1 开始，您应将属性动画的 XML 文件保存到 res/animator/ 目录中。\n\n以下属性动画类具有带相应 XML 标签的 XML 声明支持：\n\nValueAnimator - <animator>\nObjectAnimator - <objectAnimator>\nAnimatorSet - <set>\n要查找 XML 声明中可使用的属性，请参阅动画资源。以下示例依次播放两组对象动画，其中第一个嵌套集会同时播放两个对象动画：\n\n    <set android:ordering=\"sequentially\">\n        <set>\n            <objectAnimator\n                android:propertyName=\"x\"\n                android:duration=\"500\"\n                android:valueTo=\"400\"\n                android:valueType=\"intType\"/>\n            <objectAnimator\n                android:propertyName=\"y\"\n                android:duration=\"500\"\n                android:valueTo=\"300\"\n                android:valueType=\"intType\"/>\n        </set>\n        <objectAnimator\n            android:propertyName=\"alpha\"\n            android:duration=\"500\"\n            android:valueTo=\"1f\"/>\n    </set>\n    \n为了运行此动画，您必须将代码中的 XML 资源扩充为 AnimatorSet 对象，然后在开始动画集之前为所有动画设置目标对象。调用 setTarget() 即可为 AnimatorSet 的所有子项设置一个目标对象，这是系统提供的便捷方式。以下代码展示了如何做到这一点：\n\n    (AnimatorInflater.loadAnimator(myContext, R.animator.property_animator) as AnimatorSet).apply {\n        setTarget(myObject)\n        start()\n    }\n    \n    AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,\n        R.animator.property_animator);\n    set.setTarget(myObject);\n    set.start();\n    \n您还可以在 XML 中声明 ValueAnimator，如以下示例所示：\n\n    <animator xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:duration=\"1000\"\n        android:valueType=\"floatType\"\n        android:valueFrom=\"0f\"\n        android:valueTo=\"-100f\" />\n    \n要使用代码中的上一个 ValueAnimator，您必须扩充对象、添加 AnimatorUpdateListener、获取更新后的动画值并在某个视图的属性中使用它，如下面的代码所示：\n\n    (AnimatorInflater.loadAnimator(this, R.animator.animator) as ValueAnimator).apply {\n        addUpdateListener { updatedAnimation ->\n            textView.translationX = updatedAnimation.animatedValue as Float\n        }\n        start\n\n()\n    }\n    \n    ValueAnimator xmlAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(this,\n            R.animator.animator);\n    xmlAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator updatedAnimation) {\n            float animatedValue = (float)updatedAnimation.getAnimatedValue();\n            textView.setTranslationX(animatedValue);\n        }\n    });\n    xmlAnimator\n\n.start();\n    \n如需了解定义属性动画的 XML 语法，请参阅动画资源。\n\n对界面性能的潜在影响\n用于更新界面的 Animator 会使动画运行的每一帧都进行额外的渲染。因此，使用资源密集型动画可能会对应用的性能产生负面影响。\n\n为界面添加动画效果所需的工作已添加到渲染管道的动画阶段。您可以启用 GPU 渲染模式分析并监控动画阶段，以了解您的动画是否会影响应用的性能。如需了解详情，请参阅 GPU 渲染模式分析演示。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243910245},"updatedAt":{"$$date":1597244861484},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TOQu3v19Zk9QgYNH"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597404252835},"updatedAt":{"$$date":1597404252835},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TiPrmBW2fHWdMjpT"}
{"name":"andr-在 Fragment 之间传递数据","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\ndeveloper.android.google.cn /training/basics/fragments/pass-data-between\n在 Fragment 之间传递数据  |  Android 开发者  |  Android Developers\n6-7 minutes\n从 Fragment 1.3.0-alpha04 开始，每个 FragmentManager 都会实现 FragmentResultOwner。这意味着 FragmentManager 可以充当 Fragment 结果的集中存储区。此更改通过设置 Fragment 结果并监听这些结果，而不要求 Fragment 直接引用彼此，让单独的 Fragment 相互通信。\n\n如需将数据从 Fragment B 传回到 Fragment A，请先在接收结果的 Fragment A 上设置结果监听器。在 Fragment A 的 FragmentManager 上调用 setFragmentResultListener() API，如以下示例所示：\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    // Use the Kotlin extension in the fragment-ktx artifact\n    setResultListener(\"requestKey\") { key, bundle ->\n        // We use a String here, but any type that can be put in a Bundle is supported\n        val result = bundle.getString(\"bundleKey\")\n        // Do something with the result...\n    }\n}\n@Override\npublic void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    getParentFragmentManager().setFragmentResultListener(\"key\", this, new FragmentResultListener() {\n        @Override\n        public void onFragmentResult(@NonNull String key, @NonNull Bundle bundle) {\n            // We use a String here, but any type that can be put in a Bundle is supported\n            String result = bundle.getString(\"bundleKey\");\n            // Do something with the result...\n        }\n    });\n}\nFragment B 使用 Fragment 管理器将数据发送到 Fragment A\n图 1. Fragment B 使用 FragmentManager 将数据发送到 Fragment A。\n在生成结果的 Fragment B 中，您必须使用相同的 requestKey 在同一 FragmentManager 上设置结果。您可以使用 setFragmentResult() API 来完成此操作：\n\nbutton.setOnClickListener {\n    val result = \"result\"\n    // Use the Kotlin extension in the fragment-ktx artifact\n    setResult(\"requestKey\", bundleOf(\"bundleKey\" to result))\n}\nbutton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Bundle result = new Bundle();\n        result.putString(\"bundleKey\", \"result\");\n        getParentFragmentManager().setFragmentResult(\"requestKey\", result);\n    }\n});\n然后，在值为 STARTED 后，Fragment A 便会收到结果并执行监听器回调。\n\n对于一个指定键，您只能有一个监听器和一个结果。如果您对同一个键多次调用 setResult()，则系统会将 Fragment B 从返回堆栈退出之前的最近结果发送给 Fragment A。如果您设置的结果没有相应的监听器来接收，则结果会存储在 FragmentManager 中，直到您设置一个具有相同键的监听器。请注意，监听器的 Fragment 必须为 STARTED，然后该 Fragment 才能收到结果。监听器收到结果并触发 onFragmentResult() 回调后，结果会被清除。这种行为有两个主要影响：\n\n返回堆栈上的 Fragment 只有在被弹出栈顶且为 STARTED 之后才会收到结果。\n如果在设置结果时监听结果的 Fragment 为 STARTED，则系统会立即触发监听器的回调。\n在父级 Fragment 和子级 Fragment 之间传递结果\n如需将结果从子级 Fragment 传递到父级 Fragment，父级 Fragment 在调用 setFragmentResultListener() 时应使用 getChildFragmentManager() 而不是 getParentFragmentManager()。\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    // We set the listener on the child fragmentManager\n    childFragmentManager.setResultListener(\"requestKey\") { key, bundle ->\n        val result = bundle.getString(\"bundleKey\")\n        // Do something with the result..\n    }\n}\n@Override\npublic void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    // We set the listener on the child fragmentManager\n    getChildFragmentManager().setFragmentResultListener(\"key\", this, new FragmentResultListener() {\n        @Override\n        public void onFragmentResult(@NonNull String key, @NonNull Bundle bundle) {\n            String result = bundle.getString(\"bundleKey\");\n            // Do something with the result..\n        }\n    });\n}\n子级 Fragment 可以使用 Fragment 管理器将结果发送到其父级 Fragment\n图 2. 子级 Fragment 可以使用 FragmentManager 将结果发送到其父级 Fragment。\n子级 Fragment 在其 FragmentManager 上设置结果。然后，当父级 Fragment 为 STARTED 时便会收到结果：\n\nbutton.setOnClickListener {\n    val result = \"result\"\n    // Use the Kotlin extension in the fragment-ktx artifact\n    setResult(\"requestKey\", bundleOf(\"bundleKey\" to result))\n}\nbutton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Bundle result = new Bundle();\n        result.putString(\"bundleKey\", \"result\");// The child fragment needs to still set the result on its parent fragment manager\n        getParentFragmentManager().setFragmentResult(\"requestKey\", result);\n    }\n});\n测试 Fragment 结果\n使用 FragmentScenario 测试对 setFragmentResult() 和 setFragmentResultListener() 的调用。使用 launchFragmentInContainer 或 launchFragment 为被测 Fragment 创建场景，然后手动调用目前未测试的方法。\n\n如需测试 setResultListener()，请使用调用 setResultListener() 的 Fragment 创建一个场景。接下来，直接调用 setResult() 并验证结果：\n\n@Test\nfun testFragmentResultListener() {\n    val scenario = launchFragmentInContainer<ResultListenerFragment>()\n    scenario.onFragment { fragment ->\n        val expectedResult = \"result\"\n        fragment.parentFragmentManagager.setResult(\"requestKey\", bundleOf(\"bundleKey\" to expectedResult))\n        assertThat(fragment.result).isEqualTo(expectedResult)\n    }\n}class ResultListenerFragment : Fragment() {\n    var result : String? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // Use the Kotlin extension in the fragment-ktx artifact\n        setResultListener(\"requestKey\") { key, bundle ->\n            result = bundle.getString(\"bundleKey\")\n        }\n    }\n}\n如需测试 setResult()，请使用调用 setResult() 的 Fragment 创建一个场景。接下来，直接调用 setResultListener() 并验证结果：\n\n@Test\nfun testFragmentResult() {\n    val scenario = launchFragmentInContainer<ResultFragment>()\n    lateinit var actualResult: String?\n    scenario.onFragment { fragment ->\n        fragment.parentFragmentManagager.setResultListener(\"requestKey\") { key, bundle ->\n            actualResult = bundle.getString(\"bundleKey\")\n        }\n    }\n    onView(withId(R.id.result_button)).perform(click())\n    assertThat(actualResult).isEqualTo(\"result\")\n}class ResultFragment : Fragment(R.layout.fragment_result) {\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        view.findViewById(R.id.result_button).setOnClickListener {\n            val result = \"result\"\n            // Use the Kotlin extension in the fragment-ktx artifact\n            setResult(\"requestKey\", bundleOf(\"bundleKey\" to result))\n        }\n    }\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243445624},"updatedAt":{"$$date":1597243889014},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TleHBclMu2mj7T5r"}
{"name":"andr-了解任务和返回堆栈","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/components/activities/tasks-and-back-stack\n了解任务和返回堆栈  |  Android 开发者  |  Android Developers\n10-12 minutes\n任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。例如，电子邮件应用可能有一个 Activity 来显示新邮件列表。当用户选择一封邮件时，系统会打开一个新的 Activity 来显示该邮件。这个新的 Activity 会添加到返回堆栈中。如果用户按返回按钮，这个新的 Activity 即会完成并从堆栈中退出。通过以下视频可以大致了解返回堆栈的工作原理。\n\nAndroid 7.0（API 级别 24）及更高版本支持多窗口环境，当应用在这种环境中同时运行时，系统会单独管理每个窗口的任务；而每个窗口可能包含多项任务。在 Chromebook 上运行的 Android 应用也是如此：系统按窗口管理任务或任务组。\n\n大多数任务都从设备主屏幕上启动。当用户轻触应用启动器中的图标（或主屏幕上的快捷方式）时，该应用的任务就会转到前台运行。如果该应用没有任务存在（应用最近没有使用过），则会创建一个新的任务，并且该应用的“主”Activity 将会作为堆栈的根 Activity 打开。\n\n在当前 Activity 启动另一个 Activity 时，新的 Activity 将被推送到堆栈顶部并获得焦点。上一个 Activity 仍保留在堆栈中，但会停止。当 Activity 停止时，系统会保留其界面的当前状态。当用户按返回按钮时，当前 Activity 会从堆栈顶部退出（该 Activity 销毁），上一个 Activity 会恢复（界面会恢复到上一个状态）。堆栈中的 Activity 永远不会重新排列，只会被送入和退出，在当前 Activity 启动时被送入堆栈，在用户使用返回按钮离开时从堆栈中退出。因此，返回堆栈按照“后进先出”的对象结构运作。图 1 借助一个时间轴直观地显示了这种行为。该时间轴显示了 Activity 之间的进展以及每个时间点的当前返回堆栈。\n\n\n\n图 1. 有关任务中的每个新 Activity 如何添加到返回堆栈的图示。当用户按返回按钮时，当前 Activity 会销毁，上一个 Activity 将恢复。\n\n如果用户继续按返回，则堆栈中的 Activity 会逐个退出，以显示前一个 Activity，直到用户返回到主屏幕（或任务开始时运行的 Activity）。移除堆栈中的所有 Activity 后，该任务将不复存在。\n\n\n\n图 2. 两个任务：任务 B 在前台接收用户互动，任务 A 在后台等待恢复。\n\n任务是一个整体单元，当用户开始一个新任务或通过主屏幕按钮进入主屏幕时，任务可移至“后台”。在后台时，任务中的所有 Activity 都会停止，但任务的返回堆栈会保持不变，当其他任务启动时，当前任务只是失去了焦点，如图 2 所示。这样一来，任务就可以返回到“前台”，以便用户可以从他们离开的地方继续操作。举例来说，假设当前任务（任务 A）的堆栈中有 3 个 Activity，当前 Activity 下有 2 个 Activity。用户按主屏幕按钮，然后从应用启动器中启动新应用。主屏幕出现后，任务 A 转到后台。当新应用启动时，系统会启动该应用的任务（任务 B），该任务具有自己的 Activity 堆栈。与该应用互动后，用户再次返回到主屏幕并选择最初启动任务 A 的应用。现在，任务 A 进入前台，其堆栈中的所有三个 Activity 都完好如初，堆栈顶部的 Activity 恢复运行。此时，用户仍可通过以下方式切换到任务 B：转到主屏幕并选择启动该任务的应用图标（或者从最近使用的应用屏幕中选择该应用的任务）。这就是在 Android 上进行多任务处理的一个例子。\n\n注意：多个任务可以同时在后台进行。但是，如果用户同时运行很多后台任务，系统可能会为了恢复内存而开始销毁后台 Activity，导致 Activity 状态丢失。\n\n\n\n图 3. 单个 Activity 会被多次实例化。\n\n由于返回堆栈中的 Activity 不会被重新排列，如果您的应用允许用户从多个 Activity 启动特定的 Activity，系统便会创建该 Activity 的新实例并将其推送到堆栈中（而不是将该 Activity 的某个先前的实例移至堆栈顶部）。这样一来，应用中的一个 Activity 就可能被多次实例化（甚至是从其他任务对其进行实例化），如图 3 所示。因此，如果用户使用返回按钮向后导航，Activity 的每个实例将按照它们被打开的顺序显示出来（每个实例都有自己的界面状态）。不过，如果您不希望某个 Activity 被实例化多次，可以修改此行为。有关如何实现此操作，将在后面的管理任务部分中讨论。\n\nActivity 和任务的默认行为总结如下：\n\n当 Activity A 启动 Activity B 时，Activity A 会停止，但系统会保留其状态（例如滚动位置和输入到表单中的文本）。如果用户在 Activity B 中按返回按钮，系统会恢复 Activity A 及其状态。\n当用户通过按主屏幕按钮离开任务时，当前 Activity 会停止，其任务会转到后台。系统会保留任务中每个 Activity 的状态。如果用户稍后通过点按该任务的启动器图标来恢复该任务，该任务会进入前台并恢复堆栈顶部的 Activity。\n如果用户按返回按钮，当前 Activity 将从堆栈中退出并销毁。堆栈中的上一个 Activity 将恢复。Activity 被销毁后，系统不会保留该 Activity 的状态。\nActivity 可以多次实例化，甚至是从其他任务对其进行实例化。\n导航设计\n\n要详细了解 Android 上的应用导航如何运作，请参阅 Android 设计中的导航指南。\n\n管理任务\n如上文所述，Android 管理任务和返回堆栈的方式是将所有接连启动的 Activity 放到同一任务和一个“后进先出”堆栈中，这对于大多数应用都很有效，而且您不必担心 Activity 如何与任务相关联，或者它们如何存在于返回堆栈中。不过，您可能需要决定是否要打破正常行为。或许您希望应用中的某个 Activity 在启动时开启一个新的任务（而不是被放入当前的任务中），或者当您启动某个 Activity 时，您希望调用它的一个现有实例（而不是在返回堆栈顶部创建一个新实例），或者您希望在用户离开任务时清除返回堆栈中除根 Activity 以外的所有 Activity。\n\n您可以借助 <activity> 清单元素中的属性以及您传递给 startActivity() 的 intent 中的标记来实现上述目的。\n\n在这方面，您可以使用的主要 <activity> 属性包括：\n\ntaskAffinity\nlaunchMode\nallowTaskReparenting\nclearTaskOnLaunch\nalwaysRetainTaskState\nfinishOnTaskLaunch\n您可以使用的主要 intent 标记包括：\n\nFLAG_ACTIVITY_NEW_TASK\nFLAG_ACTIVITY_CLEAR_TOP\nFLAG_ACTIVITY_SINGLE_TOP\n在下面几节中，您将了解到如何使用这些清单属性和 intent 标记来定义 Activity 与任务之间的关联方式，以及它们在返回堆栈中的行为。\n\n另外，下面还分别介绍了如何在最近使用的应用屏幕中表示和管理任务与 Activity。有关详情，请参阅“最近使用的应用”屏幕。通常，您应允许系统定义任务和 Activity 在最近使用的应用屏幕中的表示方式，您无需修改此行为。\n\n注意：大多数应用不应打破 Activity 和任务的默认行为。如果您确定需要让 Activity 改变默认行为，请谨慎操作，并且务必要测试该 Activity 在以下情况下的可用性：启动期间以及您通过返回按钮从其他 Activity 和任务返回该 Activity 时。务必要测试是否存在可能与用户预期的行为冲突的导航行为。\n\n定义启动模式\n您可以通过启动模式定义 Activity 的新实例如何与当前任务关联。您可以通过两种方式定义不同的启动模式：\n\n使用清单文件\n当您在清单文件中声明 Activity 时，您可以指定该 Activity 在启动时如何与任务关联。\n\n使用 Intent 标记\n当您调用 startActivity() 时，可以在 Intent 中添加一个标记，用于声明新 Activity 如何（或是否）与当前任务相关联。\n\n因此，如果 Activity A 启动 Activity B，Activity B 可在其清单中定义如何与当前任务相关联（如果关联的话），Activity A 也可以请求 Activity B 应该如何与当前任务关联。如果两个 Activity 都定义了 Activity B 应如何与任务关联，将优先遵循 Activity A 的请求（在 intent 中定义），而不是 Activity B 的请求（在清单中定义）。\n\n注意：有些启动模式可通过清单文件定义，但不能通过 intent 标记定义，同样，有些启动模式可通过 intent 标记定义，却不能在清单中定义。\n\n使用清单文件\n在清单文件中声明 Activity 时，可以使用 <activity> 元素的 launchMode 属性指定 Activity 应该如何与任务关联。\n\nlaunchMode 属性说明了 Activity 应如何启动到任务中。您可以为 launchMode 属性指定 4 种不同的启动模式：\n\n\"standard\"（默认模式）\n默认值。系统在启动该 Activity 的任务中创建 Activity 的新实例，并将 intent 传送给该实例。Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。\n\"singleTop\"\n如果当前任务的顶部已存在 Activity 的实例，则系统会通过调用其 onNewIntent() 方法来将 intent 转送给该实例，而不是创建 Activity 的新实例。Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例（但前提是返回堆栈顶部的 Activity 不是该 Activity 的现有实例）。\n例如，假设任务的返回堆栈包含根 Activity A 以及 Activity B、C 和位于顶部的 D（堆栈为 A-B-C-D；D 位于顶部）。收到以 D 类型 Activity 为目标的 intent。如果 D 采用默认的 \"standard\" 启动模式，则会启动该类的新实例，并且堆栈将变为 A-B-C-D-D。但是，如果 D 的启动模式为 \"singleTop\"，则 D 的现有实例会通过 onNewIntent() 接收 intent，因为它位于堆栈顶部，堆栈仍为 A-B-C-D。但是，如果收到以 B 类型 Activity 为目标的 intent，则会在堆栈中添加 B 的新实例，即使其启动模式为 \"singleTop\" 也是如此。\n\n注意：创建 Activity 的新实例后，用户可以按返回按钮返回到上一个 Activity。但是，当由 Activity 的现有实例处理新 intent 时，用户将无法通过按返回按钮返回到 onNewIntent() 收到新 intent 之前的 Activity 状态。\n\n\"singleTask\"\n系统会创建新任务，并实例化新任务的根 Activity。但是，如果另外的任务中已存在该 Activity 的实例，则系统会通过调用其 onNewIntent() 方法将 intent 转送到该现有实例，而不是创建新实例。Activity 一次只能有一个实例存在。\n注意：虽然 Activity 在新任务中启动，但用户按返回按钮仍会返回到上一个 Activity。\n\n\"singleInstance\"\n与 \"singleTask\" 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。\n再举个例子，Android 浏览器应用在 <activity> 元素中指定 singleTask 启动模式，由此声明网络浏览器 Activity 应始终在它自己的任务中打开。这意味着，如果您的应用发出打开 Android 浏览器的 intent，系统不会将其 Activity 置于您的应用所在的任务中，而是会为浏览器启动一个新任务，如果浏览器已经有任务在后台运行，则会将该任务转到前台来处理新 intent。\n\n无论 Activity 是在新任务中启动的，还是在和启动它的 Activity 相同的任务中启动，用户按返回按钮都会回到上一个 Activity。但是，如果您启动了指定 singleTask 启动模式的 Activity，而后台任务中已存在该 Activity 的实例，则系统会将该后台任务整个转到前台运行。此时，返回堆栈包含了转到前台的任务中的所有 Activity，这些 Activity 都位于堆栈的顶部。图 4 展示了具体的情景。\n\n\n\n图 4. 采用“singleTask”启动模式的 Activity 添加到返回堆栈的过程图示。如果 Activity 已经存在于某个具有自己的返回堆栈的后台任务中，那么整个返回堆栈也会转到前台，覆盖当前任务。\n\n要详细了解如何在清单文件中设置启动模式，请参阅 <activity> 元素的说明文档，里面详细介绍了 launchMode 属性和可接受的值。\n\n注意：您通过 launchMode 属性为 Activity 指定的行为，可被启动 Activity 的 intent 所包含的标记替换。下一节将对此进行介绍。\n\n使用 Intent 标记\n启动 Activity 时，您可以在传送给 startActivity() 的 intent 中添加相应的标记来修改 Activity 与其任务的默认关联。您可以使用以下标记来修改默认行为：\n\nFLAG_ACTIVITY_NEW_TASK\n在新任务中启动 Activity。如果您现在启动的 Activity 已经有任务在运行，则系统会将该任务转到前台并恢复其最后的状态，而 Activity 将在 onNewIntent() 中收到新的 intent。\n这与上一节中介绍的 \"singleTask\" launchMode 值产生的行为相同。\n\nFLAG_ACTIVITY_SINGLE_TOP\n如果要启动的 Activity 是当前 Activity（即位于返回堆栈顶部的 Activity），则现有实例会收到对 onNewIntent() 的调用，而不会创建 Activity 的新实例。\n这与上一节中介绍的 \"singleTop\" launchMode 值产生的行为相同。\n\nFLAG_ACTIVITY_CLEAR_TOP\n如果要启动的 Activity 已经在当前任务中运行，则不会启动该 Activity 的新实例，而是会销毁位于它之上的所有其他 Activity，并通过 onNewIntent() 将此 intent 传送给它的已恢复实例（现在位于堆栈顶部）。\nlaunchMode 属性没有可产生此行为的值。\n\nFLAG_ACTIVITY_CLEAR_TOP 最常与 FLAG_ACTIVITY_NEW_TASK 结合使用。将这两个标记结合使用，可以查找其他任务中的现有 Activity，并将其置于能够响应 intent 的位置。\n\n注意：如果指定 Activity 的启动模式为 \"standard\"，系统也会将其从堆栈中移除，并在它的位置启动一个新实例来处理传入的 intent。这是因为当启动模式为 \"standard\" 时，始终会为新 intent 创建新的实例。\n\n处理亲和性\n“亲和性”表示 Activity 倾向于属于哪个任务。默认情况下，同一应用中的所有 Activity 彼此具有亲和性。因此，在默认情况下，同一应用中的所有 Activity 都倾向于位于同一任务。不过，您可以修改 Activity 的默认亲和性。在不同应用中定义的 Activity 可以具有相同的亲和性，或者在同一应用中定义的 Activity 也可以被指定不同的任务亲和性。\n\n您可以使用 <activity> 元素的 taskAffinity 属性修改任何给定 Activity 的亲和性。\n\ntaskAffinity 属性采用字符串值，该值必须不同于 <manifest> 元素中声明的默认软件包名称，因为系统使用该名称来标识应用的默认任务亲和性。\n\n亲和性可在两种情况下发挥作用：\n\n当启动 Activity 的 intent 包含 FLAG_ACTIVITY_NEW_TASK 标记时。\n默认情况下，新 Activity 会启动到调用 startActivity() 的 Activity 的任务中。它会被推送到调用方 Activity 所在的返回堆栈中。但是，如果传递给 startActivity() 的 intent 包含 FLAG_ACTIVITY_NEW_TASK 标记，则系统会寻找其他任务来容纳新 Activity。通常会是一个新任务，但也可能不是。如果已存在与新 Activity 具有相同亲和性的现有任务，则会将 Activity 启动到该任务中。如果不存在，则会启动一个新任务。\n\n如果此标记导致 Activity 启动一个新任务，而用户按下主屏幕按钮离开该任务，则必须为用户提供某种方式来返回到该任务。有些实体（例如通知管理器）总是在外部任务中启动 Activity，而不在它们自己的任务中启动，因此它们总是将 FLAG_ACTIVITY_NEW_TASK 添加到传递给 startActivity() 的 intent 中。如果您的 Activity 可由外部实体调用，而该实体可能使用此标记，请注意用户可以通过一种独立的方式返回到所启动的任务，例如使用启动器图标（任务的根 Activity 具有一个 CATEGORY_LAUNCHER intent 过滤器；请参阅下面的启动任务部分）。\n\n当 Activity 的 allowTaskReparenting 属性设为 \"true\" 时。\n在这种情况下，一旦和 Activity 有亲和性的任务进入前台运行，Activity 就可从其启动的任务转移到该任务。\n\n举例来说，假设一款旅行应用中定义了一个报告特定城市天气状况的 Activity。该 Activity 与同一应用中的其他 Activity 具有相同的亲和性（默认应用亲和性），并通过此属性支持重新归属。当您的某个 Activity 启动该天气预报 Activity 时，该天气预报 Activity 最初会和您的 Activity 同属于一个任务。不过，当旅行应用的任务进入前台运行时，该天气预报 Activity 就会被重新分配给该任务并显示在其中。\n\n提示：如果一个 APK 文件中包含了就用户角度而言的多个“应用”，您可能需要使用 taskAffinity 属性为每个“应用”所关联的 Activity 指定不同的亲和性。\n\n清除返回堆栈\n如果用户离开任务较长时间，系统会清除任务中除根 Activity 以外的所有 Activity。当用户再次返回到该任务时，只有根 Activity 会恢复。系统之所以采取这种行为方式是因为，经过一段时间后，用户可能已经放弃了之前执行的操作，现在返回任务是为了开始某项新的操作。\n\n您可以使用一些 Activity 属性来修改此行为：\n\nalwaysRetainTaskState\n如果在任务的根 Activity 中将该属性设为 \"true\"，则不会发生上述默认行为。即使经过很长一段时间后，任务仍会在其堆栈中保留所有 Activity。\nclearTaskOnLaunch\n如果在任务的根 Activity 中将该属性设为 \"true\"，那么只要用户离开任务再返回，堆栈就会被清除到只剩根 Activity。也就是说，它与 alwaysRetainTaskState 正好相反。用户始终会返回到任务的初始状态，即便只是短暂离开任务也是如此。\nfinishOnTaskLaunch\n该属性与 clearTaskOnLaunch 类似，但它只会作用于单个 Activity 而非整个任务。它还可导致任何 Activity 消失，包括根 Activity。如果将该属性设为 \"true\"，则 Activity 仅在当前会话中归属于任务。如果用户离开任务再返回，则该任务将不再存在。\n启动任务\n您可以设置一个 Activity 作为任务的入口点，方法是为该 Activity 提供一个 intent 过滤器，并将 \"android.intent.action.MAIN\" 作为指定操作，将 \"android.intent.category.LAUNCHER\" 作为指定类别。例如：\n\n    <activity ... >\n        <intent-filter ... >\n            <action android:name=\"android.intent.action.MAIN\" />\n            <category android:name=\"android.intent.category.LAUNCHER\" />\n        </intent-filter>\n        ...\n    </activity>\n    \n这种 intent 过滤器可在应用启动器中显示 Activity 的图标和标签，让用户可以启动 Activity 并在启动后随时返回到该 Activity 创建的任务。\n\n第二个作用非常重要：用户必须能够离开任务，之后再使用此 Activity 启动器返回到该任务。因此，只有当 Activity 具有 ACTION_MAIN 和 CATEGORY_LAUNCHER 过滤器时，才应使用 \"singleTask\" 和 \"singleInstance\" 这两种启动模式，它们会将 Activity 标记为始终启动任务。比如，可以想象一下，如果缺少该过滤器会发生什么情况：intent 会启动 \"singleTask\" Activity，随之启动新任务，用户花了一些时间在该任务上。然后，用户按主屏幕按钮。此时，该任务会转到后台，不再可见。现在，用户无法返回到该任务，因为它未显示在应用启动器中。\n\n对于那些您不希望用户能够返回到 Activity 的情况，请将 <activity> 元素的 finishOnTaskLaunch 设置为 \"true\"（请参阅清除返回堆栈）。\n\n如需详细了解如何在概览屏幕中显示和管理任务及 Activity，请参阅“最近使用的应用”屏幕。\n\n更多资源\nAndroid 设计：导航\n<activity> 清单元素\n“最近使用的应用”屏幕\nAndroid 中的多任务处理"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243439887},"updatedAt":{"$$date":1597243681240},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TwPGsi80VInGPIrk"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975701402},"updatedAt":{"$$date":1598975701402},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"U0LZp2kT408Ee6f3"}
{"name":"html-HTML <head>","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"HTML <head>\nExamples\n查看在线实例\n<title> - 定义了HTML文档的标题\n使用 <title> 标签定义HTML文档的标题\n\n<base> - 定义了所有链接的URL\n使用 <base> 定义页面中所有链接默认的链接目标地址。\n\n<meta> - 提供了HTML文档的meta标记\n使用 <meta> 元素来描述HTML文档的描述，关键词，作者，字符集等。\n\nHTML <head> 元素\n<head> 元素包含了所有的头部标签元素。在 <head>元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。\n\n可以添加在头部区域的元素标签为: <title>, <style>, <meta>, <link>, <script>, <noscript> 和 <base>。\n\nHTML <title> 元素\n<title> 标签定义了不同文档的标题。\n\n<title> 在 HTML/XHTML 文档中是必须的。\n\n<title> 元素:\n\n定义了浏览器工具栏的标题\n当网页添加到收藏夹时，显示在收藏夹中的标题\n显示在搜索引擎结果页面的标题\n一个简单的 HTML 文档:\n\n实例\n<!DOCTYPE html>\n<html>\n<head> \n<meta charset=\"utf-8\"> \n<title>文档标题</title>\n</head>\n \n<body>\n文档内容......\n</body>\n \n</html>\n\nHTML <base> 元素\n<base> 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接:\n\n<head>\n<base href=\"http://www.runoob.com/images/\" target=\"_blank\">\n</head>\nHTML <link> 元素\n<link> 标签定义了文档与外部资源之间的关系。\n\n<link> 标签通常用于链接到样式表:\n\n<head>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\">\n</head>\nHTML <style> 元素\n<style> 标签定义了HTML文档的样式文件引用地址.\n\n在<style> 元素中你也可以直接添加样式来渲染 HTML 文档:\n\n<head>\n<style type=\"text/css\">\nbody {background-color:yellow}\np {color:blue}\n</style>\n</head>\nHTML <meta> 元素\nmeta标签描述了一些基本的元数据。\n\n<meta> 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。\n\nMETA 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。\n\n元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。\n\n<meta> 一般放置于 <head> 区域\n\n<meta> 标签- 使用实例\n为搜索引擎定义关键词:\n\n<meta name=\"keywords\" content=\"HTML, CSS, XML, XHTML, JavaScript\">\n为网页定义描述内容:\n\n<meta name=\"description\" content=\"免费 Web & 编程 教程\">\n定义网页作者:\n\n<meta name=\"author\" content=\"Runoob\">\n每30秒钟刷新当前页面:\n\n<meta http-equiv=\"refresh\" content=\"30\">\nHTML <script> 元素\n<script>标签用于加载脚本文件，如： JavaScript。\n\n<script> 元素在以后的章节中会详细描述。\n\nHTML head 元素\n标签\t描述\n<head>\t定义了文档的信息\n<title>\t定义了文档的标题\n<base>\t定义了页面链接标签的默认链接地址\n<link>\t定义了一个文档和外部资源之间的关系\n<meta>\t定义了HTML文档中的元数据\n<script>\t定义了客户端的脚本文件\n<style>\t定义了HTML文档的样式文件\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885702216},"updatedAt":{"$$date":1598886219306},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"U4uzXrIg8Xekm9dX"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975859294},"updatedAt":{"$$date":1598975859294},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"U6usUaDpqouV5FG4"}
{"name":"plus","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"dart","value":"fun main() {\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n\n    // plus (+)\n    println(numbersMap + Pair(\"four\", 4)) // {one=1, two=2, three=3, four=4}\n    println(numbersMap + Pair(\"one\", 10)) // {one=10, two=2, three=3}\n    println(numbersMap + Pair(\"five\", 5) + Pair(\"one\", 11)) // {one=11, two=2, three=3, five=5}\n\n    // minus (-)\n    println(numbersMap - \"one\") // {two=2, three=3}\n    println(numbersMap - listOf(\"two\", \"four\")) // {one=1, three=3}\n}\n\n\n\n////\ndata class Salary(var base: Int = 100){\n    override fun toString(): String = base.toString()\n}\n\noperator fun Salary.plus(other: Salary): Salary = Salary(base + other.base)\noperator fun Salary.minus(other: Salary): Salary = Salary(base - other.base)\n\nval s1 = Salary(10)\nval s2 = Salary(20)\nprintln(s1 + s2) // 30\nprintln(s1 - s2) // -10\n\n\n\n"}],"tags":["aZ7LswF9qbcVtQZT"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594728292744},"updatedAt":{"$$date":1594728360331},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"kotlin","_id":"aZ7LswF9qbcVtQZT","text":"kotlin"}],"_id":"UFiWdNvIKOHEvjv9"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973267266},"updatedAt":{"$$date":1594973267266},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Ue9VTEclkV43vaFD"}
{"name":"kotlin-委托属性 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/delegated-properties.html\n委托属性 - Kotlin 语言中文站\n27-33 minutes\n改进翻译\n有一些常见的属性类型，虽然我们可以在每次需要的时候手动实现它们， 但是如果能够为大家把他们只实现一次并放入一个库会更好。例如包括：\n\n延迟属性（lazy properties）: 其值只在首次访问时计算；\n可观察属性（observable properties）: 监听器会收到有关此属性变更的通知；\n把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。\n为了涵盖这些（以及其他）情况，Kotlin 支持 委托属性:\n\nclass Example {\n    var p: String by Delegate()\n}\n语法是： val/var <属性名>: <类型> by <表达式>。在 by 后面的表达式是该 委托， 因为属性对应的 get()（与 set()）会被委托给它的 getValue() 与 setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（与 setValue()——对于 var 属性）。 例如:\n\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, thank you for delegating '${property.name}' to me!\"\n    }\n \n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$value has been assigned to '${property.name}' in $thisRef.\")\n    }\n}\n当我们从委托到一个 Delegate 实例的 p 读取时，将调用 Delegate 中的 getValue() 函数， 所以它第一个参数是读出 p 的对象、第二个参数保存了对 p 自身的描述 （例如你可以取它的名字)。 例如:\n\nval e = Example()\nprintln(e.p)\n输出结果：\n\nExample@33a17727, thank you for delegating ‘p’ to me!\n类似地，当我们给 p 赋值时，将调用 setValue() 函数。前两个参数相同，第三个参数保存将要被赋予的值：\n\n输出结果：\n\nNEW has been assigned to ‘p’ in Example@33a17727.\n委托对象的要求规范可以在下文找到。\n\n请注意，自 Kotlin 1.1 起你可以在函数或代码块中声明一个委托属性，因此它不一定是类的成员。 你可以在下文找到其示例。\n\nKotlin 标准库为几种有用的委托提供了工厂方法。\n\nlazy() 是接受一个 lambda 并返回一个 Lazy <T> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。\n\nval lazyValue: String by lazy {\n    println(\"computed!\")\n    \"Hello\"\n}\n\nfun main() {\n    println(lazyValue)\n    println(lazyValue)\n}\n默认情况下，对于 lazy 属性的求值是同步锁的（synchronized）：该值只在一个线程中计算，并且所有线程会看到相同的值。如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给 lazy() 函数。 而如果你确定初始化将总是发生在与属性使用位于相同的线程， 那么可以使用 LazyThreadSafetyMode.NONE 模式：它不会有任何线程安全的保证以及相关的开销。\n\nDelegates.observable() 接受两个参数：初始值与修改时处理程序（handler）。 每当我们给属性赋值时会调用该处理程序（在赋值后执行）。它有三个参数：被赋值的属性、旧值与新值：\n\nimport kotlin.properties.Delegates\n\nclass User {\n    var name: String by Delegates.observable(\"<no name>\") {\n        prop, old, new ->\n        println(\"$old -> $new\")\n    }\n}\n\nfun main() {\n    val user = User()\n    user.name = \"first\"\n    user.name = \"second\"\n}\n如果你想截获赋值并“否决”它们，那么使用 vetoable() 取代 observable()。 在属性被赋新值生效之前会调用传递给 vetoable 的处理程序。\n\n一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他“动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。\n\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n在这个例子中，构造函数接受一个映射参数：\n\nval user = User(mapOf(\n    \"name\" to \"John Doe\",\n    \"age\"  to 25\n))\n委托属性会从这个映射中取值（通过字符串键——属性的名称）：\n\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n\nfun main() {\n    val user = User(mapOf(\n        \"name\" to \"John Doe\",\n        \"age\"  to 25\n    ))\n//sampleStart\n    println(user.name) // Prints \"John Doe\"\n    println(user.age)  // Prints 25\n//sampleEnd\n}\n这也适用于 var 属性，如果把只读的 Map 换成 MutableMap 的话：\n\nclass MutableUser(val map: MutableMap<String, Any?>) {\n    var name: String by map\n    var age: Int     by map\n}\n你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：\n\nfun example(computeFoo: () -> Foo) {\n    val memoizedFoo by lazy(computeFoo)\n\n    if (someCondition && memoizedFoo.isValid()) {\n        memoizedFoo.doSomething()\n    }\n}\nmemoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。\n\n这里我们总结了委托对象的要求。\n\n对于一个只读属性（即 val 声明的），委托必须提供一个操作符函数 getValue()，该函数具有以下参数：\n\nthisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是其超类型。\nproperty —— 必须是类型 KProperty<*> 或其超类型。\ngetValue() 必须返回与属性相同的类型（或其子类型）。\n\nclass Resource\n\nclass Owner {\n    val valResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return Resource()\n    }\n}\n对于一个可变属性（即 var 声明的），委托必须额外提供一个操作符函数 setValue()， 该函数具有以下参数：\n\nthisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是其超类型。\nproperty —— 必须是类型 KProperty<*> 或其超类型。\nvalue — 必须与属性类型相同（或者是其超类型）。\nclass Resource\n\nclass Owner {\n    var varResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate(private var resource: Resource = Resource()) {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return resource\n    }\n    operator fun setValue(thisRef: Owner, property: KProperty<*>, value: Any?) {\n        if (value is Resource) {\n            resource = value\n        }\n    }\n}\ngetValue() 或/与 setValue() 函数可以通过委托类的成员函数提供或者由扩展函数提供。 当你需要委托属性到原本未提供的这些函数的对象时后者会更便利。 两函数都需要用 operator 关键字来进行标记。\n\n委托类可以实现包含所需 operator 方法的 ReadOnlyProperty 或 ReadWriteProperty 接口之一。 这俩接口是在 Kotlin 标准库中声明的：\n\ninterface ReadOnlyProperty<in R, out T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n}\n\ninterface ReadWriteProperty<in R, T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n    operator fun setValue(thisRef: R, property: KProperty<*>, value: T)\n}\n在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性：\n\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// 这段是由编译器生成的相应代码：\nclass C {\n    private val prop$delegate = MyDelegate()\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\nKotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。\n\n请注意，直接在代码中引用绑定的可调用引用的语法 this::prop 自 Kotlin 1.1 起才可用。\n\n通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来创建属性委托实例。\n\nprovideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检测属性一致性。\n\n例如，如果要在绑定之前检测属性名称，可以这样写：\n\nclass ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {\n    override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... }\n}\n    \nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(\n            thisRef: MyUI,\n            prop: KProperty<*>\n    ): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        // 创建委托\n        return ResourceDelegate()\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { …… }\n}\n\nclass MyUI {\n    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { …… }\n\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\nprovideDelegate 的参数与 getValue 相同：\n\nthisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型；\nproperty —— 必须是类型 KProperty<*> 或其超类型。\n在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。\n\n如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：\n\n// 检测属性名称而不使用“provideDelegate”功能\nclass MyUI {\n    val image by bindResource(ResourceID.image_id, \"image\")\n    val text by bindResource(ResourceID.text_id, \"text\")\n}\n\nfun <T> MyUI.bindResource(\n        id: ResourceID<T>,\n        propertyName: String\n): ReadOnlyProperty<MyUI, T> {\n   checkProperty(this, propertyName)\n   // 创建委托\n}\n在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与上面（当 provideDelegate 方法不存在时）生成的代码：\n\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// 这段代码是当“provideDelegate”功能可用时\n// 由编译器生成的代码：\nclass C {\n    // 调用“provideDelegate”来创建额外的“delegate”属性\n    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\n请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307932174},"updatedAt":{"$$date":1597308442533},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Uo27JveR0ktDbb6A"}
{"name":"ad-","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539557233},"updatedAt":{"$$date":1598539557233},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"UxREXsqrlYSYsp1u"}
{"name":"kotlin-kotlin入门中文教程（2）","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\njuejin.im /post/6844904017487888392\nkotlin入门中文教程（2） - 掘金\n叶志陈 2019年12月10日 阅读 1547 已关注\n32-40 minutes\n本文已收录至学习笔记大全：JavaKotlinAndroidGuide\n\n作者：leavesC\n\n[TOC]\n\n十五、扩展函数和扩展属性\n15.1、扩展函数\n扩展函数用于为一个类增加一种新的行为，这是为缺少有用函数的类进行扩展的途径。扩展函数的用途就类似于在 Java 中实现的静态工具方法。而在 kotlin 中使用扩展函数的一个优势就是我们不需要在调用方法的时候把整个对象当作参数传入，扩展函数表现得就像是属于这个类本身的一样，可以使用 this 关键字并直接调用其所有 public 方法\n\n扩展函数并不允许你打破它的封装性，和在类内部定义的方法不同的是，扩展函数不能访问私有的或是受保护的成员\n\n\n\nfun String.lastChar() = get(length - 1)\n\n\n\nfun Int.doubleValue() = this * 2\n复制代码\n之后，我们就可以像调用类本身内部声明的方法一样，直接调用扩展函数\n\nfun main() {\n    val name = \"leavesC\"\n    println(\"$name lastChar is: \" + name.lastChar())\n\n    val age = 24\n    println(\"$age doubleValue is: \" + age.doubleValue())\n}\n复制代码\n如果需要声明一个静态的扩展函数，则必须将其定义在伴生对象上，这样就可以在没有 Namer 实例的情况下调用其扩展函数，就如同在调用 Java 的静态函数一样\n\nclass Namer {\n\n    companion object {\n\n        val defaultName = \"mike\"\n\n    }\n\n}\n\nfun Namer.Companion.getName(): String {\n    return defaultName\n}\n\nfun main() {\n    Namer.getName()\n}\n复制代码\n需要注意的是，如果扩展函数声明于 class 内部，则该扩展函数只能该类和其子类内部调用，因为此时相当于声明了一个非静态函数，外部无法引用到。所以一般都是将扩展函数声明为全局函数\n\n15.2、扩展属性\n扩展函数也可以用于属性\n\n\n\nvar String.customLen: Int\n    get() = length\n    set(value) {\n        println(\"set\")\n    }\n\nfun main() {\n    val name = \"leavesC\"\n    println(name.customLen)\n    name.customLen = 10\n    println(name.customLen)\n    \n    \n    \n}\n复制代码\n15.3、不可重写的扩展函数\n看以下例子，子类 Button 重写了父类 View 的 click() 函数，此时如果声明一个 View 变量，并赋值为 Button 类型的对象，调用的 click() 函数将是 Button 类重写的方法\n\nfun main() {\n    val view: View = Button()\n    view.click() \n}\n\nopen class View {\n    open fun click() = println(\"View clicked\")\n}\n\nclass Button : View() {\n    override fun click() = println(\"Button clicked\")\n}\n复制代码\n对于扩展函数来说，与以上的例子却不一样。如果基类和子类都分别定义了一个同名的扩展函数，此时要调用哪个扩展函数是由变量的静态类型来决定的，而非这个变量的运行时类型\n\nfun main() {\n    val view: View = Button()\n    view.longClick() \n}\n\nopen class View {\n    open fun click() = println(\"View clicked\")\n}\n\nclass Button : View() {\n    override fun click() = println(\"Button clicked\")\n}\n\nfun View.longClick() = println(\"View longClicked\")\n\nfun Button.longClick() = println(\"Button longClicked\")\n复制代码\n此外，如果一个类的成员函数和扩展函数有相同的签名，成员函数会被优先使用\n\n扩展函数并不是真正地修改了原来的类，其底层其实是以静态导入的方式来实现的。扩展函数可以被声明在任何一个文件中，因此有个通用的实践是把一系列有关的函数放在一个新建的文件里\n\n需要注意的是，扩展函数不会自动地在整个项目范围内生效，如果需要使用到扩展函数，需要进行导入\n\n15.4、可空接收者\n可以为可空的接收者类型定义扩展，即使接受者为 null，使得开发者在调用扩展函数前不必进行判空操作，且可以通过 this == null 来检查接收者是否为空\n\nfun main() {\n    var name: String? = null\n    name.check() \n    name = \"leavesC\"\n    name.check() \n}\n\nfun String?.check() {\n    if (this == null) {\n        println(\"this == null\")\n        return\n    }\n    println(\"this != null\")\n}\n复制代码\n十六、Lambda 表达式\nLambda 表达式本质上就是可以传递给其它函数的一小段代码，通过 Lambda 表达式可以把通用的代码结构抽取成库函数，也可以把 Lambda 表达式存储在一个变量中，把这个变量当做普通函数对待\n\n    \n    val plus1: (Int, Int) -> Int = { x: Int, y: Int -> x + y }\n    val plus2: (Int, Int) -> Int = { x, y -> x + y }\n    val plus3 = { x: Int, y: Int -> x + y }\n    println(plus3(1, 2))\n复制代码\n一个 Lambda 表达式始终用花括号包围，通过箭头把实参列表和函数体分开\n如果 Lambda 声明了函数类型，那么就可以省略函数体的类型声明\n如果 Lambda 声明了参数类型，且返回值支持类型推导，那么就可以省略函数类型声明\n虽然说倾向于尽量避免让 Lambda 表达式引用外部变量以避免副作用，但有些情况下让 Lambda 引用外部变量也可以简化计算结构。访问了外部环境变量的 Lambda 表达式称之为闭包，闭包可以被当做参数传递或者直接使用。与 Java 不同，kotlin 中的闭包不仅可以访问外部变量也可以对其进行修改\n\n例如，假设我们需要一个计算总和的方法，每次调用函数时都返回当前的总和大小。方法外部不提供保存当前总和的变量，由 Lambda 表达式内部进行存储\n\nfun main() {\n    val sum = sumFunc()\n    println(sum(10)) \n    println(sum(20)) \n    println(sum(30)) \n}\n\nfun sumFunc(): (Int) -> Int {\n    var base = 0\n    return fun(va: Int): Int {\n        base += va\n        return base\n    }\n}\n复制代码\n此外，kotlin 也支持一种自动运行的语法\n\n{ va1: Int, va2: Int -> println(va1 + va2) }(10, 20)\n复制代码\nLambda 表达式最常见的用途就是和集合一起工作，看以下例子\n\n要从一个人员列表中取出年龄最大的一位\n\ndata class Person(val name: String, val age: Int)\n\nfun main() {\n    val people = listOf(Person(\"leavesC\", 24), Person(\"Ye\", 22))\n    println(people.maxBy { it.age }) \n}\n复制代码\n当中，库函数 maxBy 可以在任何集合上调用，其需要一个实参：一个函数，用于指定要用来进行比较的函数。花括号中的代码 { it.age } 就是实现了这个逻辑的 Lambda 表达式\n\n上述 maxBy 函数的实参是简化后的写法，这里来看下 maxBy 函数的简化过程\n\n最原始的语法声明应该是这样的，用括号包裹着 Lambda 表达式\n\nprintln(people.maxBy({ p: Person -> p.age }))\n复制代码\nkotlin 有一种语法约定，如果 Lambda 表达式是函数调用的最后一个实参，可以将之放到括号的外边\n\n println(people.maxBy() { p: Person -> p.age })\n复制代码\n当 Lamdba 表达式是函数唯一的实参时，可以去掉调用代码中的空括号对\n\n println(people.maxBy { p: Person -> p.age })\n复制代码\n当 Lambda 表达式的参数类型是可以被推导出来时就可以省略声明参数类型\n\nprintln(people.maxBy { p -> p.age })\n复制代码\n如果当前上下文期待的是只有一个参数的 Lambda 表达式且参数类型可以被推断出来，就会为该参数生成一个默认名称：it\n\n println(people.maxBy { it.age })\n复制代码\nkotlin 和 Java 的一个显著区别就是，在 kotlin 中函数内部的 Lambda 表达式不会仅限于访问函数的参数以及 final 变量，在 Lambda 内部也可以访问并修改非 final 变量\n\n从 Lambda 内部访问外部变量，我们称这些变量被 Lambda 捕捉。当捕捉 final 变量时，变量值和使用这个值的 Lambda 代码一起存储，对非 final 变量来说，其值被封装在一个特殊的包装器中，对这个包装器的引用会和 Lambda 代码一起存储\n\n    var number = 0\n    val list = listOf(10, 20, 30, 40)\n    list.forEach {\n        if (it > 20) {\n            number++\n        }\n    }\n    println(number) \n复制代码\n成员引用用于创建一个调用单个方法或者访问单个属性的函数值，通过双冒号把类名称和要引用的成员（一个方法或者一个属性）名称分隔开\n\n成员引用的一个用途就是：如果要当做参数传递的代码块已经被定义成了函数，此时不必专门创建一个调用该函数的 Lambda 表达式，可以直接通过成员引用的方式来传递该函数（也可以传递属性）。此外，成员引用对扩展函数一样适用\n\ndata class Person(val name: String, val age: Int) {\n\n    val myAge = age\n\n    fun getPersonAge() = age\n}\n\nfun Person.filterAge() = age\n\nfun main() {\n    val people = listOf(Person(\"leavesC\", 24), Person(\"Ye\", 22))\n    println(people.maxBy { it.age })    \n    println(people.maxBy(Person::age))  \n    println(people.maxBy(Person::myAge))  \n    println(people.maxBy(Person::getPersonAge))  \n    println(people.maxBy(Person::filterAge))  \n}\n复制代码\n不管引用的是函数还是属性，都不要在成员引用的名称后面加括号\n\n此外，还可以引用顶层函数\n\nfun test() {\n    println(\"test\")\n}\n\nfun main() {\n    val t = ::test\n}\n复制代码\n也可以用构造方法引用存储或者延期执行创建类实例的动作\n\ndata class Person(val name: String, val age: Int)\n\nfun main() {\n    val createPerson = ::Person\n    val person = createPerson(\"leavesC\", 24)\n    println(person)\n}\n复制代码\n十七、标准库中的扩展函数\nkotlin 标准库中提供了几个比较实用的扩展函数，定义在 Standard 文件下\n\n17.1、run\nrun 函数接收一个函数参数并以该函数的返回值作为 run 函数的返回值\n\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n复制代码\n用例\n\nfun main() {\n    var nickName = \"leavesC\"\n    nickName = nickName.run {\n        if (isNotEmpty()) {\n            this\n        } else {\n            \"\"\n        }\n    }\n    println(nickName)\n}\n复制代码\n17.2、with\nwith 函数并不是扩展函数，不过由于作用相近，此处就一起介绍了。with 函数的第一个参数是接受者对象 receiver，第二个参数是在 receiver 对象类型上定义的扩展函数，所以可以在函数内部直接调用 receiver 其公开的方法和属性\n\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n复制代码\nwith 函数用于对同一个对象执行多次操作而不需要反复把对象的名称写出来\n\n例如，为了构建一个包含指定内容的字符串，需要先后如下调用\n\nfun main() {\n    val result = StringBuilder()\n    result.append(\"leavesC\")\n    result.append(\"\\n\")\n    for (letter in 'A'..'Z') {\n        result.append(letter)\n    }\n    println(result.toString())\n }\n复制代码\n改为通过 with 函数来构建的话会代码会简洁许多\n\n    val result = with(StringBuilder()) {\n        append(\"leavesC\")\n        append(\"\\n\")\n        for (letter in 'A'..'Z') {\n            append(letter)\n        }\n        toString()\n    }\n    println(result)\n复制代码\nwith 函数是一个接受两个参数的函数，在这个例子中就是一个 StringBuilder 和一个 Lambda 表达式，这里利用了把 Lambda 表达式放在括号外的约定\n\nwith 函数的返回值是执行 Lambda 表达式的结果，该结果就是 Lambda 中的最后一个表达式的返回值，因此如果将代码修改为如下所示的话，因为 println() 方法无返回值，所以打印出来的内容将是 kotlin.Unit\n\n    val result = with(StringBuilder()) {\n        append(\"leavesC\")\n        append(\"\\n\")\n        for (letter in 'A'..'Z') {\n            append(letter)\n        }\n        println(\"Hello\")\n    }\n    println(result)  \n复制代码\n17.3、apply\napply 函数被声明为类型 T 的扩展函数，它的接收者是作为实参的 Lambda 的接受者，最终函数返回 this 即对象本身\n\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n复制代码\n所以apply 函数和 with 函数的唯一区别在于：apply 函数始终会返回作为实参传递给它的对象\n\n val result = StringBuilder().apply {\n        append(\"leavesC\")\n        append(\"\\n\")\n        for (letter in 'A'..'Z') {\n            append(letter)\n        }\n        toString()\n    }\n    println(result)\n    println(result.javaClass) \n复制代码\n17.4、also\nalso 函数接收一个函数类型的参数，该参数又以接收者本身作为参数，最终返回接收者对象本身\n\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n复制代码\n用例\n\nfun main() {\n    val nickName = \"leavesC\"\n    val also = nickName.also {\n        it.length\n    }\n    println(also) \n}\n复制代码\n17.5、let\nalso 函数接收一个函数类型的参数，该参数又以接收者本身作为参数，最终返回函数的求值结果\n\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n复制代码\n用例\n\nfun main() {\n    val nickName = \"leavesC\"\n    val also = nickName.let {\n        it.length\n    }\n    println(also) \n}\n复制代码\n17.6、takeIf\ntakeIf 接收一个返回值类型为 bool 的函数，当该参数返回值为 true 时返回接受者对象本身，否则返回 null\n\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n复制代码\n用例\n\nfun main() {\n    println(check(\"leavesC\")) \n    println(check(null)) \n}\n\nfun check(name: String?): Int {\n    return name.takeIf { !it.isNullOrBlank() }?.length ?: 0\n}\n复制代码\n17.7、takeUnless\ntakeUnless 的判断条件与 takeIf 相反，这里不再赘述\n\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n复制代码\n十八、函数操作符\n18.1、总数操作符\n18.1.1、any\n如果至少有一个元素符合给出的判断条件，则返回 true\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.any { it > 13 })  \n    println(list.any { it > 7 })   \n复制代码\n18.1.2、all\n如果全部的元素符合给出的判断条件，则返回 true\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.all { it > 13 })  \n    println(list.all { it > 0 })   \n复制代码\n18.1.3、count\n返回符合给出判断条件的元素总数\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.count { it > 7 })  \n    println(list.count { it > 2 })  \n复制代码\n18.1.4、fold\n在一个初始值的基础上从第一项到最后一项通过一个函数累计所有的元素\n\nfun main() {\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.fold(2) { total, next->\n        println(\"$next , $total\")\n        next + total\n    })\n}\n复制代码\n1 , 2\n3 , 3\n5 , 6\n7 , 11\n9 , 18\n27\n复制代码\n18.1.5、foldRight\n与 fold 一样，但顺序是从最后一项到第一项\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.foldRight(2) { next, total->\n        println(\"$next , $total\")\n        next + total\n    })\n复制代码\n9 , 2\n7 , 11\n5 , 18\n3 , 23\n1 , 26\n27\n复制代码\n18.1.6、forEach\n    val list = listOf(1, 3, 5, 7, 9)\n    list.forEach { print(it + 1) } \n复制代码\n18.1.7、forEachIndexed\n类似于 forEach ，同时可以得到元素的索引\n\n    val list = listOf(1, 3, 5, 7, 9)\n    list.forEachIndexed { index, value -> println(\"$index value is $value\") }\n\n    0 value is 1\n\t1 value is 3\n\t2 value is 5\n    3 value is 7\n\t4 value is 9\n复制代码\n18.1.8、max\n返回最大的一项，如果没有则返回null\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.max()) \n复制代码\n18.1.9、maxBy\n根据给定的函数返回最大的一项，如果没有则返回 null\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.maxBy { -it }) \n复制代码\n18.1.10、min\n返回最小的一项，如果没有则返回null\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.min()) \n复制代码\n18.1.11、minBy\n根据给定的函数返回最小的一项，如果没有则返回null\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.minBy { -it }) \n复制代码\n18.1.12、none\n如果没有任何元素与给定的函数匹配，则返回true\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.none { it > 10 }) \n复制代码\n18.1.13、reduce\n与 fold 一样，但是没有一个初始值。通过一个函数从第一项到最后一项进行累计\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.reduce { total, next ->\n        println(\"$next , $total\")\n        total + next\n    })\n\t3 , 1\n\t5 , 4\n\t7 , 9\n\t9 , 16\n\t25\n复制代码\n18.1.14、reduceRight\n与 reduce 一样，但是顺序是从最后一项到第一项\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.reduceRight { next, total ->\n        println(\"$next , $total\")\n        total + next\n    })\n\n\t7 , 9\n\t5 , 16\n\t3 , 21\n\t1 , 24\n\t25\n复制代码\n18.1.15、sumBy\n返回所有每一项通过函数转换之后的数据的总和\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.sumBy { it + 1 }) \n复制代码\n18.2、过滤操作符\n18.2.1、drop\n返回包含去掉前n个元素的所有元素的列表\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.drop(2)) \n复制代码\n18.2.2、dropWhile\n返回从第一个开始不符合给定函数的元素起之后的列表\n\n    val list = listOf(1, 3, 5, 7, 9, 2)\n    println(list.dropWhile { it < 4 }) \n复制代码\n18.2.3、dropLastWhile\n从最后一项开始，返回从开始不符合给定函数的元素起之后的列表\n\n    val list = listOf(10, 1, 3, 5, 7, 9)\n    println(list.dropLastWhile { it > 4 }) \n复制代码\n18.2.4、filter\n过滤所有符合给定函数条件的元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2)\n    println(list.filter { it < 4 }) \n复制代码\n18.2.5、filterNot\n过滤所有不符合给定函数条件的元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2)\n    println(list.filterNot { it < 4 }) \n复制代码\n18.2.6、filterNotNull\n过滤所有元素中不是null的元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2, null)\n    println(list.filterNotNull()) \n复制代码\n18.2.7、slice\n过滤一个list中指定index的元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2, null)\n    println(list.slice(listOf(0, 3))) \n复制代码\n18.2.8、take\n返回从第一个开始的n个元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2, null)\n    println(list.take(2)) \n复制代码\n18.2.9、takeLast\n返回从最后一个开始的n个元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2, null)\n    println(list.takeLast(2)) \n复制代码\n18.2.10、takeWhile\n返回从第一个开始符合给定函数条件的元素。\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.takeWhile { it > 2 }) \n    println(list.takeWhile { it > 0 }) \n复制代码\n18.3、映射操作符\n18.3.1、flatMap\n遍历所有的元素，为每一个创建一个集合，最后把所有的集合放在一个集合中\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.flatMap { listOf(it, it + 1) }) \n复制代码\n18.3.2、groupBy\n返回一个根据给定函数分组后的map\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.groupBy { listOf(it) }) \n    println(list.groupBy { listOf(it, it + 1) }) \n复制代码\n18.3.3、map\n返回一个每一个元素根据给定的函数转换所组成的List。\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.map { listOf(it) }) \n    println(list.map { listOf(it, it + 1) }) \n复制代码\n18.3.4、mapIndexed\n返回一个每一个元素根据给定的包含元素index的函数转换所组成的List\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.mapIndexed { index, value -> index }) \n    println(list.mapIndexed { index, value -> index * value }) \n复制代码\n18.3.5、mapNotNull\n返回一个每一个非null元素根据给定的函数转换所组成的List\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.mapNotNull { it }) \n复制代码\n18.4、元素操作符\n18.4.1、contains\n如果指定元素可以在集合中找到，则返回true\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.contains(3)) \n    println(list.contains(13)) \n复制代码\n18.4.2、elementAt\n返回给定index对应的元素，如果index数组越界则会抛出 IndexOutOfBoundsException\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.elementAt(3)) \n    println(list.elementAt(6)) \n复制代码\n11.4.3、elementAtOrElse\n返回给定index对应的元素，如果index数组越界则会根据给定函数返回默认值\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.elementAtOrElse(3, { it * 2 }))  \n    println(list.elementAtOrElse(16, { it * 2 })) \n\n复制代码\n18.4.4、elementAtOrNull\n返回给定index对应的元素，如果index数组越界则会返回null\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.elementAtOrNull(3))  \n    println(list.elementAtOrNull(16)) \n复制代码\n18.4.5、first\n返回符合给定函数条件的第一个元素\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.first { it % 3 == 0 })  \n复制代码\n18.4.6、firstOrNull\n返回符合给定函数条件的第一个元素，如果没有符合则返回null\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.firstOrNull { it % 3 == 0 })  \n    println(list.firstOrNull { it % 8 == 0 })  \n复制代码\n18.4.7、indexOf\n返回指定元素的第一个index，如果不存在，则返回 -1\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.indexOf(5))  \n    println(list.indexOf(12)) \n复制代码\n18.4.8、indexOfFirst\n返回第一个符合给定函数条件的元素的index，如果没有符合则返回 -1\n\n    val list = listOf(1, 3, 5, 1, 7, 9, 2)\n    println(list.indexOfFirst { it % 2 == 0 })   \n    println(list.indexOfFirst { it % 12 == 0 })  \n复制代码\n18.4.9、indexOfLast\n返回最后一个符合给定函数条件的元素的index，如果没有符合则返回 -1\n\n    val list = listOf(1, 3, 5, 6, 7, 9, 2)\n    println(list.indexOfLast { it % 2 == 0 })   \n    println(list.indexOfLast { it % 12 == 0 })  \n复制代码\n18.4.10、last\n返回符合给定函数条件的最后一个元素\n\n    val list = listOf(1, 3, 5, 6, 7, 9, 2)\n    println(list.last { it % 2 == 0 })   \n    println(list.last { it % 3 == 0 })   \n复制代码\n18.4.10、lastIndexOf\n返回指定元素的最后一个index，如果不存在，则返回 -1\n\n    val list = listOf(1, 3, 2, 6, 7, 9, 2)\n    println(list.lastIndexOf(2))    \n    println(list.lastIndexOf(12))   \n复制代码\n18.4.11、lastOrNull\n返回符合给定函数条件的最后一个元素，如果没有符合则返回null\n\n    val list = listOf(1, 3, 2, 6, 7, 9, 2)\n    println(list.lastOrNull { it / 3 == 3 })    \n    println(list.lastOrNull { it == 10 })       \n复制代码\n18.4.12、single\n返回符合给定函数的单个元素，如果没有符合或者超过一个，则抛出异常\n\n    val list = listOf(1, 9, 2, 6, 7, 9, 2)\n    println(list.single { it % 7 == 0 })  \n    println(list.single { it == 2 })      \n复制代码\n18.4.13、singleOrNull\n返回符合给定函数的单个元素，如果没有符合或者超过一个，则返回null\n\n    val list = listOf(1, 9, 2, 6, 7, 9, 2)\n    println(list.singleOrNull { it % 7 == 0 })  \n    println(list.singleOrNull { it == 2 })      \n复制代码\n18.5、生产操作符\n18.5.1、partition\n把一个给定的集合分割成两个，第一个集合是由原集合每一项元素匹配给定函数条 件返回 true 的元素组成，第二个集合是由原集合每一项元素匹配给定函数条件返回 false 的元素组成\n\n    val list = listOf(1, 9, 2, 6, 7, 9, 2)\n    val (list1, list2) = list.partition { it % 2 == 0 }\n    println(list1)  \n    println(list2)  \n复制代码\n18.5.2、plus\n返回一个包含原集合和给定集合中所有元素的集合，因为函数的名字原因，我们可以使用 + 操作符\n\n    val list1 = listOf(1, 9, 2, 6, 7, 9, 2)\n    val list2 = listOf(1, 2, 4, 6, 8, 10)\n    println(list1.plus(list2)) \n    println(list1 + list2)  \n复制代码\n18.5.3、zip\n返回由 pair 组成的List，每个 pair 由两个集合中相同index的元素组成。这个返回的List的大小由最小的那个集合决定\n\n    val list1 = listOf(1, 9, 2, 6, 7, 9, 2)\n    val list2 = listOf(1, 2, 4, 6, 8, 10)\n    val list3 = list1.zip(list2)\n    println(list3.javaClass)\n    println(list3.get(0).javaClass)\n    println(\"${list3.get(0).first} , ${list3.get(0).second}\")\n    list3.forEach { println(it) }\n复制代码\n    class java.util.ArrayList\n    class kotlin.Pair\n    1 , 1\n    (1, 1)\n    (9, 2)\n    (2, 4)\n    (6, 6)\n    (7, 8)\n    (9, 10)\n复制代码\n18.5.4、unzip\n从包含pair的List中生成包含List的Pair\n\n    val list1 = listOf(Pair(\"leavesC\", 1), Pair(\"leavesC_2\", 2), Pair(\"leavesC_3\", 3))\n    val list2 = list1.unzip()\n    println(list2.javaClass)\n    println(list2.first)\n    println(list2.second)\n复制代码\n    class kotlin.Pair\n    [leavesC, leavesC_2, leavesC_3]\n    [1, 2, 3]\n复制代码\n18.6、顺序操作符\n18.6.1、reverse\n返回一个与指定list相反顺序的list\n\n    val list1 = listOf(Pair(\"leavesC\", 1), Pair(\"leavesC_2\", 2), Pair(\"leavesC_3\", 3))\n    val list2 = list1.reversed()\n    println(list2)      \n复制代码\n18.6.2、sort\n返回一个自然排序后的list\n\n    val list1 = listOf(2, 4, 1, 9, 5, 10)\n    val list2 = list1.sorted()\n    println(list2) \n\n    val list3 = listOf(\"a\", \"c\", \"ab\", \"b\", \"cdd\", \"cda\")\n    val list4 = list3.sorted()\n    println(list4) \n复制代码\n18.6.3、sortBy\n返回一个根据指定函数排序后的list\n\n    val list1 = listOf(2, 4, 1, 9, 5, 10)\n    val list2 = list1.sortedBy { it - 3 }\n    println(list2) \n复制代码\n18.6.4、sortDescending\n返回一个降序排序后的List\n\n    val list1 = listOf(2, 4, 1, 9, 5, 10)\n    val list2 = list1.sortedDescending()\n    println(list2) \n复制代码\n18.6.5、sortDescendingBy\n返回一个根据指定函数降序排序后的list\n\n    val list1 = listOf(2, 4, 1, 9, 5, 10)\n    val list2 = list1.sortedByDescending { it % 2 }\n    println(list2) \n复制代码\n十九、异常\nkotlin 中异常处理的基本形式和 Java 类似\n\nfun compute(index: Int): Boolean {\n    if (index !in 0..10) {\n        throw IllegalArgumentException(\"参数错误\")\n    }\n    return true\n}\n复制代码\n和 Java 不同的是，kotlin 中 throw 结构是一个表达式，可以作为另一个表达式的一部分来使用\n\n例如下面这个例子，如果条件不满足，则将抛出异常，从而导致 status 变量也不会初始化\n\nval status = if (index in 0..10) index else throw IllegalArgumentException(\"参数错误\")\n复制代码\n此外，在 Java 中对于受检异常必须显式地处理，通过 try/catch 语句捕获异常或者是抛给其调用者来处理。而 kotlin 不区分受检异常和未受检异常，不用指定函数抛出的异常，可以处理也可以不处理异常\n\n在 kotlin 中 ，try 关键字引入了一个表达式，从而可以把表达式的值赋给一个变量。如果一个 try 代码块执行正常，代码块中最后一个表达式就是结果，如果捕获到了一个异常，则相应 catch 代码块中最后一个表达式就是结果\n\n看以下例子，如果 try 表达式包裹的表达式会抛出异常，则返回值为 null ，否则为 true\n\nfun main() {\n    compute(5)   \n    compute(100) \n}\n\nfun compute(index: Int) {\n    val status = try {\n        if (index in 0..10) true else throw IllegalArgumentException(\"参数错误\")\n    } catch (e: Exception) {\n        null\n    }\n    println(\"fun end : \" + status)\n}\n复制代码\n但是，如果在 catch 语句中使用 return 结束了 compute 函数，则没有任何输出\n\nfun main() {\n    compute(5)   \n    compute(100) \n}\n\nfun compute(index: Int) {\n    val status = try {\n        if (index in 0..10) true else throw IllegalArgumentException(\"参数错误\")\n    } catch (e: Exception) {\n        return\n    }\n    println(\"fun end : \" + status)\n}\n复制代码\n二十、运算符重载\nkotlin 允许为类型提供预定义的操作符实现，这些操作符具有固定的符号表示（例如 + 和 * ）和固定的优先级，通过操作符重载可以将操作符的行为映射到指定的方法。为实现这样的操作符，需要为类提供一个固定名字的成员函数或扩展函数，相应的重载操作符的函数需要用 operator 修饰符标记\n\n20.1、一元操作符\n操作符\t函数\n+a\ta.unaryPlus()\n-a\ta.unaryMinus()\n!a\ta.not()\na++\ta.inc()\na--\ta.dec()\n20.2、二元操作符\n操作符\t函数\na + b\ta.plus(b)\na - b\ta.minus(b)\na * b\ta.times(b)\na / b\ta.div(b)\na % b\ta.rem(b)\na..b\ta.rangeTo(b)\na in b\tb.contains(a)\na !in b\t!b.contains(a)\na += b\ta.plusAssign(b)\na -= b\ta.minusAssign(b)\na *= b\ta.timesAssign(b)\na /= b\ta.divAssign(b)\na %= b\ta.remAssign(b)\n20.3、数组操作符\n操作符\t函数\na[i]\ta.get(i)\na[i, j]\ta.get(i, j)\na[i_1, ..., i_n]\ta.get(i_1, ..., i_n)\na[i] = b\ta.set(i, b)\na[i, j] = b\ta.set(i, j, b)\na[i_1, ..., i_n] = b\ta.set(i_1, ..., i_n, b)\n20.4、等于操作符\n操作符\t函数\na == b\ta?.equals(b) ?: b === null\na != b\t!(a?.equals(b) ?: b === null)\n相等操作符有一点不同，为了达到正确合适的相等检查做了更复杂的转换，因为要得到一个确切的函数结构比较，不仅仅是指定的名称\n\n方法必须要如下准确地被实现：\n\noperator fun equals(other: Any?): Boolean\n复制代码\n操作符 === 和 !== 用来做身份检查（它们分别是 Java 中的 == 和 != ），并且它们不能被重载\n\n20.5、比较操作符\n操作符\t函数\na > b\ta.compareTo(b) > 0\na < b\ta.compareTo(b) < 0\na >= b\ta.compareTo(b) >= 0\na <= b\ta.compareTo(b) <= 0\n所有的比较都转换为对 compareTo 的调用，这个函数需要返回 Int 值\n\n20.6、函数调用\n方法\t调用\na()\ta.invoke()\na(i)\ta.invoke(i)\na(i, j)\ta.invoke(i, j)\na(i_1, ..., i_n)\ta.invoke(i_1, ..., i_n)\n20.7、例子\n看几个例子\n\ndata class Point(val x: Int, val y: Int) {\n\n    \n    operator fun unaryPlus() = Point(+x, +y)\n\n    \n    operator fun inc() = Point(x + 1, y + 1)\n\n    \n    operator fun plus(point: Point) = Point(x + point.x, y + point.y)\n\n    \n    operator fun plus(value: Int) = Point(x + value, y + value)\n\n    \n    operator fun get(index: Int): Int {\n        return when (index) {\n            0 -> x\n            1 -> y\n            else -> throw IndexOutOfBoundsException(\"无效索引\")\n        }\n    }\n\n    \n    operator fun invoke(index: Int) = when (index) {\n        0 -> x\n        1 -> y\n        else -> throw IndexOutOfBoundsException(\"无效索引\")\n    }\n\n}\n复制代码\nfun main() {\n    \n    println(\"+${Point(10, -20)}  =  ${+Point(10, -20)}\")\n\n    \n    var point = Point(10, -20)\n    println(\"${Point(10, -20)}++  =  ${point++}\")\n\n    \n    point = Point(10, -20)\n    println(\"++${Point(10, -20)}  =  ${++point}\")\n\n    \n    println(\"${Point(10, -20)} + ${Point(10, -20)}  =  ${Point(10, -20) + Point(10, -20)}\")\n\n    \n    println(\"${Point(10, -20)} + ${5}  =  ${Point(10, -20) + 5}\")\n\n    point = Point(10, -20)\n    \n    println(\"point[0] value is: ${point[0]}\")\n    \n    println(\"point[1] value is: ${point[1]}\")\n\n    \n    println(\"point(0) values is: ${point(0)}\")\n}\n复制代码\n二十一、中缀调用与解构声明\n21.1、中缀调用\n可以以以下形式创建一个 Map 变量\n\nfun main() {\n    val maps = mapOf(1 to \"leavesC\", 2 to \"ye\", 3 to \"czy\")\n    maps.forEach { key, value -> println(\"key is : $key , value is : $value\") }\n}\n复制代码\n使用 “to” 来声明 map 的 key 与 value 之间的对应关系，这种形式的函数调用被称为中缀调用\n\nkotlin 标准库中对 to 函数的声明如下所示，其作为扩展函数存在，且是一个泛型函数，返回值 Pair 最终再通过解构声明分别将 key 和 value 传给 Map\n\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n复制代码\n中缀调用只能与只有一个参数的函数一起使用，无论是普通的函数还是扩展函数。中缀符号需要通过 infix 修饰符来进行标记\n\nfun main() {\n    val pair = 10 test \"leavesC\"\n    val pair2 = 1.2 test 20\n    println(pair2.javaClass) \n}\n\ninfix fun Any.test(other: Any) = Pair(this, other)\n复制代码\n对于 mapOf 函数来说，它可以接收不定数量的 Pair 类型对象，因此我们也可以通过自定义的中缀调用符 test 来创建一个 map 变量\n\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n复制代码\n val map = mapOf(10 test \"leavesC\", 20 test \"hello\")\n复制代码\n21.2、解构声明\n有时会有把一个对象拆解成多个变量的需求，在 kotlin 中这种语法称为解构声明\n\n例如，以下例子将 Person 变量结构为了两个新变量：name 和 age，并且可以独立使用它们\n\ndata class Person(val name: String, val age: Int)\n\nfun main() {\n    val (name, age) = Person(\"leavesC\", 24)\n    println(\"Name: $name , age: $age\")\n    \n}\n复制代码\n一个解构声明会被编译成以下代码：\n\n    val name = person.component1()\n    val age = person.component2()\n复制代码\n其中的 component1() 和 component2() 函数是在 kotlin 中广泛使用的约定原则的另一个例子。任何表达式都可以出现在解构声明的右侧，只要可以对它调用所需数量的 component 函数即可\n\n需要注意的是，componentN() 函数需要用 operator 关键字标记，以允许在解构声明中使用它们\n\n对于数据类来说，其自动生成了 componentN() 函数，而对非数据类，为了使用解构声明，需要我们自己来手动声明函数\n\nclass Point(val x: Int, val y: Int) {\n    operator fun component1() = x\n    operator fun component2() = y\n}\n\nfun main() {\n    val point = Point(100, 200)\n    val (x, y) = point\n    println(\"x: $x , y: $y\")\n    \n}\n复制代码\n如果我们需要从一个函数返回两个或者更多的值，这时候使用解构声明就会比较方便了\n\n这里使用的是标准类 Pair 来包装要传递的数据，当然，也可以自定义数据类\n\nfun computer(): Pair<String, Int> {\n    \n    return Pair(\"leavesC\", 24)\n}\n\nfun main() {\n    val (name, age) = computer()\n    println(\"Name: $name , age: $age\")\n}\n复制代码\n此外，解构声明也可以用在 for 循环中\n\n    val list = listOf(Person(\"leavesC\", 24), Person(\"leavesC\", 25))\n    for ((name, age) in list) {\n        println(\"Name: $name , age: $age\")\n    }\n复制代码\n对于遍历 map 同样适用\n\n    val map = mapOf(\"leavesC\" to 24, \"ye\" to 25)\n    for ((name, age) in map) {\n        println(\"Name: $name , age: $age\")\n    }\n复制代码\n同样也适用于 lambda 表达式\n\n    val map = mapOf(\"leavesC\" to 24, \"ye\" to 25)\n    map.mapKeys { (key, value) -> println(\"key : $key , value : $value\") }\n复制代码\n如果在解构声明中不需要某个变量，那么可以用下划线取代其名称，此时不会调用相应的 componentN() 操作符函数\n\n    val map = mapOf(\"leavesC\" to 24, \"ye\" to 25)\n    for ((_, age) in map) {\n        println(\"age: $age\")\n    }\n复制代码\n二十二、Object 关键字\n22.1、对象声明\n在 kotlin 的世界中，可以通过对象声明这一功能来实现 Java 中的单例模式，将类声明与该类的单一实例声明结合到一起。与类一样，一个对象声明可以包含属性、方法、初始化语句块等的声明，且可以继承类和实现接口，唯一不被允许的是构造方法\n\n与普通类的实例不同，对象声明在定义的时候就被立即创建了，不需要在代码的其它地方调用构造方法，因此为对象声明定义构造方法是没有意义的\n\ninterface Fly {\n\n    fun fly()\n\n}\n\nopen class Eat {\n\n    fun eat() {\n        println(\"eat\")\n    }\n\n}\n\nobject Animal : Eat(), Fly {\n\n    override fun fly() {\n        println(\"fly\")\n    }\n\n}\n\nfun main() {\n    Animal.fly()\n    Animal.eat()\n}\n复制代码\nkotlin 中的对象声明被编译成了通过静态字段来持有它的单一实例的类，这个字段名字始终都是 INSTANCE\n\n例如，对于 kotlin 中的如下两个对象声明\n\nclass Test {\n\n    object SingleClass {\n        val names = arrayListOf<String>()\n    }\n\n    object SingleClass2 {\n        val names = arrayListOf<String>()\n    }\n\n}\n复制代码\n在 Java 代码中来访问这两个对象\n\n    public static void main(String[] args) {\n        Test.SingleClass.INSTANCE.getNames();\n        Test.SingleClass2.INSTANCE.getNames();\n    }\n复制代码\n22.2、伴生对象\n如果需要一个可以在没有类实例的情况下调用但是需要访问类内部的函数（类似于 Java 中的静态变量/静态函数），可以将其写成那个类中的对象声明的成员\n\n通过关键字 companion ，就可以获得通过容器类名称来访问这个对象的方法和属性的能力，不再需要显式地指明对象的名称\n\nclass Test {\n\n    companion object {\n\n        const val NAME = \"\"\n\n        fun testFun() {\n\n        }\n    }\n\n}\n\nfun main() {\n    Test.NAME\n    Test.testFun()\n}\n复制代码\n22.2.1、工厂模式\n可以利用伴生对象来实现工厂模式\n\nprivate class User private constructor(val name: String) {\n\n    companion object {\n        fun newById(id: Int) = User(id.toString())\n\n        fun newByDouble(double: Double) = User(double.toString())\n    }\n\n}\n\nfun main() {\n    \n    \n    val user2 = User.newById(10)\n    val user3 = User.newByDouble(1.3)\n}\n复制代码\n22.2.2、指定名称\n伴生对象既可以为其指定名字，也可以直接使用其默认名 Companion，在引用伴生对象时，可以自由选择是否要在类名后加上伴生对象名\n\n如果使用的是其默认名 Companion（没有自定义名称），则以下两种引用方式都是等价的\n\n    val user2 = User.Companion.newById(10)\n    val user3 = User.newByDouble(1.3)\n复制代码\n如果为伴生对象声明了自定义名称，引用方式等同\n\nprivate class User private constructor(val name: String) {\n\n    companion object UserLoader {\n        fun newById(id: Int) = User(id.toString())\n\n        fun newByDouble(double: Double) = User(double.toString())\n    }\n\n}\n\nfun main() {\n    \n    \n    val user2 = User.UserLoader.newById(10)\n    val user3 = User.newByDouble(1.3)\n}\n复制代码\n22.2.3、实现接口\n伴生对象也可以实现接口，且可以直接将包含它的类的名字当做实现了该接口的对象实例来使用\n\nprivate class User private constructor(val name: String) {\n\n    companion object UserLoader : Runnable {\n\n        override fun run() {\n\n        }\n    }\n\n}\n\nfun newThread(runnable: Runnable) = Thread(runnable)\n\nfun main() {\n    \n    val thread = newThread(User)\n    val thread2 = newThread(User.UserLoader)\n}\n复制代码\n22.3、对象表达式\nobject 能用来声明匿名对象，可用于替代 Java 中的匿名内部类，且对象表达式中的代码可以访问并修改其外部的非 final 型的变量\n\nfun newThread(runnable: Runnable) = Thread(runnable)\n\nfun main() {\n    var count = 0\n    val thread = newThread(object : Runnable {\n        override fun run() {\n            count++\n        }\n    })\n}\n复制代码\n二十三、委托\n23.1、委托模式\n委托模式是一种基本的设计模式，该模式下有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。kotlin 原生支持委托模式，可以零样板代码来实现，通过关键字 by 实现委托\n\ninterface Printer {\n\n    fun print()\n    \n}\n\nclass DefaultPrinter : Printer {\n\n    override fun print() {\n         println(\"DefaultPrinter print\")\n    }\n\n}\n\nclass CustomPrinter(val printer: Printer) : Printer by printer\n\nfun main() {\n    val printer = CustomPrinter(DefaultPrinter())\n    printer.print() \n}\n复制代码\nCustomPrinter 的 by 子句表示将会在 CustomPrinter 中存储 printer 变量，并且编译器将为 CustomPrinter 隐式生成 Printer 接口的所有抽象方法，并将这些方法的调用操作转发给 printer\n\n此外，CustomPrinter 也可以决定自己实现部分方法或全部自己实现，但重写的成员不会在委托对象的成员中调用 ，委托对象的成员只能访问其自身对接口成员实现\n\ninterface Printer {\n\n    val message: String\n\n    fun print()\n\n    fun reprint()\n\n}\n\nclass DefaultPrinter : Printer {\n\n    override val message: String = \"DefaultPrinter message\"\n\n    override fun print() {\n        println(message)\n    }\n\n    override fun reprint() {\n        println(\"DefaultPrinter reprint\")\n    }\n\n}\n\nclass CustomPrinter(val printer: Printer) : Printer by printer {\n\n    override val message: String = \"CustomPrinter message\"\n\n    override fun reprint() {\n        println(\"CustomPrinter reprint\")\n    }\n\n}\n\nfun main() {\n    val printer = CustomPrinter(DefaultPrinter())\n    printer.print() \n    printer.reprint() \n}\n复制代码\n23.2、属性委托\nkotlin 支持通过委托属性将对一个属性的访问操作委托给另外一个对象来完成，对应的语法格式是：\n\nval/var <属性名>: <类型> by <表达式>\n复制代码\n属性的委托不必实现任何的接口，但需要提供一个 getValue() 方法与 setValue()（对于 var 属性），对一个属性的 get 和 set 操作会被委托给属性的委托的这两个方法\n\nclass Delegate {\n    \n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n    }\n\t\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n    }\n}\n复制代码\n看以下的小例子，通过输出值就可以看出各个方法的调用时机\n\npackage test\n\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n\n    private var message: String? = null\n\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        println(\"${thisRef?.javaClass?.name}, thank you for delegating '${property.name}' to me!\")\n        return message ?: \"null value\"\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$value has been assigned to '${property.name}' in ${thisRef?.javaClass?.name}.\")\n        message = value\n    }\n}\n\nclass Example {\n    var strValue: String by Delegate()\n}\n\nfun main() {\n    val example = Example()\n    println(example.strValue)\n    example.strValue = \"leaveC\"\n    println(example.strValue)\n\n\n\n\n\n}\n复制代码\n23.3、延迟属性\nlazy() 是接受一个 lambda 并返回一个 Lazy < T > 实例的函数，返回的实例可以作为实现延迟属性的委托，第一次调用 get() 会执行已传递给 lazy() 函数的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果\n\nclass Example {\n\n    val lazyValue1: String by lazy {\n        println(\"lazyValue1 computed!\")\n        \"Hello\"\n    }\n\n    val lazyValue2: String by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {\n        println(\"lazyValue2 computed!\")\n        computeLazyValue()\n    }\n\n    private fun computeLazyValue() = \"leavesC\"\n\n}\n\nfun main() {\n    val example = Example()\n    println(example.lazyValue1) \n    println(example.lazyValue1) \n    println(example.lazyValue2) \n}\n复制代码\n默认情况下，对于 lazy 属性的求值是带同步锁的（synchronized），即带有 LazyThreadSafetyMode.SYNCHRONIZED 参数，此时该值只允许同一时刻只能有一个线程对其进行初始化，并且所有线程会看到相同的初始化值。如果初始化委托的同步锁不是必需的，即如果允许多个线程同时执行，那么可以将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给 lazy() 函数。 而如果你确定初始化将总是发生在单个线程，那么可以使用 LazyThreadSafetyMode.NONE 模式， 此时不会有任何线程安全的保证以及相关的资源开销\n\n23.4、可观察属性\nDelegates.observable() 接受两个参数：初始值以及修改属性值时的回调函数。当为属性赋值后就会调用该回调函数，该回调函数包含三个参数：被赋值的属性、旧值与新值\n\nfun main() {\n    val example = Example()\n    example.age = 24 \n    example.age = 27 \n}\n\nclass Example {\n    var age: Int by Delegates.observable(-100) { kProperty: KProperty<*>, oldValue: Int, newValue: Int ->\n        println(\"kProperty.name: ${kProperty.name} , oldValue: $oldValue , newValue: $newValue\")\n    }\n}\n复制代码\n如果想要拦截一个赋值操作并判断是否进行否决，可以使用 vetoable() 函数，通过返回一个布尔值来决定是否进行拦截，该判断逻辑是在属性被赋新值生效之前进行\n\nfun main() {\n    val example = Example()\n    example.age = 24  \n    example.age = -10 \n    example.age = 30  \n}\n\nclass Example {\n    var age: Int by Delegates.vetoable(-100) { kProperty: KProperty<*>, oldValue: Int, newValue: Int ->\n        println(\"kProperty.name: ${kProperty.name} , oldValue: $oldValue , newValue: $newValue\")\n        age <= 0 \n    }\n}\n复制代码\n23.5、把属性储存在映射中\n可以在一个 map 映射里存储属性的值，然后把属性的存取操作委托给 map 进行管理\n\nfun main() {\n    val student = Student(\n        mapOf(\n            \"name\" to \"leavesC\",\n            \"age\" to 24\n        )\n    )\n    println(student.name)\n    println(student.age)\n}\n\nclass Student(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int by map\n}\n复制代码\n在上述示例中，属性 name 和 age 都是不可变的（val），因此 map 的类型也是 Map 而非 MutableMap（MutableMap 在赋值后可以修改），因此如果为了支持 var 属性，可以将只读的 Map 换成 MutableMap\n\n23.6、局部委托属性\n可以将局部变量声明为委托属性\n\nclass Printer {\n\n    fun print() {\n        println(\"temp.Printer print\")\n    }\n\n}\n\nfun getPrinter(): Printer {\n    println(\"temp.Printer getPrinter\")\n    return Printer()\n}\n\n\nfun example(getPrinter: () -> Printer) {\n    val lPrinter by lazy(getPrinter)\n    val valid = true\n    if (valid) {\n        lPrinter.print()\n    }\n}\n\nfun main() {\n    example { getPrinter() }\n    \n    \n}\n复制代码\n委托变量只会在第一次访问时才会进行初始化，因此如果 valid 为 false 的话，getPrinter() 方法就不会被调用\n\n二十四、注解\n注解是将元数据附加到代码元素上的一种方式，附件的元数据就可以在编译后的类文件或者运行时被相关的源代码工具访问\n\n注解的语法格式如下所示：\n\n    annotation class AnnotationName()\n复制代码\n注解的附加属性可以通过用元注解标注注解类来指定：\n\n@Target 指定该注解标注的允许范围（类、函数、属性等）\n@Retention 指定该注解是否要存储在编译后的 class 文件中，如果要保存，则在运行时可以通过反射来获取到该注解值\n@Repeatable 标明允许在单个元素上多次使用相同的该注解\n@MustBeDocumented 指定该注解是公有 API 的一部分，并且应该包含在生成的 API 文档中显示的类或方法的签名中\n    @Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)\n    @Retention(AnnotationRetention.RUNTIME)\n    @Repeatable\n    @MustBeDocumented\n    annotation class AnnotationName()\n复制代码\n注解可以声明包含有参数的构造函数\n\n    annotation class OnClick(val viewId: Long)\n复制代码\n允许的参数类型有：\n\n原生数据类型，对应 Java 原生的 int 、long、char 等\n字符串\nclass 对象\n枚举\n其他注解\n以上类型的数组\n注解参数不能包含有可空类型，因为 JVM 不支持将 null 作为注解属性的值来存储\n\n看一个在运行时获取注解值的例子\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class OnClick(val viewId: Long)\n\nclass AnnotationsTest {\n\n    @OnClick(200300)\n    fun onClickButton() {\n        println(\"Clicked\")\n    }\n\n}\n\nfun main() {\n    val annotationsTest = AnnotationsTest()\n    for (method in annotationsTest.javaClass.methods) {\n        for (annotation in method.annotations) {\n            if (annotation is OnClick) {\n                println(\"method name: \" + method.name)  \n                println(\"OnClick viewId: \" + annotation.viewId)  \n            }\n        }\n    }\n}\n复制代码"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304155310},"updatedAt":{"$$date":1597305432508},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"UyFSCCutkrNi6ea6"}
{"name":"ad-frame_imageload","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    // 鲁班图片压缩\n    implementation 'top.zibin:Luban:1.1.8'\n}\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598525722552},"updatedAt":{"$$date":1598537775211},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Uz47YfuLPXT3XkEM"}
{"name":"qk-ks_component_share","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    libraryVariants.all {\n        it.getGenerateBuildConfigProvider()\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    //可以使用kotlin 实验特性，比如Parcelize ，直接生成Parcelable\n    androidExtensions {\n        experimental = true\n    }\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    implementation deps.dialogplus\n    implementation deps.androidx.recyclerview\n    implementation deps.androidx.constraintlayout\n\n\n    if (develop) {\n        api project(':ks_lib_share')\n        implementation project(':ks_component_net')\n        implementation project(':ks_component_resource')\n        implementation project(':ks_lib_autosize')\n        implementation project(':ks_lib_ktx')\n    } else {\n        api ks.lib_share\n        implementation ks.component_net\n        implementation ks.component_resource\n        implementation ks.lib_autosize\n        implementation ks.lib_ktx\n    }\n\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\nobject ShareConstants {\n\n    const val WXKEY = \"wx81f04dfc2977d0a3\"\n    const val KEY_XCX = \"gh_d88d164294c1\"\n\n    const val SHARE_WX = \"wx\"\n    const val SHARE_PYQ = \"timeline\"\n    const val SHARE_QQ = \"qq\"\n    const val SHARE_WEIBO = \"weibo\"\n    const val SHARE_SAVE = \"save\"\n\n    const val APP_IDENTIFICATION = \"凯叔讲故事\"\n    const val NO_NET_TOAST_TIPS = \"无可用网络，请恢复网络后重试\"\n\n\n}\n\n\n\n\n\n\n\n\nfun isWechatInstall(context: Context, msgApi: IWXAPI): Boolean {\n    if (!msgApi.isWXAppInstalled) {\n        context.toast(\"请安装微信客户端\")\n        return false\n    }\n    val isPaySupported =\n        msgApi.wxAppSupportAPI >= com.tencent.mm.opensdk.constants.Build.PAY_SUPPORTED_SDK_INT\n    if (!isPaySupported) {\n        context.toast(\"请更新微信客户端\")\n        return false\n    }\n    return true\n}\n\n\nfun bmpToByteArray(bmp: Bitmap, needRecycle: Boolean): ByteArray {\n    val output = ByteArrayOutputStream()\n    bmp.compress(Bitmap.CompressFormat.JPEG, 100, output)\n    if (needRecycle) {\n        bmp.recycle()\n    }\n\n    val result = output.toByteArray()\n    try {\n        output.close()\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n\n    return result\n}\n\n\n/**\n * 判断设备是否安装QQ客户端Ａｐｐ\n *\n * @return boolean\n */\nfun Context.isQQClientAvailable(): Boolean {\n    val pinfo = packageManager.getInstalledPackages(0)\n    if (pinfo != null) {\n        for (i in pinfo!!.indices) {\n            val pn = pinfo!!.get(i).packageName\n            if (\"com.tencent.mobileqq\" == pn) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n/**\n * 判断设备是否安装新浪微博App\n *\n * @return\n */\nfun Context.isSinaClientAvailable(): Boolean {\n    val pinfo = packageManager.getInstalledPackages(0)\n    if (pinfo != null) {\n        for (i in pinfo!!.indices) {\n            val pn = pinfo!!.get(i).packageName\n            if (\"com.sina.weibo\" == pn) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n\nfun Context.wechatAvilible(action: () -> Unit) {\n    if (isWeixinAvilible()) {\n        action()\n    } else {\n        toast(\"请安装微信\")\n    }\n}\n\nfun Context.qqAvilible(action: () -> Unit) {\n    if (isQQClientAvailable()) {\n        action()\n    } else {\n        toast(\"请安装QQ客户端\")\n    }\n}\n\nfun Context.sinaAvilible(action: () -> Unit) {\n    if (isSinaClientAvailable()) {\n        action()\n    } else {\n        toast(\"请安装微博客户端\")\n    }\n}\n\n/**\n * 检测网络是否可用\n *\n * @return\n */\nfun Context.isNetworkAvailable(): Boolean {\n    val mNetworkInfo = connectivityManager?.activeNetworkInfo\n    if (mNetworkInfo != null) {\n        val isAvailable = mNetworkInfo.isAvailable\n        return when {\n            isAvailable -> isAvailable\n            else -> {\n                toast(ShareConstants.NO_NET_TOAST_TIPS)\n                false\n            }\n        }\n    }\n    toast(ShareConstants.NO_NET_TOAST_TIPS)\n    return false\n}\n\nfun getHtmlBitmap(url: String): Bitmap? {\n    var htmlUrl: URL?\n    var inStream: InputStream? = null\n    try {\n        htmlUrl = URL(url)\n        val connection = htmlUrl.openConnection()\n        val httpConnection = connection as HttpURLConnection\n        val responseCode = httpConnection.responseCode\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inStream = httpConnection.inputStream\n        }\n    } catch (e: MalformedURLException) {\n        e.printStackTrace()\n    } catch (e: IOException) {\n        e.printStackTrace()\n    }\n\n    return inputStreamToBitmap(inStream)\n}\n\nfun inputStreamToBitmap(`is`: InputStream?): Bitmap? {\n    var `is` = `is`\n    try {\n        return BitmapFactory.decodeStream(`is`)\n    } catch (e: Exception) {\n        e.printStackTrace()\n    } finally {\n        if (`is` != null) {\n            try {\n                `is`.close()\n                `is` = null\n            } catch (tE: Exception) {\n                tE.printStackTrace()\n            }\n        }\n    }\n\n    return null\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@Keep\nobject ShareDelegate {\n\n    //测试\n    const val ENV_DEBUG = 0\n    //开发\n    const val ENV_DAPI = 1\n    //预上线\n    const val ENV_GAMA = 2\n    //线上\n    const val ENV_RELEASE = 3\n\n    private var config: ShareConfig? = null\n    private var isInit: Boolean = false\n    fun init(config: ShareConfig) {\n        if (isInit) {\n            return\n        }\n        ShareDelegate.config = config\n        isInit = true\n    }\n\n    interface ShareConfig {\n        fun getEnv(): Int\n\n    }\n\n\n    fun checkConfig(): ShareConfig {\n        if (config == null) {\n            throw RuntimeException(\"请先调用 ShareDelegate.init(config: ShareConfig) 初始化 分享代理\")\n        }\n\n        return config!!\n    }\n\n    fun getEnv(): Int {\n        return checkConfig().getEnv()\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598585025070},"updatedAt":{"$$date":1598585876759},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"V3MMnigFAkP2eVnh"}
{"name":"内部系统及账号密码","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"内部系统及账号密码\n了解并熟悉办公室！ 以下列出了一些信息，帮助你快速开始新工作。建议保存书签！\n一、权限\n• 发邮件给运维申请开通各种新人权限，一键申请\n• 找开发组负责人开通代码权限\n企业邮箱\n用于权限申请，消息通知，会议邀请等较为正式的场合\n• 账号密码：zhangsan@ksjgs.com/Zs2018(名字首字母大写2018)\n• 注意事项：无\nWIFI\n用于连接网络\n• 账号密码：kaishu_office_5g/kaishu_office 密码：kaishu2099\n• 注意事项：建议使用有线网，需要转接头到钉钉找崔宇\n二、代码\nGitLab（代码仓库）\n主要存储开发代码和私有库代码\n• 账号密码：见邮件\n• 注意事项：需要VPN登录\n三、文档\nWIKI文档\n各团队文档中心\n• 账号密码：见邮件\n• 注意事项：需要VPN登录\n代码规范\n移动端团队的代码规范\n• 账号密码：无\n• 注意事项：无\n技术文档\n团队业务模块技术文档\n• 账号密码：无\n• 注意事项：无\n四、开发流程\nWorkTile（任务管理）\n各项目迭代任务管理工具，日常三省工作之一\n• 账号密码：见邮件\n• 注意事项：需要VPN登录\nUE（产品文档）\n各项目迭代版本产品文档中心\n• 账号密码：见邮件\n• 注意事项：需要VPN登录\nUI设计图\n各项目迭代版本设计文档中心\n• 账号密码：个人申请\n• 注意事项：账号申请成功后，然后点击这里加入项目\nYAPI（接口联调） \n接口联调和Mock数据专用\n• 账号密码：账号:guest@ksjgs.com 密码:kaishu2099\n• 注意事项：需要VPN登录\n数据中台（打点）\n各项目埋点数据中台\n• 账号密码：账号：ios 密码：ios\n• 注意事项：需要VPN登录\nBDP\n数据仓库和数据展示系统\n• 账号密码：找徐海缘申请\n• 注意事项：需要VPN登录\nBugly\nCrash查看和处理\n• 账号密码：使用个人qq登录\n• 注意事项：登录后及时修改个人昵称-右上角个人中心\n听云（APM）\n线上质量监控\n• 账号密码：找徐海缘申请\n• 注意事项：无\n极光\n推送，一键登录\n• 账号密码：找徐海缘申请\n• 注意事项：无\n友盟\n日活，打点\n• 账号密码：找徐海缘申请\n• 注意事项：无\n数字联盟\n设备唯一id\n• 账号密码：找徐海缘申请\n• 注意事项：无\n个推\n推送\n• 账号密码：找徐海缘申请\n• 注意事项：无\n个验\n一键登录\n• 账号密码：找徐海缘申请\n• 注意事项：无\n五、业务系统\nKMS\n新内容后台管理系统\n• 账号密码：找徐海缘申请\n• 注意事项：需要VPN登录\nCMS\n内容后台管理系统\n• 账号密码：找徐海缘申请\n• 注意事项：需要VPN登录"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598545316472},"updatedAt":{"$$date":1598545321416},"_id":"V6IWmSUnbUrdkOyy","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"使用 require 或者 check 函数作为条件检查","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"dart","value":"// 传统的做法\nval age = -1;\nif (age <= 0) {\n    throw IllegalArgumentException(\"age must  not be negative\")\n}\n\n// 使用 require 去检查\nrequire(age > 0) { \"age must be negative\" }\n\n// 使用 checkNotNull 检查\nval name: String? = null\ncheckNotNull(name){\n    \"name must not be null\"\n}\n\n作者：HiDhl\n链接：https://juejin.im/post/5edfd7c9e51d45789a7f206d\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}],"tags":["aZ7LswF9qbcVtQZT"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594728663925},"updatedAt":{"$$date":1594728663925},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"kotlin","_id":"aZ7LswF9qbcVtQZT","text":"kotlin"}],"_id":"V76phT9KREhVY2vF"}
{"name":"html-HTML 颜色","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\nHTML 颜色由红色、绿色、蓝色混合而成。\n\n颜色值\nHTML 颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。\n\n每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。\n\n这个表格给出了由三种颜色混合而成的具体效果：\n\n颜色值\n颜色(Color)\t颜色十六进制(Color HEX)\t颜色RGB(Color RGB)\n \t#000000\trgb(0,0,0)\n \t#FF0000\trgb(255,0,0)\n \t#00FF00\trgb(0,255,0)\n \t#0000FF\trgb(0,0,255)\n \t#FFFF00\trgb(255,255,0)\n \t#00FFFF\trgb(0,255,255)\n \t#FF00FF\trgb(255,0,255)\n \t#C0C0C0\trgb(192,192,192)\n \t#FFFFFF\trgb(255,255,255)\n\n尝试一下 »\n1600万种不同颜色\n三种颜色 红，绿，蓝的组合从0到255，一共有1600万种不同颜色(256 x 256 x 256)。\n\n在下面的颜色表中你会看到不同的结果，从0到255的红色，同时设置绿色和蓝色的值为0,随着红色的值变化，不同的值都显示了不同的颜色。\n\nRed Light\tColor HEX\tColor RGB\n \t#000000 \trgb(0,0,0)\n \t#080000\trgb(8,0,0)\n \t#100000\trgb(16,0,0)\n \t#180000\trgb(24,0,0)\n \t#200000\trgb(32,0,0)\n \t#280000\trgb(40,0,0)\n \t#300000\trgb(48,0,0)\n \t#380000\trgb(56,0,0)\n \t#400000\trgb(64,0,0)\n \t#480000\trgb(72,0,0)\n \t#500000\trgb(80,0,0)\n \t#580000\trgb(88,0,0)\n \t#600000\trgb(96,0,0)\n \t#680000\trgb(104,0,0)\n \t#700000\trgb(112,0,0)\n \t#780000\trgb(120,0,0)\n \t#800000\trgb(128,0,0)\n \t#880000\trgb(136,0,0)\n \t#900000\trgb(144,0,0)\n \t#980000\trgb(152,0,0)\n \t#A00000\trgb(160,0,0)\n \t#A80000\trgb(168,0,0)\n \t#B00000\trgb(176,0,0)\n \t#B80000\trgb(184,0,0)\n \t#C00000\trgb(192,0,0)\n \t#C80000\trgb(200,0,0)\n \t#D00000\trgb(208,0,0)\n \t#D80000\trgb(216,0,0)\n \t#E00000\trgb(224,0,0)\n \t#E80000\trgb(232,0,0)\n \t#F00000\trgb(240,0,0)\n \t#F80000\trgb(248,0,0)\n \t#FF0000\trgb(255,0,0)\n\n灰暗色调\n以下展示了黑色到灰色的渐变\n\nGray Shades\tColor HEX\tColor RGB\n \t#000000 \trgb(0,0,0) \n \t#080808 \trgb(8,8,8) \n \t#101010 \trgb(16,16,16) \n \t#181818 \trgb(24,24,24) \n \t#202020 \trgb(32,32,32) \n \t#282828 \trgb(40,40,40) \n \t#303030 \trgb(48,48,48) \n \t#383838 \trgb(56,56,56) \n \t#404040 \trgb(64,64,64) \n \t#484848 \trgb(72,72,72) \n \t#505050 \trgb(80,80,80) \n \t#585858 \trgb(88,88,88) \n \t#606060 \trgb(96,96,96) \n \t#686868 \trgb(104,104,104) \n \t#707070 \trgb(112,112,112) \n \t#787878 \trgb(120,120,120) \n \t#808080 \trgb(128,128,128) \n \t#888888 \trgb(136,136,136) \n \t#909090 \trgb(144,144,144) \n \t#989898 \trgb(152,152,152) \n \t#A0A0A0 \trgb(160,160,160) \n \t#A8A8A8 \trgb(168,168,168) \n \t#B0B0B0 \trgb(176,176,176) \n \t#B8B8B8 \trgb(184,184,184) \n \t#C0C0C0 \trgb(192,192,192) \n \t#C8C8C8 \trgb(200,200,200) \n \t#D0D0D0 \trgb(208,208,208) \n \t#D8D8D8 \trgb(216,216,216) \n \t#E0E0E0 \trgb(224,224,224) \n \t#E8E8E8 \trgb(232,232,232) \n \t#F0F0F0 \trgb(240,240,240) \n \t#F8F8F8 \trgb(248,248,248) \n \t#FFFFFF \trgb(255,255,255) \n\nWeb安全色?\n数年以前，当大多数计算机仅支持 256 种颜色的时候，一系列 216 种 Web 安全色作为 Web 标准被建议使用。其中的原因是，微软和 Mac 操作系统使用了 40 种不同的保留的固定系统颜色（双方大约各使用 20 种）。\n\n我们不确定如今这么做的意义有多大，因为越来越多的计算机有能力处理数百万种颜色，不过做选择还是你自己。\n\n最初，216 跨平台 web 安全色被用来确保：当计算机使用 256 色调色板时，所有的计算机能够正确地显示所有的颜色。\n\n000000\t000033\t000066\t000099\t0000CC\t0000FF\n003300\t003333\t003366\t003399\t0033CC\t0033FF\n006600\t006633\t006666\t006699\t0066CC\t0066FF\n009900\t009933\t009966\t009999\t0099CC\t0099FF\n00CC00\t00CC33\t00CC66\t00CC99\t00CCCC\t00CCFF\n00FF00\t00FF33\t00FF66\t00FF99\t00FFCC\t00FFFF\n330000\t330033\t330066\t330099\t3300CC\t3300FF\n333300\t333333\t333366\t333399\t3333CC\t3333FF\n336600\t336633\t336666\t336699\t3366CC\t3366FF\n339900\t339933\t339966\t339999\t3399CC\t3399FF\n33CC00\t33CC33\t33CC66\t33CC99\t33CCCC\t33CCFF\n33FF00\t33FF33\t33FF66\t33FF99\t33FFCC\t33FFFF\n660000\t660033\t660066\t660099\t6600CC\t6600FF\n663300\t663333\t663366\t663399\t6633CC\t6633FF\n666600\t666633\t666666\t666699\t6666CC\t6666FF\n669900\t669933\t669966\t669999\t6699CC\t6699FF\n66CC00\t66CC33\t66CC66\t66CC99\t66CCCC\t66CCFF\n66FF00\t66FF33\t66FF66\t66FF99\t66FFCC\t66FFFF\n990000\t990033\t990066\t990099\t9900CC\t9900FF\n993300\t993333\t993366\t993399\t9933CC\t9933FF\n996600\t996633\t996666\t996699\t9966CC\t9966FF\n999900\t999933\t999966\t999999\t9999CC\t9999FF\n99CC00\t99CC33\t99CC66\t99CC99\t99CCCC\t99CCFF\n99FF00\t99FF33\t99FF66\t99FF99\t99FFCC\t99FFFF\nCC0000\tCC0033\tCC0066\tCC0099\tCC00CC\tCC00FF\nCC3300\tCC3333\tCC3366\tCC3399\tCC33CC\tCC33FF\nCC6600\tCC6633\tCC6666\tCC6699\tCC66CC\tCC66FF\nCC9900\tCC9933\tCC9966\tCC9999\tCC99CC\tCC99FF\nCCCC00\tCCCC33\tCCCC66\tCCCC99\tCCCCCC\tCCCCFF\nCCFF00\tCCFF33\tCCFF66\tCCFF99\tCCFFCC\tCCFFFF\nFF0000\tFF0033\tFF0066\tFF0099\tFF00CC\tFF00FF\nFF3300\tFF3333\tFF3366\tFF3399\tFF33CC\tFF33FF\nFF6600\tFF6633\tFF6666\tFF6699\tFF66CC\tFF66FF\nFF9900\tFF9933\tFF9966\tFF9999\tFF99CC\tFF99FF\nFFCC00\tFFCC33\tFFCC66\tFFCC99\tFFCCCC\tFFCCFF\nFFFF00\tFFFF33\tFFFF66\tFFFF99\tFFFFCC\tFFFFFF\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886137434},"updatedAt":{"$$date":1598886762348},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"VC4t3z4XvcDZGaH3"}
{"name":"kqapp-keyboard","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author jiaruihua\n * 邮箱：jiaruihua@ksjgs.com\n * 创建时间: 2020/8/5     10:38 AM\n * 用途:\n ***************************************\n */\nobject KeyboardUtil {\n\n    private var globalListener: ViewTreeObserver.OnGlobalLayoutListener? = null\n    private var keyboardHeight = 0\n\n    /**\n     * 当前软件盘打开状态\n     */\n    private var currentShow = false\n\n    private var act: WeakReference<Activity>? = null\n\n    fun regist(activity: Activity?, call: (keyboardHeight: Int, isShow: Boolean) -> Unit) {\n        activity?.let { act = WeakReference(it) }\n        act?.get()?.window?.decorView?.run {\n            globalListener = ViewTreeObserver.OnGlobalLayoutListener {\n                val rect = Rect()\n                //获取root在窗体的可视区域\n                //获取root在窗体的可视区域\n                getWindowVisibleDisplayFrame(rect)\n                //获取root在窗体的不可视区域高度 软键盘高度\n                keyboardHeight = height - rect.bottom\n\n                if (currentShow) {\n                    //当前显示\n                    if (keyboardHeight > 0) {\n                        currentShow = true\n                    } else {\n                        currentShow = false\n                        //关闭时通知一下\n                        call(keyboardHeight, keyboardHeight > 0)\n                    }\n                } else {\n                    if (keyboardHeight > 0) {\n                        currentShow = true\n                        //显示时通知一下\n                        call(keyboardHeight, keyboardHeight > 0)\n                    } else {\n                        currentShow = false\n\n                    }\n                }\n\n            }\n            viewTreeObserver.addOnGlobalLayoutListener(globalListener)\n        }\n    }\n\n\n    fun hideKeyBoard() {\n        if (currentShow)\n            act?.get()?.hideKeyboard()\n    }\n\n    fun unRegist() {\n\n        globalListener?.let { act?.get()?.window?.decorView?.viewTreeObserver?.removeOnGlobalLayoutListener(it) }\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593274125},"updatedAt":{"$$date":1598601076468},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"VEeuNWYTY3gFGwIg"}
{"name":"py-可变参数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。\n\n我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。\n\n要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：\n\ndef calc(numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n但是调用的时候，需要先组装出一个list或tuple：\n\n>>> calc([1, 2, 3])\n14\n>>> calc((1, 3, 5, 7))\n84\n如果利用可变参数，调用函数的方式可以简化成这样：\n\n>>> calc(1, 2, 3)\n14\n>>> calc(1, 3, 5, 7)\n84\n所以，我们把函数的参数改为可变参数：\n\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：\n\n>>> calc(1, 2)\n5\n>>> calc()\n0\n如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：\n\n>>> nums = [1, 2, 3]\n>>> calc(nums[0], nums[1], nums[2])\n14\n这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：\n\n>>> nums = [1, 2, 3]\n>>> calc(*nums)\n14\n*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977478427},"updatedAt":{"$$date":1594977686476},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"VHWAfsgfrAvCef04"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977496517},"updatedAt":{"$$date":1594977496517},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"VSuyIAsO09jo27nl"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977499804},"updatedAt":{"$$date":1594977499804},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"VZNqM8DM9AFgnnHz"}
{"name":"kotlin-使用命令行编译","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-command-line.html\nKotlin 使用命令行编译 | 菜鸟教程\n2-2 minutes\nKotlin 命令行编译工具下载地址：https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-2，目前最新为 1.1.2-2。\n\n你可以选择一个最新的稳定版下载。\n\n下载完成后，解压到指定目录，然后将 bin 目录添加到系统环境变量。bin 目录包含编译和运行 Kotlin 所需的脚本。\n\nSDKMAN!\n在 OS X、Linux、Cygwin、FreeBSD 和 Solaris 系统上也可以使用更简单的安装方法，命令如下：\n\n$ curl -s https://get.sdkman.io | bash\n\n$ sdk install kotlin\nHomebrew\n在 OS X 下，你可以使用 Homebrew 安装：\n\n$ brew update\n$ brew install kotlin\nMacPorts\n如果你是 MacPorts 用户，可以使用以下命令安装：\n\n$ sudo port install kotlin\n创建和运行第一个程序\n创建一个名为 hello.kt 文件，代码如下：\n\nhello.kt\nfun main(args: Array<String>) { println(\"Hello, World!\") }\n\n使用 Kotlin 编译器编译应用:\n\n$ kotlinc hello.kt -include-runtime -d hello.jar\n-d: 用来设置编译输出的名称，可以是 class 或 .jar 文件，也可以是目录。\n-include-runtime : 让 .jar 文件包含 Kotlin 运行库，从而可以直接运行。\n如果你想看所有的可用选项，运行:\n\n$ kotlinc -help\n运行应用\n\n$ java -jar hello.jar\nHello, World!\n编译成库\n若需要将生成的 jar 包供其他 Kotlin 程序使用，可无需包含 Kotlin 的运行库：\n\n$ kotlinc hello.kt -d hello.jar\n由于这样生成的 .jar 文件不包含 Kotlin 运行库，所以你应该确保当它被使用时，运行时在你的 classpath 上。\n\n你也可以使用 kotlin 命令来运行 Kotlin 编译器生成的 .jar 文件\n\n$ kotlin -classpath hello.jar HelloKt\nHelloKt 为编译器为 hello.kt 文件生成的默认类名。\n\n运行 REPL（交互式解释器）\n我们可以运行如下命令得到一个可交互的 shell，然后输入任何有效的 Kotlin 代码，并立即看到结果\n\n\n\n使用命令行执行脚本\nKotlin 也可以作为一个脚本语言使用，文件后缀名为 .kts 。\n\n例如我们创建一个名为 list_folders.kts，代码如下：\n\nimport java.io.File\n\nval folders = File(args[0]).listFiles { file -> file.isDirectory() }\nfolders?.forEach { folder -> println(folder) }\n执行时通过 -script 选项设置相应的脚本文件。\n\n$ kotlinc -script list_folders.kts <path_to_folder>\n$ kotlinc -script list_folders.kts"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303651182},"updatedAt":{"$$date":1597303736910},"_id":"Vmx389m8LLPYePVn","folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977498702},"updatedAt":{"$$date":1594977498702},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Vxpagdu45CnMF24U"}
{"name":"kqapp-","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593277494},"updatedAt":{"$$date":1598593277494},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"VznGOhBpni4hc5jp"}
{"name":"andr-ViewModel 概览","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\ndeveloper.android.google.cn /topic/libraries/architecture/viewmodel\nViewModel 概览  |  Android 开发者  |  Android Developers\n8-10 minutes\nViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。\n\nAndroid 框架可以管理界面控制器（如 Activity 和 Fragment）的生命周期。Android 框架可能会决定销毁或重新创建界面控制器，以响应完全不受您控制的某些用户操作或设备事件。\n\n如果系统销毁或重新创建界面控制器，则存储在其中的任何临时性界面相关数据都会丢失。例如，应用的某个 Activity 中可能包含用户列表。因配置更改而重新创建 Activity 后，新 Activity 必须重新提取用户列表。对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。\n\n另一个问题是，界面控制器经常需要进行异步调用，这些调用可能需要一些时间才能返回结果。界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄露。此项管理需要大量的维护工作，并且在因配置更改而重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。\n\n诸如 Activity 和 Fragment 之类的界面控制器主要用于显示界面数据、对用户操作做出响应或处理操作系统通信（如权限请求）。如果要求界面控制器也负责从数据库或网络加载数据，那么会使类越发膨胀。为界面控制器分配过多的责任可能会导致单个类尝试自己处理应用的所有工作，而不是将工作委托给其他类。以这种方式为界面控制器分配过多的责任也会大大增加测试的难度。\n\n从界面控制器逻辑中分离出视图数据所有权的做法更易行且更高效。\n\n实现 ViewModel\n架构组件为界面控制器提供了 ViewModel 辅助程序类，该类负责为界面准备数据。在配置更改期间会自动保留 ViewModel 对象，以便它们存储的数据立即可供下一个 Activity 或 Fragment 实例使用。例如，如果您需要在应用中显示用户列表，请确保将获取和保留该用户列表的责任分配给 ViewModel，而不是 Activity 或 Fragment，如以下示例代码所示：\n\nKotlin\n    class MyViewModel : ViewModel() {\n        private val users: MutableLiveData<List<User>> by lazy {\n            MutableLiveData().also {\n                loadUsers()\n            }\n        }\n\n        fun getUsers(): LiveData<List<User>> {\n            return users\n        }\n\n        private fun loadUsers() {\n            // Do an asynchronous operation to fetch users.\n        }\n    }\n    \nJava\n    public class MyViewModel extends ViewModel {\n        private MutableLiveData<List<User>> users;\n        public LiveData<List<User>> getUsers() {\n            if (users == null) {\n                users = new MutableLiveData<List<User>>();\n                loadUsers();\n            }\n            return users;\n        }\n\n        private void loadUsers() {\n            // Do an asynchronous operation to fetch users.\n        }\n    }\n    \n然后，您可以从 Activity 访问该列表，如下所示：\n\nKotlin\n    class MyActivity : AppCompatActivity() {\n\n        override fun onCreate(savedInstanceState: Bundle?) {\n            // Create a ViewModel the first time the system calls an activity's onCreate() method.\n            // Re-created activities receive the same MyViewModel instance created by the first activity.\n\n            // Use the 'by viewModels()' Kotlin property delegate\n            // from the activity-ktx artifact\n            val model: MyViewModel by viewModels()\n            model.getUsers().observe(this, Observer<List<User>>{ users ->\n                // update UI\n            })\n        }\n    }\n    \nJava\n    public class MyActivity extends AppCompatActivity {\n        public void onCreate(Bundle savedInstanceState) {\n            // Create a ViewModel the first time the system calls an activity's onCreate() method.\n            // Re-created activities receive the same MyViewModel instance created by the first activity.\n\n            MyViewModel model = new ViewModelProvider(this).get(MyViewModel.class);\n            model.getUsers().observe(this, users -> {\n                // update UI\n            });\n        }\n    }\n    \n如果重新创建了该 Activity，它接收的 MyViewModel 实例与第一个 Activity 创建的实例相同。当所有者 Activity 完成时，框架会调用 ViewModel 对象的 onCleared() 方法，以便它可以清理资源。\n\nViewModel 对象存在的时间比视图或 LifecycleOwners 的特定实例存在的时间更长。这还意味着，您可以更轻松地编写涵盖 ViewModel 的测试，因为它不了解视图和 Lifecycle 对象。ViewModel 对象可以包含 LifecycleObservers，如 LiveData 对象。但是，ViewModel 对象绝不能观察对生命周期感知型可观察对象（如 LiveData 对象）的更改。 如果 ViewModel 需要 Application 上下文（例如，为了查找系统服务），它可以扩展 AndroidViewModel 类并设置用于接收 Application 的构造函数，因为 Application 类会扩展 Context。\n\nViewModel 的生命周期\nViewModel 对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel 将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失：对于 Activity，是在 Activity 完成时；而对于 Fragment，是在 Fragment 分离时。\n\n图 1 说明了 Activity 经历屏幕旋转而后结束的过程中所处的各种生命周期状态。该图还在关联的 Activity 生命周期的旁边显示了 ViewModel 的生命周期。此图表说明了 Activity 的各种状态。这些基本状态同样适用于 Fragment 的生命周期。\n\n说明 ViewModel 随着 Activity 状态的改变而经历的生命周期。\n\n您通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel。系统可能会在 Activity 的整个生命周期内多次调用 onCreate()，如在旋转设备屏幕时。ViewModel 存在的时间范围是从您首次请求 ViewModel 直到 Activity 完成并销毁。\n\n在 Fragment 之间共享数据\nActivity 中的两个或更多 Fragment 需要相互通信是一种很常见的情况。想象一下主从 Fragment 的常见情况，假设您有一个 Fragment，在该 Fragment 中，用户从列表中选择一项，还有另一个 Fragment，用于显示选定项的内容。这种情况不太容易处理，因为这两个 Fragment 都需要定义某种接口描述，并且所有者 Activity 必须将两者绑定在一起。此外，这两个 Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。\n\n可以使用 ViewModel 对象解决这一常见的难点。这两个 Fragment 可以使用其 Activity 范围共享 ViewModel 来处理此类通信，如以下示例代码所示：\n\nKotlin\n    class SharedViewModel : ViewModel() {\n        val selected = MutableLiveData<Item>()\n\n        fun select(item: Item) {\n            selected.value = item\n        }\n    }\n\n    class MasterFragment : Fragment() {\n\n        private lateinit var itemSelector: Selector\n\n        // Use the 'by activityViewModels()' Kotlin property delegate\n        // from the fragment-ktx artifact\n        private val model: SharedViewModel by activityViewModels()\n\n        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            itemSelector.setOnClickListener { item ->\n                // Update the UI\n            }\n        }\n    }\n\n    class DetailFragment : Fragment() {\n\n        // Use the 'by activityViewModels()' Kotlin property delegate\n        // from the fragment-ktx artifact\n        private val model: SharedViewModel by activityViewModels()\n\n        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            model.selected.observe(viewLifecycleOwner, Observer<Item> { item ->\n                // Update the UI\n            })\n        }\n    }\n    \nJava\n    public class SharedViewModel extends ViewModel {\n        private final MutableLiveData<Item> selected = new MutableLiveData<Item>();\n\n        public void select(Item item) {\n            selected.setValue(item);\n        }\n\n        public LiveData<Item> getSelected() {\n            return selected;\n        }\n    }\n\n    public class MasterFragment extends Fragment {\n        private SharedViewModel model;\n\n        public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n            super.onViewCreated(view, savedInstanceState);\n            model = new ViewModelProvider(requireActivity()).get(SharedViewModel.class);\n            itemSelector.setOnClickListener(item -> {\n                model.select(item);\n            });\n        }\n    }\n\n    public class DetailFragment extends Fragment {\n\n        public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n            super.onViewCreated(view, savedInstanceState);\n            SharedViewModel model = new ViewModelProvider(requireActivity()).get(SharedViewModel.class);\n            model.getSelected().observe(getViewLifecycleOwner(), { item ->\n               // Update the UI.\n            });\n        }\n    }\n    \n请注意，这两个 Fragment 都会检索包含它们的 Activity。这样，当这两个 Fragment 各自获取 ViewModelProvider 时，它们会收到相同的 SharedViewModel 实例（其范围限定为该 Activity）。\n\n此方法具有以下优势：\n\nActivity 不需要执行任何操作，也不需要对此通信有任何了解。\n除了 SharedViewModel 约定之外，Fragment 不需要相互了解。如果其中一个 Fragment 消失，另一个 Fragment 将继续照常工作。\n每个 Fragment 都有自己的生命周期，而不受另一个 Fragment 的生命周期的影响。如果一个 Fragment 替换另一个 Fragment，界面将继续工作而没有任何问题。\n将加载器替换为 ViewModel\nCursorLoader 等加载器类经常用于使应用界面中的数据与数据库保持同步。您可以将 ViewModel 与一些其他类一起使用来替换加载器。使用 ViewModel 可将界面控制器与数据加载操作分离，这意味着类之间的强引用更少。\n\n在使用加载器的一种常见方法中，应用可能会使用 CursorLoader 观察数据库的内容。当数据库中的值发生更改时，加载器会自动触发数据的重新加载并更新界面：\n\n\n图 2. 使用加载器加载数据\nViewModel 与 Room 和 LiveData 一起使用可替换加载器。ViewModel 确保数据在设备配置更改后仍然存在。Room 在数据库发生更改时通知 LiveData，LiveData 进而使用修订后的数据更新界面。\n\n\n图 3. 使用 ViewModel 加载数据\n将协程与 ViewModel 一起使用\nViewModel 支持 Kotlin 协程。如需了解详情，请参阅将 Kotlin 协程与 Android 架构组件一起使用。\n\n更多信息\n随着数据变得越来越复杂，您可能会选择使用单独的类加载数据。ViewModel 的用途是封装界面控制器的数据，以使数据在配置更改后仍然存在。有关如何在配置更改后加载、保留和管理数据的信息，请参阅保存界面状态。\n\nAndroid 应用架构指南建议构建存储区类来处理这些功能。\n\n其他资源\n如需详细了解 ViewModel 类，请参阅以下资源。\n\n示例\nAndroid 架构组件基本示例\nSunflower，这是一款园艺应用，展示了使用 Android Jetpack 进行 Android 开发的最佳做法。\nCodelab\n带 View 的 Android Room (Java) (Kotlin)\nAndroid 生命周期感知型组件 Codelab\n博客\nViewModel：简单示例\nViewModel：持久性、onSaveInstanceState()、恢复界面状态和加载器\nViewModel 和 LiveData：模式 + 反模式\nKotlin 揭秘：理解速记 Lambda 语法\nKotlin 揭秘：范围函数\nKotlin 揭秘：何时使用自定义访问器\n使用架构组件加载生命周期感知数据\n视频\nAndroid Jetpack：ViewModel\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243907747},"updatedAt":{"$$date":1597244553082},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WBJkGPoqEsWlJwMv"}
{"name":"qk-ks_component_login","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 110\n        versionName \"110\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n\n    }\n\n    buildTypes {\n        release {\n\n            consumerProguardFiles 'proguard-rules.pro'\n        }\n    }\n\n    //可以使用kotlin 实验特性，比如Parcelize ，直接生成Parcelable\n    androidExtensions {\n        experimental = true\n    }\n\n    compileOptions {\n        sourceCompatibility 1.8\n        targetCompatibility 1.8\n    }\n\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n    if(develop){\n        implementation project(path:':ks_component_net')\n        implementation project(path: ':ks_lib_share')\n\n    }else{\n        implementation ks.component_net\n        implementation ks.lib_share\n    }\n\n    //viewmodel ktx\n    api deps.archLifecycle.lifecycle_viewmodel_ktx\n\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\ninterface LoginService {\n\n    /**\n     * 手机号码登录\n     * @param requestBody RequestBody?\n     * @return KsResponse<UserBean>\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @POST(\"/pangu/user/login/mobile\")\n    suspend fun loginByMobile(@Body requestBody: RequestBody?): KsResponse<UserBean>\n\n    /**\n     * 发送验证码\n     *\n     * @param encodeMobile\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @GET(\"/pangu/user/login/sms/code\")\n    suspend fun sendSmsCode(@Query(\"mobile\") encodeMobile: String?): KsResponse<Any>\n\n\n    /**\n     * 微信、华为 请求检查是否需要绑定手机号\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @POST(\"/pangu/user/checkLoginBindMobile\")\n    suspend fun checkLogin(@Body requestBody: RequestBody?): KsResponse<CheckLoginResult>\n\n\n    /**\n     * 微信登录\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @POST(\"/pangu/user/weChat/login\")\n    suspend fun loginByWeixin(@Body requestBody: RequestBody?): KsResponse<UserBean>\n}\n\n\n\n\n\n\n\n@Parcelize\ndata class UserBean(\n        val bindMobileText: String? = null,\n        val birthday: String? = null,\n        val currentAccount: String? = null,\n        val deviceId: String? = null,\n        val emptyBirthday: Boolean? = null,\n        val emptySex: Boolean? = null,\n        val firstLogin: Boolean? = null,\n        val headImgUrl: String? = null,\n        val isShowBindMobile: Int? = null,\n        val isSkip: Int? = null,\n        val loginType: String? = null,\n        val mobile: String? = null,\n        val nickname: String? = null,\n        val refreshToken: String? = null,\n        val regDateTime: Long? = null,\n        val sex: String? = null,\n        val token: String? = null,\n        val uid: String? = null,\n        val unionId: String? = null,\n        val userId: String? = null,\n        val refreshTokenTimeStamp : Long? = null\n) : Parcelable\n\n\n\n\n\n\n\n\n@IntDef({\n        LoginType.mobile, LoginType.wechat, LoginType.huawei\n})\n@Retention(RetentionPolicy.SOURCE)\n@Target({ElementType.PARAMETER, ElementType.FIELD})\npublic @interface LoginType {\n\n\n    int mobile = 2;\n    int wechat = 3;\n    int huawei = 4;\n\n}\n\n\n\n\n\n\n\n\n\n\n\nobject LoginConstants {\n    const val DEVICE_LIMITE_CODE = 4024 // 多人登陆\n\n    const val DEVICE_BLOCK_LOGIN_CODE = 4025 // 账号封杀\n\n    const val DEVICE_BIND_FAIL_CODE = 4026 // 账号绑定失败 两个账号都已经开通会员\n\n    const val DEVICE_BLOCK_BIND_FAIL_CODE = 4027 // 账号绑定失败 会员冻结期间不允许绑定\n\n    const val DEVICE_VIP_FREEZED_CODE = 4029 // 会员冻结\n\n    const val ACCOUNTCANCELLATION_CODE = 4030 // 帐号注销\n\n}\n\n\n\nlogin\nmodel\napi\nLoginService\nbean\nBindMobileInfo\nCheckLoginResult\nIllegalLogin\nLoginInfo\nLoginRequestBean\nLoginType\nSmsCodeBean\nUserInfoVO\nUserKt.kt\nWeixinAuthBean\nrepository\nLoginRepository\nLoginRepositoryImpl\nviewmodel\nLoginViewModel\nLoginViewModelImpl\nLoginConstants\nUserInfoHolder\nres\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598586254438},"updatedAt":{"$$date":1598592632295},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WLDjUHEGMxoCbgs3"}
{"name":"ad-ksswipeback","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.app_compat\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\nRelateSlider\nSwipeBackHelper\nSwipeBackLayout\nSwipeBackPage\nSwipeListener\nUtils\nViewDragHelper"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598519923565},"updatedAt":{"$$date":1598521125959},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WTIvTktT6vZLpRlH"}
{"name":"andr-应用清单","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\ndeveloper.android.google.cn /guide/topics/manifest/manifest-intro\n应用清单概览  |  Android 开发者  |  Android Developers\n7-9 minutes\n每个应用项目必须在项目源设置的根目录中加入 AndroidManifest.xml 文件（且必须使用此名称）。 清单文件会向 Android 构建工具、Android 操作系统和 Google Play 描述应用的基本信息。\n\n重点是，清单文件需声明以下内容：\n\n应用的软件包名称，其通常与代码的命名空间相匹配。 构建项目时，Android 构建工具会使用此信息来确定代码实体的位置。 打包应用时，构建工具会使用 Gradle 构建文件中的应用 ID 来替换此值，而此 ID 则用作系统和 Google Play 上的唯一应用标识符。了解关于软件包名称和应用 ID 的更多内容。\n应用的组件，包括所有 Activity、服务、广播接收器和内容提供程序。 每个组件都必须定义基本属性，例如其 Kotlin 或 Java 类的名称。 清单文件还能声明一些功能，例如其所能处理的设备配置，以及描述组件如何启动的 Intent 过滤器。了解关于应用组件的更多内容。\n应用为访问系统或其他应用的受保护部分所需的权限。 如果其他应用想要访问此应用的内容，则清单文件还会声明其必须拥有的权限。 了解关于权限的更多内容。\n应用需要的硬件和软件功能，这些功能会影响哪些设备能够从 Google Play 安装应用。了解关于设备兼容性的更多内容。\n如果您使用 Android Studio 构建应用，则系统会为您创建清单文件，并在您构建应用时（尤其是在使用代码模板时）添加大部分基本清单元素。\n\n文件功能\n下文介绍如何在清单文件中反映某些最重要的应用特性。\n\n软件包名称和应用 ID\n清单文件的根元素需包含应用软件包名称（通常与项目目录结构，即 Java 命名空间相匹配）的属性。\n\n例如，以下代码段显示包含软件包名称 \"com.example.myapp\" 的 <manifest> 根元素：\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.myapp\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" >\n    ...\n</manifest>\n在将应用构建为最终的应用软件包 (APK) 时，Android 构建工具会使用 package 属性完成两件事情：\n\n它会将此名称用作应用所生成 R.java 类（用于访问应用资源）的命名空间。\n示例：在上方的清单中，您可以在 com.example.myapp.R 处创建 R 类。\n\n它会使用此名称解析清单文件中声明的任何相关类名称。\n示例：在上方的清单中，系统会将声明为 <activity android:name=\".MainActivity\"> 的 Activity 解析为 com.example.myapp.MainActivity。\n\n因此，清单 package 属性中的名称应始终与项目中保存 Activity 和其他应用代码的基础软件包的名称相匹配。 当然，您可以在项目中加入其他子软件包，但此类文件必须使用 package 属性的命名空间导入 R.java 类。\n\n但请注意，APK 编译完成后，package 属性还可表示应用的通用唯一应用 ID。 当构建工具根据 package 名称执行上述任务后，它们会将 package 值替换为项目 build.gradle 文件（用于 Android Studio 项目）中赋予 applicationId 属性的值。 package 属性的这一最终值必须是通用唯一值，因为这是能确保在系统和 Google Play 中识别应用的唯一方式。\n\n清单中的 package 名称与 build.gradle 文件中 applicationId 的区别可能会令人感到有点困惑。 但若您保持二者一致，便无需担心任何问题。\n\n不过，如果您决定让代码的命名空间（以及清单中的 package 名称）有别于构建文件的 applicationId，请务必完全理解设置应用 ID的影响。 本页面将说明如何不依赖构建文件的 applicationId，安全调整清单的 package 名称，以及如何更改不同构建配置的应用 ID。\n\n应用组件\n对于在应用中创建的每个应用组件，您必须在清单文件中声明相应的 XML 元素：\n\n<activity> 用于 Activity 的每个子类。\n<service> 用于 Service 的每个子类。\n<receiver> 用于 BroadcastReceiver 的每个子类。\n<provider> 用于 ContentProvider 的每个子类。\n如果您创建此类组件的任何子类，但未在清单文件中对其进行声明，则系统便无法启动该子类。\n\n必须使用 name 属性指定子类的名称，且其必须使用完整的软件包名称。 例如，可对 Activity 子类进行如下声明：\n\n<manifest ... >\n    <application ... >\n        <activity android:name=\"com.example.myapp.MainActivity\" ... >\n        </activity>\n    </application>\n</manifest>\n不过，如果 name 值的第一个字符是句点，则应用的软件包名称（来自 <manifest> 元素的 package 属性）将作为此名称的前缀。 例如，以下 Activity 名称将解析为 `\"com.example.myapp.MainActivity\"`：\n\n<manifest package=\"com.example.myapp\" ... >\n    <application ... >\n        <activity android:name=\".MainActivity\" ... >\n            ...\n        </activity>\n    </application>\n</manifest>\n如果您拥有位于子软件包中（如在 com.example.myapp.purchases 中）的应用组件，则 name 值必须添加缺失的子软件包名称（如 \".purchases.PayActivity\"）或使用完全限定的软件包名称。\n\nIntent 过滤器\n应用的 Activity、服务和广播接收器均由 Intent 激活。 Intent 是由 Intent 对象定义的消息，用于描述要执行的操作，其中包括要执行操作的数据、应执行操作的组件类别以及其他相关说明。\n\n当应用向系统发布 Intent 后，系统会根据每个应用清单文件中的 Intent 过滤器来查找可处理此 Intent 的应用组件。 系统会启动匹配组件的实例，并向该组件传递 Intent 对象。 如果有多个应用可以处理此 Intent，则用户可选择使用哪个应用。\n\n应用组件可包含任意数量的 Intent 过滤器（通过 <intent-filter> 元素定义），每个过滤器描述该组件的不同功能。\n\n如需了解更多信息，请参阅 Intent 和 Intent 过滤器文档。\n\n图标和标签\n许多清单元素拥有 icon 和 label 属性，二者分别用于向对应应用组件的用户显示小图标和文本标签。\n\n任何情况下，在父元素中设置的图标和标签都会成为所有子元素的默认 icon 和 label 值。 例如，在 <application> 元素中设置的图标和标签即为每个应用组件（如所有 Activity）的默认图标和标签。\n\n只要以实现 Intent 的选项形式呈现组件，系统便会向用户显示在该组件的 <intent-filter> 中设置的图标和标签。 默认情况下，此图标继承自为父组件（<activity> 或 <application> 元素）声明的任何图标，但如果 Intent 过滤器提供唯一操作，且您希望该操作在选择器对话框中有更好的指示，则您可能需更改此图标。 如需了解更多信息，请参阅允许其他应用启动您的 Activity。\n\n权限\n如要访问敏感用户数据（如联系人和短信）或某些系统功能（如相机和互联网访问），则 Android 应用必须请求相关权限。 每个权限均由唯一标签标识。 例如，如果应用需要发送短信，则必须在清单中添加以下代码行：\n\n<manifest ... >\n    <uses-permission android:name=\"android.permission.SEND_SMS\"/>\n    ...\n</manifest>\n从 Android 6.0（API 级别 23）开始，用户可以在运行时同意或拒绝某些应用权限。 但是，无论您的应用支持哪个 Android 版本，您都必须使用清单中的 <uses-permission> 元素声明所有权限请求。 授予应用权限后，该应用便能使用受保护的功能。 否则，该应用在尝试访问这些功能时会失败。\n\n应用也可使用权限保护自己的组件。 它可以使用 Android 定义的任何权限（如 android.Manifest.permission 中所列），或在其他应用中声明的权限。 应用也可定义自己的权限。 应用可通过 <permission> 元素来声明新权限。\n\n如需了解更多信息，请参阅权限概览。\n\n设备兼容性\n清单文件也可用于声明应用所需的硬件或软件功能类型，以及应用兼容的设备类型。 Google Play 商店不允许在未提供应用所需功能或系统版本的设备上安装应用。\n\n某些清单标签可定义与应用兼容的设备。 以下是一些最常见的此类标签。\n\n<uses-feature>\n<uses-feature> 元素允许您声明应用所需的硬件和软件功能。 例如，如果您的应用无法在缺少罗盘传感器的设备上实现基础功能，则您可使用以下清单标记将罗盘传感器声明为必需功能：\n\n<manifest ... >\n    <uses-feature android:name=\"android.hardware.sensor.compass\"\n                  android:required=\"true\" />\n    ...\n</manifest>\n注意： 如果您想在 Chromebook 上使用自己的应用，则应考虑一些重要的硬件和软件功能限制。 如需了解更多信息，请参阅 Chromebook 的应用清单兼容性。\n\n<uses-sdk>\n每个后续平台版本往往都会新增先前版本未提供的 API。 如要指明与应用兼容的最低版本，您的清单必须包含 <uses-sdk> 标签及其 minSdkVersion 属性。\n\n但请注意，<uses-sdk> 元素中的这些属性会被 build.gradle 文件中的相应属性覆盖。 因此，如果您使用的是 Android Studio，则必须在此处指定 minSdkVersion 和 targetSdkVersion 值：\n\nandroid {\n  defaultConfig {\n    applicationId 'com.example.myapp'// Defines the minimum API level required to run the app.\n    minSdkVersion 15// Specifies the API level used to test the app.\n    targetSdkVersion 28...\n  }\n}\n如需了解关于 build.gradle 文件的更多信息，请阅读如何配置您的构建。\n\n如要详细了解如何声明应用对不同设备的支持，请参阅设备兼容性概览。\n\n文件约定\n此部分描述普遍适用于清单文件中所有元素和属性的约定和规则。\n\n元素\n只有 <manifest> 和 <application> 元素是必需的， 二者必须且只能出现一次。 大多数其他元素可以不出现或多次出现。 但是，必须提供某些元素才能使清单文件发挥作用。\n必须通过属性（而非以元素内的字符数据形式）设置所有值。\n\n同一级别的元素通常不分先后顺序。 例如，<activity>、<provider> 和<service> 元素可按任何顺序放置。 这条规则有两个主要的例外情况：\n\n<activity-alias> 元素必须跟在别名所指的 <activity> 之后。\n<application> 元素必须是 <manifest> 元素内的最后一个元素。\n属性\n严格来说，所有属性都是可选的。 但是，必须指定某些属性才可让元素实现其目的。 对于真正可选的属性，参考文档会指定默认值。\n除了根 <manifest> 元素的某些属性外，所有属性名称均以 android: 前缀开头。 例如，android:alwaysRetainTaskState。 由于该前缀是通用的，因此在按名称引用属性时，参考文档通常会将其忽略。\n\n多个值\n如果可以指定多个值，则几乎总是在重复元素，而非列出单个元素内的多个值。 例如，Intent 过滤器可以列出多个操作：\n<intent-filter ... >\n    <action android:name=\"android.intent.action.EDIT\" />\n    <action android:name=\"android.intent.action.INSERT\" />\n    <action android:name=\"android.intent.action.DELETE\" />\n    ...\n</intent-filter>\n资源值\n某些属性的值可以显示给用户，例如，Activity 的标题或应用图标。 这些属性的值可能因用户的语言或其他设备配置而异（例如根据设备的像素密度提供不同的图标大小），因此您应根据资源或主题设置值，而非将其硬编码到清单文件中。 随后，您可根据为不同设备配置提供的备用资源更改实际值。\n资源将通过以下格式表示为值：\n\n\"@[package:]type/name\"\n\n如果资源由您的应用提供，则您可以忽略软件包名称（其亦适用于资源由库依赖项提供的情况，因为 库资源会合并到您的资源中）。 当您想要使用 Android 框架中的资源时，唯一的其他有效包名称是 android。\n\ntype 是资源类型（例如 string 或 drawable），name 是标识特定资源的名称。 下面是示例：\n\n<activity android:icon=\"@drawable/smallPic\" ... >\n有关如何在项目中添加资源的更多信息，请阅读提供资源。\n\n如要应用主题中定义的值，第一个字符必须是 ?，而非 @：\n\n\"?[package:]type/name\"\n\n字符串值\n如果属性值为字符串，则您必须使用双反斜杠 (\\\\) 来转义字符，例如：使用 \\\\n 表示换行符或使用 \\\\uxxxx 表示 Unicode 字符。\n清单元素参考\n下表提供 AndroidManifest.xml 文件中所有有效元素的参考文档链接。\n\n清单文件示例\n以下 XML 文件为 AndroidManifest.xml 的一个简单示例，该示例为应用声明两个 Activity。\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\"\n    package=\"com.example.myapp\"><!-- Beware that these values are overridden by the build.gradle file -->\n    <uses-sdk android:minSdkVersion=\"15\" android:targetSdkVersion=\"26\" /><application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:label=\"@string/app_name\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\"><!-- This name is resolved to com.example.myapp.MainActivity\n             based upon the package attribute -->\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity><activity\n            android:name=\".DisplayMessageActivity\"\n            android:parentActivityName=\".MainActivity\" />\n    </application>\n</manifest>\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242645987},"updatedAt":{"$$date":1597243135044},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WWTpDkQ70Hapt4Vd"}
{"name":"py-list","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\nPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。\n\n比如，列出班里所有同学的名字，就可以用一个list表示：\n\n>>> classmates = ['Michael', 'Bob', 'Tracy']\n>>> classmates\n['Michael', 'Bob', 'Tracy']\n变量classmates就是一个list。用len()函数可以获得list元素的个数：\n\n>>> len(classmates)\n3\n用索引来访问list中每一个位置的元素，记得索引是从0开始的：\n\n>>> classmates[0]\n'Michael'\n>>> classmates[1]\n'Bob'\n>>> classmates[2]\n'Tracy'\n>>> classmates[3]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。\n\n如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：\n\n>>> classmates[-1]\n'Tracy'\n以此类推，可以获取倒数第2个、倒数第3个：\n\n>>> classmates[-2]\n'Bob'\n>>> classmates[-3]\n'Michael'\n>>> classmates[-4]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n当然，倒数第4个就越界了。\n\nlist是一个可变的有序表，所以，可以往list中追加元素到末尾：\n\n>>> classmates.append('Adam')\n>>> classmates\n['Michael', 'Bob', 'Tracy', 'Adam']\n也可以把元素插入到指定的位置，比如索引号为1的位置：\n\n>>> classmates.insert(1, 'Jack')\n>>> classmates\n['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']\n要删除list末尾的元素，用pop()方法：\n\n>>> classmates.pop()\n'Adam'\n>>> classmates\n['Michael', 'Jack', 'Bob', 'Tracy']\n要删除指定位置的元素，用pop(i)方法，其中i是索引位置：\n\n>>> classmates.pop(1)\n'Jack'\n>>> classmates\n['Michael', 'Bob', 'Tracy']\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：\n\n>>> classmates[1] = 'Sarah'\n>>> classmates\n['Michael', 'Sarah', 'Tracy']\nlist里面的元素的数据类型也可以不同，比如：\n\n>>> L = ['Apple', 123, True]\nlist元素也可以是另一个list，比如：\n\n>>> s = ['python', 'java', ['asp', 'php'], 'scheme']\n>>> len(s)\n4\n要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：\n\n>>> p = ['asp', 'php']\n>>> s = ['python', 'java', p, 'scheme']\n要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。\n\n如果一个list中一个元素也没有，就是一个空的list，它的长度为0：\n\n>>> L = []\n>>> len(L)\n0"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973934421},"updatedAt":{"$$date":1594974810062},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WcCHCkelakDVqByn"}
{"name":"ad-ks_media_wrap","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n    testImplementation deps.androidx.junit\n\n    implementation deps.androidx.app_compat\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    implementation deps.kotlin.kotlin_reflect\n    // 鲁班图片压缩\n    api deps.luban\n\n\n\n    if (rootProject.ext.isUseMediaModle) {\n        api project(\":ks_media_core\")\n        api project(\":ks_media_preview\")\n        api project(\":ks_recored_video\")\n        api project(\":ks_media_picker\")\n        api project(\":ksmediahandler\")\n    } else {\n        api ks.mediacore\n        api ks.mediapreview\n        api ks.mediacamera\n        api ks.mediapicker\n        api ks.ksmediahandler\n    }\n\n\n}\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\nmedia\nBaseMode\nCameraMode\nCompressTask\nMediaCenter\nMediaDigist\nPickMode\nPreviewMode\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522801713},"updatedAt":{"$$date":1598524162610},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WhhTtoiywHsTnQVY"}
{"name":"qk-app","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\napply plugin: 'com.android.application'\n\napply plugin: 'kotlin-android'\n\napply plugin: 'kotlin-android-extensions'\n\n//apply plugin: 'gitplugin'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        applicationId \"com.ks.ll\"\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        multiDexEnabled true\n\n        ndk {\n            //设置支持的SO库架构\n            abiFilters 'armeabi', 'armeabi-v7a'//, 'arm64-v8a'//, 'x86_64',\n        }\n    }\n\n    signingConfigs {\n        debug {\n            storeFile file('kaishustory.jks')\n            storePassword \"kaishu2099\"\n            keyAlias \"kaishustory\"\n            keyPassword \"kaishu2099\"\n        }\n    }\n\n//    splits {\n//        abi {\n//            enable true\n//            reset()\n//            include 'armeabi-v7a'\n//            universalApk false\n//        }\n//    }\n\n\n    buildTypes {\n        release {\n            minifyEnabled true\n            signingConfig signingConfigs.debug\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n\n            manifestPlaceholders = [\n                    UMENG_APPKEY  : manifesPlaceholder.UMENG_APPKEY, //暂时填写默认值即可.\n\n                    JPUSH_PKGNAME : manifesPlaceholder.JPUSH_PKGNAME,\n                    JPUSH_APPKEY  : manifesPlaceholder.JPUSH_APPKEY.RELEASE, //JPush上注册的包名对应的appkey.\n                    JPUSH_CHANNEL : manifesPlaceholder.JPUSH_CHANNEL, //暂时填写默认值即可.\n\n                    HUAWEI_APPID  : manifesPlaceholder.HUAWEI_APPID,//华为平台注册的appid\n                    XIAOMI_APPKEY : manifesPlaceholder.XIAOMI_APPKEY,\n                    XIAOMI_APPID  : manifesPlaceholder.XIAOMI_APPID,\n                    MEIZU_APPKEY  : manifesPlaceholder.MEIZU_APPKEY,\n                    MEIZU_APPID   : manifesPlaceholder.MEIZU_APPID,\n\n                    OPPO_APPKEY   : manifesPlaceholder.OPPO_APPKEY,\n                    OPPO_APPID    : manifesPlaceholder.OPPO_APPID,\n                    OPPO_APPSECRET: manifesPlaceholder.OPPO_APPSECRET,\n\n                    VIVO_APPKEY   : manifesPlaceholder.VIVO_APPKEY,\n                    VIVO_APPID    : manifesPlaceholder.VIVO_APPID,\n            ]\n        }\n\n        debug {\n            minifyEnabled false\n            signingConfig signingConfigs.debug\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n            manifestPlaceholders = [\n                    UMENG_APPKEY  : manifesPlaceholder.UMENG_APPKEY, //暂时填写默认值即可.\n\n                    JPUSH_PKGNAME : manifesPlaceholder.JPUSH_PKGNAME,\n                    JPUSH_APPKEY  : manifesPlaceholder.JPUSH_APPKEY.RELEASE, //JPush上注册的包名对应的appkey.\n                    JPUSH_CHANNEL : manifesPlaceholder.JPUSH_CHANNEL, //暂时填写默认值即可.\n\n                    HUAWEI_APPID  : manifesPlaceholder.HUAWEI_APPID,//华为平台注册的appid\n                    XIAOMI_APPKEY : manifesPlaceholder.XIAOMI_APPKEY,\n                    XIAOMI_APPID  : manifesPlaceholder.XIAOMI_APPID,\n                    MEIZU_APPKEY  : manifesPlaceholder.MEIZU_APPKEY,\n                    MEIZU_APPID   : manifesPlaceholder.MEIZU_APPID,\n\n                    OPPO_APPKEY   : manifesPlaceholder.OPPO_APPKEY,\n                    OPPO_APPID    : manifesPlaceholder.OPPO_APPID,\n                    OPPO_APPSECRET: manifesPlaceholder.OPPO_APPSECRET,\n\n                    VIVO_APPKEY   : manifesPlaceholder.VIVO_APPKEY,\n                    VIVO_APPID    : manifesPlaceholder.VIVO_APPID,\n            ]\n        }\n    }\n\n\n    repositories {\n        flatDir {\n            dirs KS_PAYMENT_CENTER_DIR_PATH\n            //dirs KS_RECORD_VOICE_DIR_PATH\n            //dirs KS_LIB_RECORD_VOICE_DIR_PATH\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility 1.8\n        targetCompatibility 1.8\n    }\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    implementation deps.kotlin.stdlib_jdk\n    implementation deps.androidx.appcompat\n    implementation deps.androidx.core_ktx\n    implementation deps.support.constraint_layout\n    testImplementation 'junit:junit:4.12'\n    implementation deps.fresco.fresco\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n    if (develop) {\n        implementation project(path: ':ks_component_payment')\n        implementation project(path: ':ks_component_net')\n        implementation project(path: ':ks_component_login')\n        implementation project(path: ':ks_lib_magic_indicator')\n        implementation project(path: ':ks_lib_picture')\n        implementation project(path: ':ks_component_sobot')\n        implementation project(path: ':ks_component_mediaplayer')\n        implementation project(':ks_component_push')\n        implementation project(path: ':ks_lib_address_selector')\n        implementation project(path: ':ks_component_download')\n\n        implementation project(path: ':ks_component_tracker')\n        implementation project(path: ':ks_component_share')\n        implementation project(path: ':ks_component_voicerecorder')\n        implementation project(path: ':ks_component_resource')\n        implementation project(path: ':ks_lib_autosize')\n        implementation project(path: ':ks_lib_persistence')\n        implementation project(path:':ks_lib_loadinglayout')\n\n    } else {\n        implementation ks.component_payment\n        implementation ks.component_net\n        implementation ks.component_login\n        implementation ks.component_sobot\n        implementation ks.component_mediaplayer\n        implementation ks.component_push\n        implementation ks.component_tracker\n        implementation ks.component_share\n        implementation ks.component_voicerecorder\n        implementation ks.component_resource\n        implementation ks.lib_magic_indicator\n        implementation ks.lib_picture\n        implementation ks.lib_address_selector\n        implementation ks.lib_persistence\n        implementation ks.lib_autosize\n        implementation ks.lib_loading\n    }\n\n    implementation project(path:':ks_lib_wheel_picker')\n\n    implementation deps.archLifecycle.lifecycle_viewmodel_ktx\n\n    implementation deps.koin.android_viewmodel\n\n    // debugImplementation because LeakCanary should only run in debug builds.\n    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.4'\n}\n\n\n\n\n\n\n\n   startKoin {\n            androidLogger()\n            androidContext(this@App)\n            modules(mainModule)\n        }\n\n\n\n\n\n\n\nval viewModelModule = module {\n    viewModel { PayViewModel(get()) }\n    viewModel { (activity: Activity) -> LoginViewModelImpl(get(), activity) }\n}\n\nval repositoryModule = module {\n    single<PayRepository> { PayRepositoryImpl() }\n    single<LoginRepository> { LoginRepositoryImpl() }\n}\n\nval mainModule = listOf(viewModelModule, repositoryModule)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage com.ks.kaishustory\n\nimport android.Manifest\nimport android.content.Intent\nimport android.os.Build\nimport android.os.Bundle\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.BaseAdapter\nimport android.widget.TextView\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport com.czt.mp3recorder.Mp3VoiceRecorder\nimport com.ks.component.net.ui.service.DownloadPemService\nimport com.ks.kaishustory.login.LoginActivity\nimport com.ks.kaishustory.payment.PayActivity\nimport com.ks.kaishustory.ui.ActivityMagicIndicatorDemo\nimport com.ks.kaishustory.ui.VideoPlayerActivity\nimport com.ks.kaishustory.ui.activity.*\nimport com.ks.kaishustory.ui.activity.address.AddressSelectorActivity\nimport com.ks.kaishustory.ui.activity.birthday.BirthSelectActivity\nimport com.ks.lib.ktx.ext.permission.request\nimport com.ks.lib.ktx.ext.startKtxActivity\nimport com.ks.ll.R\nimport com.ks.mediaplayer.ksjgs.MediaContext\nimport com.ks.tracker.Tracker\nimport com.ks.voiceanalysis.KsVoiceAnalysisConfig\nimport com.ks.voiceanalysis.RecordVoiceListener\nimport com.ks.voiceanalysis.TencentVoiceAnalysis\nimport com.sobot.chat.utils.SobotChatManager\nimport kotlinx.android.synthetic.main.activity_main.*\nimport org.json.JSONObject\n\nclass MainActivity : AppCompatActivity() {\n    //列表数据\n    private val buttonNames = arrayOf(\n        \"打开支付页面\", \"登录页面\", \"测试录音库\",\n        \"停止录音\", \"测试MAGIC_INDICATOR\", \"测试智齿客服\",\n        \"分享测试\", \"实时打点测试\", \"策略打点\",\n        \"视频播放器\", \"地址选择\", \"下载测试\",\n        \"智玲语音开始评测(只能是英语)\", \"智玲语音结束评测\", \"音频播放器\",\n        \"视频播放器(横屏)\", \"loadingLayout控件页面\", \"年龄选择组件\", \"无控制 视频播放\"\n\n    )\n\n    private lateinit var mp3Recorder: Mp3VoiceRecorder\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        if (Build.VERSION.SDK_INT >= 23) {\n            val mPermissionList = arrayOf(\n                Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                Manifest.permission.ACCESS_FINE_LOCATION,\n                Manifest.permission.READ_PHONE_STATE,\n                Manifest.permission.READ_EXTERNAL_STORAGE\n            )\n            ActivityCompat.requestPermissions(this, mPermissionList, 123)\n        }\n        initData()\n\n        listview.adapter = ListAdapter(buttonNames)\n\n        startDownloadPemService()\n    }\n\n    private fun startDownloadPemService() {\n        val intent = Intent(this, DownloadPemService::class.java)\n        val stringList = ArrayList<String>()\n        stringList.add(\"https://kaishustory-files.oss-cn-beijing.aliyuncs.com/ops/certs/android/enc-kaishustorycom.pem\");\n        intent.putStringArrayListExtra(\"pem_list\", stringList)\n        startService(intent)\n    }\n\n    /**\n     * 做初始化操作\n     */\n    private fun initData() {\n        initMp3Recorder()\n        //初始化智玲sdk\n        initZhiLingSdk()\n\n        MediaContext.mContext = this\n    }\n\n    private fun initMp3Recorder() {\n        mp3Recorder = Mp3VoiceRecorder(this, object : Mp3VoiceRecorder.VolumeListener {\n\n            override fun onVolumeCallBack(volume: Int) {\n\n                println(\"录音的音量回调 $volume\")\n            }\n        })\n    }\n\n    private fun initZhiLingSdk() {\n        KsVoiceAnalysisConfig.initOral(\n            KsVoiceAnalysisConfig.appId,\n            KsVoiceAnalysisConfig.secretId,\n            KsVoiceAnalysisConfig.secretKey\n        )\n    }\n\n    class ViewHolder(view: View) {\n        var tvTitleName: TextView = view.findViewById(R.id.tv_item_name)\n    }\n\n    inner class ListAdapter(private var dataList: Array<String>) : BaseAdapter() {\n\n        override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {\n            var view: View\n            val holder: ViewHolder\n\n            if (convertView == null) {\n                view = View.inflate(parent?.context, R.layout.adapter_main_item, null)\n                holder = ViewHolder(view)\n                view.tag = holder\n            } else {\n                view = convertView\n                holder = view.tag as ViewHolder\n            }\n\n            val itemTitle = dataList[position]\n            holder.tvTitleName.text = itemTitle\n\n            holder.tvTitleName.setOnClickListener {\n                when (position) {\n                    0 -> this@MainActivity.startKtxActivity<PayActivity>()\n                    1 -> this@MainActivity.startKtxActivity<LoginActivity>()\n                    2 -> testVoiceRecorder()\n                    3 -> stopVoiceRecord()\n                    4 -> startKtxActivity<ActivityMagicIndicatorDemo>()\n                    5 -> SobotChatManager.get().startSobotChat(this@MainActivity)\n                    6 -> Toast.makeText(this@MainActivity, \"点击了去分享\", Toast.LENGTH_LONG).show()\n                    7 -> uploadPointRealTime()\n                    8 -> tacticsPoint()\n                    9 -> startKtxActivity<VideoPlayerActivity>()\n                    10 -> startKtxActivity<AddressSelectorActivity>()\n                    11 -> startKtxActivity<KsDownloadActivity>()\n                    12 -> startZhiLingRecord()\n                    13 -> stopZhiLingRecord()\n                    14 -> startKtxActivity<AudioPlayerActivity>()\n                    15 -> startKtxActivity<VideoPlayerActivity2>()\n                    16 -> startKtxActivity<LoadingLayoutActivity>()\n                    17 -> startKtxActivity<BirthSelectActivity>()\n                    18 -> startKtxActivity<NoControlVideoActivity>()\n                }\n            }\n            return view\n        }\n\n        override fun getItem(position: Int): Any {\n            return dataList[position]\n        }\n\n        override fun getItemId(position: Int): Long {\n            return position.toLong()\n        }\n\n        override fun getCount(): Int {\n            return dataList.size\n        }\n    }\n\n    /**\n     * 开始录音\n     */\n    fun testVoiceRecorder() {\n        request(Manifest.permission.RECORD_AUDIO)\n        mp3Recorder.startReording(\"kotlin_voice\")\n    }\n\n    /**\n     * 停止录音\n     */\n    private fun stopVoiceRecord() {\n        mp3Recorder?.stopRecordVoice()?.let {\n            println(\"结束录音，录音时长为 $it\")\n        }\n    }\n\n    /**\n     * 实时打点测试\n     */\n    private fun uploadPointRealTime() {\n        var data = JSONObject().apply {\n            put(\"time\", System.currentTimeMillis())\n            put(\"author\", \"whg\")\n        }\n        Tracker.instance.trackEvent(\"main\", \"test\", \"\", data, true)\n\n\n    }\n\n    /**\n     * 策略打点\n     */\n    private fun tacticsPoint() {\n        var data = JSONObject().apply {\n            put(\"time\", System.currentTimeMillis())\n            put(\"author\", \"whg\")\n            put(\"content\", \"哈哈哈哈哈\")\n        }\n        Tracker.instance.trackEvent(\"main\", \"test\", \"\", data)\n    }\n\n\n    private lateinit var analysis: TencentVoiceAnalysis\n    /**\n     * 开始智玲语音录制\n     */\n    private fun startZhiLingRecord() {\n        Toast.makeText(this@MainActivity, \"开始语音评测\", Toast.LENGTH_LONG).show()\n        analysis = TencentVoiceAnalysis(this@MainActivity);\n        val endDuraton = 0//如果需要n秒后自动结束，传入结束时长 单位秒\n        analysis.startRecorder(endDuraton, \"I am a boy\", object : RecordVoiceListener {\n            override fun onVolumeChanged(newVolume: Int) {\n\n            }\n\n            override fun onScoreOut(score: Double, fileName: String?) {\n                Toast.makeText(this@MainActivity, \"您的评分为：$score\", Toast.LENGTH_LONG).show()\n                println(\"语音评测已结束，评分是 $score\")\n            }\n\n            override fun onAutoComplete() {\n                println(\"倒计时自动停止了语音评测\")\n            }\n\n            override fun onRecordStarted() {\n                TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n            }\n\n            override fun onError(errorCode: Int, errorMsg: String?) {\n                println(\"语音评测出现了错误 $errorCode  错误信息： $errorMsg\")\n            }\n        });\n    }\n\n    /**\n     * 手动 停止语音评测\n     */\n    private fun stopZhiLingRecord() {\n        analysis?.stopRecord(true)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\nassets\ncdn.kaishuhezi.com.pem\ncharles-ssl-proxying-certificate.pem\nkaishustorycom.pem\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598586257779},"updatedAt":{"$$date":1598593062807},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WkPzD4oysneCPTRc"}
{"name":"CSS3 简介","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 简介\n对CSS3已完全向后兼容，所以你就不必改变现有的设计。浏览器将永远支持CSS2。\n\nCSS3 模块\nCSS3被拆分为\"模块\"。旧规范已拆分成小块，还增加了新的。\n\n一些最重要CSS3模块如下：\n\n选择器\n盒模型\n背景和边框\n文字特效\n2D/3D转换\n动画\n多列布局\n用户界面\nCSS3 建议\nW3C的CSS3规范仍在开发。\n\n但是，许多新的CSS3属性已在现代浏览器使用。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974605790},"updatedAt":{"$$date":1598974678128},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WxEm4Qq3nuVObE9l"}
{"name":"qk-ks_lib_autosize","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\nvalues\nvalues-sw320dp\nvalues-sw360dp\nvalues-sw384dp\nvalues-sw392dp\nvalues-sw400dp\nvalues-sw410dp\nvalues-sw411dp\nvalues-sw432dp\nvalues-sw480dp\nvalues-sw533dp\nvalues-sw592dp\nvalues-sw600dp\nvalues-sw640dp\nvalues-sw662dp\nvalues-sw720dp\nvalues-sw768dp\nvalues-sw800dp\nvalues-sw811dp\nvalues-sw820dp\nvalues-sw960dp\nvalues-sw961dp\nvalues-sw1024dp\nvalues-sw1280dp\nvalues-sw1365dp\n\n\n\n\n\n\n\n\n\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 100\n        versionName \"100\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n\n\n\n}\n\ndependencies {\n\n}\n\nrepositories {\n    mavenCentral()\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598584065659},"updatedAt":{"$$date":1598584487672},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WyqNw2HtTJmigole"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973277479},"updatedAt":{"$$date":1594973277479},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"X0arW7y7ZqPYdX1Z"}
{"name":"kotlin-DelTextView","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\npackage com.ks.component.ui.view\n\nimport android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.Paint\nimport android.util.AttributeSet\nimport android.widget.TextView\nimport androidx.core.widget.TextViewCompat\nimport com.ks.component.ui.R\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author wuzhiguo\n * 邮箱：wuzhiguo@ksjgs.com\n * 创建时间: 2020-02-17     18:37\n * 用途:\n ***************************************\n */\nclass DelTextView : TextView{\n\n    private val paint: Paint\n    private var isLineVisible = true\n    private var delColor: Int\n\n\n    constructor(context: Context) : this(context, null)\n    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr){\n\n        paint = Paint()\n        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.DelTextView)\n        delColor = typedArray.getColor(R.styleable.DelTextView_del_line_color, currentTextColor)\n\n        typedArray.recycle()\n    }\n\n    override fun draw(canvas: Canvas?) {\n        super.draw(canvas)\n\n        if (delColor == -1){\n            delColor = currentTextColor\n        }\n        if (isLineVisible) {\n            paint.color = delColor\n            paint.isAntiAlias = true\n            paint.strokeWidth = 1.0.toFloat()\n            canvas?.drawLine(0f, (this.height / 2).toFloat(), this.width.toFloat(), (this.height / 2).toFloat(), paint)\n        }\n    }\n\n\n    fun showDelLine(visible: Boolean) {\n        this.isLineVisible = visible\n        invalidate()\n    }\n\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403207745},"updatedAt":{"$$date":1597403785082},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"XDuVOy3QDbYGTCaa"}
{"name":"ad-baseRecyclerViewAdapterHelper 庆哥","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\n//apply plugin: 'kotlin-kapt'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n    }\n\n    buildTypes {\n        release {\n            consumerProguardFiles 'proguard-rules.pro'\n        }\n        debug {\n            consumerProguardFiles 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        kotlinOptions.freeCompilerArgs += ['-module-name', \"com.github.CymChad.brvah\"]\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n\n    dataBinding {\n        enabled = true\n    }\n}\n\n// 打包源码jar\ntask sourcesJar(type: Jar) {\n    from android.sourceSets.main.java.srcDirs\n    archiveClassifier = 'sources'\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    //implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    //implementation 'androidx.recyclerview:recyclerview:1.1.0'\n    implementation deps.androidx.recyclerview_v7\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598525725820},"updatedAt":{"$$date":1598538108179},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"XE9OFZ0QZxhSruaT"}
{"name":"css-CSS 布局 - 水平 & 垂直对齐","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 布局 - 水平 & 垂直对齐\n水平 & 垂直居中对齐\n元素居中对齐\n要水平居中对齐一个元素(如 <div>), 可以使用 margin: auto;。\n\n设置到元素的宽度将防止它溢出到容器的边缘。\n\n元素通过指定宽度，并将两边的空外边距平均分配：\n\ndiv 元素是居中的\n\n\n实例\n.center {\n    margin: auto;\n    width: 50%;\n    border: 3px solid green;\n    padding: 10px;\n}\n\n尝试一下 »\n注意: 如果没有设置 width 属性(或者设置 100%)，居中对齐将不起作用。\n\n文本居中对齐\n如果仅仅是为了文本在元素内居中对齐，可以使用 text-align: center;\n\n文本居中对齐\n\n\n实例\n.center {\n    text-align: center;\n    border: 3px solid green;\n}\n\n尝试一下 »\n提示: 更多文本对齐实例，请参阅 CSS 文本 章节。\n\n图片居中对齐\n要让图片居中对齐, 可以使用 margin: auto; 并将它放到 块 元素中:\n\nParis\n实例\nimg {\n    display: block;\n    margin: auto;\n    width: 40%;\n}\n\n尝试一下 »\n左右对齐 - 使用定位方式\n我们可以使用 position: absolute; 属性来对齐元素:\n\n菜鸟教程 -- 学的不仅是技术，更是梦想！！！\n\n\n实例\n.right {\n    position: absolute;\n    right: 0px;\n    width: 300px;\n    border: 3px solid #73AD21;\n    padding: 10px;\n}\n\n尝试一下 »\n注释：绝对定位元素会被从正常流中删除，并且能够交叠元素。\n\n提示: 当使用 position 来对齐元素时, 通常 <body> 元素会设置 margin 和 padding 。 这样可以避免在不同的浏览器中出现可见的差异。\n\n当使用 position 属性时，IE8 以及更早的版本存在一个问题。如果容器元素（在我们的案例中是 <div class=\"container\">）设置了指定的宽度，并且省略了 !DOCTYPE 声明，那么 IE8 以及更早的版本会在右侧增加 17px 的外边距。这似乎是为滚动条预留的空间。当使用 position 属性时，请始终设置 !DOCTYPE 声明：\n\n\n实例\nbody {\n    margin: 0;\n    padding: 0;\n}\n \n.container {\n    position: relative;\n    width: 100%;\n}\n \n.right {\n    position: absolute;\n    right: 0px;\n    width: 300px;\n    background-color: #b0e0e6;\n}\n\n尝试一下 »\n左右对齐 - 使用 float 方式\n我们也可以使用 float 属性来对齐元素:\n\n实例\n.right {\n    float: right;\n    width: 300px;\n    border: 3px solid #73AD21;\n    padding: 10px;\n}\n\n尝试一下 »\n当像这样对齐元素时，对 <body> 元素的外边距和内边距进行预定义是一个好主意。这样可以避免在不同的浏览器中出现可见的差异。\n\n注意：如果子元素的高度大于父元素，且子元素设置了浮动，那么子元素将溢出，这时候你可以使用 \"clearfix(清除浮动)\" 来解决该问题。\n\n我们可以在父元素上添加 overflow: auto; 来解决子元素溢出的问题:\n\n实例\n.clearfix {\n    overflow: auto;\n}\n\n尝试一下 »\n当使用 float 属性时，IE8 以及更早的版本存在一个问题。如果省略 !DOCTYPE 声明，那么 IE8 以及更早的版本会在右侧增加 17px 的外边距。这似乎是为滚动条预留的空间。当使用 float 属性时，请始终设置 !DOCTYPE 声明：\n\n实例\nbody {\n    margin: 0;\n    padding: 0;\n}\n \n.right {\n    float: right;\n    width: 300px;\n    background-color: #b0e0e6;\n}\n\n尝试一下 »\n垂直居中对齐 - 使用 padding\nCSS 中有很多方式可以实现垂直居中对齐。 一个简单的方式就是头部顶部使用 padding:\n\n我是垂直居中。\n\n\n实例\n.center {\n    padding: 70px 0;\n    border: 3px solid green;\n}\n\n尝试一下 »\n如果要水平和垂直都居中，可以使用 padding 和 text-align: center:\n\n我是水平和垂直都居中的。\n\n\n实例\n.center {\n    padding: 70px 0;\n    border: 3px solid green;\n    text-align: center;\n}\n\n尝试一下 »\n垂直居中 - 使用 line-height\n我是垂直居中的。\n\n实例\n.center {\n    line-height: 200px;\n    height: 200px;\n    border: 3px solid green;\n    text-align: center;\n}\n \n/* 如果文本有多行，添加以下代码: */\n.center p {\n    line-height: 1.5;\n    display: inline-block;\n    vertical-align: middle;\n}\n\n尝试一下 »\n垂直居中 - 使用 position 和 transform\n除了使用 padding 和 line-height 属性外,我们还可以使用 transform 属性来设置垂直居中:\n\n\n实例\n.center { \n    height: 200px;\n    position: relative;\n    border: 3px solid green; \n}\n \n.center p {\n    margin: 0;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n\n尝试一下 »\n提示: 更多 transform 属性内容可以参阅 2D 翻转章节。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973610051},"updatedAt":{"$$date":1598973750991},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"XEATrREnB7ceExGr"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597404256012},"updatedAt":{"$$date":1597404256012},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"XFQBD7AgdS3pFgMU"}
{"name":"andr-将 Kotlin 协程与架构组件一起使用","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/architecture/coroutines\n将 Kotlin 协程与架构组件一起使用  |  Android 开发者  |  Android Developers\n7-9 minutes\nKotlin 协程提供了一个可供您编写异步代码的 API。通过 Kotlin 协程，您可以定义 CoroutineScope，以帮助您管理何时应运行协程。每个异步操作都在特定范围内运行。\n\n架构组件针对应用中的逻辑范围以及与 LiveData 的互操作层为协程提供了一流的支持。 本主题介绍了如何有效地结合使用协程与架构组件。\n\n添加 KTX 依赖项\n本主题中介绍的内置协程范围包含在每个相应架构组件的 KTX 扩展程序中。请务必在使用这些范围时添加相应的依赖项。\n\n对于 ViewModelScope，请使用 androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0-beta01 或更高版本。\n对于 LifecycleScope，请使用 androidx.lifecycle:lifecycle-runtime-ktx:2.2.0-alpha01 或更高版本。\n对于 liveData，请使用 androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha01 或更高版本。\n生命周期感知型协程范围\n架构组件定义了以下内置范围供您在应用中使用。\n\nViewModelScope\n为应用中的每个 ViewModel 定义了 ViewModelScope。如果 ViewModel 已清除，则在此范围内启动的协程都会自动取消。如果您具有仅在 ViewModel 处于活动状态时才需要完成的工作，此时协程非常有用。例如，如果要为布局计算某些数据，则应将工作范围限定至 ViewModel，以便在 ViewModel 清除后，系统会自动取消工作以避免消耗资源。\n\n您可以通过 ViewModel 的 viewModelScope 属性访问 ViewModel 的 CoroutineScope，如以下示例所示：\n\nclass MyViewModel: ViewModel() {\n        init {\n            viewModelScope.launch {\n                // Coroutine that will be canceled when the ViewModel is cleared.\n            }\n        }\n    }\n    \nLifecycleScope\n为每个 Lifecycle 对象定义了 LifecycleScope。在此范围内启动的协程会在 Lifecycle 被销毁时取消。您可以通过 lifecycle.coroutineScope 或 lifecycleOwner.lifecycleScope 属性访问 Lifecycle 的 CoroutineScope。\n\n以下示例演示了如何使用 lifecycleOwner.lifecycleScope 异步创建预计算文本：\n\nclass MyFragment: Fragment() {\n        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            viewLifecycleOwner.lifecycleScope.launch {\n                val params = TextViewCompat.getTextMetricsParams(textView)\n                val precomputedText = withContext(Dispatchers.Default) {\n                    PrecomputedTextCompat.create(longTextContent, params)\n                }\n                TextViewCompat.setPrecomputedText(textView, precomputedText)\n            }\n        }\n    }\n    \n暂停生命周期感知型协程\n即使 CoroutineScope 提供了适当的方法来自动取消长时间运行的操作，在某些情况下，您可能需要暂停执行代码块（除非 Lifecycle 处于特定状态）。例如，要运行 FragmentTransaction，您必须等到 Lifecycle 至少为 STARTED。对于这些情况，Lifecycle 提供了其他方法：lifecycle.whenCreated、lifecycle.whenStarted 和 lifecycle.whenResumed。如果 Lifecycle 未至少处于所需的最低状态，则会暂停在这些块内运行的任何协程。\n\n以下示例包含仅当关联的 Lifecycle 至少处于 STARTED 状态时才会运行的代码块：\n\nclass MyFragment: Fragment {\n        init { // Notice that we can safely launch in the constructor of the Fragment.\n            lifecycleScope.launch {\n                whenStarted {\n                    // The block inside will run only when Lifecycle is at least STARTED.\n                    // It will start executing when fragment is started and\n                    // can call other suspend methods.\n                    loadingView.visibility = View.VISIBLE\n                    val canAccess = withContext(Dispatchers.IO) {\n                        checkUserAccess()\n                    }// When checkUserAccess returns, the next line is automatically\n                    // suspended if the Lifecycle is not *at least* STARTED.\n                    // We could safely run fragment transactions because we know the\n                    // code won't run unless the lifecycle is at least STARTED.\n                    loadingView.visibility = View.GONE\n                    if (canAccess == false) {\n                        findNavController().popBackStack()\n                    } else {\n                        showContent()\n                    }\n                }// This line runs only after the whenStarted block above has completed.}\n        }\n    }\n    \n如果在协程处于活动状态时通过某种 when 方法销毁了 Lifecycle，协程会自动取消。在以下示例中，一旦 Lifecycle 状态变为 DESTROYED，finally 块即会运行：\n\nclass MyFragment: Fragment {\n        init {\n            lifecycleScope.launchWhenStarted {\n                try {\n                    // Call some suspend functions.\n                } finally {\n                    // This line might execute after Lifecycle is DESTROYED.\n                    if (lifecycle.state >= STARTED) {\n                        // Here, since we've checked, it is safe to run any\n                        // Fragment transactions.\n                    }\n                }\n            }\n        }\n    }\n    \n将协程与 LiveData 一起使用\n使用 LiveData 时，您可能需要异步计算值。例如，您可能需要检索用户的偏好设置并将其传送给界面。在这些情况下，您可以使用 liveData 构建器函数调用 suspend 函数，并将结果作为 LiveData 对象传送。\n\n在以下示例中，loadUser() 是在其他位置声明的暂停函数。使用 liveData 构建器函数异步调用 loadUser()，然后使用 emit() 发出结果：\n\nval user: LiveData<User> = liveData {\n        val data = database.loadUser() // loadUser is a suspend function.\n        emit(data)\n    }\n    \nliveData 构建块用作协程和 LiveData 之间的结构化并发基元。当 LiveData 变为活动状态时，代码块开始执行；当 LiveData 变为非活动状态时，代码块会在可配置的超时过后自动取消。如果代码块在完成前取消，则会在 LiveData 再次变为活动状态后重启；如果在上次运行中成功完成，则不会重启。请注意，代码块只有在自动取消的情况下才会重启。如果代码块由于任何其他原因（例如，抛出 CancelationException）而取消，则不会重启。\n\n您还可以从代码块中发出多个值。每次 emit() 调用都会暂停执行代码块，直到在主线程上设置 LiveData 值。\n\nval user: LiveData<Result> = liveData {\n        emit(Result.loading())\n        try {\n            emit(Result.success(fetchUser()))\n        } catch(ioException: Exception) {\n            emit(Result.error(ioException))\n        }\n    }\n    \n您也可以将 liveData 与 Transformations 结合使用，如以下示例所示：\n\nclass MyViewModel: ViewModel() {\n        private val userId: LiveData<String> = MutableLiveData()\n        val user = userId.switchMap { id ->\n            liveData(context = viewModelScope.coroutineContext + Dispatchers.IO) {\n                emit(database.loadUserById(id))\n            }\n        }\n    }\n    \n您可以从 LiveData 中发出多个值，方法是在每次想要发出新值时调用 emitSource() 函数。请注意，每次调用 emit() 或 emitSource() 都会移除之前添加的来源。\n\nclass UserDao: Dao {\n        @Query(\"SELECT * FROM User WHERE id = :id\")\n        fun getUser(id: String): LiveData<User>\n    }class MyRepository {\n        fun getUser(id: String) = liveData<User> {\n            val disposable = emitSource(\n                userDao.getUser(id).map {\n                    Result.loading(it)\n                }\n            )\n            try {\n                val user = webservice.fetchUser(id)\n                // Stop the previous emission to avoid dispatching the updated user\n                // as `loading`.\n                disposable.dispose()\n                // Update the database.\n                userDao.insert(user)\n                // Re-establish the emission with success type.\n                emitSource(\n                    userDao.getUser(id).map {\n                        Result.success(it)\n                    }\n                )\n            } catch(exception: IOException) {\n                // Any call to `emit` disposes the previous one automatically so we don't\n                // need to dispose it here as we didn't get an updated value.\n                emitSource(\n                    userDao.getUser(id).map {\n                        Result.error(exception, it)\n                    }\n                )\n            }\n        }\n    }\n    \n如需更多与协程相关的信息，请参阅以下链接：\n\n利用 Kotlin 协程提升应用性能\n协程概览\n在 CoroutineWorker 中进行线程处理\n其他资源\n要详细了解如何将协程与架构组件一起使用，请参阅下面列出的其他资源。\n\n示例\nKotlin 协程与架构组件\n博客\nAndroid 上的协程：应用模式\nAndroid 中的简易协程：viewModelScope\n在协程中测试两个连续的 LiveData 发出对象"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243908881},"updatedAt":{"$$date":1597244731299},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"XRiR47ijoALhZc5W"}
{"name":"CSS 教程","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"\n\n\n\n\n\nCSS 教程\n通过使用 CSS 我们可以大大提升网页开发的工作效率！\n\n在我们的 CSS 教程中，您会学到如何使用 CSS 同时控制多重网页的样式和布局。\n\n各章节实例\n本 CSS 教程包含了数百个CSS在线实例\n\n通过本站的在线编辑器，你可以在线编辑CSS,并且可以在线查看修改后的效果。\n\nCSS 实例\nbody\n{\n    background-color:#d0e4fe;\n}\nh1\n{\n    color:orange;\n    text-align:center;\n}\np\n{\n    font-family:\"Times New Roman\";\n    font-size:20px;\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888490946},"updatedAt":{"$$date":1598888517293},"_id":"Xeyx4rj5O2VVh0FE","folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-资源类型概览","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"developer.android.google.cn /guide/topics/resources/available-resources\n资源类型概览  |  Android 开发者  |  Android Developers\n2-2 minutes\n本部分中的每个页面介绍了一种您可以在项目资源目录 (res/) 中提供的应用资源的用法、格式和语法。\n\n以下是对每个页面的简要说明：\n\n动画资源\n定义预先确定的动画。\n补间动画保存在 res/anim/ 中并通过 R.anim 类访问。\n帧动画保存在 res/drawable/ 中并通过 R.drawable 类访问。\n颜色状态列表资源\n定义根据 View 状态而变化的颜色资源。\n保存在 res/color/ 中并通过 R.color 类访问。\n可绘制资源\n使用位图或 XML 定义各种图形。\n保存在 res/drawable/ 中并通过 R.drawable 类访问。\n布局资源\n定义应用界面的布局。\n保存在 res/layout/ 中并通过 R.layout 类访问。\n菜单资源\n定义应用菜单的内容。\n保存在 res/menu/ 中并通过 R.menu 类访问。\n字符串资源\n定义字符串、字符串数组和复数形式（并包括字符串格式和样式）。\n保存在 res/values/ 中，并通过 R.string、R.array 和 R.plurals 类访问。\n样式资源\n定义界面元素的外观和格式。\n保存在 res/values/ 中并通过 R.style 类访问。\n字体资源\n在 XML 中定义字体系列并包含自定义字体。\n保存在 res/font/ 中并通过 R.font 类访问。\n更多资源类型\n将其他原始值定义为静态资源，具体包括：\nBool\n包含布尔值的 XML 资源。\n颜色\n包含颜色值（十六进制颜色）的 XML 资源。\n维度\n包含维度值（及度量单位）的 XML 资源。\nID\n为应用资源和组件提供唯一标识符的 XML 资源。\n整数\n包含整数值的 XML 资源。\n整数数组\n提供整数数组的 XML 资源。\n类型化数组\n提供 TypedArray（可用于可绘制对象数组）的 XML 资源。\nContent and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2020-01-07 UTC."}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594980152912},"updatedAt":{"$$date":1597242242941},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"XpGStpIuXdRdEBzE"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975879603},"updatedAt":{"$$date":1598975879603},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Xt0vJbVysLi9OIvA"}
{"name":"Untitled snippet","folderId":null,"content":[{"label":"Fragment 1","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594709019986},"updatedAt":{"$$date":1594709019986},"_id":"XwNmnCdkgGDihMy9"}
{"name":"ad-","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539556218},"updatedAt":{"$$date":1598539556218},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"Y0LDVHxoYX5Zmk2c"}
{"name":"kotlin-Kotlin 类和对象 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-class-object.html\nKotlin 类和对象 | 菜鸟教程\n7-8 minutes\n类定义\nKotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。\n\nKotlin 中使用关键字 class 声明类，后面紧跟类名：\n\nclass Runoob {  // 类名为 Runoob\n    // 大括号内是类体构成\n}\n我们也可以定义一个空类：\n\nclass Empty\n可以在类中定义成员函数：\n\nclass Runoob() {\n    fun foo() { print(\"Foo\") } // 成员函数\n}\n类的属性\n属性定义\n类的属性可以用关键字 var 声明为可变的，否则使用只读关键字 val 声明为不可变。\n\nclass Runoob {\n    var name: String = ……\n    var url: String = ……\n    var city: String = ……\n}\n我们可以像使用普通函数那样使用构造函数创建类实例：\n\nval site = Runoob() // Kotlin 中没有 new 关键字\n要使用一个属性，只要用名称引用它即可\n\nsite.name           // 使用 . 号来引用\nsite.url\nKoltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后:\n\nclass Person constructor(firstName: String) {}\n如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。\n\nclass Person(firstName: String) {\n}\ngetter 和 setter\n属性声明的完整语法：\n\nvar <propertyName>[: <PropertyType>] [= <property_initializer>]\n    [<getter>]\n    [<setter>]\n \ngetter 和 setter 都是可选\n\n如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。\n\nvar allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法\nvar initialized = 1    // 类型为 Int, 默认实现了 getter 和 setter\nval simple: Int?       // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化\nval inferredType = 1   // 类型为 Int 类型,默认实现 getter\n实例\n以下实例定义了一个 Person 类，包含两个可变变量 lastName 和 no，lastName 修改了 getter 方法，no 修改了 setter 方法。\n\nclass Person {\n\n    var lastName: String = \"zhang\"\n        get() = field.toUpperCase()   // 将变量赋值后转换为大写\n        set\n\n    var no: Int = 100\n        get() = field                // 后端变量\n        set(value) {\n            if (value < 10) {       // 如果传入的值小于 10 返回该值\n                field = value\n            } else {\n                field = -1         // 如果传入的值大于等于 10 返回 -1\n            }\n        }\n\n    var heiht: Float = 145.4f\n        private set\n}\n\n// 测试\nfun main(args: Array<String>) {\n    var person: Person = Person()\n\n    person.lastName = \"wang\"\n\n    println(\"lastName:${person.lastName}\")\n\n    person.no = 9\n    println(\"no:${person.no}\")\n\n    person.no = 20\n    println(\"no:${person.no}\")\n\n}\n输出结果为：\n\nlastName:WANG\nno:9\nno:-1\nKotlin 中类不能有字段。提供了 Backing Fields(后端变量) 机制,备用字段使用field关键字声明,field 关键词只能用于属性的访问器，如以上实例：\n\nvar no: Int = 100\n        get() = field                // 后端变量\n        set(value) {\n            if (value < 10) {       // 如果传入的值小于 10 返回该值\n                field = value\n            } else {\n                field = -1         // 如果传入的值大于等于 10 返回 -1\n            }\n        }\n非空属性必须在定义的时候初始化,kotlin提供了一种可以延迟初始化的方案,使用 lateinit 关键字描述属性：\n\npublic class MyTest {\n    lateinit var subject: TestSubject\n\n    @SetUp fun setup() {\n        subject = TestSubject()\n    }\n\n    @Test fun test() {\n        subject.method()  // dereference directly\n    }\n}\n主构造器\n主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。\n\nclass Person constructor(firstName: String) {\n    init {\n        println(\"FirstName is $firstName\")\n    }\n}\n注意：主构造器的参数可以在初始化代码段中使用，也可以在类主体n定义的属性初始化代码中使用。 一种简洁语法，可以通过主构造器来定义属性并初始化属性值（可以是var或val）：\n\nclass People(val firstName: String, val lastName: String) {\n    //...\n}\n如果构造器有注解，或者有可见度修饰符，这时constructor关键字是必须的，注解和修饰符要放在它之前。\n\n实例\n创建一个 Runoob类，并通过构造函数传入网站名：\n\nclass Runoob  constructor(name: String) {  // 类名为 Runoob\n    // 大括号内是类体构成\n    var url: String = \"http://www.runoob.com\"\n    var country: String = \"CN\"\n    var siteName = name\n\n    init {\n        println(\"初始化网站名: ${name}\")\n    }\n\n    fun printTest() {\n        println(\"我是类的函数\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val runoob =  Runoob(\"菜鸟教程\")\n    println(runoob.siteName)\n    println(runoob.url)\n    println(runoob.country)\n    runoob.printTest()\n}\n输出结果为：\n\n初始化网站名: 菜鸟教程\n菜鸟教程\nhttp://www.runoob.com\nCN\n我是类的函数\n次构造函数\n类也可以有二级构造函数，需要加前缀 constructor:\n\nclass Person { \n    constructor(parent: Person) {\n        parent.children.add(this) \n    }\n}\n如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：\n\nclass Person(val name: String) {\n    constructor (name: String, age:Int) : this(name) {\n        // 初始化...\n    }\n}\n如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：\n\nclass DontCreateMe private constructor () {\n}\n注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得 Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。\n\nclass Customer(val customerName: String = \"\")\n实例\nclass Runoob  constructor(name: String) {  // 类名为 Runoob\n    // 大括号内是类体构成\n    var url: String = \"http://www.runoob.com\"\n    var country: String = \"CN\"\n    var siteName = name\n\n    init {\n        println(\"初始化网站名: ${name}\")\n    }\n    // 次构造函数\n    constructor (name: String, alexa: Int) : this(name) {\n        println(\"Alexa 排名 $alexa\")\n    }\n\n    fun printTest() {\n        println(\"我是类的函数\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val runoob =  Runoob(\"菜鸟教程\", 10000)\n    println(runoob.siteName)\n    println(runoob.url)\n    println(runoob.country)\n    runoob.printTest()\n}\n输出结果为：\n\n初始化网站名: 菜鸟教程\nAlexa 排名 10000\n菜鸟教程\nhttp://www.runoob.com\nCN\n我是类的函数\n抽象类\n抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。\n\n注意：无需对抽象类或抽象成员标注open注解。\n\nopen class Base {\n    open fun f() {}\n}\n\nabstract class Derived : Base() {\n    override abstract fun f()\n}\n嵌套类\n我们可以把类嵌套在其他类中，看以下实例：\n\nclass Outer {                  // 外部类\n    private val bar: Int = 1\n    class Nested {             // 嵌套类\n        fun foo() = 2\n    }\n}\n\nfun main(args: Array<String>) {\n    val demo = Outer.Nested().foo() // 调用格式：外部类.嵌套类.嵌套类方法/属性\n    println(demo)    // == 2\n}\n内部类\n内部类使用 inner 关键字来表示。\n\n内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。\n\nclass Outer {\n    private val bar: Int = 1\n    var v = \"成员属性\"\n    /**嵌套内部类**/\n    inner class Inner {\n        fun foo() = bar  // 访问外部类成员\n        fun innerTest() {\n            var o = this@Outer //获取外部类的成员变量\n            println(\"内部类可以引用外部类的成员，例如：\" + o.v)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val demo = Outer().Inner().foo()\n    println(demo) //   1\n    val demo2 = Outer().Inner().innerTest()   \n    println(demo2)   // 内部类可以引用外部类的成员，例如：成员属性\n}\n为了消除歧义，要访问来自外部作用域的 this，我们使用this@label，其中 @label 是一个 代指 this 来源的标签。\n\n匿名内部类\n使用对象表达式来创建匿名内部类：\n\nclass Test {\n    var v = \"成员属性\"\n\n    fun setInterFace(test: TestInterFace) {\n        test.test()\n    }\n}\n\n/**\n * 定义接口\n */\ninterface TestInterFace {\n    fun test()\n}\n\nfun main(args: Array<String>) {\n    var test = Test()\n\n    /**\n     * 采用对象表达式来创建接口对象，即匿名内部类的实例。\n     */\n    test.setInterFace(object : TestInterFace {\n        override fun test() {\n            println(\"对象表达式创建匿名内部类的实例\")\n        }\n    })\n}\n类的修饰符\n类的修饰符包括 classModifier 和_accessModifier_:\n\nclassModifier: 类属性修饰符，标示类本身特性。\n\nabstract    // 抽象类  \nfinal       // 类不可继承，默认属性\nenum        // 枚举类\nopen        // 类可继承，类默认是final的\nannotation  // 注解类\naccessModifier: 访问权限修饰符\n\nprivate    // 仅在同一个文件中可见\nprotected  // 同一个文件中或子类可见\npublic     // 所有调用的地方都可见\ninternal   // 同一个模块中可见\n实例\n// 文件名：example.kt\npackage foo\n\nprivate fun foo() {} // 在 example.kt 内可见\n\npublic var bar: Int = 5 // 该属性随处可见\n\ninternal val baz = 6    // 相同模块内可见"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303692034},"updatedAt":{"$$date":1597303992327},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YCZ5QP7lSIY8z4Bp"}
{"name":"html-HTML 表单和输入","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\nHTML 表单和输入\nHTML 表单用于收集不同类型的用户输入。\n\nExamples\n在线实例\n创建文本字段 (Text field)\n本例演示如何在 HTML 页面创建文本域。用户可以在文本域中写入文本。\n\n创建密码字段\n本例演示如何创建 HTML 的密码域。\n\n（在本页底端可以找到更多实例。）\n\nHTML 表单\n表单是一个包含表单元素的区域。\n\n表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。\n\n表单使用表单标签 <form> 来设置:\n\n<form>\n.\ninput 元素\n.\n</form>\n\nHTML 表单 - 输入元素\n多数情况下被用到的表单标签是输入标签（<input>）。\n\n输入类型是由类型属性（type）定义的。大多数经常被用到的输入类型如下：\n\n文本域（Text Fields）\n文本域通过<input type=\"text\"> 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。\n\n<form>\nFirst name: <input type=\"text\" name=\"firstname\"><br>\nLast name: <input type=\"text\" name=\"lastname\">\n</form>\n浏览器显示如下：\n\nFirst name: \n\nLast name: \n注意:表单本身并不可见。同时，在大多数浏览器中，文本域的默认宽度是 20 个字符。\n\n密码字段\n密码字段通过标签<input type=\"password\"> 来定义:\n\n<form>\nPassword: <input type=\"password\" name=\"pwd\">\n</form>\n浏览器显示效果如下:\n\nPassword: \n注意:密码字段字符不会明文显示，而是以星号或圆点替代。\n\n单选按钮（Radio Buttons）\n<input type=\"radio\"> 标签定义了表单单选框选项\n\n<form>\n<input type=\"radio\" name=\"sex\" value=\"male\">Male<br>\n<input type=\"radio\" name=\"sex\" value=\"female\">Female\n</form>\n浏览器显示效果如下:\n\nMale\nFemale\n复选框（Checkboxes）\n<input type=\"checkbox\"> 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。\n\n<form>\n<input type=\"checkbox\" name=\"vehicle\" value=\"Bike\">I have a bike<br>\n<input type=\"checkbox\" name=\"vehicle\" value=\"Car\">I have a car\n</form>\n浏览器显示效果如下:\n\nI have a bike\nI have a car\n提交按钮(Submit Button)\n<input type=\"submit\"> 定义了提交按钮.\n\n当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。:\n\n<form name=\"input\" action=\"html_form_action.php\" method=\"get\">\nUsername: <input type=\"text\" name=\"user\">\n<input type=\"submit\" value=\"Submit\">\n</form>\n浏览器显示效果如下:\n\nUsername: \n假如您在上面的文本框内键入几个字母，然后点击确认按钮，那么输入数据会传送到 \"html_form_action.php\" 的页面。该页面将显示出输入的结果。\n\nTry it 更多实例\n单选按钮(Radio buttons)\n本例演示如何在 HTML 中创建单选按钮。\n\n复选框(Checkboxes)\n本例演示如何在 HTML 页中创建复选框。用户可以选中或取消选取复选框。\n\n简单的下拉列表\n本例演示如何在 HTML 页面中创建简单的下拉列表框。下拉列表框是一个可选列表。\n\n预选下拉列表\n本例演示如何创建一个简单的带有预选值的下拉列表。\n\n文本域(Textarea)\n本例演示如何创建文本域（多行文本输入控件）。用户可在文本域中写入文本。可写入字符的字数不受限制。\n\n创建按钮\n本例演示如何创建按钮。你可以对按钮上的文字进行自定义。\n\nTry it 表单实例\n带边框的表单\n本例演示如何在数据周围绘制一个带标题的框。\n\n带有输入框和确认按钮的表单\n本例演示如何向页面添加表单。此表单包含两个输入框和一个确认按钮。\n\n带有复选框的表单\n此表单包含两个复选框和一个确认按钮。\n\n带有单选按钮的表单\n此表单包含两个单选框和一个确认按钮。\n\n从表单发送电子邮件\n此例演示如何从表单发送电子邮件。\n\nHTML 表单标签\nNew : HTML5新标签\n\n标签\t描述\n<form>\t定义供用户输入的表单\n<input>\t定义输入域\n<textarea>\t定义文本域 (一个多行的输入控件)\n<label>\t定义了 <input> 元素的标签，一般为输入标题\n<fieldset>\t定义了一组相关的表单元素，并使用外框包含起来\n<legend>\t定义了 <fieldset> 元素的标题\n<select>\t定义了下拉选项列表\n<optgroup>\t定义选项组\n<option>\t定义下拉列表中的选项\n<button>\t定义一个点击按钮\n<datalist>New\t指定一个预先定义的输入控件选项列表\n<keygen>New\t定义了表单的密钥对生成器字段\n<output>New\t定义一个计算结果\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886134740},"updatedAt":{"$$date":1598886663671},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YDrt24DnIXNaFT4K"}
{"name":"新人入职文档","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"账号申请：\nGitlab账号申请，钉钉 给运维 王安应 或 刘超发消息，申请Gitlab账号，一般账号为：yourname@ksjgs.com\nGerrit账号申请，入职后，@yangqing 或 @wangyanan 申请gerrit账号\nVPN软件安装，百度tunnelblick，下载mac版本\n服务器地址：\ngerrit服务器地址： http://10.0.20.167:80/                     账号密码：yourname/yourname\njenkins服务器地址： http://10.0.20.167:8080/              账号密码：admin/kaishu9527\ngitlab地址：http://gitlab.devops.kaishustory.com       账号密码：yourname@ksjgs.com/运维给的初始化密码\n一、 环境变量配置\n1.首先安装并配置jdk、sdk、adb\n2.根据自己的邮箱(使用公司邮箱) 生成ssh key, 包括id_rsa.pub 和 id_rsa 两个key文件\nssh key 生成\nssh key 的生成方式，使用命令:\nssh-keygen -t rsa -C \"your_email@example.com\"\n例如：\nssh-keygen -t rsa -C \"zhangsan@ksjgs.com\"\n提示输入密码时，直接回车即可。\nssh key 查看\nvim ~/.ssh/id_rsa.pub\n二、React Native 基础环境搭建\n必须安装的依赖有：Node和 React Native 命令行工具。如果你已经安装了 Node，请检查其版本是否在 v10 以上\nNode\n我们推荐使用[Homebrew](http://brew.sh/)来安装 Node。在命令行中执行下列命令安装：\nbrew install node\nYarn、React Native 的命令行工具（react-native-cli）\nYarn是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务\nnpm install -g yarn react-native-cli\n或\nbrew install yarn\nnpm私有库安装\n1. 安装nrm，全局安装 nrm，用于管理 npm 的下载库地址\nnpm install nrm -g\n2. 添加私有库，私有库地址： http://172.16.1.179:4873/\nnrm add ksnpm http://172.16.1.179:4873/\n2. \n添加后，确保 ksnpm 已经被添加至 nrm 中，效果如下\n3. 使用私有库\nnrm use ksnpm\n4. 配置 .npmrc。修改 ~/.npmrc 文件，在文件中加入 always-auth=true\n5. 注册/登录用户\nnpm adduser\n跟随提示，依次输入用户名、密码、邮箱\n至此，配置完成，npm 和 yarn 都能使用私有库了\n三、配置gitLab ssh key 及 gerrit ssh key\n1. 添加gitlab ssh\n2. 添加gerrit ssh\n3. gerrit 填入自己的邮箱地址和用户名，并通过邮件验证\n四、项目拉取\n项目由两部分组成，主工程项目 和 通用的依赖module。\n首先到gerrit 地址下，登录自己的账号密码，进入如下图所示页面\n点击需要clone的项目后，下图所示，拷贝 clone 项目的命令 到自己的文件夹目录下，\n五、拉取React native 代码\ncd ~/yourfilepath/ksandroid/\nls \nif (如果有ks-rn-theme 文件夹 &&  ks-rn-theme 为空) {\n    rm -rf ks-rm-theme\n    git submodule init\n    git submodule update\n}\ncd ks-rn-theme\n查看ks-rn-theme 目录下存在文件，执行yarn\n六、打开Android studio 编译代码\nif (长时间build不过，停留在index progress) {\n    cd ~/yourfilePath/kaishustory/.idea/\n    rm -rf kaishustroy.iml\n    rm -rf modules.xml\n    重启Android studio\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598548742941},"updatedAt":{"$$date":1598549131539},"_id":"YHSWu1Y401Q4peE9","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-Kotlin 基本数据类型 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-basic-types.html\nKotlin 基本数据类型 | 菜鸟教程\n4-5 minutes\nKotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。\n\n类型\t位宽度\nDouble\t64\nFloat\t32\nLong\t64\nInt\t32\nShort\t16\nByte\t8\n字面常量\n下面是所有类型的字面常量：\n\n十进制：123\n长整型以大写的 L 结尾：123L\n16 进制以 0x 开头：0x0F\n2 进制以 0b 开头：0b00001011\n注意：8进制不支持\nKotlin 同时也支持传统符号表示的浮点数值：\n\nDoubles 默认写法: 123.5, 123.5e10\nFloats 使用 f 或者 F 后缀：123.5f\n你可以使用下划线使数字常量更易读：\n\nval oneMillion = 1_000_000\nval creditCardNumber = 1234_5678_9012_3456L\nval socialSecurityNumber = 999_99_9999L\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n比较两个数字\nKotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所以在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。\n\n在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。\n\nfun main(args: Array<String>) {\n    val a: Int = 10000\n    println(a === a) // true，值相等，对象地址相等\n\n    //经过了装箱，创建了两个不同的对象\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n\n    //虽然经过了装箱，但是值是相等的，都是10000\n    println(boxedA === anotherBoxedA) //  false，值相等，对象地址不一样\n    println(boxedA == anotherBoxedA) // true，值相等\n}\n类型转换\n由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。\n\nval b: Byte = 1 // OK, 字面值是静态检测的\nval i: Int = b // 错误\n我们可以代用其toInt()方法。\n\nval b: Byte = 1 // OK, 字面值是静态检测的\nval i: Int = b.toInt() // OK\n每种数据类型都有下面的这些方法，可以转化为其它的类型：\n\ntoByte(): Byte\ntoShort(): Short\ntoInt(): Int\ntoLong(): Long\ntoFloat(): Float\ntoDouble(): Double\ntoChar(): Char\n有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的：\n\nval l = 1L + 3 // Long + Int => Long\n位操作符\n对于Int和Long类型，还有一系列的位操作符可以使用，分别是：\n\nshl(bits) – 左移位 (Java’s <<)\nshr(bits) – 右移位 (Java’s >>)\nushr(bits) – 无符号右移位 (Java’s >>>)\nand(bits) – 与\nor(bits) – 或\nxor(bits) – 异或\ninv() – 反向\n字符\n和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 ' 包含起来的。比如普通字符 '0'，'a'。\n\nfun check(c: Char) {\n    if (c == 1) { // 错误：类型不兼容\n        // ……\n    }\n}\n字符字面值用单引号括起来: '1'。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\\t、 \\b、\\n、\\r、\\'、\\\"、\\\\ 和 \\$。 编码其他字符要用 Unicode 转义序列语法：'\\uFF00'。\n\n我们可以显式把字符转换为 Int 数字：\n\nfun decimalDigitValue(c: Char): Int {\n    if (c !in '0'..'9')\n        throw IllegalArgumentException(\"Out of range\")\n    return c.toInt() - '0'.toInt() // 显式转换为数字\n}\n当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。\n\n布尔\n布尔用 Boolean 类型表示，它有两个值：true 和 false。\n\n若需要可空引用布尔会被装箱。\n\n内置的布尔运算有：\n\n|| – 短路逻辑或\n&& – 短路逻辑与\n! - 逻辑非\n数组\n数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。\n\n数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组：\n\nfun main(args: Array<String>) {\n    //[1,2,3]\n    val a = arrayOf(1, 2, 3)\n    //[0,2,4]\n    val b = Array(3, { i -> (i * 2) })\n\n    //读取数组内容\n    println(a[0])    // 输出结果：1\n    println(b[1])    // 输出结果：2\n}\n如上所述，[] 运算符代表调用成员函数 get() 和 set()。\n\n注意: 与 Java 不同的是，Kotlin 中数组是不协变的（invariant）。\n\n除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样：\n\nval x: IntArray = intArrayOf(1, 2, 3)\nx[0] = x[1] + x[2]\n字符串\n和 Java 一样，String 是不可变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历：\n\nfor (c in str) {\n    println(c)\n}\nKotlin 支持三个引号 \"\"\" 扩起来的字符串，支持多行字符串，比如：\n\nfun main(args: Array<String>) {\n    val text = \"\"\"\n    多行字符串\n    多行字符串\n    \"\"\"\n    println(text)   // 输出有一些前置空格\n}\nString 可以通过 trimMargin() 方法来删除多余的空白。\n\nfun main(args: Array<String>) {\n    val text = \"\"\"\n    |多行字符串\n    |菜鸟教程\n    |多行字符串\n    |Runoob\n    \"\"\".trimMargin()\n    println(text)    // 前置空格删除了\n}\n默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(\">\")。\n\n字符串模板\n字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:\n\nfun main(args: Array<String>) {\n    val i = 10\n    val s = \"i = $i\" // 求值结果为 \"i = 10\"\n    println(s)\n}\n或者用花括号扩起来的任意表达式:\n\nfun main(args: Array<String>) {\n    val s = \"runoob\"\n    val str = \"$s.length is ${s.length}\" // 求值结果为 \"runoob.length is 6\"\n    println(str)\n}\n原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：\n\nfun main(args: Array<String>) {\n    val price = \"\"\"\n    ${'\n   \n  \n  \n  \n\n\n}9.99\n    \"\"\"\n    println(price)  // 求值结果为 $9.99\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303688467},"updatedAt":{"$$date":1597303842660},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YMuUumshn6YUgFzT"}
{"name":"html-","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887695829},"updatedAt":{"$$date":1598887695829},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YNwxo5CBDBzF4j4e"}
{"name":"css-CSS 图像透明/不透明","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 图像透明/不透明\n使用CSS很容易创建透明的图像。\n\n注意：CSS Opacity属性是W3C的CSS3建议的一部分。\n\nExamples\n更多实例\n创建透明图像 - 悬停效果\n\n创建一个具有文本的拥有背景图像的透明框\n\n实例1 - 创建一个透明图像\nCSS3中属性的透明度是 opacity。\n\n首先，我们将向您展示如何用CSS创建一个透明图像。\n\n正常的图像\n\nklematis\n相同的图像带有透明度：\n\nklematis\n看看下面的CSS：\n\nimg\n{\n  opacity:0.4;\n  filter:alpha(opacity=40); /* IE8 及其更早版本 */\n}\nIE9，Firefox，Chrome，Opera，和Safari浏览器使用透明度属性可以将图像变的不透明。 Opacity属性值从0.0 - 1.0。值越小，使得元素更加透明。\n\nIE8和早期版本使用滤镜：alpha（opacity= x）。 x可以采取的值是从0 - 100。较低的值，使得元素更加透明。\n\n实例2 - 图像的透明度 - 悬停效果\n将鼠标移到图像上：\n\nklematisklematis\nCSS样式：\n\nimg\n{\n  opacity:0.4;\n  filter:alpha(opacity=40); /*  IE8 及其更早版本 */\n}\nimg:hover\n{\n  opacity:1.0;\n  filter:alpha(opacity=100); /* IE8 及其更早版本 */\n}\n第一个CSS块是和例1中的代码类似。此外，我们还增加了当用户将鼠标悬停在其中一个图像上时发生什么。在这种情况下，当用户将鼠标悬停在图像上时，我们希望图片是清晰的。\n\n此CSS是：opacity=1.\n\nIE8和更早版本使用： filter:alpha(opacity=100).\n\n当鼠标指针远离图像时，图像将重新具有透明度。\n\n实例3 - 透明的盒子中的文字\n这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。\n\n源代码如下：\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<style>\ndiv.background\n{\n  width:500px;\n  height:250px;\n  background:url(https://www.runoob.com/images/klematis.jpg) repeat;\n  border:2px solid black;\n}\ndiv.transbox\n{\n  width:400px;\n  height:180px;\n  margin:30px 50px;\n  background-color:#ffffff;\n  border:1px solid black;\n  opacity:0.6;\n  filter:alpha(opacity=60); /* IE8 及更早版本 */\n}\ndiv.transbox p\n{\n  margin:30px 40px;\n  font-weight:bold;\n  color:#000000;\n}\n</style>\n</head>\n \n<body>\n \n<div class=\"background\">\n<div class=\"transbox\">\n<p>这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。\n</p>\n</div>\n</div>\n \n</body>\n</html>\n首先，我们创建一个固定的高度和宽度的div元素，带有一个背景图片和边框。然后我们在第一个div内部创建一个较小的div元素。 这个div也有一个固定的宽度，背景颜色，边框 - 而且它是透明的。透明的div里面，我们在P元素内部添加一些文本。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973620590},"updatedAt":{"$$date":1598974314252},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YPAblH7FHUSfIYdJ"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241214846},"updatedAt":{"$$date":1597241214846},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YPVEnYDWzZ3y5Ral"}
{"name":"ad-ks_frame_net","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n\n    testImplementation deps.test.junit\n    testImplementation deps.test.ext_junit\n    androidTestImplementation deps.test.spresso_core\n\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    implementation deps.androidx.core\n    implementation deps.androidx.app_compat\n    implementation deps.kotlin.coroutines_core\n    implementation deps.kotlin.coroutines_android\n\n    api deps.retrofit.retrofit\n    api deps.retrofit.converter_gson\n    api deps.okhttp3.logging_interceptor\n}\n\n\n\n\n\n\n\n\n\n\n\nopen class BaseException(override val message: String = \"\",\n                         val isNeedRetry: Boolean = false,\n                         open val code: Int = 0) : Exception(message)\n\n\n\n\n\n\n\n\n\n\n\n\nabstract class BaseRetrofitClient {\n\n    private val client: OkHttpClient by lazy {\n        val builder = OkHttpClient.Builder()\n        handleBuilder(builder)\n        builder.build()\n    }\n\n    private val retrofit: Retrofit by lazy {\n        Retrofit.Builder()\n                .client(client)\n                .addConverterFactory(GsonConverterFactory.create())\n                .baseUrl(baseUrl())\n                .build()\n    }\n\n    protected abstract fun handleBuilder(builder: OkHttpClient.Builder)\n    protected abstract fun baseUrl(): String\n\n    fun <S> getService(serviceClass: Class<S>): S {\n        return retrofit.create(serviceClass)\n    }\n}\n\n\n\n\n\n\n\n\n@Keep\nsealed class KsResult<out T : Any> {\n\n    data class Success<out T : Any>(val data: T? = null, val code: Int = 0, val message: String = \"\") : KsResult<T>()\n    data class Error(val code: Int = -1, val exception: Exception) : KsResult<Nothing>()\n\n    override fun toString(): String {\n        return when (this) {\n            is Success<*> -> \"Success[data=$data]\"\n            is Error -> \"Error[exception=$exception]\"\n        }\n    }\n\n    /**\n     * 请求数据 正确返回，没有异常code\n     */\n    fun isOk(): Boolean {\n        if (this is Success) {\n            return code == 0\n        }\n        return false\n    }\n}\n\n\n\n\n\n\n\n\n\n/**\n * 网络请求基本的返回数据封装\n * ，一切皆有可能，所以都可空。\n */\n@Keep\ndata class KsResponse<out T>(\n        val code: Int?,\n        val message: String? = \"\",\n        val data: T? = null,\n        val fail: Boolean? = false,\n        val success: Boolean? = false,\n        //兼容老接口\n        val errcode: Int?,\n        //兼容老接口\n        val errmsg: String? = \"\",\n        //兼容老接口\n        val result: T? = null\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nabstract class BaseRepository {\n\n    /**\n     *  对网络请求过程中的异常进行了捕获，并返回自定义exception。\n     *  @param call 实际进行网络请求 的方法 引用\n     * @param errorMessage 调用方自定义 错误信息提示，比如错误了，就提示这个消息\n     * @return KsResult ,\n     */\n    suspend fun <T : Any> safeApiCall(\n            call: suspend () -> KsResult<T>,\n            errorMessage: String? = null\n    ): KsResult<T> {\n        return try {\n            val result = call()\n            if (result is KsResult.Error) {\n                return handleException(result.exception, errorMessage, call)\n            }\n            return result\n        } catch (e: Exception) {\n            // An exception was thrown when calling the API so we're converting this to an IOException\n            KsResult.Error(\n                    exception = IOException(if (errorMessage.isNullOrEmpty()) e.message else errorMessage, e)\n            )\n        }\n    }\n\n    /**\n     * 处理 异常，加入了 是否重试 选项\n     * @param exception Exception 异常类\n     * @param errorMessage String? 错误信息\n     * @param call SuspendFunction0<KsResult<T>> ，重试需要调用的方法\n     * @return KsResult<T> 返回结果\n     */\n    private suspend fun <T : Any> handleException(\n            exception: Exception,\n            errorMessage: String?,\n            call: suspend () -> KsResult<T>\n    ): KsResult<T> {\n        if (exception is BaseException) {\n            println(\"handleException..........need retry:${exception.isNeedRetry},exception:$exception\")\n        }\n\n        return if (exception is BaseException) {\n            if (exception.isNeedRetry) {\n                call()\n            } else {\n                KsResult.Error(code = exception.code, exception = exception)\n            }\n\n        } else {\n            println(\"不需要重试，返回错误 exception:${if (errorMessage.isNullOrEmpty()) exception.message else errorMessage}\")\n            KsResult.Error(\n                    exception = IOException(\n                            if (errorMessage.isNullOrEmpty()) exception.message else errorMessage, exception\n                    )\n            )\n        }\n    }\n\n    /**\n     * 处理从网络获取的数据\n     * @param\n     */\n    suspend fun <T : Any> executeResponse(\n            response: KsResponse<T>,\n            successBlock: (suspend CoroutineScope.() -> Unit)? = null,\n            errorBlock: (suspend CoroutineScope.() -> Unit)? = null\n    ): KsResult<T> {\n        return coroutineScope {\n            //\n            when (val result = handleCode(response)) {\n                is Exception -> {\n                    errorBlock?.let { it() }\n                    KsResult.Error(correctCode(response), result)\n                }\n                else -> {\n                    successBlock?.let { it() }\n                    KsResult.Success(\n                            data = correctData(response),\n                            code = correctCode(response),\n                            message = correctMessage(response)\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * 处理网络请求错误code和业务code\n     * @param response KsResponse<T>\n     * @return Any\n     */\n    abstract suspend fun <T> handleCode(response: KsResponse<T>): Any\n\n    /**\n     * 兼容后端，转换code\n     * @param response KsResponse<T>\n     * @return Int\n     */\n    private fun <T> correctCode(response: KsResponse<T>): Int {\n        return response.code ?: response.errcode ?: Int.MAX_VALUE\n    }\n\n    /**\n     * 兼容后端，转换message\n     * @param response KsResponse<T>\n     * @return String\n     */\n    private fun <T> correctMessage(response: KsResponse<T>): String {\n        return response.message ?: response.errmsg ?: \"\"\n    }\n\n    /**\n     * 兼容后端，转换data\n     * @param response KsResponse<T>\n     * @return T?\n     */\n    private fun <T> correctData(response: KsResponse<T>): T? = with(response) {\n        data ?: result\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539549334},"updatedAt":{"$$date":1598542038533},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"YTJOttvLI4cAzPfq"}
{"name":"CSS3 框大小","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 框大小\nCSS3 box-sizing 属性可以设置 width 和 height 属性中包含了 padding(内边距) 和 border(边框)。\n\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器的版本号。\n\n紧跟在数字后面的 -webkit- 或 -moz- 为指定浏览器的前缀。\n\n属性\t\t\t\t\t\nbox-sizing\t10.0\n4.0 -webkit-\t8.0\t29.0\n2.0 -moz-\t5.1\n3.1 -webkit-\t9.5\n不使用 CSS3 box-sizing 属性\n默认情况下，元素的宽度与高度计算方式如下：\n\nwidth(宽) + padding(内边距) + border(边框) = 元素实际宽度\n\nheight(高) + padding(内边距) + border(边框) = 元素实际高度\n\n这就意味着我们在设置元素的 width/height 时，元素真实展示的高度与宽度会更大(因为元素的边框与内边距也会计算在 width/height 中)。\n\n这个是个较小的框 (width 为 300px ，height 为 100px)。\n\n这个是个较大的框 (width 为 300px ，height 为 100px)。\n以上两个 <div> 元素虽然宽度与高度设置一样，但真实展示的大小不一致，因为 div2 指定了内边距:\n\n实例\n.div1 {\n    width: 300px;\n    height: 100px;\n    border: 1px solid blue;\n}\n\n.div2 {\n    width: 300px;\n    height: 100px;\n    padding: 50px;\n    border: 1px solid red;\n}\n\n尝试一下 »\n使用这种方式如果想要获得较小的那个框且包含内边距，就不得不考虑到边框和内边距的宽度。\n\nCSS3 的 box-sizing 属性很好的解决了这个问题。\n\n使用 CSS3 box-sizing 属性\nCSS3 box-sizing 属性在一个元素的 width 和 height 中包含 padding(内边距) 和 border(边框)。\n\n如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:\n\n两个 div 现在是一样大小的!\n\n菜鸟教程!\n\n以下是两个 <div> 元素添加 box-sizing: border-box; 属性的简单实例。\n\n实例\n.div1 {\n    width: 300px;\n    height: 100px;\n    border: 1px solid blue;\n    box-sizing: border-box;\n}\n\n.div2 {\n    width: 300px;\n    height: 100px;\n    padding: 50px;\n    border: 1px solid red;\n    box-sizing: border-box;\n}\n\n尝试一下 »\n从结果上看 box-sizing: border-box; 效果更好，也正是很多开发人员需要的效果。\n\n以下代码可以让所有元素以更直观的方式展示大小。很多浏览器已经支持 box-sizing: border-box; (但是并非所有 - 这就是为什么 input 和 text 元素设置了 width: 100%; 后的宽度却不一样)。\n\n所有元素使用 box-sizing 是比较推荐的：\n\n实例\n* {\n    box-sizing: border-box;\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974628932},"updatedAt":{"$$date":1598975678619},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YWxYGZrW1xYbhXtG"}
{"name":"andr-Parcelable 和 Bundle","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/components/activities/parcelables-and-bundles\nParcelable 和 Bundle  |  Android 开发者  |  Android Developers\n2-3 minutes\nParcelable 和 Bundle 对象可跨进程边界使用，例如与 IPC/Binder 事务之间，带有 intent 的 Activity 之间等，还可以用来存储跨配置更改的瞬时状态。本页介绍了使用 Parcelable 和 Bundle 对象的建议和最佳做法。\n\n注意：Parcel 不是通用序列化机制，您绝不能将任何 Parcel 数据存储在磁盘上或通过网络发送。\n\n在 Activity 之间发送数据\n当应用创建 Intent 对象以在 startActivity(android.content.Intent) 中用于启动新的 Activity 时，应用可使用 putExtra(java.lang.String, java.lang.String) 方法传入参数。\n\n以下示例代码段演示了如何执行此操作。\n\n    val intent = Intent(this, MyActivity::class.java).apply {\n        putExtra(\"media_id\", \"a1b2c3\")\n        // ...\n    }\n    startActivity(intent)\n    \n    Intent intent = new Intent(this, MyActivity.class);\n    intent.putExtra(\"media_id\", \"a1b2c3\");\n    // ...\n    startActivity(intent);\n    \n操作系统会将 intent 的基础 Bundle 打包。然后，操作系统会创建新的 Activity，将数据拆包，并将 intent 传递给新的 Activity。\n\n我们建议您使用 Bundle 类为 Intent 对象设置操作系统已知的基元。Bundle 类针对使用 parcel 进行编组和解组进行了高度优化。\n\n在某些情况下，您可能需要一种机制来跨 Activity 发送复合对象或复杂对象。在这种情况下，自定义类应实现 Parcelable，并提供相应的 writeToParcel(android.os.Parcel, int) 方法。它还必须提供实现 Parcelable.Creator 接口的非空字段 CREATOR，该接口的 createFromParcel() 方法用于将 Parcel 转回为当前对象。如需了解详情，请参阅 Parcelable 对象的参考文档。\n\n通过 intent 发送数据时，应小心地将数据大小限制为几 KB。发送过多数据会导致系统抛出 TransactionTooLargeException 异常。\n\n在进程之间发送数据\n在进程之间发送数据与在 Activity 之间发送数据类似。不过，在进程之间发送时，我们建议您不要使用自定义 Parcelable。如果您将一个自定义 Parcelable 对象从一个应用发送到另一个应用，则需要确保发送和接收的应用上都存在版本完全相同的自定义类。通常情况下，这可能是在两个应用中都会使用的通用库。如果您的应用尝试向系统发送自定义 Parblelable，则可能会发生错误，因为系统无法对其不了解的类进行解组。\n\n例如，某个应用可能会使用 AlarmManager 类设置闹钟，并对闹钟 intent 使用自定义Parcelable。当闹钟响铃时，系统会修改 intent 的 extra Bundle 以添加重复计数。此修改可导致系统从 extra 中剥离自定义 Parcelable。这种剥离进而会导致应用在收到修改后的警报 intent 时崩溃，因为应用预计会收到 extra 数据，而它已不存在。\n\nBinder 事务缓冲区的大小固定有限，目前为 1MB，由进程中正在处理的所有事务共享。由于此限制是进程级别而不是 Activity 级别的限制，因此这些事务包括应用中的所有 binder 事务，例如 onSaveInstanceState，startActivity 以及与系统的任何互动。超过大小限制时，将引发 TransactionTooLargeException。\n\n对于 savedInstanceState 的具体情况，应将数据量保持在较小的规模，因为只要用户可以返回到该 Activity，系统进程就需要保留所提供的数据（即使 Activity 的进程已终止）。我们建议您将保存的状态保持在 50k 数据以下。\n\n注意：在 Android 7.0（API 级别 24）或更高版本中，系统会在运行时抛出 TransactionTooLargeException 异常。在较低版本的 Android 中，系统仅在 logcat 中显示警告。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243441107},"updatedAt":{"$$date":1597243712940},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YatiXPyAeOHq3Ll8"}
{"name":"html-","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887696906},"updatedAt":{"$$date":1598887696906},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YeJUX9G3AKtZdnCB"}
{"name":"Untitled snippet","folderId":null,"content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598519512417},"updatedAt":{"$$date":1598519512417},"_id":"YgTEFhpwWkWmucHX"}
{"name":"kotlin-Map 相关操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/map-operations.html\nMap 相关操作 - Kotlin 语言中文站\n18-22 minutes\n改进翻译\n在 map 中，键和值的类型都是用户定义的。 对基于键的访问启用了各种特定于 map 的处理函数，从键获取值到对键和值进行单独过滤。 在此页面上，我们提供了来自标准库的 map 处理功能的描述。\n\n要从 Map 中检索值，必须提供其键作为 get() 函数的参数。 还支持简写 [key] 语法。 如果找不到给定的键，则返回 null 。 还有一个函数 getValue() ，它的行为略有不同：如果在 Map 中找不到键，则抛出异常。 此外，还有两个选项可以解决键缺失的问题：\n\ngetOrElse() 与 list 的工作方式相同：对于不存在的键，其值由给定的 lambda 表达式返回。\ngetOrDefault() 如果找不到键，则返回指定的默认值。\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.get(\"one\"))\n    println(numbersMap[\"one\"])\n    println(numbersMap.getOrDefault(\"four\", 10))\n    println(numbersMap[\"five\"])               // null\n    //numbersMap.getValue(\"six\")      // exception!\n//sampleEnd\n}\n\n要对 map 的所有键或所有值执行操作，可以从属性 keys 和 values 中相应地检索它们。 keys 是 Map 中所有键的集合， values 是 Map 中所有值的集合。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.keys)\n    println(numbersMap.values)\n//sampleEnd\n}\n\n可以使用 filter() 函数来过滤 map 或其他集合。 对 map 使用 filter() 函数时， Pair 将作为参数的谓词传递给它。 它将使用谓词同时过滤其中的键和值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\n\n还有两种用于过滤 map 的特定函数：按键或按值。 这两种方式，都有对应的函数： filterKeys() 和 filterValues() 。 两者都将返回一个新 Map ，其中包含与给定谓词相匹配的条目。 filterKeys() 的谓词仅检查元素键， filterValues() 的谓词仅检查值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredKeysMap = numbersMap.filterKeys { it.endsWith(\"1\") }\n    val filteredValuesMap = numbersMap.filterValues { it < 10 }\n\n    println(filteredKeysMap)\n    println(filteredValuesMap)\n//sampleEnd\n}\n\n由于需要访问元素的键，plus（+）与 minus（-）运算符对 map 的作用与其他集合不同。 plus 返回包含两个操作数元素的 Map ：左侧的 Map 与右侧的 Pair 或另一个 Map 。 当右侧操作数中有左侧 Map 中已存在的键时，该条目将使用右侧的值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap + Pair(\"four\", 4))\n    println(numbersMap + Pair(\"one\", 10))\n    println(numbersMap + mapOf(\"five\" to 5, \"one\" to 11))\n//sampleEnd\n}\n\nminus 将根据左侧 Map 条目创建一个新 Map ，右侧操作数带有键的条目将被剔除。 因此，右侧操作数可以是单个键或键的集合： list 、 set 等。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap - \"one\")\n    println(numbersMap - listOf(\"two\", \"four\"))\n//sampleEnd\n}\n\n关于在可变 Map 中使用 plusAssign（+=）与 minusAssign（-=）运算符的详细信息，请参见 Map 写操作 。\n\nMutable Map （可变 Map ）提供特定的 Map 写操作。 这些操作使你可以使用键来访问或更改 Map 值。\n\nMap 写操作的一些规则：\n\n值可以更新。 反过来，键也永远不会改变：添加条目后，键是不变的。\n每个键都有一个与之关联的值。也可以添加和删除整个条目。\n下面是对可变 Map 中可用写操作的标准库函数的描述。\n\n要将新的键值对添加到可变 Map ，请使用 put() 。 将新条目放入 LinkedHashMap （Map的默认实现）后，会添加该条目，以便在 Map 迭代时排在最后。 在 Map 类中，新元素的位置由其键顺序定义。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    println(numbersMap)\n//sampleEnd\n}\n\n要一次添加多个条目，请使用 putAll() 。它的参数可以是 Map 或一组 Pair ： Iterable 、 Sequence 或 Array 。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.putAll(setOf(\"four\" to 4, \"five\" to 5))\n    println(numbersMap)\n//sampleEnd\n}\n\n如果给定键已存在于 Map 中，则 put() 与 putAll() 都将覆盖值。 因此，可以使用它们来更新 Map 条目的值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    val previousValue = numbersMap.put(\"one\", 11)\n    println(\"value associated with 'one', before: $previousValue, after: ${numbersMap[\"one\"]}\")\n    println(numbersMap)\n//sampleEnd\n}\n\n还可以使用快速操作符将新条目添加到 Map 。 有两种方式：\n\nplusAssign （+=） 操作符。\n[] 操作符为 put() 的别名。\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap[\"three\"] = 3     // 调用 numbersMap.put(\"three\", 3)\n    numbersMap += mapOf(\"four\" to 4, \"five\" to 5)\n    println(numbersMap)\n//sampleEnd\n}\n\n使用 Map 中存在的键进行操作时，将覆盖相应条目的值。\n\n要从可变 Map 中删除条目，请使用 remove() 函数。 调用 remove() 时，可以传递键或整个键值对。 如果同时指定键和值，则仅当键值都匹配时，才会删除此的元素。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.remove(\"one\")\n    println(numbersMap)\n    numbersMap.remove(\"three\", 4)            //不会删除任何条目\n    println(numbersMap)\n//sampleEnd\n}\n\n还可以通过键或值从可变 Map 中删除条目。 在 Map 的 .keys 或 .values 中调用 remove() 并提供键或值来删除条目。 在 .values 中调用时， remove() 仅删除给定值匹配到的的第一个条目。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"threeAgain\" to 3)\n    numbersMap.keys.remove(\"one\")\n    println(numbersMap)\n    numbersMap.values.remove(3)\n    println(numbersMap)\n//sampleEnd\n}\n\nminusAssign （-=） 操作符也可用于可变 Map 。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap -= \"two\"\n    println(numbersMap)\n    numbersMap -= \"five\"             //不会删除任何条目\n    println(numbersMap)\n//sampleEnd\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382139474},"updatedAt":{"$$date":1597386351907},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Yjach19u2aDqDEVt"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973279148},"updatedAt":{"$$date":1594973279148},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YlC1ukwYNcBH8L9x"}
{"name":"kotlin-编码规范 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"www.kotlincn.net /docs/reference/coding-conventions.html\n编码规范 - Kotlin 语言中文站\n43-53 minutes\n改进翻译\n本页包含当前 Kotlin 语言的编码风格。\n\n源代码组织\n命名规则\n格式化\n文档注释\n避免重复结构\n语言特性的惯用法\n库的编码规范\n如需根据本风格指南配置 IntelliJ 格式化程序，请安装 Kotlin 插件 1.2.20 或更高版本，转到 Settings | Editor | Code Style | Kotlin，点击右上角的 Set from… 链接，并从菜单中选择 Predefined style | Kotlin style guide。\n\n如需验证代码已按风格指南格式化，请转到探查设置（Inspections）并启用 Kotlin | Style issues | File is not formatted according to project settings 探查项。 验证风格指南中描述的其他问题（如命名约定）的附加探查项默认已启用。\n\n在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构。例如，如果项目中的所有代码都位于 org.example.kotlin 包及其子包中，那么 org.example.kotlin 包的文件应该直接放在源代码根目录下，而 org.example.kotlin.network.socket 中的文件应该放在源代码根目录下的 network/socket 子目录中。\n\n对于 JVM 平台：Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中。\n\n如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。 使用首字母大写的驼峰风格（例如 ProcessDeclarations.kt）。\n\n文件的名称应该描述文件中代码的作用。因此，应避免在文件名中使用诸如“Util”之类的无意义词语。\n\n鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。\n\n特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。不要只是为了保存 “Foo 的所有扩展函数”而创建文件。\n\n通常，一个类的内容按以下顺序排列：\n\n属性声明与初始化块\n次构造函数\n方法声明\n伴生对象\n不要按字母顺序或者可见性对方法声明排序，也不要将常规方法与扩展方法分开。而是要把相关的东西放在一起，这样从上到下阅读类的人就能够跟进所发生事情的逻辑。选择一个顺序（高级别优先，或者相反）并坚持下去。\n\n将嵌套类放在紧挨使用这些类的代码之后。如果打算在外部使用嵌套类，而且类中并没有引用这些类，那么把它们放到末尾，在伴生对象之后。\n\n在实现一个接口时，实现成员的顺序应该与该接口的成员顺序相同（如果需要， 还要插入用于实现的额外的私有方法）\n\n在类中总是将重载放在一起。\n\n在 Kotlin 中，包名与类名的命名规则非常简单：\n\n包的名称总是小写且不使用下划线（org.example.project）。 通常不鼓励使用多个词的名称，但是如果确实需要使用多个词，可以将它们连接在一起或使用驼峰风格（org.example.myProject）。\n\n类与对象的名称以大写字母开头并使用驼峰风格：\n\nopen class DeclarationProcessor { /*……*/ }\n\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*……*/ }\n函数、属性与局部变量的名称以小写字母开头、使用驼峰风格而不使用下划线：\n\nfun processDeclarations() { /*……*/ }\nvar declarationCount = 1\n例外：用于创建类实例的工厂函数可以与抽象返回类型具有相同的名称：\n\ninterface Foo { /*……*/ }\n\nclass FooImpl : Foo { /*……*/ }\n\nfun Foo(): Foo { return FooImpl() }\n当且仅当在测试中，可以使用反引号括起来的带空格的方法名。 （请注意，Android 运行时目前不支持这样的方法名。）测试代码中也允许方法名使用下划线。\n\nclass MyTestCase {\n     @Test fun `ensure everything works`() { /*...*/ }\n     \n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}\n常量名称（标有 const 的属性，或者保存不可变数据的没有自定义 get 函数的顶层/对象 val 属性）应该使用大写、下划线分隔的名称：\n\nconst val MAX_COUNT = 8\nval USER_NAME_FIELD = \"UserName\"\n保存带有行为的对象或者可变数据的顶层/对象属性的名称应该使用驼峰风格名称：\n\nval mutableCollection: MutableSet<String> = HashSet()\n保存单例对象引用的属性的名称可以使用与 object 声明相同的命名风格：\n\nval PersonComparator: Comparator<Person> = /*...*/\n对于枚举常量，可以使用大写、下划线分隔的名称 （enum class Color { RED, GREEN }）也可使用首字母大写的常规驼峰名称，具体取决于用途。\n\n如果一个类有两个概念上相同的属性，一个是公共 API 的一部分，另一个是实现细节，那么使用下划线作为私有属性名称的前缀：\n\nclass C {\n    private val _elementList = mutableListOf<Element>()\n\n    val elementList: List<Element>\n         get() = _elementList\n}\n类的名称通常是用来解释类是什么的名词或者名词短语：List、 PersonReader。\n\n方法的名称通常是动词或动词短语，说明该方法做什么：close、 readPersons。 修改对象或者返回一个新对象的名称也应遵循建议。例如 sort 是对一个集合就地排序，而 sorted 是返回一个排序后的集合副本。\n\n名称应该表明实体的目的是什么，所以最好避免在名称中使用无意义的单词 （Manager、 Wrapper 等）。\n\n当使用首字母缩写作为名称的一部分时，如果缩写由两个字母组成，就将其大写（IOStream）； 而如果缩写更长一些，就只大写其首字母（XmlFormatter、 HttpInputStream）。\n\n使用 4 个空格缩进。不要使用 tab。\n\n对于花括号，将左花括号放在结构起始处的行尾，而将右花括号放在与左括结构横向对齐的单独一行。\n\nif (elements != null) {\n    for (element in elements) {\n        // ……\n    }\n}\n（注意：在 Kotlin 中，分号是可选的，因此换行很重要。语言设计采用 Java 风格的花括号格式，如果尝试使用不同的格式化风格，那么可能会遇到意外的行为。）\n\n在二元操作符左右留空格（a + b）。例外：不要在“range to”操作符（0..i）左右留空格。\n\n不要在一元运算符左右留空格（a++）\n\n在控制流关键字（if、 when、 for 以及 while）与相应的左括号之间留空格。\n\n不要在主构造函数声明、方法声明或者方法调用的左括号之前留空格。\n\nclass A(val x: Int)\n\nfun foo(x: Int) { …… }\n\nfun bar() {\n    foo(1)\n}\n绝不在 (、 [ 之后或者 ]、 ) 之前留空格。\n\n绝不在. 或者 ?. 左右留空格：foo.bar().filter { it > 2 }.joinToString(), foo?.bar()\n\n在 // 之后留一个空格：// 这是一条注释\n\n不要在用于指定类型参数的尖括号前后留空格：class Map<K, V> { …… }\n\n不要在 :: 前后留空格：Foo::class、 String::length\n\n不要在用于标记可空类型的 ? 前留空格：String?\n\n作为一般规则，避免任何类型的水平对齐。将标识符重命名为不同长度的名称不应该影响声明或者任何用法的格式。\n\n在以下场景中的 : 之前留一个空格：\n\n当它用于分隔类型与超类型时；\n当委托给一个超类的构造函数或者同一类的另一个构造函数时；\n在 object 关键字之后。\n而当分隔声明与其类型时，不要在 : 之前留空格。\n\n在 : 之后总要留一个空格。\n\nabstract class Foo<out T : Any> : IFoo {\n    abstract fun foo(a: Int): T\n}\n\nclass FooImpl : Foo() {\n    constructor(x: String) : this(x) { /*……*/ }\n    \n    val x = object : IFoo { /*……*/ } \n} \n具有少数主构造函数参数的类可以写成一行：\n\nclass Person(id: Int, name: String)\n具有较长类头的类应该格式化，以使每个主构造函数参数都在带有缩进的独立的行中。 另外，右括号应该位于一个新行上。如果使用了继承，那么超类的构造函数调用或者所实现接口的列表应该与右括号位于同一行：\n\nclass Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name) { /*……*/ }\n对于多个接口，应该将超类构造函数调用放在首位，然后将每个接口应放在不同的行中：\n\nclass Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name),\n    KotlinMaker { /*……*/ }\n对于具有很长超类型列表的类，在冒号后面换行，并横向对齐所有超类型名：\n\nclass MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne {\n\n    fun foo() { /*...*/ }\n}\n为了将类头与类体分隔清楚，当类头很长时，可以在类头后放一空行 （如上例所示）或者将左花括号放在独立行上：\n\nclass MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne \n{\n    fun foo() { /*...*/ }\n}\n构造函数参数使用常规缩进（4 个空格）。\n\n理由：这确保了在主构造函数中声明的属性与 在类体中声明的属性具有相同的缩进。\n\n如果一个声明有多个修饰符，请始终按照以下顺序安放：\n\npublic / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation\ncompanion\ninline\ninfix\noperator\ndata\n将所有注解放在修饰符前：\n\n@Named(\"Foo\")\nprivate val foo: Foo\n除非你在编写库，否则请省略多余的修饰符（例如 public）。\n\n注解通常放在单独的行上，在它们所依附的声明之前，并使用相同的缩进：\n\n@Target(AnnotationTarget.PROPERTY)\nannotation class JsonExclude\n无参数的注解可以放在同一行：\n\n@JsonExclude @JvmField\nvar x: String\n无参数的单个注解可以与相应的声明放在同一行：\n\n@Test fun foo() { /*……*/ }\n文件注解位于文件注释（如果有的话）之后、package 语句之前，并且用一个空白行与 package 分开（为了强调其针对文件而不是包）。\n\n/** 授权许可、版权以及任何其他内容 */\n@file:JvmName(\"FooBar\")\n\npackage foo.bar\n如果函数签名不适合单行，请使用以下语法：\n\nfun longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType\n): ReturnType {\n    // 函数体\n}\n函数参数使用常规缩进（4 个空格）。\n\n理由：与构造函数参数一致\n\n对于由单个表达式构成的函数体，优先使用表达式形式。\n\nfun foo(): Int {     // 不良\n    return 1 \n}\n\nfun foo() = 1        // 良好\n如果函数的表达式函数体与函数声明不适合放在同一行，那么将 = 留在第一行。 将表达式函数体缩进 4 个空格。\n\nfun f(x: String) =\n    x.length\n对于非常简单的只读属性，请考虑单行格式：\n\nval isEmpty: Boolean get() = size == 0\n对于更复杂的属性，总是将 get 与 set 关键字放在不同的行上：\n\nval foo: String\n    get() { /*……*/ }\n对于具有初始化器的属性，如果初始化器很长，那么在等号后增加一个换行并将初始化器缩进四个空格：\n\nprivate val defaultCharset: Charset? =\n    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)\n如果 if 或 when 语句的条件有多行，那么在语句体外边总是使用大括号。 将该条件的每个后续行相对于条件语句起始处缩进 4 个空格。 将该条件的右圆括号与左花括号放在单独一行：\n\nif (!component.isSyncing &&\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}\n理由：对齐整齐并且将条件与语句体分隔清楚\n\n将 else、 catch、 finally 关键字以及 do/while 循环的 while 关键字与之前的花括号放在相同的行上：\n\nif (condition) {\n    // 主体\n} else {\n    // else 部分\n}\n\ntry {\n    // 主体\n} finally {\n    // 清理\n}\n在 when 语句中，如果一个分支不止一行，可以考虑用空行将其与相邻的分支块分开：\n\nprivate fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken ->\n            callback.visitValue(propName, token.value)\n\n        Token.LBRACE -> { // ……\n        }\n    }\n}\n将短分支放在与条件相同的行上，无需花括号。\n\nwhen (foo) {\n    true -> bar() // 良好\n    false -> { baz() } // 不良\n}\n在较长参数列表的左括号后添加一个换行符。按 4 个空格缩进参数。 将密切相关的多个参数分在同一行。\n\ndrawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)\n在分隔参数名与值的 = 左右留空格。\n\n当对链式调用换行时，将 . 字符或者 ?. 操作符放在下一行，并带有单倍缩进：\n\nval anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }\n调用链的第一个调用通常在换行之前，当然如果能让代码更有意义也可以忽略这点。\n\n在 lambda 表达式中，应该在花括号左右以及分隔参数与代码体的箭头左右留空格。 如果一个调用接受单个 lambda 表达式，应该尽可能将其放在圆括号外边传入。\n\n如果为 lambda 表达式分配一个标签，那么不要在该标签与左花括号之间留空格：\n\nfun foo() {\n    ints.forEach lit@{\n        // ……\n    }\n}\n在多行的 lambda 表达式中声明参数名时，将参数名放在第一行，后跟箭头与换行符：\n\nappendCommaSeparated(properties) { prop ->\n    val propertyValue = prop.get(obj)  // ……\n}\n如果参数列表太长而无法放在一行上，请将箭头放在单独一行：\n\nfoo {\n   context: Context,\n   environment: Env\n   ->\n   context.configureEnv(environment)\n}\n对于较长的文档注释，将开头 /** 放在一个独立行中，并且后续每行都以星号开头：\n\n简短注释可以放在一行内：\n\n通常，避免使用 @param 与 @return 标记。而是将参数与返回值的描述直接合并到文档注释中，并在提到参数的任何地方加上参数链接。 只有当需要不适合放进主文本流程的冗长描述时才应使用 @param 与 @return。\n\n// 避免这样：\n\n/**\n * Returns the absolute value of the given number.\n * @param number The number to return the absolute value for.\n * @return The absolute value.\n */\nfun abs(number: Int) { /*……*/ }\n\n// 而要这样：\n\n/**\n * Returns the absolute value of the given [number].\n */\nfun abs(number: Int) { /*……*/ }\n一般来说，如果 Kotlin 中的某种语法结构是可选的并且被 IDE 高亮为冗余的，那么应该在代码中省略之。为了清楚起见，不要在代码中保留不必要的语法元素 。\n\n如果函数返回 Unit，那么应该省略返回类型：\n\nfun foo() { // 这里省略了“: Unit”\n\n}\n尽可能省略分号。\n\n将简单变量传入到字符串模版中时不要使用花括号。只有用到更长表达式时才使用花括号。\n\nprintln(\"$name has ${children.size} children\")\n优先使用不可变（而不是可变）数据。初始化后未修改的局部变量与属性，总是将其声明为 val 而不是 var 。\n\n总是使用不可变集合接口（Collection, List, Set, Map）来声明无需改变的集合。使用工厂函数创建集合实例时，尽可能选用返回不可变集合类型的函数：\n\n// 不良：使用可变集合类型作为无需改变的值\nfun validateValue(actualValue: String, allowedValues: HashSet<String>) { …… }\n\n// 良好：使用不可变集合类型\nfun validateValue(actualValue: String, allowedValues: Set<String>) { …… }\n\n// 不良：arrayListOf() 返回 ArrayList<T>，这是一个可变集合类型\nval allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n\n// 良好：listOf() 返回 List<T>\nval allowedValues = listOf(\"a\", \"b\", \"c\")\n优先声明带有默认参数的函数而不是声明重载函数。\n\n// 不良\nfun foo() = foo(\"a\")\nfun foo(a: String) { /*……*/ }\n\n// 良好\nfun foo(a: String = \"a\") { /*……*/ }\n如果有一个在代码库中多次用到的函数类型或者带有类型参数的类型，那么最好为它定义一个类型别名：\n\ntypealias MouseClickHandler = (Any, MouseEvent) -> Unit\ntypealias PersonIndex = Map<String, Person>\n在简短、非嵌套的 lambda 表达式中建议使用 it 用法而不是显式声明参数。而在有参数的嵌套 lambda 表达式中，始终应该显式声明参数。\n\n避免在 lambda 表达式中使用多个返回到标签。请考虑重新组织这样的 lambda 表达式使其只有单一退出点。 如果这无法做到或者不够清晰，请考虑将 lambda 表达式转换为匿名函数。\n\n不要在 lambda 表达式的最后一条语句中使用返回到标签。\n\n当一个方法接受多个相同的原生类型参数或者多个 Boolean 类型参数时，请使用具名参数语法， 除非在上下文中的所有参数的含义都已绝对清楚。\n\ndrawSquare(x = 10, y = 10, width = 100, height = 100, fill = true)\n优先使用 try、if 与 when 的表达形式。例如：\n\nreturn if (x) foo() else bar()\n\nreturn when(x) {\n    0 -> \"zero\"\n    else -> \"nonzero\"\n}\n优先选用上述代码而不是：\n\nif (x)\n    return foo()\nelse\n    return bar()\n    \nwhen(x) {\n    0 -> return \"zero\"\n    else -> return \"nonzero\"\n}    \n二元条件优先使用 if 而不是 when。不要使用\n\nwhen (x) {\n    null -> // ……\n    else -> // ……\n}\n而应使用 if (x == null) …… else ……\n\n如果有三个或多个选项时优先使用 when。\n\n如果需要在条件语句中用到可空的 Boolean, 使用 if (value == true) 或 if (value == false) 检测。\n\n优先使用高阶函数（filter、map 等）而不是循环。例外：forEach（优先使用常规的 for 循环， 除非 forEach 的接收者是可空的或者 forEach 用做长调用链的一部分。）\n\n当在使用多个高阶函数的复杂表达式与循环之间进行选择时，请了解每种情况下所执行操作的开销并且记得考虑性能因素。\n\n使用 until 函数在一个开区间上循环：\n\nfor (i in 0..n - 1) { /*……*/ }  // 不良\nfor (i in 0 until n) { /*……*/ }  // 良好\n优先使用字符串模板而不是字符串拼接。\n\n优先使用多行字符串而不是将 \\n 转义序列嵌入到常规字符串字面值中。\n\n如需在多行字符串中维护缩进，当生成的字符串不需要任何内部缩进时使用 trimIndent，而需要内部缩进时使用 trimMargin：\n\nassertEquals(\n    \"\"\"\n    Foo\n    Bar\n    \"\"\".trimIndent(), \n    value\n)\n\nval a = \"\"\"if(a > 1) {\n          |    return a\n          |}\"\"\".trimMargin()\n在某些情况下，不带参数的函数可与只读属性互换。 虽然语义相似，但是在某种程度上有一些风格上的约定。\n\n底层算法优先使用属性而不是函数：\n\n不会抛异常\n计算开销小（或者在首次运行时缓存）\n如果对象状态没有改变，那么多次调用都会返回相同结果\n放手去用扩展函数。每当你有一个主要用于某个对象的函数时，可以考虑使其成为一个以该对象为接收者的扩展函数。为了尽量减少 API 污染，尽可能地限制扩展函数的可见性。根据需要，使用局部扩展函数、成员扩展函数或者具有私有可视性的顶层扩展函数。\n\n一个函数只有用于两个角色类似的对象时才将其声明为中缀函数。良好示例如：and、 to、zip。 不良示例如：add。\n\n如果一个方法会改动其接收者，那么不要声明为中缀形式。\n\n如果为一个类声明一个工厂函数，那么不要让它与类自身同名。优先使用独特的名称， 该名称能表明为何该工厂函数的行为与众不同。只有当确实没有特殊的语义时， 才可以使用与该类相同的名称。\n\n例如：\n\nclass Point(val x: Double, val y: Double) {\n    companion object {\n        fun fromPolar(angle: Double, radius: Double) = Point(...)\n    }\n}\n如果一个对象有多个重载的构造函数，它们并非调用不同的超类构造函数，并且不能简化为具有默认参数值的单个构造函数，那么优先用工厂函数取代这些重载的构造函数。\n\n返回平台类型表达式的公有函数/方法必须显式声明其 Kotlin 类型：\n\nfun apiCall(): String = MyJavaApi.getProperty(\"name\")\n任何使用平台类型表达式初始化的属性（包级别或类级别）必须显式声明其 Kotlin 类型：\n\nclass Person {\n    val name: String = MyJavaApi.getProperty(\"name\")\n}\n使用平台类型表达式初始化的局部值可以有也可以没有类型声明：\n\nfun main() {\n    val name = MyJavaApi.getProperty(\"name\")\n    println(name)\n}\nKotlin 提供了一系列用来在给定对象上下文中执行代码块的函数：let、 run、 with、 apply 以及 also。 关于不同情况下选择正确作用域函数的准则，请参考作用域函数。\n\n在编写库时，建议遵循一组额外的规则以确保 API 的稳定性：\n\n总是显式指定成员的可见性（以避免将声明意外暴露为公有 API ）\n总是显式指定函数返回类型以及属性类型（以避免当实现改变时意外更改返回类型）\n为所有公有成员提供 KDoc 注释，不需要任何新文档的覆盖成员除外 （以支持为该库生成文档）"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306169562},"updatedAt":{"$$date":1597307252302},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Yn4wumKYLpHhyFnY"}
{"name":"kqapp-initTask","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\nclass InitArouterTask : AppStartTask() {\n    override fun run() {\n        if (BuildConfig.DEBUG) { //日志开启\n            ARouter.openLog()\n            //调试模式开启，如果在install run模式下运行，则必须开启调试模式\n            ARouter.openDebug()\n        }\n        ARouter.init(BaseApplication.instance)\n        RouterDelegate.init(object :RouterDelegate.RouterConfig{\n            override fun getCurrentActivityStatisticKey(): String? {\n                return GlobalConstants.KEY_FROM_ACTIVITY\n            }\n\n            override fun getCurrentActivityStatisticName(): String? {\n                return BaseApplication.currentActivityStatisticPageName\n            }\n        })\n    }\n\n    override fun isRunOnMainThread(): Boolean {\n        return false\n    }\n\n    override fun needWait(): Boolean {\n        return true\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass InitCourseModuleTask : AppStartTask() {\n    override fun run() {\n        Trace.beginSection(\"InitCourseModuleTask run()\")\n        val provider = KsRouterHelper.courseProvider()\n        \"InitCourseModuleTask provider:$provider\".loge()\n        Trace.endSection()\n    }\n\n    override fun isRunOnMainThread(): Boolean = false\n\n\n    override fun getDependsTaskList(): MutableList<Class<out AppStartTask>> {\n        return mutableListOf(InitArouterTask::class.java)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass InitWebViewX5Task : AppStartTask() {\n\n    override fun isRunOnMainThread(): Boolean {\n        return true\n\n    }\n    override fun run() {\n        if (BaseApplication.instance == null) {\n            return\n        }\n        WebViewX5Manager.getInstance().initX5Core(BaseApplication.instance)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage com.ks.lightlearn.wxapi\n\nimport com.tencent.mm.opensdk.modelbase.BaseReq\nimport com.tencent.mm.opensdk.modelbase.BaseResp\nimport com.tencent.mm.opensdk.openapi.IWXAPIEventHandler\nimport com.umeng.socialize.weixin.view.WXCallbackActivity\n\n/**\n * 微信分享结果页\n *\n */\nclass WXEntryActivity : WXCallbackActivity(), IWXAPIEventHandler {\n\n    override fun onReq(baseReq: BaseReq) {\n\n    }\n\n    override fun onResp(resp: BaseResp) {\n    }\n}\n\n\n\n\n\n\n\n\nraw\n    clickmusic.ogg\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593268804},"updatedAt":{"$$date":1598599111687},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YsNTkTK9azVR8f0e"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975861149},"updatedAt":{"$$date":1598975861149},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Ytp5h8HL30do3f3j"}
{"name":"andr-向项目添加组件 ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/architecture/adding-components\n向项目添加组件  |  Android 开发者  |  Android Developers\n1-2 minutes\n在开始之前，我们建议您阅读架构组件的应用架构指南。该指南包含一些适用于所有 Android 应用的有用原则，并展示了如何将架构组件组合到一起使用。\n\n架构组件可从 Google 的 Maven 代码库中获得。要使用这些组件，您必须将代码库添加到项目中。\n\n打开项目的 build.gradle 文件（而不是应用或模块的该文件）并添加 google() 代码库，如下所示：\n\n    allprojects {\n        repositories {\n            google()\n            jcenter()\n        }\n    }\n    \n声明依赖项\n打开应用或模块的 build.gradle 文件，然后添加所需的软件工件作为依赖项。您可以为所有架构组件添加依赖项，也可以选择其中一部分。\n\n请参阅版本说明中关于为每个架构组件声明依赖项的说明：\n\nFutures（可在 androidx.concurrent 中找到）\n生命周期组件（包括 ViewModel）\n导航（包括 SafeArgs）\nPaging\nRoom\nWorkManager\n如需详细了解 AndroidX 重构及其对这些类包和模块 ID 的影响，请参阅 AndroidX 重构文档。\n\nKotlin\nKotlin 扩展模块支持使用多个 AndroidX 依赖项。这些模块的名称后附加了后缀“-ktx”。例如：\n\nimplementation \"androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version\"\n    \n会变为\n\nimplementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version\"\n    \n您可以在 ktx 文档中找到更多信息，包括 Kotlin 扩展程序的文档。\n\n注意：对于基于 Kotlin 的应用，请确保使用 kapt 而不是annotationProcessor。您还应添加 kotlin-kapt 插件。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243902702},"updatedAt":{"$$date":1597244054538},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YuLOPJ6GQKtlzu1V"}
{"name":"qk-ks_lib_pull_refresh","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'lib-route-consumer-rules.pro'\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.kotlin.stdlib_jdk\n    implementation deps.androidx.core_ktx\n    implementation deps.androidx.recyclerview\n    // 下拉刷新组件\n    api 'com.lcodecorex:tkrefreshlayout:1.0.7'\n    // BaseQuickAdapter + 上拉加载更多组件\n    api 'com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.0-beta11'\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass TwinkingFreshLayout @JvmOverloads constructor(\n\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : FrameLayout(context, attrs, defStyleAttr), IHeaderView {\n\n    private var mCircleView: ImageView? = null\n\n    private var animationDrawable: AnimationDrawable? = null\n    private var mCurrentDrawableName: String? = \"\"\n\n    private var mIsBeingDragged = false\n\n    init {\n        createProgressView(context)\n        ViewCompat.setChildrenDrawingOrderEnabled(this, true)\n        // the absolute offset has to take into account that the circle starts at an offset 11111\n    }\n\n    private fun createProgressView(context: Context) {\n        mCircleView = ImageView(getContext())\n        val params = LayoutParams(dp2px(40), dp2px(40), Gravity.CENTER)\n        mCircleView!!.scaleType = ImageView.ScaleType.FIT_XY\n        mCircleView!!.layoutParams = params\n        addView(mCircleView)\n    }\n\n    /**\n     * One of DEFAULT, or LARGE.\n     */\n    fun setSize(size: Int) {\n        // force the bounds of the progress circle inside the circle view to\n        // update by setting it to null before updating its size and then\n        // re-setting it\n        mCircleView!!.setImageDrawable(null)\n        mCircleView!!.setImageResource(R.drawable.anim_loading_view)\n    }\n\n    override fun reset() {\n        mCircleView!!.clearAnimation()\n        mCircleView!!.visibility = View.GONE\n        mCircleView!!.setImageDrawable(null)\n    }\n\n    fun getResource(imageName: String): Int {\n        mCurrentDrawableName = imageName\n        val ctx = context\n        return resources.getIdentifier(imageName, \"drawable\", ctx.packageName)\n    }\n\n    override fun getView(): View {\n        return this\n    }\n\n    override fun onPullingDown(fraction: Float, maxHeadHeight: Float, headHeight: Float) {\n        if (mCircleView!!.visibility != View.VISIBLE) {\n            mCircleView!!.visibility = View.VISIBLE\n        }\n        setAnimResourse(fraction)\n        if (!mIsBeingDragged) {\n            mIsBeingDragged = true\n        }\n\n\n    }\n\n    private fun setAnimResourse(fraction: Float) {\n        var fraction = fraction\n        if (fraction > 1) {\n            fraction = 1f\n        }\n        val index = (fraction * 16).toInt() % 17\n        val drawableName = String.format(\"comp_000%02d\", index)\n\n        if (null != mCurrentDrawableName && null != drawableName && mCurrentDrawableName != drawableName) {\n            mCircleView!!.setImageResource(getResource(drawableName))\n        }\n    }\n\n    override fun onPullReleasing(fraction: Float, maxHeadHeight: Float, headHeight: Float) {\n        mIsBeingDragged = false\n    }\n\n    override fun startAnim(maxHeadHeight: Float, headHeight: Float) {\n        mCircleView!!.visibility = View.VISIBLE\n        mCircleView!!.setImageDrawable(null)\n        mCircleView!!.setImageResource(R.drawable.anim_dropdown_refresh_loading_view)\n        animationDrawable = mCircleView!!.drawable as AnimationDrawable\n        animationDrawable!!.start()\n\n    }\n\n    override fun onFinish(animEndListener: OnAnimEndListener) {\n        mCircleView!!.animate().scaleX(1f).scaleY(1f).alpha(1f)\n            .setListener(object : AnimatorListenerAdapter() {\n                override fun onAnimationEnd(animation: Animator) {\n                    reset()\n                    animEndListener.onAnimEnd()\n                }\n            }).start()\n    }\n\n\n    private fun dp2px(dp: Int): Int {\n        return TypedValue.applyDimension(\n            TypedValue.COMPLEX_UNIT_DIP, dp.toFloat(),\n            resources.displayMetrics\n        ).toInt()\n    }\n}\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580903391},"updatedAt":{"$$date":1598581775213},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YvytAsinCs3buYfG"}
{"name":"ad-ks_frame_bsdiffpatcher","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\nbzip\nblocksort.c\nbzlib.c\nbzlib.h\nbzlib_private.h\ncompress.c\ncrctable.c\ndecompress.c\nhuffman.c\nrandtable.c\nbspatch.c\nnative-lib.cpp\n\n\n\n\n\n\n\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n//        externalNativeBuild {\n//            cmake {\n//                cppFlags \"-frtti -fexceptions\"\n//                abiFilters 'armeabi-v7a'\n//            }\n//        }\n\n        ndk {\n            abiFilters 'armeabi-v7a'\n        }\n    }\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n            java {\n                srcDirs += []\n            }\n        }\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n    splits {//删除64位的so库\n        abi {\n            enable true\n            reset()\n            include 'armeabi-v7a'\n            universalApk false\n        }\n    }\n//\n//    externalNativeBuild {\n//        cmake {\n//            path \"CMakeLists.txt\"\n//        }\n//    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n}\n\napply from: rootProject.file(\"./script/upload_local_maven.gradle\")\n\n\n\n////该task用来打包jar包\n//task makeJar(type: Copy) {\n//    delete 'libs/ksbsdiff.jar' //删除已经存在的jar包\n//    from('build/intermediates/runtime_library_classes/release/')//从该目录下加载要打包的文件，注意这个目录，不同版本的AndroidStudio是不一样的，比如在3.0版本是build/intermediates/bundles/release/，要自己去查一下。\n//    into('libs/')//jar包的保存目录\n//    include('classes.jar')//设置过滤，只打包classes文件\n//    rename('classes.jar', 'ksbsdiff.jar')//重命名，mylibrary.jar 根据自己的需求设置\n//}\n//\n//makeJar.dependsOn(build)\n\n\n\n\n\n\n\n\n/**\n * **************************************\n * @Author guanhuawei\n * 邮箱：guanhuawei@ksjgs\n * 用途 老文件通过patch包生成新文件，实现增量更新的功能\n * **************************************\n */\npublic class KsBsDiffPatcher {\n\n    // 用于在应用程序启动时，加载本地的lib库\n    static {\n        System.loadLibrary(\"ksbspatcher\");\n    }\n\n    /**\n     * 合成新文件\n     *\n     * @param oldZip 旧版文件包，如1.1.1版本\n     * @param patch  差分包，Patch文件\n     * @param output 合成后新版本文件的输出路径\n     */\n    public static native void ksBsPatch(String oldZip, String patch, String output);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nCMakeLists.txt\n\n\n         cmake_minimum_required(VERSION 3.4.1)\n\n        # 查找文件系统中制定模式的路径，如：/*是匹配根目录下的所有文件\n        file(GLOB bzip_source ${CMAKE_SOURCE_DIR}/src/main/cpp/bzip/*.c)\n\n\n        # 设置本地动态库，编译生成动态库\n        add_library(\n                ksbspatcher # 模块名\n\n                SHARED # 动态库、分享库\n\n                src/main/cpp/native-lib.cpp\n                src/main/cpp/bspatch.c\n                ${bzip_source}) # 源文件\n\n        # 查找系统库，日志输出库Log\n        find_library(\n                log-lib\n                log)\n\n        # 需要链接或者编译的库\n        target_link_libraries(\n                ksbspatcher\n                ${log-lib})\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539551617},"updatedAt":{"$$date":1598542429841},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"YyEKUpDWbJ0UMh30"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980155146},"updatedAt":{"$$date":1594980155146},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YyL9H9HN2Px1LM6D"}
{"name":"ad-dependencies.gradle","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\ndef versions = [\n        // gradle_plugin\n        gradle_plugin             : \"4.0.0\",\n        packer_np_plugin          : \"2.0.1\",\n        kotlin_version            : \"1.3.72\",\n        grale_retrolambda         : \"3.7.0\",\n        arouter_plugin            : \"1.0.2\",\n        tingyun_plugin            : \"2.14.2\",\n\n        androidx                  : \"1.2.0-alpha03\",\n        support                   : \"1.1.0\",\n        lifecycle_version         : \"2.2.0\",\n        constraint_layout         : \"1.1.3\",\n        retrofit                  : \"2.3.0\",\n        //升级修复bug   https://github.com/DV8FromTheWorld/JDA/issues/861\n        //再次升级  https://github.com/square/okhttp/issues/5029\n        okhttp3                   : \"3.12.12\",\n        tkrefreshlayout           : \"1.0.7\",\n        explosionfield            : \"1.0,1\",\n        multidex                  : \"2.0.1\",\n        junit                     : \"4.12\",\n        fresco                    : \"1.11.0\",\n        sobot                     : \"2.6.0\",\n        arouter_annotation_version: \"1.2.1\",\n        kotlin_coroutines         : '1.3.2',\n        arouter                   : \"1.4.0\",\n        zip                       : '0.0.1',\n]\n\next {\n    LIB_MEDIA_DIR_PATH = project(':libmedia').file('libs')\n    LIB_LOGIN_DIR_PATH = project(':ks_login_center').file('libs')\n    KS_PAYMENT_CENTER_DIR_PATH = project(':ks_payment_center').file('libs')\n    KS_BASE_DIR_PATH = project(':ks_base').file('libs')\n    KS_STORYMACHINE_CENTER_DIR_PATH = project(':ks_storymachine_center').file('libs')\n}\n\next {\n    app_id = \"com.ks.kaishustory\"\n    useLibrary = \"org.apache.http.legacy\"   //兼容httpclient\n\n    testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n\n    signConfig = [\n            storeFile    : \"../../config/kaishustory.jks\",\n            storePassword: \"kaishu2099\",\n            keyAlias     : \"kaishustory\",\n            keyPassword  : \"kaishu2099\",\n    ]\n\n    signAloneConfig = [\n            storeFile    : \"../../../config/kaishustory.jks\",\n            storePassword: \"kaishu2099\",\n            keyAlias     : \"kaishustory\",\n            keyPassword  : \"kaishu2099\",\n    ]\n    //三方的appid\n    manifesPlaceholder = [\n            JPUSH_PKGNAME   : \"com.ks.kaishustory\",\n            JPUSH_APPKEY    : [\n                    RELEASE: \"27ea5c4118841949e028b5a6\",\n                    DEBUG  : \"57283276b61298889419e1a6\",\n\n            ], //JPush上注册的包名对应的appkey.\n            JPUSH_CHANNEL   : \"ks\", //暂时填写默认值即可.\n            qqappid         : \"1104587779\",\n\n            XIAOMI_APPKEY   : \"MI-5831749188290\",\n            XIAOMI_APPID    : \"MI-2882303761517491290\",\n\n            MEIZU_APPKEY    : \"MZ-cee873ccd82146a79f2645c57ab2a347\",\n            MEIZU_APPID     : \"MZ-116650\",\n\n            HUAWEI_APPID    : \"10595297\",\n\n            OPPO_APPKEY     : \"OP-8cnegjBCg8gSGK88w8owkkw40\", // OPPO平台注册的appkey\n            OPPO_APPID      : \"OP-3382749\", // OPPO平台注册的appid\n            OPPO_APPSECRET  : \"OP-2123b87e9F8CfFfb46C6a8bb5eCEd44e\",//OPPO平台注册的appsecret\n\n            VIVO_APPKEY     : \"990cab12-0dda-4875-92eb-9e54402098bd\", // VIVO平台注册的appkey\n            VIVO_APPID      : \"18372\", // VIVO平台注册的appid\n\n            GETUI_APP_ID    : [\n                    RELEASE: \"99rFI9wgTwAKWOtChN6hl\",\n                    DEBUG  : \"7oWpfF2WBt97t7TvpR1YH3\"\n            ],\n            GETUI_APP_KEY   : [\n                    RELEASE: \"BHc2U8Qn5u85pwKCmDVxh\",\n                    DEBUG  : \"OBbcU2hw6FAPa8fvsVKr6A\"\n            ],\n            GETUI_APP_SECRET: [\n                    RELEASE: \"TWGQqkAsMY5kJyY7ndw2b2\",\n                    DEBUG  : \"7U43ayQSO46VMHdosjSyc\"\n            ],\n            GY_APP_ID       : [\n                    RELEASE: \"99rFI9wgTwAKWOtChN6hl\",\n                    DEBUG  : \"7oWpfF2WBt97t7TvpR1YH3\"\n            ],\n            GY_CHANNEL      : [\n                    RELEASE: \"ks\",\n                    DEBUG  : \"ks\"\n            ],\n\n    ]\n\n    //for react native module\n    buildToolsVersion = \"28.0.3\"\n    minSdkVersion = 16\n    compileSdkVersion = 28\n    targetSdkVersion = 28\n    supportLibVersion = \"28.0.0\"\n\n    build_versions = [\n            compile_sdk : 28,\n            min_sdk     : 17,\n            target_sdk  : 28,\n            tool_version: \"28.0.3\",\n\n            versionCode : 6170,\n            versionName : \"6.17.0\",\n    ]\n    project_plugin = [\n            gradle_plugin    : \"com.android.tools.build:gradle:${versions.gradle_plugin}\",\n            grale_retrolambda: \"me.tatarka:gradle-retrolambda:${versions.grale_retrolambda}\",\n            kotlin_plugin    : \"org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin_version}\",\n            packer_np_plugin : \"com.mcxiaoke.packer-ng:plugin:${versions.packer_np_plugin}\",\n            arouter_plugin   : \"com.alibaba:arouter-register:${versions.arouter_plugin}\",\n            tingyun_plugin   : \"com.networkbench.newlens.agent.android:agent-gradle-plugin:${versions.tingyun_plugin}\",\n            growingio        : \"com.growingio.android:vds-gradle-plugin:autotrack-2.8.13\",\n            appmerge         : \"com.ks.kotlin:ks-lib-appmerge-plugin:1.0.7.2\",\n            aspectjx         : \"com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.10\"\n    ]\n\n    deps = [\n            zip                           : \"com.leo618:zip:${versions.zip}\",\n            //support 系统库\n            androidx                      : [\n                    app_compat              : \"androidx.appcompat:appcompat:${versions.androidx}\",\n                    design                  : \"com.google.android.material:material:${versions.support}\",\n                    constraint_layout       : \"androidx.constraintlayout:constraintlayout:${versions.constraint_layout}\",\n                    cardview                : \"androidx.cardview:cardview:1.0.0\",\n                    multidex                : \"androidx.multidex:multidex:${versions.multidex}\",\n                    support_v4              : \"androidx.legacy:legacy-support-v4:1.0.0\",\n                    fragment                : \"androidx.fragment:fragment:${versions.support}\",\n                    palette                 : \"androidx.palette:palette:1.0.0\",\n                    recyclerview_v7         : \"androidx.recyclerview:recyclerview:${versions.support}\",\n                    annotations_experimental: \"androidx.annotation:annotation-experimental:1.0.0\",\n                    annotations             : \"androidx.annotation:annotation:1.1.0\",\n                    junit                   : \"junit:junit:${versions.junit}\",\n                    test_runner             : \"androidx.test:runner:1.2.0\",\n                    spresso_core            : \"androidx.test.espresso:espresso-core:3.2.0\",\n                    core                    : \"androidx.core:core-ktx:1.1.0\",\n\n            ],\n\n            lifecycle                     : [\n                    extensions: \"androidx.lifecycle:lifecycle-extensions:$versions.lifecycle_version\",\n                    viewmodel : \"androidx.lifecycle:lifecycle-viewmodel:$versions.lifecycle_version\",\n                    livedata  : \"androidx.lifecycle:lifecycle-livedata:$versions.lifecycle_version\",\n                    runtime   : \"androidx.lifecycle:lifecycle-runtime:$versions.lifecycle_version\"\n            ],\n            //retrofit相关依赖--网络请求封装\n            retrofit                      : [\n                    retrofit         : \"com.squareup.retrofit2:retrofit:${versions.retrofit}\",\n                    converter_gson   : \"com.squareup.retrofit2:converter-gson:${versions.retrofit}\",\n                    adapter_rxjava2  : \"com.squareup.retrofit2:adapter-rxjava2:${versions.retrofit}\",\n                    converter_scalars: \"com.squareup.retrofit2:converter-scalars:${versions.retrofit}\"\n            ],\n            //okhttp相关依赖--网络请求\n            okhttp3                       : [\n                    okhttp             : \"com.squareup.okhttp3:okhttp:${versions.okhttp3}\",\n                    logging_interceptor: \"com.squareup.okhttp3:logging-interceptor:${versions.okhttp3}\"\n            ],\n            //极光相关依赖--推送\n            jiguang                       : [\n                    jpush : \"cn.jiguang.sdk:jpush:3.4.1\",\n                    jcore : 'cn.jiguang.sdk:jcore:2.3.4',\n                    jmlink: \"cn.jiguang.sdk:jmlink:1.1.0\"\n            ],\n            //极光推送依赖的三方推送\n            jpush                         : [\n                    jpush_xiaomi: \"cn.jiguang.sdk.plugin:xiaomi:3.4.1\",\n                    jpush_meizu : \"cn.jiguang.sdk.plugin:meizu:3.4.1\",\n                    jpush_huawei: \"cn.jiguang.sdk.plugin:huawei:3.4.1\",\n                    jpush_vivo  : \"cn.jiguang.sdk.plugin:vivo:3.4.1\",\n                    jpush_oppo  : \"cn.jiguang.sdk.plugin:oppo:3.4.1\",\n//                    jpush_verification: \"cn.jiguang.sdk:jverification:2.6.4\",\n\n            ],\n            //个推相关依赖--推送\n            getui                         : [\n                    //sdk   : 'com.getui:sdk:2.13.2.0',\n                    gtc: 'com.getui:gtc:2.1.0',\n                    //gysdk : 'com.getui:gysdk:1.5.0.1',\n                    //一键登录扩展包 不使用一键登录不需要集成\n                    //elogin: 'com.getui:elogin:1.0.0.3',\n            ],\n            //fresco相关依赖--图片显示\n            fresco                        : [\n                    fresco              : \"com.facebook.fresco:fresco:${versions.fresco}\",\n                    imagepipeline_okhttp: \"com.facebook.fresco:imagepipeline-okhttp3:${versions.fresco}\",\n                    animated_gif        : \"com.facebook.fresco:animated-gif:${versions.fresco}\",\n            ],\n            //rxjava相关依赖\n            rxjava2                       : [\n                    rxjava   : 'io.reactivex.rxjava2:rxjava:2.2.12',\n                    rxandroid: 'io.reactivex.rxjava2:rxandroid:2.1.1'\n            ],\n            //rxlifecycler相关依赖--生命周期管理\n            rxlifecycle                   : [\n                    android   : 'com.trello.rxlifecycle2:rxlifecycle-android:2.1.0',\n                    components: 'com.trello.rxlifecycle2:rxlifecycle-components:2.1.0',\n                    lifecycle : 'com.trello.rxlifecycle2:rxlifecycle:2.1.0'\n            ],\n            //kotlin\n            kotlin                        : [\n                    kotlin_stdlib_jdk : \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:${versions.kotlin_version}\",\n                    kotlin_reflect    : \"org.jetbrains.kotlin:kotlin-reflect:${versions.kotlin_version}\",\n\n                    coroutines_core   : \"org.jetbrains.kotlinx:kotlinx-coroutines-core:${versions.kotlin_coroutines}\",\n                    coroutines_android: \"org.jetbrains.kotlinx:kotlinx-coroutines-android:${versions.kotlin_coroutines}\"\n            ],\n            //router相关依赖--路由跳转\n            router                        : [\n                    arouter           : \"com.alibaba:arouter-api:${versions.arouter}\",\n                    arouter_annotation: \"com.alibaba:arouter-compiler:${versions.arouter_annotation_version}\",\n            ],\n            //听云相关依赖\n            tingyun                       : [\n                    newlens_agent      : 'com.networkbench.newlens.agent.android:nbs.newlens.agent:2.14.2',\n                    newlens_nativecrash: 'com.networkbench.newlens.agent.android:nbs.newlens.nativecrash:1.0.0'\n            ],\n            httpdns                       : [\n                    httpdns       : 'com.aliyun.ams:alicloud-android-httpdns:1.3.2.3',\n                    //避免切换到 androidx时报错\n                    httpdns_utdid : 'com.aliyun.ams:alicloud-android-utdid:1.5.2',\n                    httpdns_ut    : 'com.aliyun.ams:alicloud-android-ut:5.4.3',\n                    httpdns_beacon: 'com.aliyun.ams:alicloud-android-beacon:1.0.4.3'\n            ],\n            tencent                       : [\n                    //故事机联网的\n                    dmsdktskm: \"com.tencent.yunxiaowei.dmsdk:tskm:2.1.4\",\n                    dmsdkcore: \"com.tencent.yunxiaowei.dmsdk:core:2.1.4\",\n                    //智龄\n                    taisdk   : \"com.tencent.taisdk:taisdk:1.2.3.3\"\n            ],\n            //多渠道打包\n            packer_ng                     : \"com.mcxiaoke.packer-ng:helper:${versions.packer_np_plugin}\",\n            //下拉刷新库\n            tkrefreshlayout               : \"com.ks.lcodecorex:twinklingRefreshLayout:1.0.7.5\",\n            //右滑退出Actiivty库\n//            swipebackhelper               : \"com.jude:swipebackhelper:3.1.2\",\n\n            //弹窗库--------后面可以统一\n            materialdialog                : \"me.drakeet.materialdialog:library:1.3.1\",\n            //图片剪裁\n            ucrop                         : \"com.github.yalantis:ucrop:2.2.5\",\n            //点赞动画库\n            LikeButton                    : \"com.github.jd-alexander:LikeButton:0.2.3\",\n            //流式布局样式\n            apmem_layouts                 : \"org.apmem.tools:layouts:1.10@aar\",\n            //阿里云oss上传和下载库\n            oss_android_sdk               : \"com.aliyun.dpa:oss-android-sdk:2.9.1\",\n            //横滑删除库\n            //swipemenu_recyclerview        : \"com.tubb.smrv:swipemenu-recyclerview:3.0.7\",\n            //三方工具类（字符串判空、打印日志）----后续工具类整合\n            toolsfinal                    : \"cn.finalteam:toolsfinal:1.1.5\",\n            //多线程通讯\n            eventbus                      : \"org.greenrobot:eventbus:3.1.1\",\n            //腾讯bugly崩溃上报\n            crashreport                   : \"com.tencent.bugly:crashreport:3.2.3\",\n            //进度条\n            materialprogressbar           : \"me.zhanghai.android.materialprogressbar:library:1.6.1\",\n            //进度条\n            circleprogress                : \"com.github.lzyzsd:circleprogress:1.2.1\",\n            //图片缩放库\n            photodraweeview               : \"me.relex:photodraweeview:2.0.0\",\n            //伴读伴唱自定义view\n            ticker                        : \"com.robinhood.ticker:ticker:2.0.2\",\n\n            //腾讯openSdk\n            wechat_sdk_android_without_mta: \"com.tencent.mm.opensdk:wechat-sdk-android-without-mta:5.4.3\",\n            //谷歌的服务\n            play_services_appindexing     : \"com.google.android.gms:play-services-appindexing:8.4.0\",\n            //popupwindow\n            CustomPopwindow               : \"com.github.pinguo-zhouwei:CustomPopwindow:2.1.1\",\n            //fastjson\n            fastjson                      : \"com.alibaba:fastjson:1.1.71.android\",\n            //友盟统计\n            //analytics                     : \"com.umeng.umsdk:analytics:8.1.4\",\n            //Gson\n            google_gson                   : \"com.google.code.gson:gson:2.8.5\",\n            //切换按钮\n            switch_button                 : \"com.github.zcweng:switch-button:0.0.3@aar\",\n\n            //图片压缩库\n            compressor                    : 'id.zelory:compressor:2.1.0',\n            //视频横竖屏切换动画效果库\n            transitionseverywhere         : \"com.andkulikov:transitionseverywhere:2.0.0\",\n            //lottie动画\n//            lottie                        : \"com.airbnb.android:lottie:3.4.0\",\n            //gif\n            gif_drawable                  : 'pl.droidsonroids.gif:android-gif-drawable:1.2.19',\n            BackgroundLibrary             : \"com.noober.background:core:1.6.5\",\n            //腾讯mmkv库--本地轻量数据缓存\n            mmkv                          : \"com.tencent:mmkv-static:1.1.2\",\n            growingio                     : \"com.growingio.android:vds-android-agent:autotrack-2.8.13\",\n            //LeakCanary\n            leakcanary                    : \"com.squareup.leakcanary:leakcanary-android:2.4\",\n            //BlockCanary\n            blockcanary                   : \"com.github.markzhai:blockcanary-android:1.5.0\",\n            polyv                         : \"com.easefun.polyv:polyvSDKCloudClass:0.12.0.06\",\n            svga                          : \"com.github.yyued:SVGAPlayer-Android:2.5.3\",\n            xiaoaccount                   : \"com.xiaomi.account:oauth-android:2.0.10\",\n            rxpermissions                 : \"com.github.tbruyelle:RxPermissions:0.10.2\",\n            volley                        : \"com.android.volley:volley:1.1.0\",\n            methodtraceman                : 'com.github.zhengcx:MethodTraceMan:1.0.7',\n            leakcanary                    : 'com.squareup.leakcanary:leakcanary-android:2.3',\n            flowLayout                    : 'com.github.1002326270xc:LayoutManager-FlowLayout:v1.8',\n            pdfviewer                     : 'com.github.barteksc:android-pdf-viewer:2.8.2',\n            tecentX5                      : \"com.tencent.tbs.tbssdk:sdk:43903\",\n\n    ]\n\n    //jcenter\n    ks = [\n            ksui                    : 'com.ks.ksui:ksui:0.0.2',\n            ksutils                 : 'com.ks.ksutils:ksutils:0.0.3',\n            kscityselector          : 'com.ks.kscityselector:kscityselector:0.0.2',\n            kszxing                 : 'com.ks.kszxing:kszxing:0.0.2',\n            kstoast                 : 'com.ks.kstoast:kstoast:0.0.2',\n            kprogresshud            : 'com.ks.ksprogresshud:ksprogresshud:0.0.2',\n            ksdialogplus            : 'com.ks.ksdialogplus:ksdialogplus:0.0.2',\n            ksurirouter             : 'com.ks.ksurirouter:ksurirouter:0.1.0',\n            ksappmerge              : \"com.ks.kotlin:ks-lib-appmerge:0.0.2\",\n            ksswipeback             : \"com.ks.ksswipeback:ksswipeback:0.0.2\",\n            ksinit                  : \"com.ks.ksinit:ksinit:0.0.2\",\n            ksEmptyClassReplace     : \"com.ks.ksEmptyClassReplace:emptyclassreplace:0.0.2\",\n            //baseAdapter\n            easyrecyclerview        : \"com.ks.kseasyrecyclerview:kseasyrecyclerview:0.0.2\",\n            ksautosizebybd          : \"com.ks.ksautosizebybd:ksautosizebybd:0.0.1\",\n            ksmediahandler          : \"com.ks.ksmediahandler:ksmediahandler:0.0.4\",\n            ksconvenientbanner      : \"com.ks.ksconvenientbanner:ksconvenientbanner:0.0.1\",\n            ksdiskframe             : \"com.ks.ksdiskframe:ksdiskframe:0.0.6\",\n            ksloadpic               : \"com.ks.ksloadpic:ksloadpic:0.0.2\",\n            ksbottomnavigationbar   : \"com.ks.ksbottomnavigationbar:bottomnavigationbar:0.0.1\",\n            ksflycotablayout        : \"com.ks.ksflycotablayout:flytablayout:0.0.1\",\n            ksmagicindicator        : \"com.ks.ksmagicindicator:magicindicator:0.0.1\",\n            ksliulishuodownload     : \"com.ks.ksliulishuodownload:liulishuodownload:0.0.1\",\n            ksrclayout              : \"com.ks.ksrclayout:rclayout:0.0.1\",\n            ksseekbar               : \"com.ks.ksseekbar:seekbar:0.0.1\",\n            kswheelpicker           : \"com.ks.kswheelpicker:wheelpicker:0.0.1\",\n            ksxtablayout            : \"com.ks.ksxtablayout:xtablayout:0.0.1\",\n            ksmp3recorder           : \"com.ks.ksmp3recorder:mp3recorder:0.0.4\",\n            kscocos2dx              : \"com.ks.kscocos2dx:cocos2dx:0.0.2\",\n            kschatframe             : \"com.ks.kschatframe:chatframe:0.0.1\",\n            ksliveframe             : \"com.ks.ksliveframe:liveframe:0.0.1\",\n            kspolyvplayer           : \"com.ks.kspolyvplayer:polyvplayer:0.0.1\",\n            kspolyvchat             : \"com.ks.kspolyvchat:polyvchat:0.0.1\",\n            ksliveimpl              : \"com.ks.ksliveimpl:liveimpl:0.0.1\",\n            ksktxsupport            : \"com.ks.ksktxsupport:ktxsupport:0.0.1\",\n            kswebview               : \"com.ks.kswebview:kswebview:0.0.4\",\n            ksbsdiffpatcher         : \"com.ks.ksbsdiffpatcher:bsdiffpatcher:0.0.1\",\n            recyclerViewAdaperHelper: \"com.ks.baseRecyclerViewAdapterHelper:baseRecyclerViewAdapterHelper:0.0.11\",\n            kstheforcesystem        : \"com.ks.kotlin:ks_component_theforcesystem:0.0.13.5\",\n\n    ]\n\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515779063},"updatedAt":{"$$date":1598516833820},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Z1RlBxAlUFrKsrds"}
{"name":"kotlin-密封类 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/sealed-classes.html\n密封类 - Kotlin 语言中文站\n4-4 minutes\n改进翻译\n密封类用来表示受限的类继承结构：当一个值为有限几种的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。\n\n要声明一个密封类，需要在类名前面添加 sealed 修饰符。虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前， 该规则更加严格：子类必须嵌套在密封类声明的内部）。\n\nsealed class Expr\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n（上文示例使用了 Kotlin 1.1 的一个额外的新功能：数据类扩展包括密封类在内的其他类的可能性。 ）\n\n一个密封类是自身抽象的，它不能直接实例化并可以有抽象（abstract）成员。\n\n密封类不允许有非-private 构造函数（其构造函数默认为 private）。\n\n请注意，扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。\n\n使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。当然，这只有当你用 when 作为表达式（使用结果）而不是作为语句时才有用。\n\nfun eval(expr: Expr): Double = when(expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n    // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307922502},"updatedAt":{"$$date":1597308021281},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Z2qE8cvpy4SldhXn"}
{"name":"kqapp-ks_component_ui","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion BuildVersion.compile_sdk\n    buildToolsVersion BuildVersion.tool_version\n\n\n    defaultConfig {\n        minSdkVersion BuildVersion.min_sdk\n        targetSdkVersion BuildVersion.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n\n        debug.initWith(release)\n        debug {\n            debuggable true\n            externalNativeBuild {\n                ndkBuild {\n                    arguments 'NDK_DEBUG=1'\n                }\n            }\n\n        }\n\n        gama.initWith(debug)\n        gama {\n            debuggable true\n            matchingFallbacks = ['debug', 'release']\n        }\n\n        CDGama.initWith(debug)\n        CDGama {\n            debuggable true\n            matchingFallbacks = ['release', 'debug']\n        }\n\n        CDDebug.initWith(debug)\n        CDDebug {\n            signingConfig signingConfigs.debug\n            matchingFallbacks = ['release', 'debug']\n        }\n\n        dapi.initWith(debug)\n        dapi {\n            matchingFallbacks = ['debug', 'release']\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation Kotlin.stdlib_jdk\n    implementation Androidx.appcompat\n    implementation Androidx.constraintlayout\n\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    //fresco\n    implementation (Ks_lib.lib_picture){ changing = true }\n\n    implementation (Ks_lib.lib_ktx){ changing = true }\n    implementation (Ks_lib.lib_autosize){ changing = true }\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * 作用：圆角图片\n * 作者：GcsSloop\n */\n@SuppressLint(\"AppCompatCustomView\")\npublic class RCImageView extends ImageView implements Checkable, RCAttrs {\n\n    RCHelper mRCHelper;\n\n    public RCImageView(Context context) {\n        this(context, null);\n    }\n\n    public RCImageView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public RCImageView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        mRCHelper = new RCHelper();\n        mRCHelper.initAttrs(context, attrs);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        mRCHelper.onSizeChanged(this, w, h);\n    }\n\n    @Override\n    public void draw(Canvas canvas) {\n        if (mRCHelper.mClipBackground) {\n            canvas.save();\n            canvas.clipPath(mRCHelper.mClipPath);\n            super.draw(canvas);\n            canvas.restore();\n        } else {\n            super.draw(canvas);\n        }\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        canvas.saveLayer(mRCHelper.mLayer, null, Canvas.ALL_SAVE_FLAG);\n        super.onDraw(canvas);\n        mRCHelper.onClipDraw(canvas);\n        canvas.restore();\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        int action = ev.getAction();\n        if (action == MotionEvent.ACTION_DOWN && !mRCHelper.mAreaRegion.contains((int) ev.getX(), (int) ev.getY())) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_UP) {\n            refreshDrawableState();\n        } else if (action == MotionEvent.ACTION_CANCEL) {\n            setPressed(false);\n            refreshDrawableState();\n        }\n        return super.dispatchTouchEvent(ev);\n    }\n\n\n    //--- 公开接口 ----------------------------------------------------------------------------------\n\n    public void setClipBackground(boolean clipBackground) {\n        mRCHelper.mClipBackground = clipBackground;\n        invalidate();\n    }\n\n    public void setRoundAsCircle(boolean roundAsCircle) {\n        mRCHelper.mRoundAsCircle = roundAsCircle;\n        invalidate();\n    }\n\n    public void setRadius(int radius) {\n        for (int i = 0; i < mRCHelper.radii.length; i++) {\n            mRCHelper.radii[i] = radius;\n        }\n        invalidate();\n    }\n\n    public void setTopLeftRadius(int topLeftRadius) {\n        mRCHelper.radii[0] = topLeftRadius;\n        mRCHelper.radii[1] = topLeftRadius;\n        invalidate();\n    }\n\n    public void setTopRightRadius(int topRightRadius) {\n        mRCHelper.radii[2] = topRightRadius;\n        mRCHelper.radii[3] = topRightRadius;\n        invalidate();\n    }\n\n    public void setBottomLeftRadius(int bottomLeftRadius) {\n        mRCHelper.radii[6] = bottomLeftRadius;\n        mRCHelper.radii[7] = bottomLeftRadius;\n        invalidate();\n    }\n\n    public void setBottomRightRadius(int bottomRightRadius) {\n        mRCHelper.radii[4] = bottomRightRadius;\n        mRCHelper.radii[5] = bottomRightRadius;\n        invalidate();\n    }\n\n    public void setStrokeWidth(int strokeWidth) {\n        mRCHelper.mStrokeWidth = strokeWidth;\n        invalidate();\n    }\n\n    public void setStrokeColor(int strokeColor) {\n        mRCHelper.mStrokeColor = strokeColor;\n        invalidate();\n    }\n\n    @Override\n    public void invalidate() {\n        if (null != mRCHelper)\n            mRCHelper.refreshRegion(this);\n        super.invalidate();\n    }\n\n    public boolean isClipBackground() {\n        return mRCHelper.mClipBackground;\n    }\n\n    public boolean isRoundAsCircle() {\n        return mRCHelper.mRoundAsCircle;\n    }\n\n    public float getTopLeftRadius() {\n        return mRCHelper.radii[0];\n    }\n\n    public float getTopRightRadius() {\n        return mRCHelper.radii[2];\n    }\n\n    public float getBottomLeftRadius() {\n        return mRCHelper.radii[4];\n    }\n\n    public float getBottomRightRadius() {\n        return mRCHelper.radii[6];\n    }\n\n    public int getStrokeWidth() {\n        return mRCHelper.mStrokeWidth;\n    }\n\n    public int getStrokeColor() {\n        return mRCHelper.mStrokeColor;\n    }\n\n\n    //--- Selector 支持 ----------------------------------------------------------------------------\n\n    @Override\n    protected void drawableStateChanged() {\n        super.drawableStateChanged();\n        mRCHelper.drawableStateChanged(this);\n    }\n\n    @Override\n    public void setChecked(boolean checked) {\n        if (mRCHelper.mChecked != checked) {\n            mRCHelper.mChecked = checked;\n            refreshDrawableState();\n            if (mRCHelper.mOnCheckedChangeListener != null) {\n                mRCHelper.mOnCheckedChangeListener.onCheckedChanged(this, mRCHelper.mChecked);\n            }\n        }\n    }\n\n    @Override\n    public boolean isChecked() {\n        return mRCHelper.mChecked;\n    }\n\n    @Override\n    public void toggle() {\n        setChecked(!mRCHelper.mChecked);\n    }\n\n    public void setOnCheckedChangeListener(RCHelper.OnCheckedChangeListener listener) {\n        mRCHelper.mOnCheckedChangeListener = listener;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * 作用：圆角相对布局\n * 作者：GcsSloop\n * git 仓库 https://github.com/GcsSloop/rclayout\n * 原仓库已经 不更新了，而且他用的私库。。所以我们只能下载下来源码，自己维护了。\n */\npublic class RCRelativeLayout extends RelativeLayout implements Checkable, RCAttrs {\n    RCHelper mRCHelper;\n\n    public RCRelativeLayout(Context context) {\n        this(context, null);\n    }\n\n    public RCRelativeLayout(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public RCRelativeLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        mRCHelper = new RCHelper();\n        mRCHelper.initAttrs(context, attrs);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        mRCHelper.onSizeChanged(this, w, h);\n    }\n\n    @Override\n    protected void dispatchDraw(Canvas canvas) {\n        canvas.saveLayer(mRCHelper.mLayer, null, Canvas.ALL_SAVE_FLAG);\n        super.dispatchDraw(canvas);\n        mRCHelper.onClipDraw(canvas);\n        canvas.restore();\n    }\n\n    @Override\n    public void draw(Canvas canvas) {\n        if (mRCHelper.mClipBackground) {\n            canvas.save();\n            canvas.clipPath(mRCHelper.mClipPath);\n            super.draw(canvas);\n            canvas.restore();\n        } else {\n            super.draw(canvas);\n        }\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        int action = ev.getAction();\n        if (action == MotionEvent.ACTION_DOWN && !mRCHelper.mAreaRegion.contains((int) ev.getX(), (int) ev.getY())) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_UP) {\n            refreshDrawableState();\n        } else if (action == MotionEvent.ACTION_CANCEL) {\n            setPressed(false);\n            refreshDrawableState();\n        }\n        return super.dispatchTouchEvent(ev);\n    }\n\n    //--- 公开接口 ----------------------------------------------------------------------------------\n\n    public void setClipBackground(boolean clipBackground) {\n        mRCHelper.mClipBackground = clipBackground;\n        invalidate();\n    }\n\n    public void setRoundAsCircle(boolean roundAsCircle) {\n        mRCHelper.mRoundAsCircle = roundAsCircle;\n        invalidate();\n    }\n\n    public void setRadius(int radius) {\n        for (int i = 0; i < mRCHelper.radii.length; i++) {\n            mRCHelper.radii[i] = radius;\n        }\n        invalidate();\n    }\n\n    public void setTopLeftRadius(int topLeftRadius) {\n        mRCHelper.radii[0] = topLeftRadius;\n        mRCHelper.radii[1] = topLeftRadius;\n        invalidate();\n    }\n\n    public void setTopRightRadius(int topRightRadius) {\n        mRCHelper.radii[2] = topRightRadius;\n        mRCHelper.radii[3] = topRightRadius;\n        invalidate();\n    }\n\n    public void setBottomLeftRadius(int bottomLeftRadius) {\n        mRCHelper.radii[6] = bottomLeftRadius;\n        mRCHelper.radii[7] = bottomLeftRadius;\n        invalidate();\n    }\n\n    public void setBottomRightRadius(int bottomRightRadius) {\n        mRCHelper.radii[4] = bottomRightRadius;\n        mRCHelper.radii[5] = bottomRightRadius;\n        invalidate();\n    }\n\n    public void setStrokeWidth(int strokeWidth) {\n        mRCHelper.mStrokeWidth = strokeWidth;\n        invalidate();\n    }\n\n    public void setStrokeColor(int strokeColor) {\n        mRCHelper.mStrokeColor = strokeColor;\n        invalidate();\n    }\n\n    @Override\n    public void invalidate() {\n        if (null != mRCHelper)\n            mRCHelper.refreshRegion(this);\n        super.invalidate();\n    }\n\n    public boolean isClipBackground() {\n        return mRCHelper.mClipBackground;\n    }\n\n    public boolean isRoundAsCircle() {\n        return mRCHelper.mRoundAsCircle;\n    }\n\n    public float getTopLeftRadius() {\n        return mRCHelper.radii[0];\n    }\n\n    public float getTopRightRadius() {\n        return mRCHelper.radii[2];\n    }\n\n    public float getBottomLeftRadius() {\n        return mRCHelper.radii[4];\n    }\n\n    public float getBottomRightRadius() {\n        return mRCHelper.radii[6];\n    }\n\n    public int getStrokeWidth() {\n        return mRCHelper.mStrokeWidth;\n    }\n\n    public int getStrokeColor() {\n        return mRCHelper.mStrokeColor;\n    }\n\n\n    //--- Selector 支持 ----------------------------------------------------------------------------\n\n    @Override\n    protected void drawableStateChanged() {\n        super.drawableStateChanged();\n        mRCHelper.drawableStateChanged(this);\n    }\n\n    @Override\n    public void setChecked(boolean checked) {\n        if (mRCHelper.mChecked != checked) {\n            mRCHelper.mChecked = checked;\n            refreshDrawableState();\n            if (mRCHelper.mOnCheckedChangeListener != null) {\n                mRCHelper.mOnCheckedChangeListener.onCheckedChanged(this, mRCHelper.mChecked);\n            }\n        }\n    }\n\n    @Override\n    public boolean isChecked() {\n        return mRCHelper.mChecked;\n    }\n\n    @Override\n    public void toggle() {\n        setChecked(!mRCHelper.mChecked);\n    }\n\n    public void setOnCheckedChangeListener(RCHelper.OnCheckedChangeListener listener) {\n        mRCHelper.mOnCheckedChangeListener = listener;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author wuzhiguo\n * 邮箱：wuzhiguo@ksjgs.com\n * 创建时间: 2020-02-17     18:37\n * 用途:\n ***************************************\n */\nclass DelTextView : TextView{\n\n    private val paint: Paint\n    private var isLineVisible = true\n    private var delColor: Int\n\n\n    constructor(context: Context) : this(context, null)\n    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr){\n\n        paint = Paint()\n        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.DelTextView)\n        delColor = typedArray.getColor(R.styleable.DelTextView_del_line_color, currentTextColor)\n\n        typedArray.recycle()\n    }\n\n    override fun draw(canvas: Canvas?) {\n        super.draw(canvas)\n\n        if (delColor == -1){\n            delColor = currentTextColor\n        }\n        if (isLineVisible) {\n            paint.color = delColor\n            paint.isAntiAlias = true\n            paint.strokeWidth = 1.0.toFloat()\n            canvas?.drawLine(0f, (this.height / 2).toFloat(), this.width.toFloat(), (this.height / 2).toFloat(), paint)\n        }\n    }\n\n\n    fun showDelLine(visible: Boolean) {\n        this.isLineVisible = visible\n        invalidate()\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass HightLightTextView : TextView {\n\n    private var hightlightColor: Int = -1\n\n    constructor(context: Context) : this(context, null)\n    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {\n\n        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.IconTitleRightArrow)\n\n        hightlightColor = typedArray.getColor(R.styleable.HightLightTextView_hightlightColor, Color.parseColor(\"#FFFE7401\"))\n\n        setTextWightHighLight(text as String)\n\n        typedArray.recycle()\n\n    }\n\n    var dolorIndexList = mutableListOf<Int>()\n\n    fun setTextWightHighLight(str: String?) {\n        if(str== null){\n            return\n        }\n        dolorIndexList.clear()\n        str.forEachIndexed { index, c ->\n            if (c == '$') {\n                dolorIndexList.add(index)\n            }\n        }\n        var pairs = mutableListOf<Pair<Int, Int>>()\n        var lastV = -1\n        var pr: Pair<Int, Int>\n        dolorIndexList.forEachIndexed { index, i ->\n            if (index % 2 == 0) {\n                lastV = i\n            } else {\n                pr = Pair(lastV - index + 1, i - lastV - 1)\n                println(pr)\n                pairs.add(pr)\n            }\n        }\n        var strNew = str.replace(\"$\", \"\")\n        val spannableString = SpannableString(strNew)\n        pairs.forEachIndexed { _, pair ->\n            val foregroundColorSpan = ForegroundColorSpan(Color.parseColor(\"#FFFE7401\"))\n            spannableString.setSpan(foregroundColorSpan, pair.first, pair.first + pair.second, Spanned.SPAN_INCLUSIVE_EXCLUSIVE)\n\n        }\n        text = spannableString\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass IconTitleRightArrow : FrameLayout {\n\n    constructor(context: Context) : this(context, null)\n    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr){\n\n        val a = context.obtainStyledAttributes(attrs, R.styleable.IconTitleRightArrow)\n        title = a.getString(R.styleable.IconTitleRightArrow_itra_title)\n        subTitle = a.getString(R.styleable.IconTitleRightArrow_itra_subtitle)\n        titlePicSrcId = a.getResourceId(R.styleable.IconTitleRightArrow_itra_icon, -1)\n        isShowDesc = a.getBoolean(R.styleable.IconTitleRightArrow_itra_is_show_subtitle, false)\n\n        a.recycle()\n\n        setView()\n    }\n\n\n    private var title: String? = null\n    private var isShowDesc: Boolean = false\n    private var titlePicSrcId: Int = -1\n    private var subTitle: String? = null\n\n    private lateinit var llMore: LinearLayout\n\n    private fun setView() {\n        LayoutInflater.from(context).inflate(R.layout.home_layout_person_title_arrow, this)\n\n        var tvTitle: TextView = findViewById(R.id.tv_title)\n        tvTitle.text = title\n\n        llMore = findViewById(R.id.ll_more)\n        llMore.visibility = if (isShowDesc) VISIBLE else INVISIBLE\n\n        var tvMore:TextView = findViewById(R.id.tv_more)\n        tvMore.text = subTitle\n\n        if (titlePicSrcId < 0){\n            iv_pic.visibility = View.GONE\n        } else {\n            iv_pic.visibility = View.VISIBLE\n            iv_pic.setImageResource(titlePicSrcId!!)\n        }\n    }\n\n    fun setRightClickListener(onClickListener: OnClickListener) {\n        llMore.setOnClickListener(onClickListener)\n    }\n\n    fun setRightText(subTitle: String){\n        tv_more.text = subTitle\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nclass LessonsProgressView  @JvmOverloads constructor(context: Context,attributes: AttributeSet?=null,defStyleAttr:Int=0 ) : LinearLayout(context,attributes, defStyleAttr) {\n   private var iconCheckedResId = 0\n    private var iconUncheckedResId = 0\n    private var marginRight = 0f\n    init {\n        orientation = HORIZONTAL\n        attributes?.run {\n            val typedArray = context.obtainStyledAttributes(this, R.styleable.LessonsProgressView )\n            val count = typedArray.getInt(R.styleable.LessonsProgressView_progress_total_count,3)\n            val checkedCount = typedArray.getInt(R.styleable.LessonsProgressView_progress_checked_count,0)\n            marginRight = typedArray.getDimension(R.styleable.LessonsProgressView_progress_item_margin_right,dp2px(5).toFloat())\n            iconCheckedResId = typedArray.getResourceId(R.styleable.LessonsProgressView_progress_item_checked_icon, 0)\n            iconUncheckedResId = typedArray.getResourceId(R.styleable.LessonsProgressView_progress_item_unchecked_icon, 0)\n            typedArray.recycle()\n            val unCheckedCount = count - checkedCount\n            addCheckedView(checkedCount,iconCheckedResId)\n            addUnCheckedView(unCheckedCount,iconUncheckedResId)\n            invalidate()\n        }\n\n\n    }\n\n    private fun addUnCheckedView( unCheckedCount: Int, iconUncheckedResId: Int) {\n        addCheckedView(unCheckedCount,iconUncheckedResId)\n    }\n\n    private fun createItem(): ImageView {\n        return ImageView(context).apply{\n            layoutParams = LayoutParams(MarginLayoutParams.WRAP_CONTENT,MarginLayoutParams.WRAP_CONTENT).apply {\n                this.rightMargin = marginRight.toInt()\n            }\n            scaleType = ImageView.ScaleType.FIT_CENTER\n        }\n    }\n\n    private fun addCheckedView( count: Int,@DrawableRes resId:Int) {\n        repeat(count) {\n            addView(createItem().apply {\n                setImageResource(resId)\n            } )\n        }\n    }\n\n    fun setupView(checkedCount:Int,totalCount:Int){\n        removeAllViews()\n        addCheckedView(checkedCount,iconCheckedResId)\n        addUnCheckedView(totalCount-checkedCount,iconUncheckedResId)\n        invalidate()\n    }\n}\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author ylc\n * 邮箱：yanglichuan@ksjgs.com\n * 创建时间: 2020-02-21\n * 用途:可以限制 滑动方向的Viewpager\n ***************************************\n */\nclass LimitSlideDirectionViewPager(context: Context?, attrs: AttributeSet?) : ViewPager(context!!, attrs) {\n\n    //    为了 禁用快速滑动，记录按下时间\n    private var lastTouchDownTime = 0L\n\n\n    sealed class SwipeDirection {\n        object ALL : SwipeDirection()\n        object LEFT : SwipeDirection()\n        object RIGHT : SwipeDirection()\n        object NONE : SwipeDirection()\n    }\n\n    private var initialXValue = 0f\n    private var direction: SwipeDirection\n    override fun onTouchEvent(event: MotionEvent): Boolean {\n        return if (IsSwipeAllowed(event)) {\n            super.onTouchEvent(event)\n        } else false\n    }\n\n    override fun onInterceptTouchEvent(event: MotionEvent): Boolean {\n//        when (event.action) {\n//            MotionEvent.ACTION_DOWN ->\n//            {\n//\n//                val currentTouchDownTime = System.currentTimeMillis()\n//                val diff = currentTouchDownTime - lastTouchDownTime\n//                lastTouchDownTime = currentTouchDownTime\n//                if (diff < 1000) {\n//                    return false\n//                }\n//            }\n//        }\n        return if (IsSwipeAllowed(event)) {\n            super.onInterceptTouchEvent(event)\n        } else false\n    }\n\n    private fun IsSwipeAllowed(event: MotionEvent): Boolean {\n        if (direction === SwipeDirection.ALL) return true\n        if (direction === SwipeDirection.NONE) //disable any swipe\n            return false\n        if (event.action == MotionEvent.ACTION_DOWN) {\n            initialXValue = event.x\n            return true\n        }\n        if (event.action == MotionEvent.ACTION_MOVE) {\n            try {\n                val diffX = event.x - initialXValue\n                if (diffX > 0 && direction === SwipeDirection.RIGHT) { // swipe from left to right detected\n                    return false\n                } else if (diffX < 0 && direction === SwipeDirection.LEFT) { // swipe from right to left detected\n                    return false\n                }\n            } catch (exception: Exception) {\n                exception.printStackTrace()\n            }\n        }\n        return true\n    }\n\n    fun setAllowedSwipeDirection(direction: SwipeDirection) {\n        this.direction = direction\n    }\n\n    init {\n        direction = SwipeDirection.ALL\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author wuzhiguo\n * 邮箱：wuzhiguo@ksjgs.com\n * 创建时间: 2020/3/16     5:13 PM\n * 用途: 阴影\n    containerShadowColor：阴影颜色\n    containerShadowRadius：阴影半径\n    containerCornerRadius:阴影圆角\n    containerDeltaLength：阴影到边框距离\n    deltaX：阴影X方向偏移\n    deltaY：阴影Y\n    enable：是否显示阴影\n *\n ***************************************\n */\nclass MaskViewGroup : ViewGroup{\n    private var deltaLength = 0f\n    private var cornerRadius = 0f\n    private var mShadowPaint: Paint? = null\n    private var drawShadow = false\n    private var mContext: Context? = null\n    private var shadowColor = 0\n    private var shadowRadius = 0f\n    private var dx = 0f\n    private var dy = 0f\n\n\n    constructor (context: Context) : this(context, null)\n\n    constructor (context: Context, @Nullable attrs: AttributeSet?) : this(context, attrs, 0)\n\n    constructor (context: Context?, @Nullable attrs: AttributeSet?, defStyleAttr: Int):  super(context, attrs, defStyleAttr) {\n        mContext = context\n        initView(attrs)\n    }\n\n    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {\n        val child = getChildAt(0)\n        val measuredWidth = measuredWidth\n        val measuredHeight = measuredHeight\n        val childMeasureWidth = child.measuredWidth\n        val childMeasureHeight = child.measuredHeight\n        child.layout((measuredWidth - childMeasureWidth) / 2, (measuredHeight - childMeasureHeight) / 2, (measuredWidth + childMeasureWidth) / 2, (measuredHeight + childMeasureHeight) / 2)\n    }\n\n\n    /**\n     * 初始化信息变量\n     */\n    private fun initView(attrs: AttributeSet?) {\n        val a = mContext!!.obtainStyledAttributes(attrs, R.styleable.ShadowViewGroup)\n        shadowColor = a.getColor(R.styleable.ShadowViewGroup_containerShadowColor, Color.RED)\n        //        int shadowColor = Color.RED;\n        shadowRadius = a.getDimension(R.styleable.ShadowViewGroup_containerShadowRadius, 0f)\n        dx = a.getDimension(R.styleable.ShadowViewGroup_deltaX, 0f)\n        dy = a.getDimension(R.styleable.ShadowViewGroup_deltaY, 0f)\n        deltaLength = a.getDimension(R.styleable.ShadowViewGroup_containerDeltaLength, 0f)\n        cornerRadius = a.getDimension(R.styleable.ShadowViewGroup_containerCornerRadius, 0f)\n        drawShadow = a.getBoolean(R.styleable.ShadowViewGroup_enable, true)\n        a.recycle()\n        initShadowPaint()\n    }\n\n    private fun initShadowPaint() {\n        mShadowPaint = Paint()\n        mShadowPaint?.apply {\n            style = Paint.Style.FILL\n            isAntiAlias = true\n            color = shadowColor\n            setShadowLayer(shadowRadius, dx, dy, shadowColor)\n        }\n\n    }\n\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n        check(childCount == 1) { \"子View只能有一个\" }\n        val measuredWidth = measuredWidth\n        val measuredHeight = measuredHeight\n        val widthMode = MeasureSpec.getMode(widthMeasureSpec)\n        val heightMode = MeasureSpec.getMode(heightMeasureSpec)\n        val child = getChildAt(0)\n        val layoutParams = child.layoutParams as LayoutParams\n        val childBottomMargin = (Math.max(deltaLength, layoutParams.bottomMargin.toFloat()) + 1).toInt()\n        val childLeftMargin = (Math.max(deltaLength, layoutParams.leftMargin.toFloat()) + 1).toInt()\n        val childRightMargin = (Math.max(deltaLength, layoutParams.rightMargin.toFloat()) + 1).toInt()\n        val childTopMargin = (Math.max(deltaLength, layoutParams.topMargin.toFloat()) + 1).toInt()\n        val widthMeasureSpecMode: Int\n        val widthMeasureSpecSize: Int\n        val heightMeasureSpecMode: Int\n        val heightMeasureSpecSize: Int\n        if (widthMode == MeasureSpec.UNSPECIFIED) {\n            widthMeasureSpecMode = MeasureSpec.UNSPECIFIED\n            widthMeasureSpecSize = MeasureSpec.getSize(widthMeasureSpec)\n        } else {\n            if (layoutParams.width == ViewGroup.LayoutParams.MATCH_PARENT) {\n                widthMeasureSpecMode = MeasureSpec.EXACTLY\n                widthMeasureSpecSize = measuredWidth - childLeftMargin - childRightMargin\n            } else if (ViewGroup.LayoutParams.WRAP_CONTENT == layoutParams.width) {\n                widthMeasureSpecMode = MeasureSpec.AT_MOST\n                widthMeasureSpecSize = measuredWidth - childLeftMargin - childRightMargin\n            } else {\n                widthMeasureSpecMode = MeasureSpec.EXACTLY\n                widthMeasureSpecSize = layoutParams.width\n            }\n        }\n        if (heightMode == MeasureSpec.UNSPECIFIED) {\n            heightMeasureSpecMode = MeasureSpec.UNSPECIFIED\n            heightMeasureSpecSize = MeasureSpec.getSize(heightMeasureSpec)\n        } else {\n            if (layoutParams.height == ViewGroup.LayoutParams.MATCH_PARENT) {\n                heightMeasureSpecMode = MeasureSpec.EXACTLY\n                heightMeasureSpecSize = measuredHeight - childBottomMargin - childTopMargin\n            } else if (ViewGroup.LayoutParams.WRAP_CONTENT == layoutParams.height) {\n                heightMeasureSpecMode = MeasureSpec.AT_MOST\n                heightMeasureSpecSize = measuredHeight - childBottomMargin - childTopMargin\n            } else {\n                heightMeasureSpecMode = MeasureSpec.EXACTLY\n                heightMeasureSpecSize = layoutParams.height\n            }\n        }\n        measureChild(child, MeasureSpec.makeMeasureSpec(widthMeasureSpecSize, widthMeasureSpecMode), MeasureSpec.makeMeasureSpec(heightMeasureSpecSize, heightMeasureSpecMode))\n        val parentWidthMeasureSpec = MeasureSpec.getMode(widthMeasureSpec)\n        val parentHeightMeasureSpec = MeasureSpec.getMode(heightMeasureSpec)\n        var height = measuredHeight\n        var width = measuredWidth\n        val childHeight = child.measuredHeight\n        val childWidth = child.measuredWidth\n        if (parentHeightMeasureSpec == MeasureSpec.AT_MOST) {\n            height = childHeight + childTopMargin + childBottomMargin\n        }\n        if (parentWidthMeasureSpec == MeasureSpec.AT_MOST) {\n            width = childWidth + childRightMargin + childLeftMargin\n        }\n        if (width < childWidth + 2 * deltaLength) {\n            width = (childWidth + 2 * deltaLength).toInt()\n        }\n        if (height < childHeight + 2 * deltaLength) {\n            height = (childHeight + 2 * deltaLength).toInt()\n        }\n        if (height != measuredHeight || width != measuredWidth) {\n            setMeasuredDimension(width, height)\n        }\n    }\n\n    internal class LayoutParams : MarginLayoutParams {\n        constructor(c: Context?, attrs: AttributeSet?) : super(c, attrs) {}\n        constructor(width: Int, height: Int) : super(width, height) {}\n        constructor(source: MarginLayoutParams?) : super(source) {}\n        constructor(source: ViewGroup.LayoutParams?) : super(source) {}\n    }\n\n    override fun generateDefaultLayoutParams(): ViewGroup.LayoutParams? {\n        return LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)\n    }\n\n    override fun generateLayoutParams(p: ViewGroup.LayoutParams?): ViewGroup.LayoutParams? {\n        return LayoutParams(p)\n    }\n\n    override fun generateLayoutParams(attrs: AttributeSet?): ViewGroup.LayoutParams? {\n        return LayoutParams(context, attrs)\n    }\n\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP)\n    override fun dispatchDraw(canvas: Canvas) {\n        if (drawShadow) {\n            if (layerType != View.LAYER_TYPE_SOFTWARE) {\n                setLayerType(View.LAYER_TYPE_SOFTWARE, null)\n            }\n            val child = getChildAt(0)\n            val left = child.left\n            val top = child.top\n            val right = child.right\n            val bottom = child.bottom\n            val rectF = RectF(left.toFloat(), top.toFloat(), right.toFloat(), bottom.toFloat())\n            canvas.drawRoundRect(rectF, cornerRadius, cornerRadius, mShadowPaint)\n        }\n        super.dispatchDraw(canvas)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:jrhApplication\n * @Author jiaruihua\n * 邮箱：jiaruihua@ksjgs.com\n * 创建时间: 2020/6/17     10:52 AM\n * 用途:\n ***************************************\n */\nclass MoveProgressLayout(context: Context, attrs: AttributeSet?) : RoundCornerLinearLayout(context, attrs) {\n\n\n    private var color1 = Color.parseColor(\"#ff0000\")\n    private var color2 = Color.parseColor(\"#00ff00\")\n    private val moveLay by lazy { getChildAt(0) }\n    private var ani:ObjectAnimator?=null\n    private var mRadius = 0f\n    private val paint1 by lazy {\n        Paint(Paint.ANTI_ALIAS_FLAG)\n    }\n    private val paint2 by lazy {\n        Paint(Paint.ANTI_ALIAS_FLAG)\n    }\n\n\n    fun initViews(radius: Float, color1: Int, color2: Int) {\n        this.color1 = color1\n        this.color2 = color2\n        this.mRadius = radius\n        removeAllViews()\n        setRadius(radius)\n        addColorViews()\n    }\n\n    private fun createMoveViewLay() = LinearLayout(context)\n\n    private fun createColorfulView() = ColorfulView(context, measuredWidth, paint1.apply { color = color1 }, paint2.apply { color = color2 })\n\n\n    override fun dispatchDraw(canvas: Canvas) {\n        super.dispatchDraw(canvas)\n\n\n    }\n    private fun addColorViews() = addView(createMoveViewLay().apply {\n        addView(createColorfulView())\n        addView(createColorfulView())\n    }, ViewGroup.LayoutParams(measuredWidth * 2, ViewGroup.LayoutParams.MATCH_PARENT))\n\n    fun startAni(durationTime: Long = 15000) {\n        stopAni()\n        ani = ObjectAnimator.ofFloat(moveLay, \"translationX\", 0f, measuredWidth.toFloat())\n        ani?.apply {\n            duration = if (isSmallView())5000 else durationTime\n            repeatMode = ValueAnimator.RESTART\n            repeatCount = ValueAnimator.INFINITE\n            interpolator = LinearInterpolator()\n        }\n        ani?.start()\n    }\n\n    fun stopAni() {\n        ani?.cancel()\n        ani=null\n    }\n\n    fun pauseAni(){\n        ani?.pause()\n    }\n\n    fun isAniRunning() = ani?.isRunning\n\n    fun isSmallView() = measuredWidth<resources.displayMetrics.widthPixels/3.0f\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author wuzhiguo\n * 邮箱：wuzhiguo@ksjgs.com\n * 创建时间: 2020-02-11     11:42\n * 用途: 任意圆角frameLayout\n *\n * 用法：把该view作为控件的最底层，然后设置圆角角度即可，（不要给此view设置背景！！！）\n *\n * attr参数：\n * cornerRadius 角度\n * allEnabled 全部都是圆角-->其他圆角设置无效\n * topEnabled 顶部使用圆角-->单独设置左上 or 右上无效\n * bottomEnabled 底部使用圆角-->单独设置左下 or 右下无效\n * topLeftEnabled 左上角\n * topRightEnabled 右上角\n * bottomLeftEnabled 左下角\n * bottomRightEnabled 右下角\n *\n ***************************************\n */\n\nopen class RandomCornerFrameLayout @JvmOverloads constructor(\n        context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : FrameLayout(context, attrs, defStyleAttr) {\n\n    private val CORNER_RADIUS_DEFAULT: Float = 10.0f\n\n    private var mTopLeftEnabled: Boolean = false\n    private var mTopRightEnabled: Boolean = false\n    private var mBottomLeftEnabled: Boolean = false\n    private var mBottomRightEnabled: Boolean = false\n\n    private var mCornerRadius = CORNER_RADIUS_DEFAULT\n\n    init {\n        setupAttributes(attrs)\n        setLayerType(View.LAYER_TYPE_SOFTWARE, null)\n    }\n\n\n    override fun dispatchDraw(canvas: Canvas) {\n\n        val count = canvas.save()\n        val path = Path()\n        val rect = RectF(0f, 0f, canvas.width.toFloat(), canvas.height.toFloat())\n        val arrayRadius = floatArrayOf(0f, 0f, 0f, 0f, 0f, 0f, 0f, 0f)\n\n        if (mTopLeftEnabled) {\n            arrayRadius[0] = mCornerRadius\n            arrayRadius[1] = mCornerRadius\n        }\n\n        if (mTopRightEnabled) {\n            arrayRadius[2] = mCornerRadius\n            arrayRadius[3] = mCornerRadius\n        }\n\n        if (mBottomRightEnabled) {\n            arrayRadius[4] = mCornerRadius\n            arrayRadius[5] = mCornerRadius\n        }\n\n        if (mBottomLeftEnabled) {\n            arrayRadius[6] = mCornerRadius\n            arrayRadius[7] = mCornerRadius\n        }\n\n        path.addRoundRect(rect, arrayRadius, Path.Direction.CW)\n        canvas.clipPath(path)\n\n        super.dispatchDraw(canvas)\n\n        canvas.restoreToCount(count)\n    }\n\n\n    fun setupAttributes(attrs: AttributeSet?){\n        val radius = getPixelValue(CORNER_RADIUS_DEFAULT)\n        val a: TypedArray = context.obtainStyledAttributes(attrs, R.styleable.RandomCornerFrameLayout)\n\n        mCornerRadius = a.getDimension(R.styleable.RandomCornerFrameLayout_cornerRadius, radius)\n\n        if (a.hasValue(R.styleable.RandomCornerFrameLayout_allEnabled)){\n            mTopLeftEnabled = a.getBoolean(R.styleable.RandomCornerFrameLayout_allEnabled, false)\n            mTopRightEnabled = mTopLeftEnabled\n            mBottomLeftEnabled = mTopLeftEnabled\n            mBottomRightEnabled = mTopLeftEnabled\n\n        } else {\n            if (a.hasValue(R.styleable.RandomCornerFrameLayout_topEnabled)) {\n                mTopLeftEnabled = a.getBoolean(R.styleable.RandomCornerFrameLayout_topEnabled, false)\n                mTopRightEnabled = mTopLeftEnabled\n            } else {\n                mTopLeftEnabled = a.getBoolean(R.styleable.RandomCornerFrameLayout_topLeftEnabled, false)\n                mTopRightEnabled = a.getBoolean(R.styleable.RandomCornerFrameLayout_topRightEnabled, false)\n            }\n\n            if (a.hasValue(R.styleable.RandomCornerFrameLayout_bottomEnabled)) {\n                mBottomLeftEnabled = a.getBoolean(R.styleable.RandomCornerFrameLayout_bottomEnabled, false)\n                mBottomRightEnabled = mBottomLeftEnabled\n            } else {\n                mBottomLeftEnabled = a.getBoolean(R.styleable.RandomCornerFrameLayout_bottomLeftEnabled, false)\n                mBottomRightEnabled = a.getBoolean(R.styleable.RandomCornerFrameLayout_bottomRightEnabled, false)\n            }\n        }\n\n        a.recycle()\n\n    }\n\n    /**\n     * 设置圆角是否可用\n     * @param topLeft Boolean\n     * @param topRight Boolean\n     * @param bottomLeft Boolean\n     * @param bottomRight Boolean\n     */\n    fun setCornerEnabled(topLeft: Boolean, topRight: Boolean, bottomLeft: Boolean, bottomRight: Boolean) {\n        mTopLeftEnabled = topLeft\n        mTopRightEnabled = topRight\n        mBottomLeftEnabled = bottomLeft\n        mBottomRightEnabled = bottomRight\n        invalidate()\n    }\n\n    /**\n     * 设置圆角角度 单位px\n     * @param radius Float\n     */\n    fun setRadius(radius: Float) {\n        mCornerRadius = radius\n        invalidate()\n    }\n\n\n    private fun getPixelValue(dip: Float): Float {\n        val metrics = resources.displayMetrics\n        return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dip, metrics)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 圆角LinearLayout\n *\n * @author Wiser\n */\npublic class RoundAngleConstraintLayout extends ConstraintLayout {\n\n\tprivate float\ttopLeftRadius;\n\n\tprivate float\ttopRightRadius;\n\n\tprivate float\tbottomLeftRadius;\n\n\tprivate float\tbottomRightRadius;\n\n\tprivate Paint roundPaint;\n\n\tprivate Paint imagePaint;\n\n\tpublic RoundAngleConstraintLayout(Context context) {\n\t\tthis(context, null);\n\t}\n\n\tpublic RoundAngleConstraintLayout(Context context, AttributeSet attrs) {\n\t\tthis(context, attrs, 0);\n\t}\n\n\tpublic RoundAngleConstraintLayout(Context context, AttributeSet attrs, int defStyle) {\n\t\tsuper(context, attrs, defStyle);\n\t\tif (attrs != null) {\n\t\t\tTypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.RoundAngleLayout);\n\t\t\tfloat radius = ta.getDimension(R.styleable.RoundAngleLayout_radius, 0);\n\t\t\ttopLeftRadius = ta.getDimension(R.styleable.RoundAngleLayout_topLeftRadius, radius);\n\t\t\ttopRightRadius = ta.getDimension(R.styleable.RoundAngleLayout_topRightRadius, radius);\n\t\t\tbottomLeftRadius = ta.getDimension(R.styleable.RoundAngleLayout_bottomLeftRadius, radius);\n\t\t\tbottomRightRadius = ta.getDimension(R.styleable.RoundAngleLayout_bottomRightRadius, radius);\n\t\t\tta.recycle();\n\t\t}\n\t\troundPaint = new Paint();\n\t\troundPaint.setColor(Color.WHITE);\n\t\troundPaint.setAntiAlias(true);\n\t\troundPaint.setStyle(Paint.Style.FILL);\n\t\troundPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));\n\n\t\timagePaint = new Paint();\n\t\timagePaint.setXfermode(null);\n\t}\n\n\t@Override\n    public void dispatchDraw(Canvas canvas) {\n\t\tcanvas.saveLayer(new RectF(0, 0, canvas.getWidth(), canvas.getHeight()), imagePaint, Canvas.ALL_SAVE_FLAG);\n\t\tsuper.dispatchDraw(canvas);\n\t\tdrawTopLeft(canvas);\n\t\tdrawTopRight(canvas);\n\t\tdrawBottomLeft(canvas);\n\t\tdrawBottomRight(canvas);\n\t\tcanvas.restore();\n\t}\n\n\tprivate void drawTopLeft(Canvas canvas) {\n\t\tif (topLeftRadius > 0) {\n\t\t\tPath path = new Path();\n\t\t\tpath.moveTo(0, topLeftRadius);\n\t\t\tpath.lineTo(0, 0);\n\t\t\tpath.lineTo(topLeftRadius, 0);\n\t\t\tpath.arcTo(new RectF(0, 0, topLeftRadius * 2, topLeftRadius * 2), -90, -90);\n\t\t\tpath.close();\n\t\t\tcanvas.drawPath(path, roundPaint);\n\t\t}\n\t}\n\n\tprivate void drawTopRight(Canvas canvas) {\n\t\tif (topRightRadius > 0) {\n\t\t\tint width = getWidth();\n\t\t\tPath path = new Path();\n\t\t\tpath.moveTo(width - topRightRadius, 0);\n\t\t\tpath.lineTo(width, 0);\n\t\t\tpath.lineTo(width, topRightRadius);\n\t\t\tpath.arcTo(new RectF(width - 2 * topRightRadius, 0, width, topRightRadius * 2), 0, -90);\n\t\t\tpath.close();\n\t\t\tcanvas.drawPath(path, roundPaint);\n\t\t}\n\t}\n\n\tprivate void drawBottomLeft(Canvas canvas) {\n\t\tif (bottomLeftRadius > 0) {\n\t\t\tint height = getHeight();\n\t\t\tPath path = new Path();\n\t\t\tpath.moveTo(0, height - bottomLeftRadius);\n\t\t\tpath.lineTo(0, height);\n\t\t\tpath.lineTo(bottomLeftRadius, height);\n\t\t\tpath.arcTo(new RectF(0, height - 2 * bottomLeftRadius, bottomLeftRadius * 2, height), 90, 90);\n\t\t\tpath.close();\n\t\t\tcanvas.drawPath(path, roundPaint);\n\t\t}\n\t}\n\n\tprivate void drawBottomRight(Canvas canvas) {\n\t\tif (bottomRightRadius > 0) {\n\t\t\tint height = getHeight();\n\t\t\tint width = getWidth();\n\t\t\tPath path = new Path();\n\t\t\tpath.moveTo(width - bottomRightRadius, height);\n\t\t\tpath.lineTo(width, height);\n\t\t\tpath.lineTo(width, height - bottomRightRadius);\n\t\t\tpath.arcTo(new RectF(width - 2 * bottomRightRadius, height - 2 * bottomRightRadius, width, height), 0, 90);\n\t\t\tpath.close();\n\t\t\tcanvas.drawPath(path, roundPaint);\n\t\t}\n\t}\n\n}\n\n\n\n\n\n\n\nclass RoundProgressBarView(context: Context,val colorPaint:Int, val progressPer:Float) : View(context) {\n\n    val paint by lazy {\n        Paint(Paint.ANTI_ALIAS_FLAG).apply {\n            color = colorPaint\n        }\n    }\n\n    var roundRect: RectF?=null\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n        roundRect = RectF(0f,0f,measuredWidth.toFloat()*progressPer,measuredHeight.toFloat())\n    }\n\n    override fun onDraw(canvas: Canvas?) {\n        super.onDraw(canvas)\n\n        canvas?.run {\n            roundRect?.let {\n                drawRoundRect(it,measuredWidth/2f,measuredWidth/2f,paint)\n            }\n        }\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\npackage com.ks\n\nimport android.annotation.SuppressLint\nimport android.app.Activity\nimport android.content.Context\nimport android.content.Intent\nimport android.graphics.Bitmap\nimport android.net.Uri\nimport android.os.Process\nimport android.provider.MediaStore\nimport android.text.TextUtils\nimport android.view.View\nimport androidx.annotation.Nullable\nimport com.facebook.common.executors.UiThreadImmediateExecutorService\nimport com.facebook.common.references.CloseableReference\nimport com.facebook.datasource.DataSource\nimport com.facebook.drawee.backends.pipeline.Fresco\nimport com.facebook.imagepipeline.datasource.BaseBitmapDataSubscriber\nimport com.facebook.imagepipeline.image.CloseableImage\nimport com.facebook.imagepipeline.request.ImageRequest\nimport com.ks.lib.ktx.ext.ViewClickDelay\nimport com.ks.lib.ktx.ext.activityManager\nimport com.ks.lib.ktx.ext.connectivityManager\nimport com.ks.lib.ktx.ext.toast\nimport java.io.File\nimport java.io.FileNotFoundException\nimport java.io.FileOutputStream\nimport java.io.IOException\nimport java.util.*\nimport kotlin.system.exitProcess\n\n///**\n// * view的点击事件\n// * @receiver View 当前点击的view\n// * @param needBgMusic Boolean 点击是否需要背景音乐\n// * @param action Function0<Unit> block\n// */\n//fun View.click(needBgMusic: Boolean = false, action: () -> Unit) {\n//\n//    setOnClickListener {\n//        if (needBgMusic) {\n//            SoundPoolUtil.getInstance(context).play(1)\n//        }\n//        if (hashCode() != ViewClickDelay.hash) {\n//            ViewClickDelay.hash = hashCode()\n//            ViewClickDelay.lastClickTime = System.currentTimeMillis()\n//            action()\n//        } else {\n//              val currentTime = System.currentTimeMillis()\n//            if (currentTime - ViewClickDelay.lastClickTime > ViewClickDelay.SPACE_TIME) {\n//                ViewClickDelay.lastClickTime = System.currentTimeMillis()\n//                action()\n//            }\n//        }\n//    }\n//}\n\n\n\n\n\n\n/**\n * 判断设备是否安装微信APP\n *\n * @return boolean\n */\nfun Context.isWeixinAvilible(): Boolean {\n    val pinfo = packageManager.getInstalledPackages(0)// 获取所有已安装程序的包信息\n    if (pinfo != null) {\n        for (i in pinfo.indices) {\n            val pn = pinfo[i].packageName\n            if (\"com.tencent.mm\" == pn) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n\n/**\n * 是否有网络连接\n * @receiver Context\n * @return Boolean\n */\n@SuppressLint(\"MissingPermission\")\nfun Context.isNetworkAvailable(): Boolean {\n    val mNetworkInfo = connectivityManager?.activeNetworkInfo\n    if (mNetworkInfo != null) return mNetworkInfo.isAvailable\n    return false\n}\n\n/**\n * 是否有运行的服务\n * @receiver Context\n * @param className String\n * @return Boolean\n */\nfun Context.isServiceRunning(className: String): Boolean {\n    var isRunning = false\n    val serviceList = activityManager?.getRunningServices(30)\n    if (serviceList == null || serviceList.size <= 0) {\n        return false\n    }\n    for (i in serviceList.indices) {\n        if (serviceList[i] != null && serviceList[i].service != null) {\n            val cName = serviceList[i].service.className\n            if (cName.contains(className)) {\n                isRunning = true\n                break\n            }\n        }\n    }\n    return isRunning\n}\n\n\n/**\n * 包名判断是否为主进程\n *\n * @param context\n * @return\n */\nfun Context.isMainProcess(): Boolean {\n    return packageName == getProcessName()\n}\n\n/**\n * 获取进程名称\n *\n * @param context\n * @return\n */\nfun Context.getProcessName(): String? {\n    try {\n        val runningApps = activityManager?.runningAppProcesses ?: return null\n        for (proInfo in runningApps) {\n            if (proInfo.pid == Process.myPid()) {\n                if (proInfo.processName != null) {\n                    return proInfo.processName\n                }\n            }\n        }\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n    return null\n}\n\n/**\n * 判断当前app是否存活\n * @receiver Context\n * @param packageName String\n * @return Boolean\n */\nfun Context.isAppAlive(packageName: String): Boolean {\n    val processInfos = activityManager?.runningAppProcesses\n    if (processInfos != null) {\n        for (i in processInfos.indices) {\n            if (processInfos[i].processName == packageName) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n/**\n * 下载bitmap\n * @receiver Context\n * @param imgUrl String\n * @param success Function1<[@kotlin.ParameterName] Bitmap, Unit?>\n * @param fail Function0<Unit>\n */\nfun Context.downloadBitmap(imgUrl: String, success: (bitmap: Bitmap) -> Unit?, fail: () -> Unit) {\n    val imagePipeline = Fresco.getImagePipeline()\n    val imageRequest = ImageRequest.fromUri(imgUrl)\n    val dataSource = imagePipeline.fetchDecodedImage(imageRequest, this)\n    dataSource.subscribe(object : BaseBitmapDataSubscriber() {\n        override fun onFailureImpl(dataSource: DataSource<CloseableReference<CloseableImage>>?) {\n            try {\n                fail()\n            } catch (e: java.lang.Exception) {\n                toast(\"下载失败${e}\")\n                e.printStackTrace()\n            }\n        }\n\n        override fun onNewResultImpl(@Nullable bitmap: Bitmap?) {\n            if (bitmap != null && !bitmap.isRecycled) {\n                try {\n                    success(bitmap)\n                } catch (e: java.lang.Exception) {\n                    e.printStackTrace()\n                }\n            }\n        }\n\n    }, UiThreadImmediateExecutorService.getInstance())\n}\n\n/**\n * 图片存放本地\n * @receiver Context\n * @param bmp Bitmap?\n * @param fileName String?\n */\nfun Context.saveImageToGallery(bmp: Bitmap?, fileName: String?) {\n    var fileName = fileName\n    if (this == null || bmp == null) {\n        return\n    }\n    val dirName = \"Kaishu_Doc\"\n    val appDir = File(this.getExternalCacheDir(), dirName)\n    if (!appDir.exists()) {\n        appDir.mkdir()\n    }\n    if (TextUtils.isEmpty(fileName)) {\n        fileName = System.currentTimeMillis().toString() + \".jpg\"\n    }\n    val file = File(appDir, fileName)\n    try {\n        val fos = FileOutputStream(file)\n        bmp.compress(Bitmap.CompressFormat.JPEG, 100, fos)\n        fos.flush()\n        fos.close()\n    } catch (e: FileNotFoundException) {\n        toast(\"保存失败\")\n        e.printStackTrace()\n    } catch (e: IOException) {\n        toast(\"保存失败\")\n        e.printStackTrace()\n    }\n    // 把文件插入到系统图库\n    try {\n        val insertImage: String = MediaStore.Images.Media.insertImage(this.contentResolver,\n                file.absolutePath, fileName, null)\n        //            // 通知图库更新\n        val file1 = File(getRealPathFromURI(Uri.parse(insertImage)))\n        val intent = Intent()\n        intent.action = Intent.ACTION_MEDIA_SCANNER_SCAN_FILE\n        intent.data = Uri.fromFile(file1)\n        this.sendBroadcast(intent)\n        toast(\"保存成功\")\n    } catch (e: java.lang.Exception) {\n        toast(\"保存失败\")\n        e.printStackTrace()\n    }\n}\n\nfun Context.getRealPathFromURI(contentUri: Uri): String? {\n    val proj = arrayOf(MediaStore.Images.Media.DATA)\n    val cursor = this.contentResolver.query(contentUri, proj, null, null, null)\n    val column_index = cursor?.getColumnIndexOrThrow(MediaStore.Images.Media.DATA)\n    cursor?.moveToFirst()\n    column_index?.let {\n        val fileStr = cursor.getString(column_index)\n        cursor.close()\n        return fileStr\n    }\n    return null\n}\n\n/**\n * 清楚当前所有的activity\n */\nfun Context.clearAllActivity() {\n    val allActivitys = getAllActivitys()\n    for (i in allActivitys.indices) {\n        allActivitys.get(i).finish()\n    }\n}\n\n/**\n * 获取当前所有的activity\n *\n * @return activity列表\n */\n@SuppressLint(\"PrivateApi\", \"DiscouragedPrivateApi\")\nfun Context.getAllActivitys(): List<Activity> {\n    val list = ArrayList<Activity>()\n    try {\n        val activityThread = Class.forName(\"android.app.ActivityThread\")\n        val currentActivityThread = activityThread.getDeclaredMethod(\"currentActivityThread\")\n        currentActivityThread.isAccessible = true\n        //获取主线程对象\n        val activityThreadObject = currentActivityThread.invoke(null)\n        val mActivitiesField = activityThread.getDeclaredField(\"mActivities\")\n        mActivitiesField.isAccessible = true\n        val mActivities = mActivitiesField.get(activityThreadObject) as Map<Any, Any>\n        for ((_, value) in mActivities) {\n            val activityClientRecordClass = value.javaClass\n            val activityField = activityClientRecordClass.getDeclaredField(\"activity\")\n            activityField.isAccessible = true\n            val o = activityField.get(value)\n            list.add(o as Activity)\n        }\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n\n    return list\n}\n\n/**\n * 注意：不能先杀掉主进程，否则逻辑代码无法继续执行，需先杀掉相关进程最后杀掉主进程\n */\nfun Context.killAppProcess() {\n    val mList = activityManager?.runningAppProcesses\n    for (runningAppProcessInfo in mList!!) {\n        if (runningAppProcessInfo.pid != Process.myPid()) {\n            Process.killProcess(runningAppProcessInfo.pid)\n        }\n    }\n    Process.killProcess(Process.myPid())\n    exitProcess(0)\n}\n\n\n\n\n\n\n\nclass SoundPoolUtil private constructor(context: Context){\n\n    private var soundPool: SoundPool? = null\n    init {\n        soundPool = SoundPool(3, AudioManager.STREAM_SYSTEM, 0)\n        soundPool!!.load(context, R.raw.clickmusic, 1)\n    }\n\n    companion object {\n        @Volatile private var instance: SoundPoolUtil? = null\n        fun getInstance(context: Context) =\n                instance ?: synchronized(this) {\n                    instance ?: SoundPoolUtil(context).also { instance = it }\n                }\n    }\n\n\n\n\n    fun play(number: Int) {\n        Log.d(\"tag\", \"number $number\")\n        soundPool!!.play(number, 1f, 1f, 0, 0, 1f)\n    }\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593269857},"updatedAt":{"$$date":1598599967073},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Z3EnUuvY0Ww6ri9J"}
{"name":"HTML5 新元素","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\nHTML5 新元素\nHTML5 新元素\n自1999年以后HTML 4.01 已经改变了很多,今天，在HTML 4.01中的几个已经被废弃，这些元素在HTML5中已经被删除或重新定义。\n\n为了更好地处理今天的互联网应用，HTML5添加了很多新元素及功能，比如: 图形的绘制，多媒体内容，更好的页面结构，更好的形式 处理，和几个api拖放元素，定位，包括网页 应用程序缓存，存储，网络工作者，等。\n\n<canvas> 新元素\n标签\t描述\n<canvas>\t标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API\n\n新多媒体元素\n标签\t描述\n<audio>\t定义音频内容\n<video>\t定义视频（video 或者 movie）\n<source>\t定义多媒体资源 <video> 和 <audio>\n<embed>\t定义嵌入的内容，比如插件。\n<track>\t为诸如 <video> 和 <audio> 元素之类的媒介规定外部文本轨道。\n\n新表单元素\n标签\t描述\n<datalist>\t定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。\n<keygen>\t规定用于表单的密钥对生成器字段。\n<output>\t定义不同类型的输出，比如脚本的输出。\n\n新的语义和结构元素\nHTML5提供了新的元素来创建更好的页面结构：\n\n标签\t描述\n<article>\t定义页面独立的内容区域。\n<aside>\t定义页面的侧边栏内容。\n<bdi>\t允许您设置一段文本，使其脱离其父元素的文本方向设置。\n<command>\t定义命令按钮，比如单选按钮、复选框或按钮\n<details>\t用于描述文档或文档某个部分的细节\n<dialog>\t定义对话框，比如提示框\n<summary>\t标签包含 details 元素的标题\n<figure>\t规定独立的流内容（图像、图表、照片、代码等等）。\n<figcaption>\t定义 <figure> 元素的标题\n<footer>\t定义 section 或 document 的页脚。\n<header>\t定义了文档的头部区域\n<mark>\t定义带有记号的文本。\n<meter>\t定义度量衡。仅用于已知最大和最小值的度量。\n<nav>\t定义导航链接的部分。\n<progress>\t定义任何类型的任务的进度。\n<ruby>\t定义 ruby 注释（中文注音或字符）。\n<rt>\t定义字符（中文注音或字符）的解释或发音。\n<rp>\t在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。\n<section>\t定义文档中的节（section、区段）。\n<time>\t定义日期或时间。\n<wbr>\t规定在文本中的何处适合添加换行符。\n\n已移除的元素\n以下的 HTML 4.01 元素在HTML5中已经被删除:\n\n<acronym>\n<applet>\n<basefont>\n<big>\n<center>\n<dir>\n<font>\n<frame>\n<frameset>\n<noframes>\n<strike>\n<tt>\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886954837},"updatedAt":{"$$date":1598887306523},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Z4Aqm22D8Xi7K6ZO"}
{"name":"qk-","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598586262223},"updatedAt":{"$$date":1598586262223},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Z4shE2LmpIR3yu2Y"}
{"name":"css-CSS 背景","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 背景\n\nCSS 背景属性用于定义HTML元素的背景。\n\nCSS 属性定义背景效果:\n\nbackground-color\nbackground-image\nbackground-repeat\nbackground-attachment\nbackground-position\n背景颜色\nbackground-color 属性定义了元素的背景颜色.\n\n页面的背景颜色使用在body的选择器中:\n\n实例\nbody {background-color:#b0c4de;}\n\n尝试一下 »\nCSS中，颜色值通常以以下方式定义:\n\n十六进制 - 如：\"#ff0000\"\nRGB - 如：\"rgb(255,0,0)\"\n颜色名称 - 如：\"red\"\n以下实例中, h1, p, 和 div 元素拥有不同的背景颜色:\n\n实例\nh1 {background-color:#6495ed;}\np {background-color:#e0ffff;}\ndiv {background-color:#b0c4de;}\n\n尝试一下 »\n\n背景图像\nbackground-image 属性描述了元素的背景图像.\n\n默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体.\n\n页面背景图片设置实例:\n\n实例\nbody {background-image:url('paper.gif');}\n\n尝试一下 »\n下面是一个例子是一个糟糕的文字和背景图像组合。文本可读性差:\n\n实例\nbody {background-image:url('bgdesert.jpg');}\n\n尝试一下 »\n\n背景图像 - 水平或垂直平铺\n默认情况下 background-image 属性会在页面的水平或者垂直方向平铺。\n\n一些图像如果在水平方向与垂直方向平铺，这样看起来很不协调，如下所示: \n\n实例\nbody\n{\nbackground-image:url('gradient2.png');\n}\n\n尝试一下 »\n如果图像只在水平方向平铺 (repeat-x), 页面背景会更好些:\n\n实例\nbody\n{\nbackground-image:url('gradient2.png');\nbackground-repeat:repeat-x;\n}\n\n尝试一下 »\n\n背景图像- 设置定位与不平铺\nRemark 让背景图像不影响文本的排版\n\n如果你不想让图像平铺，你可以使用 background-repeat 属性:\n\n实例\nbody\n{\nbackground-image:url('img_tree.png');\nbackground-repeat:no-repeat;\n}\n\n尝试一下 »\n以上实例中，背景图像与文本显示在同一个位置，为了让页面排版更加合理，不影响文本的阅读，我们可以改变图像的位置。\n\n可以利用 background-position 属性改变图像在背景中的位置:\n\n实例\nbody\n{\nbackground-image:url('img_tree.png');\nbackground-repeat:no-repeat;\nbackground-position:right top;\n}\n\n尝试一下 »\n\n背景- 简写属性\n在以上实例中我们可以看到页面的背景颜色通过了很多的属性来控制。\n\n为了简化这些属性的代码，我们可以将这些属性合并在同一个属性中.\n\n背景颜色的简写属性为 \"background\":\n\n实例\nbody {background:#ffffff url('img_tree.png') no-repeat right top;}\n\n尝试一下 »\n当使用简写属性时，属性值的顺序为：:\n\nbackground-color\nbackground-image\nbackground-repeat\nbackground-attachment\nbackground-position\n以上属性无需全部使用，你可以按照页面的实际需要使用.\n\n这个实例使用了先前介绍的CSS，你可以查看相应实例: CSS 实例\n\nExamples\n更多实例\n如何设置固定的背景图像\n本例演示如何设置固定的背景图像。图像不会随着页面的其他部分滚动。\n\nCSS 背景属性\nProperty\t描述\nbackground\t简写属性，作用是将背景属性设置在一个声明中。\nbackground-attachment\t背景图像是否固定或者随着页面的其余部分滚动。\nbackground-color\t设置元素的背景颜色。\nbackground-image\t把图像设置为背景。\nbackground-position\t设置背景图像的起始位置。\nbackground-repeat\t设置背景图像是否及如何重复。\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888545050},"updatedAt":{"$$date":1598888726867},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Z8VE832LZQKS1UUc"}
{"name":"kotlin-加减操作符 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-plus-minus.html\n加减操作符 - Kotlin 语言中文站\n3-4 minutes\n改进翻译\n在 Kotlin 中，为集合定义了 plus (+) 和 minus (-) 操作符。 它们把一个集合作为第一个操作数；第二个操作数可以是一个元素或者是另一个集合。 返回值是一个新的只读集合：\n\nplus 的结果包含原始集合 和 第二个操作数中的元素。\nminus 的结果包含原始集合中的元素，但第二个操作数中的元素 除外。 如果第二个操作数是一个元素，那么 minus 移除其在原始集合中的 第一次 出现；如果是一个集合，那么移除其元素在原始集合中的 所有 出现。\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    val plusList = numbers + \"five\"\n    val minusList = numbers - listOf(\"three\", \"four\")\n    println(plusList)\n    println(minusList)\n//sampleEnd\n}\n有关 map 的 plus 和 minus 操作符的详细信息，请参见 Map 相关操作。 \n也为集合定义了广义赋值操作符 plusAssign (+=) 和 minusAssign (-=)。 \n然而，对于只读集合，它们实际上使用 plus 或者 minus 操作符并尝试将结果赋值给同一变量。 \n因此，它们仅在由 var 声明的只读集合中可用。 对于可变集合，如果它是一个 val，\n那么它们会修改集合。更多详细信息请参见集合写操作。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382121213},"updatedAt":{"$$date":1597382559637},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ZHoQsArltgOLwIBb"}
{"name":"html-HTML 属性","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n属性是 HTML 元素提供的附加信息。\n\nHTML 属性\nHTML 元素可以设置属性\n属性可以在元素中添加附加信息\n属性一般描述于开始标签\n属性总是以名称/值对的形式出现，比如：name=\"value\"。\n属性实例\nHTML 链接由 <a> 标签定义。链接的地址在 href 属性中指定：\n\n实例\n<a href=\"http://www.runoob.com\">这是一个链接</a>\n\n尝试一下 »\n\nHTML 属性常用引用属性值\n属性值应该始终被包括在引号内。\n\n双引号是最常用的，不过使用单引号也没有问题。\n\nRemark提示: 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name='John \"ShotGun\" Nelson'\n\nHTML 提示：使用小写属性\n属性和属性值对大小写不敏感。\n\n不过，万维网联盟在其 HTML 4 推荐标准中推荐小写的属性/属性值。\n\n而新版本的 (X)HTML 要求使用小写属性。\n\nHTML 属性参考手册\n查看完整的HTML属性列表: HTML 标签参考手册。\n\n下面列出了适用于大多数 HTML 元素的属性：\n\n属性\t描述\nclass\t为html元素定义一个或多个类名（classname）(类名从样式文件引入)\nid\t定义元素的唯一id\nstyle\t规定元素的行内样式（inline style）\ntitle\t描述了元素的额外信息 (作为工具条使用)\n更多标准属性说明： HTML 标准属性参考手册.\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885695208},"updatedAt":{"$$date":1598885978278},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ZKwiBJbErmcJuqIK"}
{"name":"html-HTML 文本格式化","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\nHTML 文本格式化\n\nHTML 文本格式化\n加粗文本\n\n斜体文本\n\n电脑自动输出\n\n这是 下标 和 上标\n\n尝试一下 »\nHTML 格式化标签\nHTML 使用标签 <b>(\"bold\") 与 <i>(\"italic\") 对输出的文本进行格式, 如：粗体 or 斜体\n\n这些HTML标签被称为格式化标签（请查看底部完整标签参考手册）。\n\nRemark\t通常标签 <strong> 替换加粗标签 <b> 来使用, <em> 替换 <i>标签使用。\n\n然而，这些标签的含义是不同的：\n\n<b> 与<i> 定义粗体或斜体文本。\n\n<strong> 或者 <em>意味着你要呈现的文本是重要的，所以要突出显示。现今所有主要浏览器都能渲染各种效果的字体。不过，未来浏览器可能会支持更好的渲染效果。\n\nExamples\n在线实例\n文本格式化\n此例演示如何在一个 HTML 文件中对文本进行格式化\n\n预格式文本\n此例演示如何使用 pre 标签对空行和空格进行控制。\n\n\"计算机输出\"标签\n此例演示不同的\"计算机输出\"标签的显示效果。\n\n地址\n此例演示如何在 HTML 文件中写地址。\n\n缩写和首字母缩写\n此例演示如何实现缩写或首字母缩写。\n\n文字方向\n此例演示如何改变文字的方向。\n\n块引用\n此例演示如何实现长短不一的引用语。\n\n删除字效果和插入字效果\n此例演示如何标记删除文本和插入文本。\n\nHTML 文本格式化标签\n标签\t描述\n<b>\t定义粗体文本\n<em>\t定义着重文字\n<i>\t定义斜体字\n<small>\t定义小号字\n<strong>\t定义加重语气\n<sub>\t定义下标字\n<sup>\t定义上标字\n<ins>\t定义插入字\n<del>\t定义删除字\nHTML \"计算机输出\" 标签\n标签\t描述\n<code>\t定义计算机代码\n<kbd>\t定义键盘码\n<samp>\t定义计算机代码样本\n<var>\t定义变量\n<pre>\t定义预格式文本\nHTML 引文, 引用, 及标签定义\n标签\t描述\n<abbr>\t定义缩写\n<address>\t定义地址\n<bdo>\t定义文字方向\n<blockquote>\t定义长的引用\n<q>\t定义短的引用语\n<cite>\t定义引用、引证\n<dfn>\t定义一个定义项目。\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885698471},"updatedAt":{"$$date":1598886108285},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ZhvfMlH7Y8mOAvtW"}
{"name":"kotlin-类型别名（自 1.1 起） - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/type-aliases.html\n类型别名（自 1.1 起） - Kotlin 语言中文站\n3-4 minutes\n改进翻译\n类型别名为现有类型提供替代名称。 如果类型名称太长，你可以另外引入较短的名称，并使用新的名称替代原类型名。\n\n它有助于缩短较长的泛型类型。 例如，通常缩减集合类型是很有吸引力的：\n\n你可以为函数类型提供另外的别名：\n\ntypealias MyHandler = (Int, String, Any) -> Unit\n\ntypealias Predicate<T> = (T) -> Boolean\n你可以为内部类和嵌套类创建新名称：\n\nclass A {\n    inner class Inner\n}\nclass B {\n    inner class Inner\n}\n\ntypealias AInner = A.Inner\ntypealias BInner = B.Inner\n类型别名不会引入新类型。 它们等效于相应的底层类型。 当你在代码中添加 typealias Predicate<T> 并使用 Predicate<Int> 时，Kotlin 编译器总是把它扩展为 (Int) -> Boolean。 因此，当你需要泛型函数类型时，你可以传递该类型的变量，反之亦然：\n\ntypealias Predicate<T> = (T) -> Boolean\n\nfun foo(p: Predicate<Int>) = p(42)\n\nfun main() {\n    val f: (Int) -> Boolean = { it > 0 }\n    println(foo(f)) // 输出 \"true\"\n\n    val p: Predicate<Int> = { it > 0 }\n    println(listOf(1, -2).filter(p)) // 输出 \"[1]\"\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307928886},"updatedAt":{"$$date":1597308147597},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ZoAVIhjj8gdWbOt9"}
{"name":"ad-ksbsdiffpatcher","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        ndk {\n            abiFilters 'armeabi-v7a'\n        }\n    }\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n            java {\n                srcDirs += []\n            }\n        }\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n    splits {//删除64位的so库\n        abi {\n            enable true\n            reset()\n            include 'armeabi-v7a'\n            universalApk false\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\narmeabi-v7a\nlibksbspatcher.so\n\n\n\n\n\n\n\n\n\npublic class KsBsDiffPatcher {\n\n    // 用于在应用程序启动时，加载本地的lib库\n    static {\n        System.loadLibrary(\"ksbspatcher\");\n    }\n\n    /**\n     * 合成新文件\n     *\n     * @param oldZip 旧版文件包，如1.1.1版本\n     * @param patch  差分包，Patch文件\n     * @param output 合成后新版本文件的输出路径\n     */\n    public static native void ksBsPatch(String oldZip, String patch, String output);\n\n\n}\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522796361},"updatedAt":{"$$date":1598523765377},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ZuLmd7HhWq5BjKT0"}
{"name":"Android 私有库 Nexus 使用方法","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"私有库升级创建调试步骤\n1. 根据需求，优化修改代码\n2. 修改对应 module 下的 gradle.properties ，升级版本号，添加后缀  -SNAPSHOT，则会上传到对应测试库中，可以重复部署\nVERSION_NAME=1.0.1-SNAPSHOT\n3. 上传到私有库中后，再次修改轻课使用的版本依赖，可以修改 ks_kotlin_lib_versions.gradle 对应 module的依赖，添加测试后缀，然后不断调试到自己满意为止。\ndef versions = [\n                // 正式发版 Release ： ks_lib_net_version          : '1.0.1',\n        ks_lib_net_version          : '1.0.1-SNAPSHOT',// 调试期间（升级版本号+添加-SNAPSHOT）\n]\n4. Git 打对应 modlue 的 TAG 版本记录，方便代码版本查看\ngit  tag  ks_lib_net-1.0.1\n5. 成功调试成功后，去掉后缀  -SNAPSHOT，再次上传则可以上传到正式库中"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598548469508},"updatedAt":{"$$date":1598548577569},"_id":"Zytb0XhCEffm8Qh4","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-扩展 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/extensions.html\n扩展 - Kotlin 语言中文站\n18-22 minutes\n改进翻译\nKotlin 能够扩展一个类的新功能而无需继承该类或者使用像装饰者这样的设计模式。 这通过叫做 扩展 的特殊声明完成。 例如，你可以为一个你不能修改的、来自第三方库中的类编写一个新的函数。 这个新增的函数就像那个原始类本来就有的函数一样，可以用普通的方法调用。 这种机制称为 扩展函数 。此外，也有 扩展属性 ， 允许你为一个已经存在的类添加新的属性。\n\n声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面代码为 MutableList<Int> 添加一个swap 函数：\n\n这个 this 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象） 现在，我们对任意 MutableList<Int> 调用该函数了：\n\nval list = mutableListOf(1, 2, 3)\nlist.swap(0, 2) // “swap()”内部的“this”会保存“list”的值\n当然，这个函数对任何 MutableList<T> 起作用，我们可以泛化它：\n\nfun <T> MutableList<T>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // “this”对应该列表\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n为了在接收者类型表达式中使用泛型，我们要在函数名前声明泛型参数。 参见泛型函数。\n\n扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。\n\n我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如：\n\nfun main() {\n//sampleStart\n    open class Shape\n    \n    class Rectangle: Shape()\n    \n    fun Shape.getName() = \"Shape\"\n    \n    fun Rectangle.getName() = \"Rectangle\"\n    \n    fun printClassName(s: Shape) {\n        println(s.getName())\n    }    \n    \n    printClassName(Rectangle())\n//sampleEnd\n}\n这个例子会输出 \"Shape\"，因为调用的扩展函数只取决于参数 s 的声明类型，该类型是 Shape 类。\n\n如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、 相同的名字，并且都适用给定的参数，这种情况总是取成员函数。 例如：\n\nfun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType() { println(\"Extension function\") }\n    \n    Example().printFunctionType()\n//sampleEnd\n}\n这段代码输出“Class method”。\n\n当然，扩展函数重载同样名字但不同签名成员函数也完全可以：\n\nfun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType(i: Int) { println(\"Extension function\") }\n    \n    Example().printFunctionType(1)\n//sampleEnd\n}\n注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为 null，并且可以在函数体内检测 this == null，这能让你在没有检测 null 的时候调用 Kotlin 中的toString()：检测发生在扩展函数的内部。\n\nfun Any?.toString(): String {\n    if (this == null) return \"null\"\n    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()\n    // 解析为 Any 类的成员函数\n    return toString()\n}\n与函数类似，Kotlin 支持扩展属性：\n\nval <T> List<T>.lastIndex: Int\n    get() = size - 1\n注意：由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。\n\n例如:\n\nval House.number = 1 // 错误：扩展属性不能有初始化器\n如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数与属性。就像伴生对象的常规成员一样， 可以只使用类名作为限定符来调用伴生对象的扩展成员：\n\nclass MyClass {\n    companion object { }  // 将被称为 \"Companion\"\n}\n\nfun MyClass.Companion.printCompanion() { println(\"companion\") }\n\nfun main() {\n    MyClass.printCompanion()\n}\n大多数时候我们在顶层定义扩展——直接在包里：\n\npackage org.example.declarations\n \nfun List<String>.getLongestString() { /*……*/}\n要使用所定义包之外的一个扩展，我们需要在调用方导入它：\n\npackage org.example.usage\n\nimport org.example.declarations.getLongestString\n\nfun main() {\n    val list = listOf(\"red\", \"green\", \"blue\")\n    list.getLongestString()\n}\n更多信息参见导入\n\n在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个 隐式接收者 —— 其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为 分发接收者，扩展方法调用所在的接收者类型的实例称为 扩展接收者 。\n\nclass Host(val hostname: String) {\n    fun printHostname() { print(hostname) }\n}\n\nclass Connection(val host: Host, val port: Int) {\n     fun printPort() { print(port) }\n\n     fun Host.printConnectionString() {\n         printHostname()   // 调用 Host.printHostname()\n         print(\":\")\n         printPort()   // 调用 Connection.printPort()\n     }\n\n     fun connect() {\n         /*……*/\n         host.printConnectionString()   // 调用扩展函数\n     }\n}\n\nfun main() {\n    Connection(Host(\"kotl.in\"), 443).connect()\n    //Host(\"kotl.in\").printConnectionString(443)  // 错误，该扩展函数在 Connection 外不可用\n}\n对于分发接收者与扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者的成员你可以使用 限定的 this 语法。\n\nclass Connection {\n    fun Host.getConnectionString() {\n        toString()         // 调用 Host.toString()\n        this@Connection.toString()  // 调用 Connection.toString()\n    }\n}\n声明为成员的扩展可以声明为 open 并在子类中覆盖。这意味着这些函数的分发对于分发接收者类型是虚拟的，但对于扩展接收者类型是静态的。\n\nopen class Base { }\n\nclass Derived : Base() { }\n\nopen class BaseCaller {\n    open fun Base.printFunctionInfo() {\n        println(\"Base extension function in BaseCaller\")\n    }\n\n    open fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in BaseCaller\")\n    }\n\n    fun call(b: Base) {\n        b.printFunctionInfo()   // 调用扩展函数\n    }\n}\n\nclass DerivedCaller: BaseCaller() {\n    override fun Base.printFunctionInfo() {\n        println(\"Base extension function in DerivedCaller\")\n    }\n\n    override fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in DerivedCaller\")\n    }\n}\n\nfun main() {\n    BaseCaller().call(Base())   // “Base extension function in BaseCaller”\n    DerivedCaller().call(Base())  // “Base extension function in DerivedCaller”——分发接收者虚拟解析\n    DerivedCaller().call(Derived())  // “Base extension function in DerivedCaller”——扩展接收者静态解析\n}\n扩展的可见性与相同作用域内声明的其他实体的可见性相同。例如：\n\n在文件顶层声明的扩展可以访问同一文件中的其他 private 顶层声明；\n如果扩展是在其接收者类型外部声明的，那么该扩展不能访问接收者的 private 成员。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306190500},"updatedAt":{"$$date":1597307977253},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"a2fUO3iAWaRB8fYd"}
{"name":"andr-动画","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"developer.android.google.cn /guide/topics/resources/animation-resource\n动画资源  |  Android 开发者  |  Android Developers\n16-20 minutes\n一个动画资源可以定义以下两种动画类型之一：\n\n属性动画\n通过使用 Animator 在设定的时间段内修改对象的属性值来创建动画。\n视图动画\n使用视图动画框架可以创建两种类型的动画：\n\n补间动画：通过使用 Animation 对单张图片执行一系列转换来创建动画\n帧动画：通过使用 AnimationDrawable 按顺序显示一系列图片来创建动画。\n属性动画\n在 XML 中定义的动画，用于在设定的一段时间内修改目标对象的属性，例如背景颜色或 Alpha 值。\n\n文件位置：\nres/animator/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 ValueAnimator、ObjectAnimator 或 AnimatorSet 的资源指针。\n资源引用：\n在 Java 或 Kotlin 代码中：R.animator.filename\n在 XML 中：@[package:]animator/filename\n语法：\n    <set\n      android:ordering=[\"together\" | \"sequentially\"]><objectAnimator\n            android:propertyName=\"string\"\n            android:duration=\"int\"\n            android:valueFrom=\"float | int | color\"\n            android:valueTo=\"float | int | color\"\n            android:startOffset=\"int\"\n            android:repeatCount=\"int\"\n            android:repeatMode=[\"repeat\" | \"reverse\"]\n            android:valueType=[\"intType\" | \"floatType\"]/><animator\n            android:duration=\"int\"\n            android:valueFrom=\"float | int | color\"\n            android:valueTo=\"float | int | color\"\n            android:startOffset=\"int\"\n            android:repeatCount=\"int\"\n            android:repeatMode=[\"repeat\" | \"reverse\"]\n            android:valueType=[\"intType\" | \"floatType\"]/><set>\n            ...\n        </set>\n    </set>\n    \n该文件必须具有一个根元素，可以是 <set>、<objectAnimator> 或 <valueAnimator>。您可以将动画元素（包括其他 <set> 元素）组合到 <set> 元素中。\n\n元素：\n<set>\n容纳其他动画元素（<objectAnimator>、<valueAnimator> 或其他 <set> 元素）的容器。代表 AnimatorSet。\n您可以指定嵌套的 <set> 标记来将动画进一步组合在一起。每个 <set> 都可以定义自己的 ordering 属性。\n\n属性：\n\nandroid:ordering\n关键字。指定此集合中动画的播放顺序。\n值\t说明\nsequentially\t依序播放此集合中的动画\ntogether（默认）\t同时播放此集合中的动画。\n<objectAnimator>\n在特定的一段时间内为对象的特定属性创建动画。代表 ObjectAnimator。\n属性：\n\nandroid:propertyName\n字符串。必需。要添加动画的对象属性，通过其名称引用。例如，您可以为 View 对象指定 \"alpha\" 或 \"backgroundColor\"。 但是，objectAnimator 元素不包含 target 属性，因此您无法在 XML 声明中设置要添加动画的对象。您必须通过调用 loadAnimator() 来扩充您的动画 XML 资源，然后调用 setTarget() 来设置包含此属性的目标对象。\nandroid:valueTo\n浮点数、整数或颜色。必需。动画属性的结束值。颜色以六位十六进制数字表示（例如，#333333）。\nandroid:valueFrom\n浮点数、整数或颜色。动画属性的开始值。如果未指定，则动画将从属性的 get 方法获得的值开始。颜色以六位十六进制数字表示（例如，#333333）。\nandroid:duration\n整数。动画的时间，以毫秒为单位。默认为 300 毫秒。\nandroid:startOffset\n整数。调用 start() 后动画延迟的毫秒数。\nandroid:repeatCount\n整数。动画的重复次数。设为 \"-1\" 表示无限次重复，也可设为正整数。例如，值 \"1\" 表示动画在初次播放后重复播放一次，因此动画总共播放两次。默认值为 \"0\"，表示不重复。\nandroid:repeatMode\n整数。动画播放到结尾处的行为。android:repeatCount 必须设置为正整数或 \"-1\"，该属性才有效。设置为 \"reverse\" 可让动画在每次迭代时反向播放，设置为 \"repeat\" 则可让动画每次从头开始循环播放。\nandroid:valueType\n关键字。如果值为颜色，则不要指定此属性。动画框架会自动处理颜色值\n值\t说明\nintType\t指定动画值为整数\nfloatType（默认）\t指定动画值为浮点数\n<animator>\n在指定的时间段内执行动画。代表 ValueAnimator。\n属性：\n\nandroid:valueTo\n浮点数、整数或颜色。必需。动画的结束值。颜色以六位十六进制数字表示（例如，#333333）。\nandroid:valueFrom\n浮点数、整数或颜色。必需。动画的开始值。颜色以六位十六进制数字表示（例如，#333333）。\nandroid:duration\n整数。动画的时间，以毫秒为单位。默认为 300ms。\nandroid:startOffset\n整数。调用 start() 后动画延迟的毫秒数。。\nandroid:repeatCount\n整数。动画的重复次数。设为 \"-1\" 表示无限次重复，也可设为正整数。例如，值 \"1\" 表示动画在初次播放后重复播放一次，因此动画总共播放两次。默认值为 \"0\"，表示不重复。\nandroid:repeatMode\n整数。动画播放到结尾处的行为。android:repeatCount 必须设置为正整数或 \"-1\"，该属性才有效。设置为 \"reverse\" 可让动画在每次迭代时反向播放，设置为 \"repeat\" 则可让动画每次从头开始循环播放。\nandroid:valueType\n关键字。如果值为颜色，则不要指定此属性。动画框架会自动处理颜色值。\n值\t说明\nintType\t指定动画值为整数\nfloatType（默认）\t指定动画值为浮点数\n示例：\n保存在 res/animator/property_animator.xml 的 XML 文件：\n    <set android:ordering=\"sequentially\">\n        <set>\n            <objectAnimator\n                android:propertyName=\"x\"\n                android:duration=\"500\"\n                android:valueTo=\"400\"\n                android:valueType=\"intType\"/>\n            <objectAnimator\n                android:propertyName=\"y\"\n                android:duration=\"500\"\n                android:valueTo=\"300\"\n                android:valueType=\"intType\"/>\n        </set>\n        <objectAnimator\n            android:propertyName=\"alpha\"\n            android:duration=\"500\"\n            android:valueTo=\"1f\"/>\n    </set>\n    \n为了运行此动画，您必须将代码中的 XML 资源扩充为 AnimatorSet 对象，然后在开始运行动画集之前为所有动画设置目标对象。为方便起见，调用 setTarget() 即可设置一个用于 AnimatorSet 的所有子项的目标对象。以下代码展示了如何执行此操作：\n\n    val set: AnimatorSet = AnimatorInflater.loadAnimator(myContext, R.animator.property_animator)\n        .apply {\n            setTarget(myObject)\n            start()\n        }\n    \n    AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,\n        R.animator.property_animator);\n    set.setTarget(myObject);\n    set.start();\n    \n另请参阅：\n属性动画\n有关如何使用属性动画系统的示例，请参阅 API 演示。\n视图动画\n视图动画框架可支持补间动画和逐帧动画，两者都可以在 XML 中声明。以下几个部分介绍如何使用这两种方法。\n\n补间动画\n在 XML 中定义的动画，用于对图形执行旋转、淡出、移动和拉伸等转换。\n\n文件位置：\nres/anim/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 Animation 的资源指针。\n资源引用：\n在 Java 中：R.anim.filename\n在 XML 中：@[package:]anim/filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:interpolator=\"@[package:]anim/interpolator_resource\"\n        android:shareInterpolator=[\"true\" | \"false\"] >\n        <alpha\n            android:fromAlpha=\"float\"\n            android:toAlpha=\"float\" />\n        <scale\n            android:fromXScale=\"float\"\n            android:toXScale=\"float\"\n            android:fromYScale=\"float\"\n            android:toYScale=\"float\"\n            android:pivotX=\"float\"\n            android:pivotY=\"float\" />\n        <translate\n            android:fromXDelta=\"float\"\n            android:toXDelta=\"float\"\n            android:fromYDelta=\"float\"\n            android:toYDelta=\"float\" />\n        <rotate\n            android:fromDegrees=\"float\"\n            android:toDegrees=\"float\"\n            android:pivotX=\"float\"\n            android:pivotY=\"float\" />\n        <set>\n            ...\n        </set>\n    </set>\n    \n该文件必须具有一个根元素，可以是 <alpha>、<scale>、<translate>、<rotate> 或包含一组（或多组）其他动画元素（甚至是嵌套的 <set> 元素）的 <set> 元素。\n\n元素：\n<set>\n容纳其他动画元素（<alpha>、<scale>、<translate>、<rotate>）或其他 <set> 元素的容器。代表 AnimationSet。\n属性：\n\nandroid:interpolator\n插值器资源。 要应用于动画的 Interpolator。 该值必须是对指定插值器的资源的引用（而不是插值器类名称）。您可以使用平台提供的默认插值器资源，也可以创建自己的插值器资源。有关插值器的详细信息，请参阅以下说明。\nandroid:shareInterpolator\n布尔值。如果要在所有子元素中共用同一插值器，则为“true”。\n<alpha>\n淡入或淡出动画。代表 AlphaAnimation。\n属性：\n\nandroid:fromAlpha\n浮点数。起始不透明度偏移，0.0 表示透明，1.0 表示不透明。\nandroid:toAlpha\n浮点数。结束不透明度偏移，0.0 表示透明，1.0 表示不透明。\n要了解 <alpha> 支持的更多属性，请参阅 Animation 类引用（其中所有 XML 属性均由此元素继承）。\n\n<scale>\n大小调整动画。您可以通过指定 pivotX 和 pivotY，来指定图片向外（或向内）扩展的中心点。例如，如果这两个值为 0、0（左上角），则所有扩展均向右下方向进行。代表 ScaleAnimation。\n属性：\n\nandroid:fromXScale\n浮点数。起始 X 尺寸偏移，其中 1.0 表示不变。\nandroid:toXScale\n浮点数。结束 X 尺寸偏移，其中 1.0 表示不变。\nandroid:fromYScale\n浮点数。起始 Y 尺寸偏移，其中 1.0 表示不变。\nandroid:toYScale\n浮点数。结束 Y 尺寸偏移，其中 1.0 表示不变。\nandroid:pivotX\n浮点数。在对象缩放时要保持不变的 X 坐标。\nandroid:pivotY\n浮点数。在对象缩放时要保持不变的 Y 坐标。\n要了解 <scale> 支持的更多属性，请参阅 Animation 类引用（其中所有 XML 属性均由此元素继承）。\n\n<translate>\n垂直和/或水平移动。支持采用以下三种格式之一的以下属性：从 -100 到 100 的以“％”结尾的值，表示相对于自身的百分比；从 -100 到 100 的以“％p”结尾的值，表示相对于其父项的百分比；不带后缀的浮点值，表示绝对值。代表 TranslateAnimation。\n属性：\n\nandroid:fromXDelta\n浮动数或百分比。起始 X 偏移。表示方式：相对于正常位置的像素数（例如 \"5\"），相对于元素宽度的百分比（例如 \"5%\"），或相对于父项宽度的百分比（例如 \"5%p\"）。\nandroid:toXDelta\n浮动数或百分比。结束 X 偏移。表示方式：相对于正常位置的像素数（例如 \"5\"），相对于元素宽度的百分比（例如 \"5%\"），或相对于父项宽度的百分比（例如 \"5%p\"）。\nandroid:fromYDelta\n浮动数或百分比。起始 Y 偏移。表示方式：相对于正常位置的像素数（例如 \"5\"），相对于元素高度的百分比（例如 \"5%\"），或相对于父项高度的百分比（例如 \"5%p\"）。\nandroid:toYDelta\n浮动数或百分比。结束 Y 偏移。表示方式：相对于正常位置的像素数（例如 \"5\"），相对于元素高度的百分比（例如 \"5%\"），或相对于父项高度的百分比（例如 \"5%p\"）。\n要了解 <translate> 支持的更多属性，请参阅 Animation 类引用（其中所有 XML 属性均由此元素继承）。\n\n<rotate>\n旋转动画。代表 RotateAnimation。\n属性：\n\nandroid:fromDegrees\n浮点数。起始角度位置，以度为单位。\nandroid:toDegrees\n浮点数。结束角度位置，以度为单位。\nandroid:pivotX\n浮动数或百分比。旋转中心的 X 坐标。表示方式：相对于对象左边缘的像素数（例如 \"5\"），相对于对象左边缘的百分比（例如 \"5%\"），或相对于父级容器左边缘的百分比（例如 \"5%p\"）。\nandroid:pivotY\n浮点数或百分比。旋转中心的 Y 坐标。表示方式：相对于对象上边缘的像素数（例如 \"5\"），相对于对象上边缘的百分比（例如 \"5%\"），或相对于父级容器上边缘的百分比（例如 \"5%p\"）。\n要了解 <rotate> 支持的更多属性，请参阅 Animation 类引用（其中所有 XML 属性均由此元素继承）。\n\n示例：\n保存在 res/anim/hyperspace_jump.xml 的 XML 文件：\n    <set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:shareInterpolator=\"false\">\n        <scale\n            android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n            android:fromXScale=\"1.0\"\n            android:toXScale=\"1.4\"\n            android:fromYScale=\"1.0\"\n            android:toYScale=\"0.6\"\n            android:pivotX=\"50%\"\n            android:pivotY=\"50%\"\n            android:fillAfter=\"false\"\n            android:duration=\"700\" />\n        <set\n            android:interpolator=\"@android:anim/accelerate_interpolator\"\n            android:startOffset=\"700\">\n            <scale\n                android:fromXScale=\"1.4\"\n                android:toXScale=\"0.0\"\n                android:fromYScale=\"0.6\"\n                android:toYScale=\"0.0\"\n                android:pivotX=\"50%\"\n                android:pivotY=\"50%\"\n                android:duration=\"400\" />\n            <rotate\n                android:fromDegrees=\"0\"\n                android:toDegrees=\"-45\"\n                android:toYScale=\"0.0\"\n                android:pivotX=\"50%\"\n                android:pivotY=\"50%\"\n                android:duration=\"400\" />\n        </set>\n    </set>\n    \n以下应用代码会将动画应用到 ImageView 并启动动画：\n\n    val image: ImageView = findViewById(R.id.image)\n    val hyperspaceJump: Animation = AnimationUtils.\nloadAnimation\n(this, R.anim.hyperspace_jump)\n    image.\nstartAnimation\n(hyperspaceJump)\n    \n    ImageView image = (ImageView) findViewById(R.id.image);\n    Animation hyperspaceJump = AnimationUtils.\nloadAnimation\n(this, R.anim.hyperspace_jump);\n    image.\nstartAnimation\n(hyperspaceJump);\n    \n另请参阅：\n2D 图形：补间动画\n插值器\n插值器是在 XML 中定义的动画修改器，它会影响动画的变化率。插值器可对现有的动画效果执行加速、减速、重复、退回等。\n\n插值器通过 android:interpolator 属性应用于动画元素，该属性的值是对插值器资源的引用。\n\nAndroid 中提供的所有插值器都是 Interpolator 类的子类。为便于您使用 android:interpolator 属性将插值器应用于动画，Android 针对每个插值器类包含了一个可供您引用的公共资源。下表指定了每个插值器要使用的资源：\n\n您可以通过以下方式使用 android:interpolator 属性应用上述某个插值器：\n\n    <set android:interpolator=\"@android:anim/accelerate_interpolator\">\n        ...\n    </set>\n    \n自定义插值器\n如果您对平台提供的插值器（在上表中列出）不满意，则可以使用修改过的属性创建自定义插值器资源。例如，您可以调整 AnticipateInterpolator 的加速率或调整 CycleInterpolator 的循环次数。为此，您需要在 XML 文件中创建自己的插值器资源。\n\n文件位置：\nres/anim/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向相应插值器对象的资源指针。\n资源引用：\n在 XML 中：@[package:]anim/filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <InterpolatorName xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:attribute_name=\"value\"\n        />\n    \n如果您不应用任何属性，则您的插值器的运作方式将与平台提供的插值器（在上表中列出）完全相同。\n\n元素：\n请注意，在 XML 中定义的每个 Interpolator 实现的名称都以小写字母开头。\n<accelerateDecelerateInterpolator>\n变化率在开始和结束时缓慢，但在中间会加快。\n没有属性。\n\n<accelerateInterpolator>\n变化率在开始时较为缓慢，然后会加快。\n属性：\n\nandroid:factor\n浮点数。加速率（默认为 1）。\n<anticipateInterpolator>\n先反向变化，然后再急速正向变化。\n属性：\n\nandroid:tension\n浮点数。要应用的张力（默认为 2）。\n<anticipateOvershootInterpolator>\n先反向变化，再急速正向变化并超过目标值，然后以最终值结束。\n属性：\n\nandroid:tension\n浮点数。要应用的张力（默认为 2）。\nandroid:extraTension\n浮点数。张力要乘以的倍数（默认值为 1.5）。\n<bounceInterpolator>\n变化会在结束时退回。\n没有属性。\n\n<cycleInterpolator>\n按指定的循环次数重复动画。变化率符合正弦曲线图。\n属性：\n\nandroid:cycles\n整数。循环次数（默认值为 1）。\n<decelerateInterpolator>\n变化率开始时很快，然后减慢。\n属性：\n\nandroid:factor\n浮点数。减速率（默认值为 1）。\n<linearInterpolator>\n变化率恒定不变。\n没有属性。\n\n<overshootInterpolator>\n先急速正向变化，再超过最终值，然后回到最终值。\n属性：\n\nandroid:tension\n浮点数。要应用的张力（默认为 2）。\n示例：\n保存在 res/anim/my_overshoot_interpolator.xml 的 XML 文件：\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <overshootInterpolator xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:tension=\"7.0\"\n        />\n    \n此动画 XML 将应用插值器：\n\n    <scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:interpolator=\"@anim/my_overshoot_interpolator\"\n        android:fromXScale=\"1.0\"\n        android:toXScale=\"3.0\"\n        android:fromYScale=\"1.0\"\n        android:toYScale=\"3.0\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:duration=\"700\" />\n    \n帧动画\n在 XML 中定义的按顺序显示一系列图片的动画（如电影）。\n\n文件位置：\nres/drawable/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 AnimationDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable.filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:oneshot=[\"true\" | \"false\"] >\n        <item\n            android:drawable=\"@[package:]drawable/drawable_resource_name\"\n            android:duration=\"integer\" />\n    </animation-list>\n    \n元素：\n<animation-list>\n必需。此元素必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nandroid:oneshot\n布尔值。如果您想要执行一次动画，则为“true”；如果要循环播放动画，则为“false”。\n<item>\n单帧动画。必须是 <animation-list> 元素的子元素。\n属性：\n\nandroid:drawable\n可绘制资源。要用于此帧的可绘制对象。\nandroid:duration\n整数。显示此帧的持续时间，以毫秒为单位。\n示例：\n保存在 res/drawable/rocket.xml 的 XML 文件：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:oneshot=\"false\">\n        <item android:drawable=\"@drawable/rocket_thrust1\" android:duration=\"200\" />\n        <item android:drawable=\"@drawable/rocket_thrust2\" android:duration=\"200\" />\n        <item android:drawable=\"@drawable/rocket_thrust3\" android:duration=\"200\" />\n    </animation-list>\n    \n以下应用代码会将该动画设置为 View 的背景，然后播放动画：\n另请参阅：\n2D 图形：帧动画\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242354407},"updatedAt":{"$$date":1597242403503},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"a4sq0zwgBohpdNtc"}
{"name":"线上事故定级标准","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"线上事故定级标准\n线上事故定级标准规范\n文件编号\nTGJ-S0001\n版本\nV1.0\n适用范围：技术部\n生效时间\n2020/08/01\n更新时间\n2020/08/11\n编制人员\n架构组/熊书宏\n2020.8.26 修改影响\n2020.8.5 增加指标数据计算方式，修改人@熊书宏\n2020.8.11 按照新的文件编号规范将TGJ-S0090修改文件编号为TGJ-S0001，修改人@周宇\n服务级别\n服务级别：由产品、运营、研发根据业务重要性来确定。\n级别\n说明\n一级服务【S】\n产品核心功能支撑服务，服务如出现故障会对大部分用户的使用造成重大影响，比如APP首页服务、会员服务、用户服务、交易服务、电商服务、音频播放服务、网关服务、学堂（训练营服务），共计22个工程；\n二级服务【A】\n非产品核心功能支撑服务，比如答题游戏、收货地址、优惠券、小红点、站内信、评论服务、DSP服务、微信服务、短链接服务等\n三级服务【B】\n内部系统，比如：内容运营系统、活动中心等\n服务定级清单参见如下：\n此处为语雀文档，点击链接查看：https://kaishu.yuque.com/tiangongju/rules/ape5tq#KaRv\n事故级别\n事故级别：以服务级别和影响程度来确定，满足多项指标以最高级别确定\n适用范围：服务因自身问题导致的事故\n指标\n服务级别\nP3\nP2\nP1\nP0\n服务对外完全停止的时间\n一级服务【S】\n1~3分钟\n3~10分钟\n10~30分钟\n30分钟以上\n二级服务【A】\n5~10分钟\n10~30分钟\n30分钟以上\n-\n三级服务【B】\n10分钟~30分钟\n30分钟以上\n-\n-\n服务部分功能故障，严重影响用户体验，受影响访问量占影响时段总请求量比例\n一级服务【S】\n3%~9%\n9%~30%\n30~90%\n90%以上\n二级服务【A】\n9%~30%\n30~90%\n90%以上\n-\n三级服务【B】\n30~90%\n90%以上\n-\n-\n用户数据延迟、错误或丢失\n一级服务【S】\n延迟1~2小时\n延迟2~12小时\n延迟12小时以上\n延迟12小时以上且数据无法恢复\n二级服务【A】\n延迟1~2小时\n延迟2~12小时\n延迟12小时以上\n延迟12小时以上且数据无法恢复\n三级服务【B】\n延迟6~12小时\n延迟12~24小时\n延迟24小时以上且数据无法恢复\n-\n指标数据统计方式\n服务对外完全停止的时间：\n依据服务所在ECS或Pod的网络流量和请求量（PV）以及状态（Status）来共同确定影响的时间范围，网络出口流量降至较低状态可认为服务不可用，PV大幅下降到较低状态或Status中404/500/503等占比超过95%以上可认为服务不可用。\n受影响访问量占影响时段内总访问量比例：\n接口响应时间超过4s和接口非200状态作为受影响访问量来统计，影响时段内总访问量以事故发生到恢复的时间范围的访问量总和来统计，数据来源为SLB日志。\n数据延迟时间：受影响的数据从影响开始到恢复的时间。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598545987031},"updatedAt":{"$$date":1598546197091},"_id":"a5pQMkYZPwwNR3D2","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"css-CSS 图片廊","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 图片廊\n以下是使用CSS创建图片廊：\n\n图片文本描述\n这里添加图片文本描述\n图片文本描述\n这里添加图片文本描述\n图片文本描述\n这里添加图片文本描述\n图片文本描述\n这里添加图片文本描述\n\n图片廊\n以下是使用 CSS 创建图片廊：\n\n实例\n<div class=\"responsive\">\n  <div class=\"img\">\n    <a target=\"_blank\" href=\"http://static.runoob.com/images/demo/demo1.jpg\">\n      <img src=\"http://static.runoob.com/images/demo/demo1.jpg\" alt=\"图片文本描述\" width=\"300\" height=\"200\">\n    </a>\n    <div class=\"desc\">这里添加图片文本描述</div>\n  </div>\n</div>\n \n<div class=\"responsive\">\n  <div class=\"img\">\n    <a target=\"_blank\" href=\"http://static.runoob.com/images/demo/demo2.jpg\">\n      <img src=\"http://static.runoob.com/images/demo/demo2.jpg\" alt=\"图片文本描述\" width=\"300\" height=\"200\">\n    </a>\n    <div class=\"desc\">这里添加图片文本描述</div>\n  </div>\n</div>\n \n<div class=\"responsive\">\n  <div class=\"img\">\n    <a target=\"_blank\" href=\"http://static.runoob.com/images/demo/demo3.jpg\">\n      <img src=\"http://static.runoob.com/images/demo/demo3.jpg\" alt=\"图片文本描述\" width=\"300\" height=\"200\">\n    </a>\n    <div class=\"desc\">这里添加图片文本描述</div>\n  </div>\n</div>\n \n<div class=\"responsive\">\n  <div class=\"img\">\n    <a target=\"_blank\" href=\"http://static.runoob.com/images/demo/demo4.jpg\">\n      <img src=\"http://static.runoob.com/images/demo/demo4.jpg\" alt=\"图片文本描述\" width=\"300\" height=\"200\">\n    </a>\n    <div class=\"desc\">这里添加图片文本描述</div>\n  </div>\n</div>\n\n尝试一下 »\n更多实例\n响应式图片廊\n使用 CSS3 的媒体查询来创建响应式图片廊：\n\n<div class=\"responsive\">\n  <div class=\"img\">\n    <a target=\"_blank\" href=\"img_fjords.jpg\">\n      <img src=\"http://www.runoob.com/wp-content/uploads/2016/04/img_fjords.jpg\" alt=\"Trolltunga Norway\" width=\"300\" height=\"200\">\n    </a>\n    <div class=\"desc\">这里添加图片文本描述</div>\n  </div>\n</div>\n \n \n<div class=\"responsive\">\n  <div class=\"img\">\n    <a target=\"_blank\" href=\"img_forest.jpg\">\n      <img src=\"http://www.runoob.com/wp-content/uploads/2016/04/img_forest.jpg\" alt=\"Forest\" width=\"600\" height=\"400\">\n    </a>\n    <div class=\"desc\">这里添加图片文本描述</div>\n  </div>\n</div>\n \n<div class=\"responsive\">\n  <div class=\"img\">\n    <a target=\"_blank\" href=\"img_lights.jpg\">\n      <img src=\"http://www.runoob.com/wp-content/uploads/2016/04/img_lights.jpg\" alt=\"Northern Lights\" width=\"600\" height=\"400\">\n    </a>\n    <div class=\"desc\">这里添加图片文本描述</div>\n  </div>\n</div>\n \n<div class=\"responsive\">\n  <div class=\"img\">\n    <a target=\"_blank\" href=\"img_mountains.jpg\">\n      <img src=\"http://www.runoob.com/wp-content/uploads/2016/04/img_mountains.jpg\" alt=\"Mountains\" width=\"600\" height=\"400\">\n    </a>\n    <div class=\"desc\">这里添加图片文本描述</div>\n  </div>\n</div>\n \n<div class=\"clearfix\"></div>\n \n<div style=\"padding:6px;\">\n  \n  <h4>重置浏览器大小查看效果</h4>\n</div>\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973619079},"updatedAt":{"$$date":1598974300165},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"a6iWVFlVjGxCRMfK"}
{"name":"py-tuple","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：\n\n>>> classmates = ('Michael', 'Bob', 'Tracy')\n现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。\n\n不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n\ntuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：\n\n>>> t = (1, 2)\n>>> t\n(1, 2)\n如果要定义一个空的tuple，可以写成()：\n\n>>> t = ()\n>>> t\n()\n但是，要定义一个只有1个元素的tuple，如果你这么定义：\n\n>>> t = (1)\n>>> t\n1\n定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。\n\n所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：\n\n>>> t = (1,)\n>>> t\n(1,)\nPython在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。\n\n最后来看一个“可变的”tuple：\n\n>>> t = ('a', 'b', ['A', 'B'])\n>>> t[2][0] = 'X'\n>>> t[2][1] = 'Y'\n>>> t\n('a', 'b', ['X', 'Y'])\n这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？\n\n别急，我们先看看定义的时候tuple包含的3个元素：\n\ntuple-0\n\n当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：\n\ntuple-1\n\n表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973936435},"updatedAt":{"$$date":1594976863644},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"a81dmxIgcDEMynAr"}
{"name":"ad-备忘","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\nhttp://yapi.devops.kaishustory.com/project/168/interface/api/33687\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598517308966},"updatedAt":{"$$date":1598519938493},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"aCcg1ySvEhHdAX8Q"}
{"name":"kotlin-将 Kotlin 添加到现有应用  |  Android 开发者  |  Android Developers","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /kotlin/add-kotlin\n将 Kotlin 添加到现有应用  |  Android 开发者  |  Android Developers\n5-6 minutes\nAndroid Studio 提供全面的 Kotlin 支持，让您能够将 Kotlin 文件添加到现有项目并将 Java 语言代码转换为 Kotlin 代码。然后，您可以使用 Android Studio 的所有现有工具来处理 Kotlin 代码，包括自动补全、lint 检查、重构和调试等。\n\n如果您要开始一个新项目，并希望使用 Kotlin，请参阅创建项目。\n\n如需示例，请查看我们的 Kotlin 代码示例。\n\n将 Kotlin 添加到现有项目\n如需将 Kotlin 添加到项目，请执行以下操作：\n\n依次点击 File > New，然后从各种 Android 模板中选择一个，例如一个新的空白 Fragment，如图 1 所示。如果您未在此菜单中看到模板列表，请先打开 Project 窗口，然后选择您的应用模块。\n\n创建一个新的空白 Fragment\n图 1.从可用模板中进行选择，例如 Fragment 或 Activity。\n在随即显示的向导中，选择 Kotlin 作为 Source Language。图 2 显示了当您要创建新 Activity 时使用的 New Android Activity 对话框。\n\n可让您选择 Kotlin 作为源语言的对话框\n图 2. New Android Activity 对话框，您可以从中选择 Kotlin 作为 Source Language。\n继续执行向导中的操作，直到完成。\n\n或者，您也可以依次点击 File > New > Kotlin File/Class 以创建一个基本的 Kotlin 文件。如果您没有看到此选项，请打开 Project 窗口，然后选择 java 目录。在 New Kotlin File/Class 窗口中，您可以定义文件名并提供多种文件类型选择：File、Class、Interface、Enum Class 或 Object。您做出的选择决定了在新的 Kotlin 文件中为您创建的基本架构。如果您选择 Class，Android Studio 会创建一个具有给定名称和匹配类定义的新 Kotlin 源文件。如果您选择 Interface，会在文件中声明一个接口，诸如此类。\n\n如果这是您首次直接将一个新的 Kotlin 类或文件添加到项目（不使用 Android 模板），Android Studio 会显示一条警告，指出项目中未配置 Kotlin，如图 3 所示。您可以在编辑器的右上角点击 Configure 或在右下角弹出的事件日志提醒中点击该按钮来配置 Kotlin。\n\n提示您为项目配置 Kotlin 的警告对话框\n图 3.如果没有为项目配置 Kotlin，Android Studio 会显示一个警告对话框。\n出现提示时，选择用于为包含 Kotlin 文件的所有模块配置 Kotlin 的 All modules containing Kotlin files 选项，如图 4 所示：\n\n选择为包含 Kotlin 代码的所有模块配置 Kotlin\n图 4. 选择为包含 Kotlin 代码的所有模块配置 Kotlin。\n您点击 OK 后，Android Studio 会将 Kotlin 添加到项目类路径，并将 Kotlin 和 Kotlin Android 扩展程序插件应用于包含 Kotlin 文件的每个模块。您的 build.gradle 文件应与以下示例类似：\n\n// Project build.gradle file.\nbuildscript {\n    ext.kotlin_version = '1.3.30'\n    ...\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n// Inside each module using kotlin\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-android'...\ndependencies \n\n{\n   implementation \"androidx.core:core-ktx:1.0.1\"\n   implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n}\n源代码组织\n默认情况下，新的 Kotlin 文件保存在 src/main/java/ 中，这样方便您在一个位置同时查看 Kotlin 文件和 Java 文件。如果您希望将 Kotlin 文件与 Java 文件分开，可以将 Kotlin 文件放在 src/main/kotlin/ 下。如果这样做，则还需要在 sourceSets 配置中添加此目录，如下所示：\n\nandroid {\n   sourceSets {\n       main.java.srcDirs += 'src/main/kotlin'\n   }\n}\n将现有 Java 代码转换为 Kotlin 代码\n如需将 Java 代码转换为 Kotlin 代码，请在 Android Studio 中打开 Java 文件，然后依次选择 Code > Convert Java File to Kotlin File。或者，也可以创建一个新的 Kotlin 文件（依次选择 File > New > Kotlin File/Class），然后将 Java 代码粘贴到该文件中。Android Studio 随即显示一条提示，询问您是否要将代码转换为 Kotlin 代码，如图 5 所示。点击 Yes 即可转换。您可以选择性地勾选 Don't show this dialog next time，这样会使将来的转换自动进行。\n\n选择为包含 Kotlin 代码的所有模块配置 Kotlin\n图 5. Android Studio 可将 Java 代码转换为 Kotlin 代码。\n代码转换和可为 null 性\nAndroid Studio 的转换过程会生成与编译和运行的 Kotlin 代码在功能上等效的代码。不过，您可能需要对转换后的代码进行额外的优化。例如，您可能想要优化转换后的代码如何处理可为 null 类型。\n\n在 Android 中，通常会延迟 View 对象及其他组件的初始化，直到它们附加到的 Fragment 或 Activity 达到适当的生命周期状态。例如，您可能在某个 Fragment 中引用了一个按钮，如以下代码段所示：\n\npublic class JavaFragment extends Fragment {// Null until onCreateView.\n    private Button button;@Override\n    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n        View root = inflater.inflate(R.layout.fragment_content, container,false);// Get a reference to the button in the view, only after the root view is inflated.\n        button = root.findViewById(R.id.button);return root;\n    }@Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);// Not null at this point of time when onViewCreated runs\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                ...\n            }\n        });\n    }\n}\n尽管按钮变量可为 null，但实际上，在本例中使用时，它绝不能为 null。不过，由于在构建时没有为按钮变量赋值，因此生成的 Kotlin 代码将 Button 视为可为 null 类型，并在添加点击监听器时使用非 null 断言运算符来解封按钮，如下所示：\n\nclass JavaFragment : Fragment() {// Null until onCreateView.\n    private var button: Button? = nulloverride fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,\n            savedInstanceState: Bundle?): View? {\n        ...\n        // Get a reference to the button in the view, only after the root view is inflated.\n        button = root.findViewById(R.id.button)\n        ...\n    }override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)// Not null at the point of time when onViewCreated fires\n        // but force unwrapped nonetheless\n        button!!.setOnClickListener { }\n    }\n}\n对于这种情况，这种转换不如使用 lateinit 理想，因为您不得不在访问按钮引用的每个位置都使用非 null 断言或安全调用运算符解封按钮引用。\n\n在其他情况下（根据应用的用例，null 是有效的变量赋值），将安全调用运算符 (?.) 与终止 elvis 运算符 (?:) 一起使用可能是一种更合适的方法，可以安全地解封可为 null 对象或将其强制转换为合理的非 null 默认值。在转换过程中，Android studio 没有足够的信息做出这一决定。虽然它默认为非 null 断言，但您应不断跟进并根据需要调整转换后的代码。\n\n更多信息\n如需详细了解如何在项目中同时使用 Kotlin 代码和 Java 代码，请参阅从 Kotlin 调用 Java 代码。\n\n如需详细了解如何在企业环境中使用 Kotlin，请参阅为大型团队采用 Kotlin。\n\n如需了解现有 Android API 的惯用 Kotlin 封装容器，请参阅 Android KTX。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397419641},"updatedAt":{"$$date":1597398905259},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"aGYy9XfxkAnnGrqJ"}
{"name":"使用 require 或者 check 函数作为条件检查","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"dart","value":"// 传统的做法\nval age = -1;\nif (age <= 0) {\n    throw IllegalArgumentException(\"age must  not be negative\")\n}\n\n// 使用 require 去检查\nrequire(age > 0) { \"age must be negative\" }\n\n// 使用 checkNotNull 检查\nval name: String? = null\ncheckNotNull(name){\n    \"name must not be null\"\n}\n\n作者：HiDhl\n链接：https://juejin.im/post/5edfd7c9e51d45789a7f206d\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}],"tags":["aZ7LswF9qbcVtQZT"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594728306573},"updatedAt":{"$$date":1594728649563},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"kotlin","_id":"aZ7LswF9qbcVtQZT","text":"kotlin"}],"_id":"aOo0gNUoasiSzVMr"}
{"name":"kotlin-集合操作概述 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-operations.html\n集合操作概述 - Kotlin 语言中文站\n9-11 minutes\n改进翻译\nKotlin 标准库提供了用于对集合执行操作的多种函数。这包括简单的操作，例如获取或添加元素，以及更复杂的操作，包括搜索、排序、过滤、转换等。\n\n集合操作在标准库中以两种方式声明：集合接口的成员函数和扩展函数。\n\n成员函数定义了对于集合类型是必不可少的操作。例如，Collection 包含函数 isEmpty() 来检查其是否为空； List 包含用于对元素进行索引访问的 get()，等等。\n\n创建自己的集合接口实现时，必须实现其成员函数。 为了使新实现的创建更加容易，请使用标准库中集合接口的框架实现：AbstractCollection、AbstractList、AbstractSet、AbstractMap 及其相应可变抽象类。\n\n其他集合操作被声明为扩展函数。这些是过滤、转换、排序和其他集合处理功能。\n\n公共操作可用于只读集合与可变集合。 常见操作分为以下几类：\n\n集合转换\n集合过滤\nplus 与 minus 操作符\n分组\n取集合的一部分\n取单个元素\n集合排序\n集合聚合操作\n这些页面中描述的操作将返回其结果，而不会影响原始集合。例如，一个过滤操作产生一个_新集合_，其中包含与过滤谓词匹配的所有元素。 此类操作的结果应存储在变量中，或以其他方式使用，例如，传到其他函数中。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    numbers.filter { it.length > 3 }  // `numbers` 没有任何改变，结果丢失\n    println(\"numbers are still $numbers\")\n    val longerThan3 = numbers.filter { it.length > 3 } // 结果存储在 `longerThan3` 中\n    println(\"numbers longer than 3 chars are $longerThan3\")\n//sampleEnd\n}\n\n对于某些集合操作，有一个选项可以指定 目标 对象。 目标是一个可变集合，该函数将其结果项附加到该可变对象中，而不是在新对象中返回它们。 对于执行带有目标的操作，有单独的函数，其名称中带有 To 后缀，例如，用 filterTo() 代替 filter() 以及用 associateTo() 代替 associate()。 这些函数将目标集合作为附加参数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val filterResults = mutableListOf<String>()  // 目标对象\n    numbers.filterTo(filterResults) { it.length > 3 }\n    numbers.filterIndexedTo(filterResults) { index, _ -> index == 0 }\n    println(filterResults) // 包含两个操作的结果\n//sampleEnd\n}\n为了方便起见，这些函数将目标集合返回了，因此您可以在函数调用的相应参数中直接创建它：\n\nfun main() {\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n//sampleStart\n    // 将数字直接过滤到新的哈希集中，\n    // 从而消除结果中的重复项\n    val result = numbers.mapTo(HashSet()) { it.length }\n    println(\"distinct item lengths are $result\")\n//sampleEnd\n}\n具有目标的函数可用于过滤、关联、分组、展平以及其他操作。 有关目标操作的完整列表，请参见 Kotlin collections reference。\n\n对于可变集合，还存在可更改集合状态的 写操作 。这些操作包括添加、删除和更新元素。写操作在集合写操作以及 List 写操作与 Map 写操作的相应部分中列出。\n\n对于某些操作，有成对的函数可以执行相同的操作：一个函数就地应用该操作，另一个函数将结果作为单独的集合返回。 例如， sort() 就地对可变集合进行排序，因此其状态发生了变化； sorted() 创建一个新集合，该集合包含按排序顺序相同的元素。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    val sortedNumbers = numbers.sorted()\n    println(numbers == sortedNumbers)  // false\n    numbers.sort()\n    println(numbers == sortedNumbers)  // true\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308434927},"updatedAt":{"$$date":1597377733865},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"aQ6x8SNpUseCLwZi"}
{"name":"kotlin-利用 Kotlin 协程提升应用性能  |  Android 开发者  |  Android Developers","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /kotlin/coroutines-adv\n利用 Kotlin 协程提升应用性能  |  Android 开发者  |  Android Developers\n7-9 minutes\n借助 Kotlin 协程，您可以编写整洁、简化的异步代码，以在管理长时间运行的任务（例如网络调用或磁盘操作）时使应用保持敏捷的响应。\n\n本主题详细介绍 Android 上的协程。如果您不熟悉协程，请务必先阅读 Android 上的 Kotlin 协程，然后再阅读本主题。\n\n管理长时间运行的任务\n协程在常规函数的基础上添加了两项操作，用于处理长时间运行的任务。在 invoke（或 call）和 return 之外，协程添加了 suspend 和 resume：\n\nsuspend 用于暂停执行当前协程，并保存所有局部变量。\nresume 用于让已暂停的协程从暂停处继续执行。\n如需调用 suspend 函数，只能从其他 suspend 函数进行调用，或通过使用协程构建器（例如 launch）来启动新的协程。\n\n以下示例展示了一项任务（假设这是一项长时间运行的任务）的简单协程实现：\n\nsuspend fun fetchDocs() {                             // Dispatchers.Main\n    val result = get(\"https://developer.android.com\") // Dispatchers.IO for `get`\n    show(result)                                      // Dispatchers.Main\n}suspend fun get(url: String) = withContext(Dispatchers.IO) { /* ... */ }\n在上面的示例中，get() 仍在主线程上运行，但它会在启动网络请求之前暂停协程。当网络请求完成时，get 会恢复已暂停的协程，而不是使用回调通知主线程。\n\nKotlin 使用堆栈帧管理要运行哪个函数以及所有局部变量。暂停协程时，系统会复制并保存当前的堆栈帧以供稍后使用。恢复时，会将堆栈帧从其保存位置复制回来，然后函数再次开始运行。即使代码可能看起来像普通的顺序阻塞请求，协程也能确保网络请求避免阻塞主线程。\n\n使用协程确保主线程安全\nKotlin 协程使用调度程序确定哪些线程用于执行协程。要在主线程之外运行代码，可以让 Kotlin 协程在 Default 或 IO 调度程序上执行工作。在 Kotlin 中，所有协程都必须在调度程序中运行，即使它们在主线程上运行也是如此。协程可以自行暂停，而调度程序负责将其恢复。\n\nKotlin 提供了三个调度程序，可用于指定应在何处运行协程：\n\nDispatchers.Main - 使用此调度程序可在 Android 主线程上运行协程。此调度程序只能用于与界面交互和执行快速工作。示例包括调用 suspend 函数、运行 Android 界面框架操作，以及更新 LiveData 对象。\nDispatchers.IO - 此调度程序经过了专门优化，适合在主线程之外执行磁盘或网络 I/O。示例包括使用 Room 组件、从文件中读取数据或向文件中写入数据，以及运行任何网络操作。\nDispatchers.Default - 此调度程序经过了专门优化，适合在主线程之外执行占用大量 CPU 资源的工作。用例示例包括对列表排序和解析 JSON。\n接着前面的示例来讲，您可以使用调度程序重新定义 get 函数。在 get 的主体内，调用 withContext(Dispatchers.IO) 来创建一个在 IO 线程池中运行的块。您放在该块内的任何代码都始终通过 IO 调度程序执行。由于 withContext 本身就是一个暂停函数，因此函数 get 也是一个暂停函数。\n\nsuspend fun fetchDocs() {                      // Dispatchers.Main\n    val result = get(\"developer.android.com\")  // Dispatchers.Main\n    show(result)                               // Dispatchers.Main\n}suspend fun get(url: String) =                 // Dispatchers.Main\n    withContext(Dispatchers.IO) {              // Dispatchers.IO (main-safety block)\n        /* perform network IO here */          // Dispatchers.IO (main-safety block)\n    }                                          // Dispatchers.Main\n}\n借助协程，您可以通过精细控制来调度线程。由于 withContext() 可让您在不引入回调的情况下控制任何代码行的线程池，因此您可以将其应用于非常小的函数，例如从数据库中读取数据或执行网络请求。一种不错的做法是使用 withContext() 来确保每个函数都是主线程安全的，这意味着，您可以从主线程调用每个函数。这样，调用方就从不需要考虑应该使用哪个线程来执行函数了。\n\n在前面的示例中，fetchDocs() 在主线程上执行；不过，它可以安全地调用 get，这样会在后台执行网络请求。由于协程支持 suspend 和 resume，因此 withContext 块完成后，主线程上的协程会立即根据 get 结果恢复。\n\nwithContext() 的效用\n与基于回调的等效实现相比，withContext() 不会增加额外的开销。此外，在某些情况下，还可以优化 withContext() 调用，使其超越基于回调的等效实现。例如，如果某个函数对一个网络进行十次调用，您可以使用外部 withContext() 让 Kotlin 只切换一次线程。这样，即使网络库多次使用 withContext()，它也会留在同一调度程序上，并避免切换线程。此外，Kotlin 还优化了 Dispatchers.Default 与 Dispatchers.IO 之间的切换，以尽可能避免线程切换。\n\n启动协程\n您可以通过以下两种方式来启动协程：\n\nlaunch 可启动新协程而不将结果返回给调用方。任何被视为“一劳永逸”的工作都可以使用 launch 来启动。\nasync会启动一个新的协程，并允许您使用一个名为 await 的暂停函数返回结果。\n通常，您应使用 launch 从常规函数启动新协程，因为常规函数无法调用 await。只有在另一个协程内或在暂停函数内且在执行并行分解时，才使用 async。\n\n并行分解\n由 suspend 函数启动的所有协程都必须在该函数返回结果时停止，因此您可能需要保证这些协程在返回结果之前完成。借助 Kotlin 中的结构化并发机制，您可以定义用于启动一个或多个协程的 coroutineScope。然后，您可以使用 await()（针对单个协程）或 awaitAll()（针对多个协程）保证这些协程在从函数返回结果之前完成。\n\n例如，假设我们定义一个用于异步获取两个文档的 coroutineScope。通过对每个延迟引用调用 await()，我们可以保证这两项 async 操作在返回值之前完成：\n\nsuspend fun fetchTwoDocs() =\n    coroutineScope {\n        val deferredOne = async { fetchDoc(1) }\n        val deferredTwo = async { fetchDoc(2) }\n        deferredOne.await()\n        deferredTwo.await()\n    }\n您还可以对集合使用 awaitAll()，如以下示例所示：\n\nsuspend fun fetchTwoDocs() =        // called on any Dispatcher (any thread, possibly Main)\n    coroutineScope {\n        val deferreds = listOf(     // fetch two docs at the same time\n            async { fetchDoc(1) },  // async returns a result for the first doc\n            async { fetchDoc(2) }   // async returns a result for the second doc\n        )\n        deferreds.awaitAll()        // use awaitAll to wait for both network requests\n    }\n虽然 fetchTwoDocs() 使用 async 启动新协程，但该函数使用 awaitAll() 等待启动的协程完成后才会返回结果。不过请注意，即使我们没有调用 awaitAll()，coroutineScope 构建器也会等到所有新协程都完成后才恢复名为 fetchTwoDocs 的协程。\n\n此外，coroutineScope 会捕获协程抛出的所有异常，并将其传送回调用方。\n\n如需详细了解并行分解，请参阅编写暂停函数。\n\n协程概念\nCoroutineScope\nCoroutineScope 会跟踪它使用 launch 或 async 创建的所有协程。您可以随时调用 scope.cancel() 以取消正在进行的工作（即正在运行的协程）。在 Android 中，某些 KTX 库为某些生命周期类提供自己的 CoroutineScope。例如，ViewModel 有 viewModelScope，Lifecycle 有 lifecycleScope。不过，与调度程序不同，CoroutineScope 不运行协程。\n\nviewModelScope 也可用于 Android 上采用协程的后台线程中的示例。但是，如果您需要创建自己的 CoroutineScope 以控制协程在应用的特定层中的生命周期，则可以创建一个如下所示的 CoroutineScope：\n\nclass ExampleClass {// Job and Dispatcher are combined into a CoroutineContext which\n    // will be discussed shortly\n    val scope = CoroutineScope(Job() + Dispatchers.Main)\n    fun exampleMethod() {\n        // Starts a new coroutine within the scope\n        scope.launch {\n            // New coroutine that can call suspend functions\n            fetchDocs()\n        }\n    }\n    fun cleanUp() {\n        // Cancel the scope to cancel ongoing coroutines work\n        scope.cancel()\n    }\n}\n已取消的作用域无法再创建协程。因此，仅当控制其生命周期的类被销毁时，才应调用 scope.cancel()。使用 viewModelScope 时，ViewModel 类会在 ViewModel 的 onCleared() 方法中自动为您取消作用域。\n\n作业\nJob 是协程的句柄。使用 launch 或 async 创建的每个协程都会返回一个 Job 实例，该实例唯一标识协程并管理其生命周期。您还可以将 Job 传递给 CoroutineScope 以进一步管理其生命周期，如以下示例所示：\n\nclass ExampleClass {\n    ...\n    fun exampleMethod() {\n        // Handle to the coroutine, you can control its lifecycle\n        val job = scope.launch {\n            // New coroutine\n        }if (...) {\n            // Cancel the coroutine started above, this doesn't affect the scope\n            // this coroutine was launched in\n            job.cancel()\n        }\n    }\n}\nCoroutineContext\nCoroutineContext 使用以下元素集定义协程的行为：\n\nJob：控制协程的生命周期。\nCoroutineDispatcher：将工作分派到适当的线程。\nCoroutineName：协程的名称，可用于调试。\nCoroutineExceptionHandler：处理未捕获的异常。\n对于在作用域内创建的新协程，系统会为新协程分配一个新的 Job 实例，而从包含作用域继承其他 CoroutineContext 元素。可以通过向 launch 或 async 函数传递新的 CoroutineContext 替换继承的元素。请注意，将 Job 传递给 launch 或 async 不会产生任何效果，因为系统始终会像新协程分配新的 Job 实例。\n\nclass ExampleClass {\n    val scope = CoroutineScope(Job() + Dispatchers.Main)fun exampleMethod() {\n        // Starts a new coroutine on Dispatchers.Main as it's the scope's default\n        val job1 = scope.launch {\n            // New coroutine with CoroutineName = \"coroutine\" (default)\n        }// Starts a new coroutine on Dispatchers.Default\n        val job2 = scope.launch(Dispatchers.Default + \"BackgroundCoroutine\") {\n            // New coroutine with CoroutineName = \"BackgroundCoroutine\" (overridden)\n        }\n    }\n}\n其他协程资源\n如需详细了解协程，请参阅下面列出的其他资源：\n\n文档\n协程概览 (JetBrains)\nCodelab\n协程 Codelab：此 Codelab 介绍如何使用 Kotlin 协程管理后台线程和简化异步代码。\n采用 Kotlin Flow 和 LiveData 的高级协程：了解如何在 Android 应用中将 Kotlin 协程与 LiveData 和 Flow 结合使用。\n视频\n协程：如何处理各种错误：了解在 Kotlin 协程中处理取消和异常的最佳做法。\n了解 Android 上的 Kotlin 协程：2019 年 Google I/O 大会上的这场讲座简要介绍了如何在 Android 上使用 Kotlin 协程。\nLiveData 与协程和 Flow：2019 年 Android 开发者峰会上的这场讲座介绍了 liveData 协程构建器，展示何时以及如何使用该构建器以及测试模式和反模式构建整洁、高效而且可靠的响应式界面。\n2019 年 Android 开发者峰会 #AskAndroid - Android 上的 Kotlin 和协程：2019 年 Android 开发者峰会的这场会议解答 Android 开发者在线提交的 Kotlin 和协程相关问题。\n博文\n关于在 2019 年 Android 开发者峰会应用中使用协程流的经验：本文重点介绍在 2019 年 Android 开发者峰会应用中添加流支持时获得的最佳做法和其他经验。\nAndroid 中的简易协程：viewModelScope：本文介绍用于向 ViewModel 类添加协程支持的扩展属性 viewModelScope。\nAndroid 中的协程（系列文章中的第 1 篇，随附链接）：本博文是介绍 Kotlin 协程的系列文章中的第一篇。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397425929},"updatedAt":{"$$date":1597400395915},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"aWhtWHPowIwiO5FQ"}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244742316},"updatedAt":{"$$date":1597244742316},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"aYoK97UTKLIsw6As"}
{"name":"qk-ks_component_net","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin:'kotlin-kapt'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 103\n        versionName \"103\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n\n        //可以使用kotlin 实验特性，比如Parcelize ，直接生成Parcelable\n        androidExtensions {\n            experimental = true\n        }\n\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n    buildTypes {\n        release {\n            consumerProguardFiles 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    if(develop){\n        api project(path:':ks_lib_net')\n        api project(path:':ks_lib_ktx')\n        implementation project(path:':ks_component_download')\n        implementation project(path:':ks_lib_persistence')\n    }else{\n        //网络库\n        api (ks.lib_net){changing = true}\n        api ks.lib_ktx\n        implementation ks.component_download\n        api ks.lib_persistence\n    }\n\n    implementation kaishu.ksdiskframe\n\n}\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.ks.component.net\" >\n\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    <application>\n\n        <service android:name=\".ui.service.DownloadPemService\"\n            android:exported=\"false\"\n            android:permission=\"android.permission.BIND_JOB_SERVICE\"></service>\n    </application>\n</manifest>\n\n\n\n\n\n\n\n\n\n\n\n\nclass SSLSocketFactoryUtils {\n    lateinit var trustManagers: Array<TrustManager>\n        private set\n\n    fun getSSlSocketFrctoryByPaths(\n        assetsPems: MutableList<InputStream>,\n        pemFile: File\n    ): SSLSocketFactory? {\n        val certificates: MutableList<InputStream> = ArrayList()\n        //首先加载从assets里面的证书，如果有效就直接使用\n        certificates.addAll(assetsPems)\n        //如果asset证书没有效则使用从网络下载的\n        if (pemFile != null && pemFile.exists()) {\n            val files = pemFile.listFiles()\n            if (files != null) {\n                for (i in files.indices) {\n                    val localFile = files[i]\n                    //读取本地的\n                    val inStream = AseUtils.decrypt(localFile, \"12345678g01234ab\")\n                    if (inStream != null) {\n                        certificates.add(inStream)\n                    }\n                }\n            }\n        }\n        return if (certificates != null && certificates.size > 0) {\n            getSSLSocketFactory(certificates)\n        } else null\n    }\n\n    private fun getSSLSocketFactory(certificates: List<InputStream>?): SSLSocketFactory? {\n        if (certificates == null || certificates.isEmpty()) {\n            return null\n        }\n        try {\n            val certificateFactory =\n                CertificateFactory.getInstance(\"X.509\")\n            // Put the certificates a key store.\n            val password = \"kaishu2099\".toCharArray() // Any password will work.\n            val keyStore = newEmptyKeyStore(password)\n            var index = 0\n            for (certificate in certificates) {\n                val certificateAlias = Integer.toString(index++)\n                keyStore.setCertificateEntry(\n                    certificateAlias,\n                    certificateFactory.generateCertificate(certificate)\n                )\n            } // Use it to b\n            val sslContext = SSLContext.getInstance(\"TLS\")\n            val trustManagerFactory =\n                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())\n            trustManagerFactory.init(keyStore)\n            trustManagers = trustManagerFactory.trustManagers\n            sslContext.init(null, trustManagers, SecureRandom())\n            return sslContext.socketFactory\n        } catch (e: CertificateException) {\n            e.printStackTrace()\n        } catch (e: GeneralSecurityException) {\n            e.printStackTrace()\n        }\n        return null\n    }\n\n    @Throws(GeneralSecurityException::class)\n    private fun newEmptyKeyStore(password: CharArray): KeyStore {\n        return try {\n            val keyStore =\n                KeyStore.getInstance(KeyStore.getDefaultType())\n            val `in`: InputStream? =\n                null // By convention, 'null' creates an empty key store.\n            keyStore.load(`in`, password)\n            keyStore\n        } catch (e: IOException) {\n            throw AssertionError(e)\n        }\n    }\n\n    companion object {\n\n        val instance: SSLSocketFactoryUtils by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {\n            SSLSocketFactoryUtils()\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\nobject NetConstants {\n    const val HTTP_REQUEST_TIMEOUT: Long = 10000L //10s\n\n\n    const val CACHE_CONTROL = \"Cache-Control\"\n    const val TOKEN = \"token\"\n    const val DEVICE_ID = \"deviceId\"\n    const val APP_DEVICE_ID = \"appDeviceId\"\n    const val APPVERSION = \"appVersion\"\n    const val ACCEPT_ENCODING = \"Accept-Encoding\"\n    const val APIVER = \"apiver\"\n    const val USERID = \"userId\"\n    const val APPID = \"appId\"\n    const val CHANNELID = \"channelId\"\n    const val CLIENTFORM = \"clientform\"\n    const val USERSOURCE = \"userSource\"\n    const val PLATFORM = \"platform\"\n    const val DEVICE = \"device\"\n    //移动国家码\n    const val MCCCODE = \"mccCode\"\n    // 超时时间的标识位\n    const val MINI_TIMEOUT = \"xTimeout: 1\"\n\n    const val HeaderContentTypeLong = \"Content-Type:application/json; charset=UTF-8\"\n}\n\n\n\n\n\n\n\n\n\nobject TokenHolder {\n    private const val KEY_TOKEN: String = \"token\"\n    private const val KEY_REFRESH_TOKEN: String = \"refresh_token\"\n    private const val KEY_REFRESH_TOKEN_TIME_STAMP: String = \"refresh_token_time_stamp\"\n\n    private var mRefreshingToken: AtomicBoolean = AtomicBoolean(false)\n    private var mGenerateToken: AtomicBoolean = AtomicBoolean(false)\n    private val tokenRepository by lazy { TokenRepository() }\n\n    var token: String by Preference(KEY_TOKEN, \"\")\n    var refreshToken: String by Preference(KEY_REFRESH_TOKEN, \"\")\n    var refreshTokenTimeStamp: Long by Preference(KEY_REFRESH_TOKEN_TIME_STAMP, 0)\n    //        通知上层调用处，是否需要重新请求接口，只有refresh 成功才去重试\n    var needRetry = false\n    @WorkerThread\n    suspend fun refreshTokenLocked():Boolean {\n        needRetry = false\n        return if (mRefreshingToken.compareAndSet(false, true)) {\n            requestRefreshToken()\n        } else {\n\n            //TODO 后面优化\n            \"已存在 token请求，开始等待上个请求结束 \".loge()\n            //实验，有可能会有问题。等待 上一个 refreshToken请求结束 ，while 结束，返回 上一个refreshToken结果 给上层 判断是否需要刷新\n            while(mRefreshingToken.get()){\n                delay(1000)\n            }\n            //等待结束，返回是否需要重试\n            \"等待结束 是否需要重试:$needRetry\".loge()\n            needRetry\n\n        }\n\n    }\n\n    @WorkerThread\n    private suspend fun requestRefreshToken():Boolean {\n        \"refreshTokenLocked 开始请求 run in Thread:${Thread.currentThread().name}\".loge()\n\n        val result = tokenRepository.refreshToken()\n\n        if (result is KsResult.Success) {\n            if (result.code == 1003) {\n                \"TokenHolder refreshTokenLocked result.code == 1003 relogin\".loge()\n                withContext(Dispatchers.Main) {\n                    NetComponent.tokenCallback.reLogin(result.message)\n                }\n\n            } else {\n                val tokenBean = result.data\n                token = tokenBean?.token ?: \"\"\n                refreshToken = tokenBean?.refreshToken ?: \"\"\n                refreshTokenTimeStamp = tokenBean?.refreshTokenTimeStamp ?: 0\n                needRetry = true\n            }\n\n\n        } else if (result is KsResult.Error) {\n            //打印出 错误日志\n            val exception = result.exception\n            if (exception is com.ks.component.net.exception.ApiException) {\n                \"refreshTokenLocked onError ${exception.displayMessage},code=${exception.code}\".loge()\n                if (exception.code == 1003) {\n                    withContext(Dispatchers.Main) {\n                        NetComponent.tokenCallback.reLogin(exception.displayMessage)\n                    }\n\n                }\n            }\n        }\n        //刷token结束，更改boolean标记\n        mRefreshingToken.compareAndSet(true, false)\n        return needRetry\n    }\n\n    /**\n     * 用户登出后需要清理token 信息\n     */\n    fun clearToken() {\n        token = \"\"\n        refreshToken = \"\"\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\nobject EncodeUtils {\n\n    /**\n     * @param string\n     * @return\n     */\n    fun md5(string: String): String? {\n        val hash: ByteArray\n        hash = try {\n            MessageDigest.getInstance(\"MD5\").digest(\n                string.toByteArray(charset(\"UTF-8\"))\n            )\n        } catch (e: NoSuchAlgorithmException) {\n            throw RuntimeException(\"Huh, MD5 should be supported?\", e)\n        } catch (e: UnsupportedEncodingException) {\n            throw RuntimeException(\"Huh, UTF-8 should be supported?\", e)\n        }\n        val hex = StringBuilder(hash.size * 2)\n        for (b in hash) {\n            if (b and 0xFF < 0x10) {\n                hex.append(\"0\")\n            }\n            hex.append(Integer.toHexString(b and 0xFF))\n        }\n        return hex.toString().toUpperCase()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\nobject DiffTimeUtils {\n    var bDiffTimeAdjusted = false\n    const val DIFFHOURADJUST = 30 * 60 * 1000 //30分鐘\n    var pointDiffTimeMs: Long = 0\n    var temp by Preference(\"servertimediff\",0L)\n\n    @JvmStatic\n    var diffMs: Long\n        get() = if (bDiffTimeAdjusted) {\n            pointDiffTimeMs\n        } else temp\n        set(diffms) {\n            bDiffTimeAdjusted = true\n            pointDiffTimeMs = diffms\n            temp = pointDiffTimeMs\n        }\n}\n\n\n\n\n\n\n\n\nobject DeviceUtils {\n\n    private const val IS_SUPPORT_MIIT: String = \"is_support_mitt\"\n    private const val MIIT_OAID: String = \"mitt_oaid\"\n    private const val MIIT_AAID: String = \"mitt_aaid\"\n\n    var isSupportMitt: Boolean by Preference(IS_SUPPORT_MIIT, false)\n    var oaid: String by Preference(MIIT_OAID, \"\")\n    var aaid: String by Preference(MIIT_AAID, \"\")\n\n\n    private//                Log.e(\"kaishu\", \"open file  Failed\", var4);\n    val macShell: String?\n        get() {\n            val var0 = arrayOf(\n                \"/sys/class/net/wlan0/address\",\n                \"/sys/class/net/eth0/address\",\n                \"/sys/devices/virtual/net/wlan0/address\"\n            )\n\n            for (var2 in var0.indices) {\n                try {\n                    val var1 = reaMac(var0[var2])\n                    if (var1 != null) {\n                        return var1\n                    }\n                } catch (var4: Exception) {\n                }\n\n            }\n\n            return null\n        }\n\n    private val macByJava: String?\n        get() {\n            try {\n                val var0 = NetworkInterface.getNetworkInterfaces()\n\n                while (var0.hasMoreElements()) {\n                    val var1 = var0.nextElement() as NetworkInterface\n                    if (\"wlan0\" == var1.name) {\n                        val var2 = var1.hardwareAddress\n                        if (var2 != null && var2.size != 0) {\n                            val var3 = StringBuilder()\n                            val var5 = var2.size\n\n                            for (var6 in 0 until var5) {\n                                val var7 = var2[var6]\n                                var3.append(\n                                    String.format(\n                                        \"%02X:\",\n                                        *arrayOf<Any>(java.lang.Byte.valueOf(var7))\n                                    )\n                                )\n                            }\n\n                            if (var3.length > 0) {\n                                var3.deleteCharAt(var3.length - 1)\n                            }\n\n                            return var3.toString()\n                        }\n\n                        return null\n                    }\n                }\n            } catch (var8: Exception) {\n            }\n\n            return null\n        }\n\n    val deviceSN: String?\n        get() {\n            var var0: String? = null\n\n            try {\n                val var1 = Class.forName(\"android.os.SystemProperties\")\n                val var2 = var1.getMethod(\n                    \"get\",\n                    *arrayOf<Class<*>>(String::class.java, String::class.java)\n                )\n                var0 = var2.invoke(var1, *arrayOf<Any>(\"ro.serialno\", \"unknown\")) as String\n            } catch (var3: Exception) {\n            }\n\n            return var0\n        }\n\n    fun fix_getimei(context: Context?): String? {\n        if (context == null) {\n            return \"\"\n        }\n        val imeiStr = getUMId(context)\n        if (!TextUtils.isEmpty(imeiStr)) {\n            return imeiStr\n        }\n\n        val var1 = context.getSystemService(Service.TELEPHONY_SERVICE) as TelephonyManager\n        var didStr = \"\"\n        try {\n            if (checkPermission(context, \"android.permission.READ_PHONE_STATE\")) {\n                //Android Q 适配\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n                    didStr = var1.imei\n                } else {\n                    didStr = var1.deviceId\n                }\n\n                putUMId(context, didStr)\n            }\n        } catch (var4: Exception) {\n            var4.printStackTrace()\n        }\n\n        return if (TextUtils.isEmpty(didStr)) {\n            \"\"\n        } else {\n            didStr\n        }\n    }\n\n    fun getUMId(var0: Context): String? {\n        val var1 = var0.getSharedPreferences(\"uidspfile\", MODE_PRIVATE)\n        return var1?.getString(\"uid260v\", null as String?)\n    }\n\n    fun putUMId(var0: Context, var1: String?): Boolean {\n        var var1 = var1\n        val var2 = var0.getSharedPreferences(\"uidspfile\", MODE_PRIVATE)\n        if (var2 == null) {\n            return false\n        } else {\n            if (TextUtils.isEmpty(var1)) {\n                var1 = \"\"\n            }\n\n            return var2.edit().putString(\"uid260v\", var1).commit()\n        }\n    }\n\n    private fun checkPermission(context: Context, var1: String): Boolean {\n        val var2 = context.packageManager\n        return var2.checkPermission(var1, context.packageName) == PackageManager.PERMISSION_GRANTED\n    }\n\n    fun fix_getmac(context: Context?): String {\n        if (context == null) {\n            return \"\"\n        }\n        val didStr = getMac(context)\n        return if (TextUtils.isEmpty(didStr)) {\n            \"\"\n        } else {\n            \"adrdmac:\" + didStr!!\n        }\n    }\n\n    fun getMac(var0: Context): String? {\n        var var1: String? = \"\"\n\n        try {\n            var1 = macShell\n            if (TextUtils.isEmpty(var1)) {\n                Log.w(\n                    \"kaishu\",\n                    \"Could not get mac address.[no permission android.permission.ACCESS_WIFI_STATE\"\n                )\n            }\n\n            if (TextUtils.isEmpty(var1)) {\n                var1 = macByJava\n                if (TextUtils.isEmpty(var1)) {\n                    Log.w(\"kaishu\", \"Could not get mac address by java\")\n                }\n            }\n\n            if (TextUtils.isEmpty(var1)) {\n                var1 = NetComponent.getMac()\n            } else {\n                NetComponent.saveMac(var1!!)\n            }\n\n            return var1\n        } catch (var3: Exception) {\n            Log.w(\"kaishu\", \"Could not get mac address.$var3\")\n            return var1\n        }\n\n    }\n\n    @Throws(FileNotFoundException::class)\n    private fun reaMac(var0: String): String? {\n        var var1: String? = null\n        val var2 = FileReader(var0)\n        var var3: BufferedReader? = null\n        if (var2 != null) {\n            try {\n                var3 = BufferedReader(var2, 1024)\n                var1 = var3.readLine()\n            } catch (var17: IOException) {\n            } finally {\n                if (var2 != null) {\n                    try {\n                        var2.close()\n                    } catch (var16: IOException) {\n                    }\n\n                }\n                if (var3 != null) {\n                    try {\n                        var3.close()\n                    } catch (var15: IOException) {\n                    }\n\n                }\n            }\n        }\n        return var1\n    }\n\n    fun fix_getadrdid(context: Context?): String {\n        if (context == null) {\n            return \"\"\n        }\n        val didStr = Settings.Secure.getString(context.contentResolver, \"android_id\")\n        return if (TextUtils.isEmpty(didStr)) {\n            \"\"\n        } else {\n            \"adrdid:$didStr\"\n        }\n    }\n\n    fun fix_getsnmac(): String {\n        val didStr = \"adrdsnmac:$deviceSN$macByJava\"\n        return if (TextUtils.isEmpty(didStr)) {\n            \"\"\n        } else {\n            didStr\n        }\n    }\n\n    fun getDeviceIdSameImei(context: Context?): String? {\n        var context = context\n        if (context == null) {\n            context = NetComponent.application\n        }\n        if (context == null) {\n            return \"\"\n        }\n        //androidid\n        val androidId: String = fix_getadrdid(context)\n        if (!TextUtils.isEmpty(androidId)) {\n            return androidId\n        }\n\n        //pdc如果是安卓q或以上的优先获取移动联盟提供的aaid\n        if (Build.VERSION.SDK_INT >= 29) {\n            val aaid: String = getMiitAAID()\n            if (!TextUtils.isEmpty(aaid)) {\n                return aaid\n            }\n            //然后oaid\n            val oaid: String = getMiitOAID()\n            if (!TextUtils.isEmpty(oaid)) {\n                return oaid\n            }\n        }\n        val imeiStr = getUMId(context)\n        if (!TextUtils.isEmpty(imeiStr)) {\n            return imeiStr\n        }\n\n        val var1 = context.getSystemService(Service.TELEPHONY_SERVICE) as TelephonyManager\n        if (var1 == null) {\n            Log.w(\"kaishu\", \"No IMEI.\")\n        }\n\n        var didStr: String? = \"\"\n\n        try {\n            if (checkPermission(context, \"android.permission.READ_PHONE_STATE\")) {\n                didStr = var1.deviceId\n\n                putUMId(context, didStr)\n            }\n        } catch (var4: Exception) {\n            Log.w(\"kaishu\", \"No IMEI.\", var4)\n        }\n\n        if (TextUtils.isEmpty(didStr)) {\n            Log.w(\"kaishu\", \"No IMEI.\")\n            didStr = getMac(context)\n            if (TextUtils.isEmpty(didStr)) {\n                Log.w(\"kaishu\", \"Failed to take mac as IMEI. Try to use Secure.ANDROID_ID instead.\")\n                didStr = Settings.Secure.getString(context.contentResolver, \"android_id\")\n                Log.w(\"kaishu\", \"getDeviceId: Secure.ANDROID_ID: \" + didStr!!)\n                if (TextUtils.isEmpty(didStr)) {\n                    didStr = \"adrdsnmac:$deviceSN$macByJava\"\n                } else {\n                    didStr = \"adrdid:$didStr\"\n                }\n            } else {\n                didStr = \"adrdmac:\" + didStr!!\n            }\n        }\n        return didStr\n    }\n\n\n    /**\n     * 获取移动安全联盟提供的aaid\n     *\n     * @return\n     */\n    fun getMiitAAID(): String {\n        if (isSupportMitt) {\n            if (!aaid.isNullOrEmpty()) {\n                return \"adrksaaid:$aaid\"\n            }\n        }\n        return \"\"\n    }\n\n    /**\n     * 获取移动安全联盟提供的oaid\n     *\n     * @return\n     */\n    fun getMiitOAID(): String {\n        if (isSupportMitt) {\n            if (isSupportMitt) {\n                if (!aaid.isNullOrEmpty()) {\n                    return \"adrksoaid:$oaid\"\n                }\n            }\n        }\n        return \"\"\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ChangeBaseUrlInterceptor : Interceptor {\n\n    override fun intercept(chain: Interceptor.Chain): Response {\n        //获取request\n        val request = chain.request()\n\n        //从request中获取原有的HttpUrl实列 oldHttpUrl\n\n        val oldHttpUrl = request.url\n        NetComponent.tokenCallback.requestUrl(oldHttpUrl.toUrl().path)\n\n        //获取request的创建者\n        val builder = request.newBuilder()\n\n        //如果有忽略\n        var urlString = oldHttpUrl.toString()\n        if (urlString.contains(GlobalUrlManager.IDENTIFICATION_IGNORE)) {\n            return chain.proceed(pruneIdentification(builder, urlString))\n        }\n\n        val headerValues = request.headers(GlobalUrlManager.DOMAIN)\n\n        if (headerValues.isNotEmpty()) {\n            builder.removeHeader(GlobalUrlManager.DOMAIN)\n            //单个接口替换\n            val newBaseUrl: HttpUrl? = GlobalUrlManager.instance.mDomain[headerValues[0]]?.toHttpUrlOrNull()\n\n            newBaseUrl?.run {\n                val newHttpUrl =\n                    oldHttpUrl.newBuilder().scheme(scheme).host(host)\n                        .port(port).build()\n                return chain.proceed(builder.url(newHttpUrl).build())\n            }\n        } else {\n            //全局替换\n            var httpUrl = GlobalUrlManager.instance.globalDomain\n            if (null != httpUrl) {\n                val urlParser = DomainUrlParser()\n                val newUrl: HttpUrl = urlParser.parseUrl(httpUrl, request.url)\n\n                return chain.proceed(builder.url(newUrl).build())\n            }\n        }\n        return chain.proceed(request)\n    }\n\n    private fun pruneIdentification(newBuilder: Request.Builder, url: String): Request {\n        var split = url.split(GlobalUrlManager.IDENTIFICATION_IGNORE)\n        var buffer = StringBuffer()\n        for (s in split) {\n            buffer.append(s)\n        }\n        return newBuilder\n            .url(buffer.toString())\n            .build()\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\nclass HeaderInterceptor : okhttp3.Interceptor {\n\n//    private val userInfoProvider: UserInfoProvider? by lazy { KsRouterHelper.buildUserInfoProvider() as? UserInfoProvider }\n\n    private fun headerJoinin(builder: Request.Builder): Request.Builder {\n\n        val headerMap = NetComponent.getHeader().entries\n        headerMap.forEach { entry ->\n            builder.header(entry.key, entry.value)\n        }\n        return builder\n//\n//        builder.header(NetConstants.TOKEN, TokenHolder.token)\n//                .header(NetConstants.DEVICE_ID, TokenHolder.deviceId)\n//                .header(NetConstants.APPVERSION, NetComponent.application.versionName)\n//                .header(NetConstants.ACCEPT_ENCODING, \"identity\")\n//                .header(NetConstants.APIVER, \"2.4\")\n//                .header(NetConstants.USERID, NetComponent.getUserId())\n//                .header(NetConstants.APPID, HttpConfigManager.getAppId())\n//                .header(NetConstants.CHANNELID, HttpConfigManager.getUmengChannel())\n//                .header(NetConstants.CLIENTFORM, HttpConfigManager.getClientFrom())\n//                .header(NetConstants.USERSOURCE, HttpConfigManager.getAppName())\n//                .header(NetConstants.DEVICE, \"android\")\n//                .header(NetConstants.PLATFORM, HttpConfigManager.getAppName())\n//        if (ActivityCompat.checkSelfPermission(NetComponent.application, Manifest.permission.READ_PHONE_STATE)\n//                !== PackageManager.PERMISSION_GRANTED) { //没有权限，则不去加上mcccode\n//            return builder\n//        }\n//        NetComponent.application.telephonyManager?.run {\n//            builder.header(NetConstants.MCCCODE, getMobileMCC(NetComponent.application))\n//        }\n//\n//        return builder\n    }\n\n    override fun intercept(chain: okhttp3.Interceptor.Chain): Response {\n        val request: Request =\n                headerJoinin(chain.request().newBuilder())\n                        .method(chain.request().method, chain.request().body)\n                        .build()\n        return chain.proceed(request)\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\npublic class BasicParamsInterceptor implements Interceptor {\n    private int serverTimeCount;\n\n    public BasicParamsInterceptor() {\n\n    }\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Response response = chain.proceed(request);\n        checkServerDateTime(response.header(\"Date\"));\n        return response;\n    }\n\n    private void checkServerDateTime(String date) {\n        if (TextUtils.isEmpty(date)) {\n            return;\n        }\n        serverTimeCount++;\n        if (serverTimeCount % 8 == 0) {\n\n            String serverTime = date;\n            SimpleDateFormat sdf = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss 'GMT'\", Locale.US);\n            sdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            Date serverDateGMT = null;\n            try {\n                serverDateGMT = sdf.parse(serverTime);\n                long diff = serverDateGMT.getTime() - System.currentTimeMillis();\n\n                if (Math.abs(diff) > DiffTimeUtils.DIFFHOURADJUST) {\n                    DiffTimeUtils.setDiffMs(diff);\n                } else {\n                    DiffTimeUtils.setDiffMs(0L);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n@Parcelize\n@Keep\ndata class DeviceIdBean(\n    val deviceId: String,\n    val appDeviceId: String\n) : Parcelable\n\n\n\n\n\n@Parcelize\n@Keep\ndata class TokenBean (var token: String,\n                      var refreshToken: String,\n                      var refreshTokenTimeStamp: Long):Parcelable\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598585029659},"updatedAt":{"$$date":1598592145009},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"agB32HaRMMoSJFCb"}
{"name":"kotlin-This 表达式 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/this-expressions.html\nThis 表达式 - Kotlin 语言中文站\n5-7 minutes\n改进翻译\n为了表示当前的 接收者 我们使用 this 表达式：\n\n在类的成员中，this 指的是该类的当前对象。\n在扩展函数或者带有接收者的函数字面值中， this 表示在点左侧传递的 接收者 参数。\n如果 this 没有限定符，它指的是最内层的包含它的作用域。要引用其他作用域中的 this，请使用 标签限定符：\n\n要访问来自外部作用域的this（一个类 或者扩展函数， 或者带标签的带有接收者的函数字面值）我们使用this@label，其中 @label 是一个代指 this 来源的标签：\n\nclass A { // 隐式标签 @A\n    inner class B { // 隐式标签 @B\n        fun Int.foo() { // 隐式标签 @foo\n            val a = this@A // A 的 this\n            val b = this@B // B 的 this\n\n            val c = this // foo() 的接收者，一个 Int\n            val c1 = this@foo // foo() 的接收者，一个 Int\n\n            val funLit = lambda@ fun String.() {\n                val d = this // funLit 的接收者\n            }\n\n\n            val funLit2 = { s: String ->\n                // foo() 的接收者，因为它包含的 lambda 表达式\n                // 没有任何接收者\n                val d1 = this\n            }\n        }\n    }\n}\n当对 this 调用成员函数时，可以省略 this. 部分。 但是如果有一个同名的非成员函数时，请谨慎使用，因为在某些情况下会调用同名的非成员：\n\nfun main() {\n//sampleStart\n    fun printLine() { println(\"Top-level function\") }\n    \n    class A {\n        fun printLine() { println(\"Member function\") }\n\n        fun invokePrintLine(omitThis: Boolean = false)  { \n            if (omitThis) printLine()\n            else this.printLine()\n        }\n    }\n    \n    A().invokePrintLine() // Member function\n    A().invokePrintLine(omitThis = true) // Top-level function\n//sampleEnd()\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386570255},"updatedAt":{"$$date":1597396839697},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"aiNfT1TMoDowHJyL"}
{"name":"css-CSS 文本格式","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 文本格式\n\n文本格式\nThis text is styled with some of the text formatting properties. The heading uses the text-align, text-transform, and color properties. The paragraph is indented, aligned, and the space between characters is specified. The underline is removed from the \"尝试一下\" link.\n\n文本颜色\n颜色属性被用来设置文字的颜色。\n\n颜色是通过CSS最经常的指定：\n\n十六进制值 - 如: ＃FF0000\n一个RGB值 - 如: RGB(255,0,0)\n颜色的名称 - 如: red\n参阅 CSS 颜色值 查看完整的颜色值。\n\n一个网页的背景颜色是指在主体内的选择：\n\n实例\nbody {color:red;}\nh1 {color:#00ff00;}\nh2 {color:rgb(255,0,0);}\n\n尝试一下 »\nRemark 对于W3C标准的CSS：如果你定义了颜色属性，你还必须定义背景色属性。\n\n文本的对齐方式\n文本排列属性是用来设置文本的水平对齐方式。\n\n文本可居中或对齐到左或右,两端对齐.\n\n当text-align设置为\"justify\"，每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）。\n\n实例\nh1 {text-align:center;}\np.date {text-align:right;}\np.main {text-align:justify;}\n\n尝试一下 »\n\n文本修饰\ntext-decoration 属性用来设置或删除文本的装饰。\n\n从设计的角度看 text-decoration属性主要是用来删除链接的下划线：\n\n实例\na {text-decoration:none;}\n\n尝试一下 »\n也可以这样装饰文字：\n\n实例\nh1 {text-decoration:overline;}\nh2 {text-decoration:line-through;}\nh3 {text-decoration:underline;}\n\n尝试一下 »\nRemark 我们不建议强调指出不是链接的文本，因为这常常混淆用户。\n\n文本转换\n文本转换属性是用来指定在一个文本中的大写和小写字母。\n\n可用于所有字句变成大写或小写字母，或每个单词的首字母大写。\n\n实例\np.uppercase {text-transform:uppercase;}\np.lowercase {text-transform:lowercase;}\np.capitalize {text-transform:capitalize;}\n\n尝试一下 »\n\n文本缩进\n文本缩进属性是用来指定文本的第一行的缩进。\n\n实例\np {text-indent:50px;}\n\n尝试一下 »\n\nExamples\n更多实例\n指定字符之间的空间\n这个例子演示了如何增加或减少字符之间的空间。\n\n指定行与行之间的空间\n这个例子演示了如何指定在一个段落中行之间的空间\n\n设置元素的文本方向\n这个例子演示了如何改变元素的文本方向。\n\n增加单词之间的空白空间\n这个例子演示了如何增加一个段落中的单词之间的空白空间。\n\n在元素内禁用文字环绕\n这个例子演示了如何禁用一个元素内的文字环绕。\n\n垂直对齐图像\n这个例子演示了如何设置文本的垂直对齐图像。\n\n添加文本阴影\n这个例子演示了如何设置文本阴影。\n\n所有CSS文本属性。\n属性\t描述\ncolor\t设置文本颜色\ndirection\t设置文本方向。\nletter-spacing\t设置字符间距\nline-height\t设置行高\ntext-align\t对齐元素中的文本\ntext-decoration\t向文本添加修饰\ntext-indent\t缩进元素中文本的首行\ntext-shadow\t设置文本阴影\ntext-transform\t控制元素中的字母\nunicode-bidi\t设置或返回文本是否被重写 \nvertical-align\t设置元素的垂直对齐\nwhite-space\t设置元素中空白的处理方式\nword-spacing\t设置字间距"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888546154},"updatedAt":{"$$date":1598888753273},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ak9RF3yXGJXXsZr4"}
{"name":"ad-ksliveframe","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\n/**\n * 播放器\n * notice ： 不要依赖Support 包\n */\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 5\n\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    testImplementation deps.androidx.junit\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class NetworkUtils {\n\n    /**\n     * get current network connected type\n     *\n     * @param context context\n     * @return int\n     */\n    public static int getNetworkState(Context context) {\n        ConnectivityManager connManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); // 获取网络服务\n        if (null == connManager) {\n            return NETWORK_STATE_NONE;\n        }\n        @SuppressLint(\"MissingPermission\")\n        NetworkInfo networkInfo = connManager.getActiveNetworkInfo();\n        if (networkInfo == null) {\n            return NETWORK_STATE_NONE;\n        }else {\n            NetworkInfo.State networkInfoState = networkInfo.getState();\n            if(networkInfoState == NetworkInfo.State.CONNECTING){\n                return NETWORK_STATE_CONNECTING;\n            }\n            if(!networkInfo.isAvailable()){\n                return NETWORK_STATE_NONE;\n            }\n        }\n        // is wifi ?\n        @SuppressLint(\"MissingPermission\")\n        NetworkInfo wifiInfo = connManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);\n        if (null != wifiInfo) {\n            NetworkInfo.State state = wifiInfo.getState();\n            if (null != state) {\n                if (state == NetworkInfo.State.CONNECTED || state == NetworkInfo.State.CONNECTING) {\n                    return NETWORK_STATE_WIFI;\n                }\n            }\n        }\n        // 2G、3G、4G ?\n        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);\n        int networkType = telephonyManager.getNetworkType();\n        switch (networkType) {\n            /*\n             GPRS : 2G(2.5) General Packet Radia Service 114kbps\n             EDGE : 2G(2.75G) Enhanced Data Rate for GSM Evolution 384kbps\n             UMTS : 3G WCDMA 联通3G Universal Mobile Telecommunication System 完整的3G移动通信技术标准\n             CDMA : 2G 电信 Code Division Multiple Access 码分多址\n             EVDO_0 : 3G (EVDO 全程 CDMA2000 1xEV-DO) Evolution - Data Only (Data Optimized) 153.6kps - 2.4mbps 属于3G\n             EVDO_A : 3G 1.8mbps - 3.1mbps 属于3G过渡，3.5G\n             1xRTT : 2G CDMA2000 1xRTT (RTT - 无线电传输技术) 144kbps 2G的过渡,\n             HSDPA : 3.5G 高速下行分组接入 3.5G WCDMA High Speed Downlink Packet Access 14.4mbps\n             HSUPA : 3.5G High Speed Uplink Packet Access 高速上行链路分组接入 1.4 - 5.8 mbps\n             HSPA : 3G (分HSDPA,HSUPA) High Speed Packet Access\n             IDEN : 2G Integrated Dispatch Enhanced Networks 集成数字增强型网络 （属于2G，来自维基百科）\n             EVDO_B : 3G EV-DO Rev.B 14.7Mbps 下行 3.5G\n             LTE : 4G Long Term Evolution FDD-LTE 和 TDD-LTE , 3G过渡，升级版 LTE Advanced 才是4G\n             EHRPD : 3G CDMA2000向LTE 4G的中间产物 Evolved High Rate Packet Data HRPD的升级\n             HSPAP : 3G HSPAP 比 HSDPA 快些\n             */\n            // 2G\n            case TelephonyManager.NETWORK_TYPE_GPRS:\n            case TelephonyManager.NETWORK_TYPE_CDMA:\n            case TelephonyManager.NETWORK_TYPE_EDGE:\n            case TelephonyManager.NETWORK_TYPE_1xRTT:\n            case TelephonyManager.NETWORK_TYPE_IDEN:\n                return NETWORK_STATE_2G;\n            // 3G\n            case TelephonyManager.NETWORK_TYPE_EVDO_A:\n            case TelephonyManager.NETWORK_TYPE_UMTS:\n            case TelephonyManager.NETWORK_TYPE_EVDO_0:\n            case TelephonyManager.NETWORK_TYPE_HSDPA:\n            case TelephonyManager.NETWORK_TYPE_HSUPA:\n            case TelephonyManager.NETWORK_TYPE_HSPA:\n            case TelephonyManager.NETWORK_TYPE_EVDO_B:\n            case TelephonyManager.NETWORK_TYPE_EHRPD:\n            case TelephonyManager.NETWORK_TYPE_HSPAP:\n                return NETWORK_STATE_3G;\n            // 4G\n            case TelephonyManager.NETWORK_TYPE_LTE:\n                return NETWORK_STATE_4G;\n            default:\n                return NETWORK_STATE_MOBILE_UNKNOWN;\n        }\n    }\n\n    public static boolean isMobile(int networkState){\n        return networkState > NETWORK_STATE_WIFI;\n    }\n\n    /**\n     * whether or not network connect.\n     *\n     * @param context context\n     * @return true/false\n     */\n    public static boolean isNetConnected(Context context) {\n        ConnectivityManager connectivity = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n        if (connectivity != null) {\n            @SuppressLint(\"MissingPermission\")\n            NetworkInfo info = connectivity.getActiveNetworkInfo();\n            if (info != null && info.isConnected()) {\n                if (info.getState() == NetworkInfo.State.CONNECTED) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * is wifi ?\n     *\n     * @param context context\n     * @return true/false\n     */\n    public static synchronized boolean isWifiConnected(Context context) {\n        ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n        if (connectivityManager != null) {\n            @SuppressLint(\"MissingPermission\")\n            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();\n            if (networkInfo != null) {\n                int networkInfoType = networkInfo.getType();\n                if (networkInfoType == ConnectivityManager.TYPE_WIFI || networkInfoType == ConnectivityManager.TYPE_ETHERNET) {\n                    return networkInfo.isConnected();\n                }\n            }\n        }\n        return false;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class PUtils {\n\n    public static int getStatusBarHeight(Context context){\n        int height = getStatusBarHeightMethod1(context);\n        if(height<=0){\n            height = getStatusBarHeightMethod2(context);\n        }\n        return height;\n    }\n\n    private static int getStatusBarHeightMethod1(Context context){\n        int statusBarHeight = -1;\n        //获取status_bar_height资源的ID\n        int resourceId = context.getResources()\n                .getIdentifier(\"status_bar_height\", \"dimen\", \"android\");\n        if (resourceId > 0) {\n            //根据资源ID获取响应的尺寸值\n            statusBarHeight = context.getResources().getDimensionPixelSize(resourceId);\n        }\n        return statusBarHeight;\n    }\n\n    private static int getStatusBarHeightMethod2(Context context){\n        return (int) Math.ceil(20 * context.getResources().getDisplayMetrics().density);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\npublic class TimeUtil {\n\n    private static final long SECONDS_ONE_HOUR = 60*60;\n\n    public static final String TIME_FORMAT_01 = \"%02d:%02d\";\n    public static final String TIME_FORMAT_02 = \"%02d:%02d:%02d\";\n\n    public static String getTimeFormat1(long timeMs){\n        return getTime(TIME_FORMAT_01, timeMs);\n    }\n\n    public static String getTimeFormat2(long timeMs){\n        return getTime(TIME_FORMAT_02, timeMs);\n    }\n\n    public static String getTimeSmartFormat(long timeMs){\n        int totalSeconds = (int) (timeMs / 1000);\n        if(totalSeconds >= SECONDS_ONE_HOUR){\n            return getTimeFormat2(timeMs);\n        }else{\n            return getTimeFormat1(timeMs);\n        }\n    }\n\n    public static String getFormat(long maxTimeMs){\n        int totalSeconds = (int) (maxTimeMs / 1000);\n        if(totalSeconds >= SECONDS_ONE_HOUR){\n            return TIME_FORMAT_02;\n        }\n        return TIME_FORMAT_01;\n    }\n\n    public static String getTime(String format, long time){\n        if(time <= 0)\n            time = 0;\n        int totalSeconds = (int) (time / 1000);\n        int seconds = totalSeconds % 60;\n        int minutes = (totalSeconds / 60) % 60;\n        int hours = totalSeconds / 3600;\n        if(TIME_FORMAT_01.equals(format)){\n            return String.format(format, minutes, seconds);\n        }else if(TIME_FORMAT_02.equals(format)){\n            return String.format(format, hours, minutes, seconds);\n        }\n        if(TextUtils.isEmpty(format)){\n            format = TIME_FORMAT_02;\n        }\n        return String.format(format, hours, minutes, seconds);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521313631},"updatedAt":{"$$date":1598522342369},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"anAt4vQzqNmzohl6"}
{"name":"kotlin-基本语法 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/basic-syntax.html\n基本语法 - Kotlin 语言中文站\n30-38 minutes\n改进翻译\n包的声明应处于源文件顶部：\n\npackage my.demo\n\nimport kotlin.text.*\n\n// ……\n目录与包的结构无需匹配：源代码可以在文件系统的任意位置。\n\n参见包。\n\nKotlin 应用程序的入口点是 main 函数。\n\nfun main() {\n    println(\"Hello world!\")\n}\n带有两个 Int 参数、返回 Int 的函数：\n\n//sampleStart\nfun sum(a: Int, b: Int): Int {\n    return a + b\n}\n//sampleEnd\n\nfun main() {\n    print(\"sum of 3 and 5 is \")\n    println(sum(3, 5))\n}\n将表达式作为函数体、返回值类型自动推断的函数：\n\n//sampleStart\nfun sum(a: Int, b: Int) = a + b\n//sampleEnd\n\nfun main() {\n    println(\"sum of 19 and 23 is ${sum(19, 23)}\")\n}\n函数返回无意义的值：\n\n//sampleStart\nfun printSum(a: Int, b: Int): Unit {\n    println(\"sum of $a and $b is ${a + b}\")\n}\n//sampleEnd\n\nfun main() {\n    printSum(-1, 8)\n}\nUnit 返回类型可以省略：\n\n//sampleStart\nfun printSum(a: Int, b: Int) {\n    println(\"sum of $a and $b is ${a + b}\")\n}\n//sampleEnd\n\nfun main() {\n    printSum(-1, 8)\n}\n参见函数。\n\n定义只读局部变量使用关键字 val 定义。只能为其赋值一次。\n\nfun main() {\n//sampleStart\n    val a: Int = 1  // 立即赋值\n    val b = 2   // 自动推断出 `Int` 类型\n    val c: Int  // 如果没有初始值类型不能省略\n    c = 3       // 明确赋值\n//sampleEnd\n    println(\"a = $a, b = $b, c = $c\")\n}\n可重新赋值的变量使用 var 关键字：\n\nfun main() {\n//sampleStart\n    var x = 5 // 自动推断出 `Int` 类型\n    x += 1\n//sampleEnd\n    println(\"x = $x\")\n}\n顶层变量：\n\n//sampleStart\nval PI = 3.14\nvar x = 0\n\nfun incrementX() { \n    x += 1 \n}\n//sampleEnd\n\nfun main() {\n    println(\"x = $x; PI = $PI\")\n    incrementX()\n    println(\"incrementX()\")\n    println(\"x = $x; PI = $PI\")\n}\n参见属性与字段。\n\n与大多数现代语言一样，Kotlin 支持单行（或行末）与多行（块）注释。\n\n// 这是一个行注释\n\n/* 这是一个多行的\n   块注释。 */\nKotlin 中的块注释可以嵌套。\n\n/* 注释从这里开始\n/* 包含嵌套的注释 */     \n并且在这里结束。 */\n参见编写 Kotlin 代码文档 查看关于文档注释语法的信息。\n\nfun main() {\n//sampleStart\n    var a = 1\n    // 模板中的简单名称：\n    val s1 = \"a is $a\" \n    \n    a = 2\n    // 模板中的任意表达式：\n    val s2 = \"${s1.replace(\"is\", \"was\")}, but now is $a\"\n//sampleEnd\n    println(s2)\n}\n参见字符串模板。\n\n//sampleStart\nfun maxOf(a: Int, b: Int): Int {\n    if (a > b) {\n        return a\n    } else {\n        return b\n    }\n}\n//sampleEnd\n\nfun main() {\n    println(\"max of 0 and 42 is ${maxOf(0, 42)}\")\n}\n在 Kotlin 中，if 也可以用作表达式：\n\n//sampleStart\nfun maxOf(a: Int, b: Int) = if (a > b) a else b\n//sampleEnd\n\nfun main() {\n    println(\"max of 0 and 42 is ${maxOf(0, 42)}\")\n}\n参见if 表达式。\n\n空值与 null 检测\n当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空。\n\n如果 str 的内容不是数字返回 null：\n\nfun parseInt(str: String): Int? {\n    // ……\n}\n使用返回可空值的函数:\n\nfun parseInt(str: String): Int? {\n    return str.toIntOrNull()\n}\n\n//sampleStart\nfun printProduct(arg1: String, arg2: String) {\n    val x = parseInt(arg1)\n    val y = parseInt(arg2)\n\n    // 直接使用 `x * y` 会导致编译错误，因为它们可能为 null\n    if (x != null && y != null) {\n        // 在空检测后，x 与 y 会自动转换为非空值（non-nullable）\n        println(x * y)\n    }\n    else {\n        println(\"'$arg1' or '$arg2' is not a number\")\n    }    \n}\n//sampleEnd\n\n\nfun main() {\n    printProduct(\"6\", \"7\")\n    printProduct(\"a\", \"7\")\n    printProduct(\"a\", \"b\")\n}\n或者\n\nfun parseInt(str: String): Int? {\n    return str.toIntOrNull()\n}\n\nfun printProduct(arg1: String, arg2: String) {\n    val x = parseInt(arg1)\n    val y = parseInt(arg2)\n    \n//sampleStart\n    // ……\n    if (x == null) {\n        println(\"Wrong number format in arg1: '$arg1'\")\n        return\n    }\n    if (y == null) {\n        println(\"Wrong number format in arg2: '$arg2'\")\n        return\n    }\n\n    // 在空检测后，x 与 y 会自动转换为非空值\n    println(x * y)\n//sampleEnd\n}\n\nfun main() {\n    printProduct(\"6\", \"7\")\n    printProduct(\"a\", \"7\")\n    printProduct(\"99\", \"b\")\n}\n参见空安全。\n\n类型检测与自动类型转换\nis 运算符检测一个表达式是否某类型的一个实例。 如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换：\n\n//sampleStart\nfun getStringLength(obj: Any): Int? {\n    if (obj is String) {\n        // `obj` 在该条件分支内自动转换成 `String`\n        return obj.length\n    }\n\n    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型\n    return null\n}\n//sampleEnd\n\n\nfun main() {\n    fun printLength(obj: Any) {\n        println(\"'$obj' string length is ${getStringLength(obj) ?: \"... err, not a string\"} \")\n    }\n    printLength(\"Incomprehensibilities\")\n    printLength(1000)\n    printLength(listOf(Any()))\n}\n或者\n\n//sampleStart\nfun getStringLength(obj: Any): Int? {\n    if (obj !is String) return null\n\n    // `obj` 在这一分支自动转换为 `String`\n    return obj.length\n}\n//sampleEnd\n\n\nfun main() {\n    fun printLength(obj: Any) {\n        println(\"'$obj' string length is ${getStringLength(obj) ?: \"... err, not a string\"} \")\n    }\n    printLength(\"Incomprehensibilities\")\n    printLength(1000)\n    printLength(listOf(Any()))\n}\n甚至\n\n//sampleStart\nfun getStringLength(obj: Any): Int? {\n    // `obj` 在 `&&` 右边自动转换成 `String` 类型\n    if (obj is String && obj.length > 0) {\n      return obj.length\n    }\n\n    return null\n}\n//sampleEnd\n\n\nfun main() {\n    fun printLength(obj: Any) {\n        println(\"'$obj' string length is ${getStringLength(obj) ?: \"... err, is empty or not a string at all\"} \")\n    }\n    printLength(\"Incomprehensibilities\")\n    printLength(\"\")\n    printLength(1000)\n}\n参见类以及类型转换。\n\nfun main() {\n//sampleStart\n    val items = listOf(\"apple\", \"banana\", \"kiwifruit\")\n    for (item in items) {\n        println(item)\n    }\n//sampleEnd\n}\n或者\n\nfun main() {\n//sampleStart\n    val items = listOf(\"apple\", \"banana\", \"kiwifruit\")\n    for (index in items.indices) {\n        println(\"item at $index is ${items[index]}\")\n    }\n//sampleEnd\n}\n参见 for 循环。\n\nfun main() {\n//sampleStart\n    val items = listOf(\"apple\", \"banana\", \"kiwifruit\")\n    var index = 0\n    while (index < items.size) {\n        println(\"item at $index is ${items[index]}\")\n        index++\n    }\n//sampleEnd\n}\n参见 while 循环。\n\n//sampleStart\nfun describe(obj: Any): String =\n    when (obj) {\n        1          -> \"One\"\n        \"Hello\"    -> \"Greeting\"\n        is Long    -> \"Long\"\n        !is String -> \"Not a string\"\n        else       -> \"Unknown\"\n    }\n//sampleEnd\n\nfun main() {\n    println(describe(1))\n    println(describe(\"Hello\"))\n    println(describe(1000L))\n    println(describe(2))\n    println(describe(\"other\"))\n}\n参见 when 表达式。\n\n使用 in 运算符来检测某个数字是否在指定区间内：\n\nfun main() {\n//sampleStart\n    val x = 10\n    val y = 9\n    if (x in 1..y+1) {\n        println(\"fits in range\")\n    }\n//sampleEnd\n}\n检测某个数字是否在指定区间外:\n\nfun main() {\n//sampleStart\n    val list = listOf(\"a\", \"b\", \"c\")\n    \n    if (-1 !in 0..list.lastIndex) {\n        println(\"-1 is out of range\")\n    }\n    if (list.size !in list.indices) {\n        println(\"list size is out of valid list indices range, too\")\n    }\n//sampleEnd\n}\n区间迭代:\n\nfun main() {\n//sampleStart\n    for (x in 1..5) {\n        print(x)\n    }\n//sampleEnd\n}\n或数列迭代：\n\nfun main() {\n//sampleStart\n    for (x in 1..10 step 2) {\n        print(x)\n    }\n    println()\n    for (x in 9 downTo 0 step 3) {\n        print(x)\n    }\n//sampleEnd\n}\n参见区间。\n\n对集合进行迭代:\n\nfun main() {\n    val items = listOf(\"apple\", \"banana\", \"kiwifruit\")\n//sampleStart\n    for (item in items) {\n        println(item)\n    }\n//sampleEnd\n}\n使用 in 运算符来判断集合内是否包含某实例：\n\nfun main() {\n    val items = setOf(\"apple\", \"banana\", \"kiwifruit\")\n//sampleStart\n    when {\n        \"orange\" in items -> println(\"juicy\")\n        \"apple\" in items -> println(\"apple is fine too\")\n    }\n//sampleEnd\n}\n使用 lambda 表达式来过滤（filter）与映射（map）集合：\n\nfun main() {\n//sampleStart\n    val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\")\n    fruits\n      .filter { it.startsWith(\"a\") }\n      .sortedBy { it }\n      .map { it.toUpperCase() }\n      .forEach { println(it) }\n//sampleEnd\n}\n参见集合概述。\n\nfun main() {\n//sampleStart\n    val rectangle = Rectangle(5.0, 2.0)\n    val triangle = Triangle(3.0, 4.0, 5.0)\n//sampleEnd\n    println(\"Area of rectangle is ${rectangle.calculateArea()}, its perimeter is ${rectangle.perimeter}\")\n    println(\"Area of triangle is ${triangle.calculateArea()}, its perimeter is ${triangle.perimeter}\")\n}\n\nabstract class Shape(val sides: List<Double>) {\n    val perimeter: Double get() = sides.sum()\n    abstract fun calculateArea(): Double\n}\n\ninterface RectangleProperties {\n    val isSquare: Boolean\n}\n\nclass Rectangle(\n    var height: Double,\n    var length: Double\n) : Shape(listOf(height, length, height, length)), RectangleProperties {\n    override val isSquare: Boolean get() = length == height\n    override fun calculateArea(): Double = height * length\n}\n\nclass Triangle(\n    var sideA: Double,\n    var sideB: Double,\n    var sideC: Double\n) : Shape(listOf(sideA, sideB, sideC)) {\n    override fun calculateArea(): Double {\n        val s = perimeter / 2\n        return Math.sqrt(s * (s - sideA) * (s - sideB) * (s - sideC))\n    }\n}\n参见类以及对象与实例。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304157492},"updatedAt":{"$$date":1597306061214},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"b1scXF7M7CPUDuK9"}
{"name":"轻课工程文档","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"轻课项目同步会议纪要 2月4日 09:30分\n一、规范：\n1. xml 布局变量声明 统一使用驼峰命名，\n\t例如： TextView 命名为：tvGetTokenInfo，ImageView 命名为： ivUserIcon\n2. AndroidStudio 统一添加代码格式化插件：Eclipse Code Formatter 和 Kotlin Code Sorter\n3. 代码注释\na. 类注释统一使用模板：\n/**\n***************************************\n* 项目名称:${PROJECT_NAME}\n* @Author username\n* 邮箱：username@ksjgs.com\n* 创建时间: ${DATE}     ${TIME}\n* 用途\n***************************************\n*/\na. 方法注释\n/**\n* 获取列表公用类型时间\n*\n* @param time 时间戳\n* @return 通用的时间显示格式\n* 返回示例：同一天， 08:34\n*          不同天， 05/12\n*          不同年， 2020/02/15 08:45\n*/\npublic static String getCommonItemTime(long time) {}\na. 全局静态常量注释\n/**\n* 测试环境\n*/\nprivate const val TEST_SERVER_URL = \"https://tapi.kaishustory.com\"\na. 规范代码中 行间剧的空格，例如下图中的空格应删除\nb. 减少waring数量\nc. 减少TODO数量\n4. xml 布局 注意适配平板或手机 大号字体\n二、项目现有组件及缺少组件的梳理\n• \t现有组件\n• 登录组件\n• 网络框架\n• 支付组件\n• 路由框架 （与ios 一起梳理路由跳转）\n• 待添加组件\n• 音频组件（包括短音频、和 长音频）\n• 视频播放组件\n• loading 视图、空view 加载视图，loading 错误（数据错误、网络错误）\n• recycleView item的多次点击过滤，button的多次点击\n• 图片库的选择？ fresco 和 Glide ， 图片圆角问题\nFresco\nGlide\n支持WebP\n不支持\n对Gif 支持的较好\nGIf的支持不好\n图片宽高必须固定\n图片宽高自适应\n代码耦合严重\n代码耦合小\n• 工具类 整理，并生成文档\n• 下载组件（中台提供下载路径 供选择）\n• 消息推送组件\n• 动画库 支持一些特效动画 例如：儿童锁\n• 打点组件库\n• Webview （有h5交互的，支持游戏的，只显示视图）\n• leakCaneray 监控内容泄漏\n• jetpack 中 哪些可以拿来使用的 例如：navigation\n• 自定义组件、UI通用组件\n• 沉浸式UI的支持\n• 弹窗添加统一管理manager，管理首页所有的弹窗 及弹窗顺序"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598548582669},"updatedAt":{"$$date":1598548724216},"_id":"b3BITRatpgYYo0C1","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977501879},"updatedAt":{"$$date":1594977501879},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bH7bL4r3r4eFTEsz"}
{"name":"Untitled snippet","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580864721},"updatedAt":{"$$date":1598580864721},"folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bLYEmHtT5vFBntwj"}
{"name":"py-空值","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。\n\n此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973927062},"updatedAt":{"$$date":1594974238383},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bPhh96qnfrGP3Abm"}
{"name":"html-HTML5 WebSocket","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\nHTML5 WebSocket\nWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。\n\nWebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。\n\n现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。\n\nHTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。\n\n\n\n浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。\n\n当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。\n\n以下 API 用于创建 WebSocket 对象。\n\nvar Socket = new WebSocket(url, [protocol] );\n以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。\n\nWebSocket 属性\n以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：\n\n属性\t描述\nSocket.readyState\t\n只读属性 readyState 表示连接状态，可以是以下值：\n\n0 - 表示连接尚未建立。\n\n1 - 表示连接已建立，可以进行通信。\n\n2 - 表示连接正在进行关闭。\n\n3 - 表示连接已经关闭或者连接不能打开。\n\nSocket.bufferedAmount\t\n只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。\n\nWebSocket 事件\n以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：\n\n事件\t事件处理程序\t描述\nopen\tSocket.onopen\t连接建立时触发\nmessage\tSocket.onmessage\t客户端接收服务端数据时触发\nerror\tSocket.onerror\t通信发生错误时触发\nclose\tSocket.onclose\t连接关闭时触发\nWebSocket 方法\n以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：\n\n方法\t描述\nSocket.send()\t\n使用连接发送数据\n\nSocket.close()\t\n关闭连接\n\nWebSocket 实例\nWebSocket 协议本质上是一个基于 TCP 的协议。\n\n为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息\"Upgrade: WebSocket\"表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。\n\n客户端的 HTML 和 JavaScript\n目前大部分浏览器支持 WebSocket() 接口，你可以在以下浏览器中尝试实例： Chrome, Mozilla, Opera 和 Safari。\n\nrunoob_websocket.html 文件内容\n\n<!DOCTYPE HTML>\n<html>\n   <head>\n   <meta charset=\"utf-8\">\n   <title>菜鸟教程(runoob.com)</title>\n    \n      <script type=\"text/javascript\">\n         function WebSocketTest()\n         {\n            if (\"WebSocket\" in window)\n            {\n               alert(\"您的浏览器支持 WebSocket!\");\n               \n               // 打开一个 web socket\n               var ws = new WebSocket(\"ws://localhost:9998/echo\");\n                \n               ws.onopen = function()\n               {\n                  // Web Socket 已连接上，使用 send() 方法发送数据\n                  ws.send(\"发送数据\");\n                  alert(\"数据发送中...\");\n               };\n                \n               ws.onmessage = function (evt) \n               { \n                  var received_msg = evt.data;\n                  alert(\"数据已接收...\");\n               };\n                \n               ws.onclose = function()\n               { \n                  // 关闭 websocket\n                  alert(\"连接已关闭...\"); \n               };\n            }\n            \n            else\n            {\n               // 浏览器不支持 WebSocket\n               alert(\"您的浏览器不支持 WebSocket!\");\n            }\n         }\n      </script>\n        \n   </head>\n   <body>\n   \n      <div id=\"sse\">\n         <a href=\"javascript:WebSocketTest()\">运行 WebSocket</a>\n      </div>\n      \n   </body>\n</html>\n安装 pywebsocket\n在执行以上程序前，我们需要创建一个支持 WebSocket 的服务。从 pywebsocket 下载 mod_pywebsocket ,或者使用 git 命令下载：\n\ngit clone https://github.com/google/pywebsocket.git\nmod_pywebsocket 需要 python 环境支持\n\nmod_pywebsocket 是一个 Apache HTTP 的 Web Socket扩展，安装步骤如下：\n解压下载的文件。\n\n进入 pywebsocket 目录。\n\n执行命令：\n\n$ python setup.py build\n$ sudo python setup.py install\n查看文档说明:\n\n$ pydoc mod_pywebsocket\n开启服务\n在 pywebsocket/mod_pywebsocket 目录下执行以下命令：\n\n$ sudo python standalone.py -p 9998 -w ../example/\n以上命令会开启一个端口号为 9998 的服务，使用 -w 来设置处理程序 echo_wsh.py 所在的目录。\n\n现在我们可以在 Chrome 浏览器打开前面创建的 runoob_websocket.html 文件。如果你的浏览器支持 WebSocket(), 点击\"运行 WebSocket\"，你就可以看到整个流程各个步骤弹出的窗口，流程 Gif 演示：\n\n\n\n在我们停止服务后，会弹出 \"连接已关闭...\"。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887694889},"updatedAt":{"$$date":1598888178225},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bRDmgKR795N1ainQ"}
{"name":"andr-应用权限最佳做法","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/permissions/usage-notes\n应用权限最佳做法  |  Android 开发者  |  Android Developers\n8-9 minutes\n权限请求可以保护设备中的敏感信息，仅当需要访问敏感信息才能使应用正常运行时，才应使用权限请求。利用本文档介绍的技巧，您无需访问此类信息即可实现相同（或更好的）功能；但本文不会详细讨论权限在 Android 操作系统中的工作方式。\n\n如需大致了解 Android 权限，请参阅权限概览。如需详细了解如何在代码中使用权限，请参阅请求应用权限。\n\n使用 Android 权限的原则\n使用 Android 权限时，我们建议遵循以下原则：\n\n1：仅使用应用正常工作所需的权限。根据您使用权限的方式，您可以通过其他方式执行所需的操作（系统 intent、标识符、电话后台处理），而无需依赖于访问敏感信息。\n\n2：注意库所需的权限。添加某个库时，您也会继承它的权限要求。您应了解您正在添加的库、它们需要的权限以及这些权限的用途。\n\n3：公开透明。请求权限时，请清晰说明您要访问的内容以及访问原因，以便用户可以做出明智的决策。在请求权限时（包括安装、运行时或更新权限对话框）提供这些信息。\n\n4：以显式方式访问系统。在访问敏感功能（例如，相机或麦克风）时提供连续指示，让用户知道您在收集数据，避免让他们认为您在偷偷地收集数据。\n\n本指南其余部分将以开发 Android 应用为背景详细介绍这些规则。\n\nAndroid 6.0 及更高版本中的权限\nAndroid 6.0 Marshmallow 引入了一种新的权限模式，让应用可以在运行时而不是安装之前向用户请求权限。支持这个新模式的应用会在应用确实需要相关服务或这些服务保护的数据时请求权限。尽管这不会（不一定会）改变整体应用行为，但会给敏感用户数据的处理方式带来一些变化：\n\n增加了情境背景信息：系统会在运行时在应用的情境中，提示用户提供访问相关权限组涵盖的功能所需的权限。用户对请求权限的情境更加敏感，如果您请求的权限与应用的用途不匹配，那么更需要向用户详细解释您为什么请求此权限；您应尽可能在请求时以及万一用户拒绝请求后出现的后续对话框中解释您的请求。\n\n在授予权限时更加灵活：用户可以在收到请求时以及在设置中拒绝单个权限，但是当功能因此而中断时，他们可能仍会感到惊讶。最好监控有多少用户拒绝权限请求，例如使用 Google Analytics（分析）进行监控，以便重构应用以避免依赖该权限，或更好地解释应用需要此权限才能正常工作的原因。您还应确保应用可以处理当用户拒绝权限请求或在设置中停用权限时产生的异常。\n\n增加了事务负担：系统将要求用户单独授予权限组的访问权限，而不是以集合的形式授予。这样，最大程度降低请求的权限数量就变得非常重要，因为数量多会增加用户授予权限的负担，并且会增大至少有一个请求被拒绝的概率。\n\n需要成为默认处理程序的权限\n有些应用依赖于访问与调用日志和短信有关的敏感用户信息。如果您想请求特定于通话记录和短信的权限，并将应用发布到 Play 商店，则必须在请求这些运行时权限之前，提示用户将应用设置为默认处理程序以获得核心系统功能。\n\n如需详细了解默认处理程序，包括有关如何向用户显示默认处理程序提示的指南，请参阅有关仅在默认处理程序中使用的权限的指南。\n\n避免请求不必要的权限\n每次您请求某个权限时，都是在强迫用户做出决定。应尽量减少提出这些请求的次数。如果用户运行的是 Android 6.0（API 级别 23）或更高版本，则每次用户尝试要求提供权限的新应用功能时，应用都必须中断用户的操作并发起权限请求。如果用户运行的是更低版本的 Android，则在安装应用时需要授予应用每一项权限；如果权限列表过长或看起来不合适，用户可能会决定不安装该应用。因此，应尽量减少应用需要的权限数量。\n\n本部分提供了常见用例的替代方法，有助于降低提出权限请求的次数。与其他请求较少权限的类似应用相比，向用户请求更多数量和类型的权限会影响下载量，因此最好避免为不必要的功能请求权限。\n\n改用 intent\n在许多情况下，要让应用执行某项任务，有两种方法供您选择。应用可以要求提供权限以自行执行该任务，也可以使用 intent 让其他应用执行该任务。\n\n例如，假设应用需要使用设备摄像头拍摄照片。应用可以请求 CAMERA 权限，从而直接访问摄像头。然后，应用将使用 Camera API 控制摄像头并拍摄照片。此方法使应用能够完全控制拍摄过程，并且您可以将摄像头界面整合到应用中。\n\n不过，如果您很少需要访问用户数据，换句话说，每次您需要访问数据时都向用户显示运行时对话框，这种中断操作并非不可接受，那么您可以使用基于 intent 的请求。Android 提供了一些系统 intent，应用可使用这些 intent 而无需请求权限，因为在发出基于 intent 的请求时用户会选择与应用共享的内容（如果有）。\n\n例如，您可以使用 MediaStore.ACTION_IMAGE_CAPTURE 或 MediaStore.ACTION_VIDEO_CAPTURE intent 操作类型拍摄图像或视频，无需直接使用 Camera 对象（或请求权限）。在这种情况下，每次拍摄图像时，系统 intent 都会代表您请求用户提供权限。\n\n同样，如果您需要拨打电话、访问用户的联系人或执行其他操作，可以通过创建适当的 intent 完成，也可以直接请求权限并访问相应的对象。每种方法各有优缺点。\n\n如果使用权限：\n\n当应用执行操作时，应用可以完全控制用户体验。不过，如此广泛的控制会增加代码的复杂性，因为您需要设计适当的界面。\n系统会在运行时或安装时（具体取决于用户的 Android 版本）提示用户授予权限一次。之后，应用即可执行操作，不再需要用户进行其他互动。不过，如果用户未授予权限（或之后撤消权限），则应用根本无法执行该操作。\n如果使用 intent：\n\n您不必为操作设计界面。处理 intent 的应用将提供界面。\n用户可以使用他们首选的应用执行任务。例如，用户可以选择用他们喜爱的照片应用拍照。\n如果用户没有执行相应操作的默认应用，则系统会提示用户选择应用。如果用户未指定默认处理程序，则必须在每次执行此操作时都要额外处理一个对话框。\n不要让用户感到无所适从\n如果用户运行的是 Android 6.0（API 级别 23）或更高版本，则用户必须在运行应用时为其授予权限。如果您让用户一次面对大量权限请求，用户可能会感到无所适从并因此退出应用。替代做法是，您应根据需要请求权限。\n\n在某些情况下，一项或几项权限可能对您的应用来说必不可少。在这种情况下，合理的做法是，在应用启动之后立即请求所有这些权限。例如，如果您创建的是摄影应用，则该应用将需要访问设备的摄像头。当用户首次启动该应用时，系统会要求他们提供摄像头使用权限，这不会令他们感到惊讶。 但是，如果同一应用还具备与用户联系人分享照片的功能，则您最好不要在应用首次启动时就要求用户提供 READ_CONTACTS 权限，而应等到用户尝试使用“分享”功能之后再请求该权限。\n\n如果应用提供教程，则合理的做法是，在教程结束时请求提供应用的必要权限。\n\n失去音频焦点后暂停媒体\n在这种情况下，用户接到电话时您的应用需要转入后台，只有在通话停止后才会重新获得焦点。\n\n对于此类情况，例如，媒体播放器在手机通话期间静音或暂停，通常采用的方法是使用 PhoneStateListener 监听通话状态有无变化或监听 android.intent.action.PHONE_STATE 的广播。这种解决方案的问题是它需要 READ_PHONE_STATE 权限，这将强制用户授予对各种敏感数据的访问权限，如用户的设备和 SIM 硬件 ID 以及来电的电话号码。此外，当应用在 Android 10（API 级别 29）或更高版本上运行时，LISTEN_CELL_LOCATION 和 LISTEN_CELL_INFO 事件需要位置权限（具体而言，当应用以 Android 10 或更高版本为目标平台时将需要 ACCESS_FINE_LOCATION）。\n\n您可以通过为应用请求 AudioFocus，在没有 READ_PHONE_STATE 或 MODIFY_PHONE_STATE 权限的情况下检测用户是否在通话中，这么做不需要显式权限（因为不访问敏感信息）。只需将让音频在后台运行所需的代码放入 onAudioFocusChange() 事件处理程序，当操作系统切换其音频焦点时，该代码将自动运行。如需详细了解如何执行此操作，请参阅此文档。\n\n确定正在运行实例的设备\n在这种情况下，您需要一个唯一标识符来确定应用实例正在哪个设备上运行。\n\n应用可能具有设备特定的偏好设置或消息，例如，在云端为用户保存设备特定的播放列表，以便他们在车上和家里可以有不同的播放列表。常见的解决方案是利用设备标识符（如 Device IMEI），但这需要 Device ID and call information 权限组（在搭载 M 及更高版本的设备中为 PHONE）。它还使用一个无法重置且在所有应用之间共享的标识符。\n\n下面两种方法可以替代这些类型的标识符：\n\n使用 com.google.android.gms.iid InstanceID API。 getInstance(Context context).getID() 将为您的应用实例返回一个唯一设备标识符。结果是一个应用实例范围标识符，在存储与应用有关的信息时可以将该标识符用作密钥，在用户重新安装应用时该标识符将重置。\n使用 randomUUID() 之类的基本系统函数创建您自己的标识符，其范围限定为应用的存储空间。\n为广告或用户分析创建唯一标识符\n在这种情况下，您需要使用一个唯一标识符为没有登录应用的用户构建个人资料（例如，用于广告定位或衡量转化率）。\n\n为广告和用户分析构建个人资料有时需要一个在其他应用之间共享的标识符。此问题的常见解决方法包括有效利用设备标识符（例如 Device IMEI），设备标识符需要 Device ID and call information 权限组（在 API 级别 23 及更高级别中为 PHONE），并且无法由用户重置。如果出现上述任何情况，除了使用不可重置的标识符并请求用户可能认为不寻常的权限外，还会违反 Play 开发者计划政策。\n\n遗憾的是，由于 ID 可能需要在各个应用中共享，在这些情况下使用 com.google.android.gms.iid InstanceID API 或系统函数创建应用作用域 ID 并不是适当的解决方法。一种替代解决方法是使用通过 getId() 方法从 AdvertisingIdClient.Info 类中获取的 Advertising Identifier。您可以使用 getAdvertisingIdInfo(Context) 方法创建一个 AdvertisingIdClient.Info 对象，并调用 getId() 方法以使用标识符。请注意，此方法会造成堵塞，因此，您不应从主线程调用它；有关此方法的详细说明，请点击此处。\n\n了解您正在使用的库\n有时，您在应用中使用的库需要权限。例如，广告和分析库可能需要访问 LOCATION 权限组以实现必需的功能。但从用户的角度来看，权限请求来自于您的应用，而不是库。\n\n就像用户会选择使用较少权限即可实现相同功能的应用一样，开发者也应检查他们的库，并选择不会使用非必要权限的第三方 SDK。例如，如果您使用的库提供了定位功能，请确保您不会请求 FINE_LOCATION 权限，除非您要使用基于位置的定位功能。\n\n限制对位置信息的后台使用权\n当您的应用在后台运行时，访问位置信息应该对应用的核心功能至关重要，并为用户带来明显的好处。\n\n解释为何需要权限\n系统在您调用 requestPermissions() 时显示的权限对话框将说明应用需要哪些权限，但不会解释为何需要这些权限。在某些情况下，用户可能会感到困惑。因此，最好在调用 requestPermissions() 之前向用户解释应用需要相应权限的原因。\n\n研究表明，如果用户知道应用需要相应权限的原因，他们会更容易接受权限请求。用户研究表明：\n\n用户是否愿意为某个移动应用授予给定权限，在很大程度上受此类权限关联用途的影响。例如，用户是否愿意授予访问其位置的访问权限取决于该权限请求是否为支持应用的核心功能所必需，或者应用是否会与广告网络或分析公司分享此信息。1\n\n卡内基梅隆大学 (CMU) 的 Jason Hong 教授根据他所带领的小组的研究成果得出一个一般结论：\n\n...与只是告诉用户应用正在使用其位置信息相比，如果用户知道应用为什么使用像他们的位置这样敏感的信息（例如，用于定向广告），用户会更容易接受。1\n\n因此，如果您仅使用归入权限组的一小部分 API 调用，明确列出您使用哪些权限以及使用原因会非常有用。例如：\n\n如果您仅使用粗略位置，请在应用说明或应用帮助文档中告知用户。\n如果您需要访问短信以接收身份验证码，从而防止用户被欺诈，请在应用说明中和/或首次访问数据时告知用户。\n\n注意：如果应用面向 Android 8.0（API 级别 26）或更高版本，请不要在验证用户凭据过程中请求 READ_SMS 权限，而应使用 createAppSpecificSmsToken() 生成应用特定的令牌，然后将此令牌传递给可以发送验证短信的其他应用或服务。\n\n在特定条件下，让用户实时了解应用在访问敏感数据也是非常有益的。例如，如果您要访问相机或麦克风，通常最好在应用中的某个位置或在通知托盘中（如果应用正在后台运行）使用通知图标通知用户，从而不会让您看上去是在偷偷地收集数据。\n\n最后，如果您需要请求权限以便在应用中运行某项功能，但用户不清楚原因，则需要找到一种方法让用户知道您为什么需要最敏感的权限。\n\n测试两种权限模型\n从 Android 6.0（API 级别 23）开始，用户将在运行时授予和撤消应用权限，而不是在安装应用时授予和撤消应用权限。因此，您必须在更广泛的条件下测试应用。在低于 Android 6.0 的版本中，您可以合理地认为，如果应用能运行，它就已经获得在应用清单中声明的全部权限。自 Android 6.0 起，用户可以开启或关闭任何应用的权限，即使面向 API 级别 22 或更低级别的应用也是如此。您应测试以确保您的应用能正常运行，无论它是否具有任何权限。\n\n以下提示可帮助您在搭载 API 级别 23 或更高级别的设备上找出与权限有关的代码问题：\n\n确定应用的当前权限和相关的代码路径。\n在各种受权限保护的服务和数据中测试用户流。\n使用授予或撤消权限的各种组合进行测试。例如，相机应用可能会在清单中列出 CAMERA、READ_CONTACTS 和 ACCESS_FINE_LOCATION。您应在测试该应用时逐一开启和关闭这些权限，确保应用可以妥善处理所有权限配置。\n使用 adb 工具从命令行管理权限：\n按组列出权限和状态：\n$ adb shell pm list permissions -d -g\n授予或撤消一项或多项权限：\n$ adb shell pm [grant|revoke] <permission-name> ...\n针对使用权限的服务对应用进行分析。\n其他资源\nAndroid 权限的 Material Design 准则\nAndroid Marshmallow 6.0：请求权限 - 此视频介绍了 Android 运行时权限模式以及请求用户提供权限的正确方法。\n解释为什么应用需要权限\n唯一标识符最佳做法\n参考\n[1] Modeling Users’ Mobile App Privacy Preferences: Restoring Usability in a Sea of Permission Settings，作者：J. Lin B. Liu、N. Sadeh 和 J. Hong。发表于 2014 年 SOUPS 会议记录。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242657709},"updatedAt":{"$$date":1597243512187},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bSU4kn5xx529kO0k"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980165074},"updatedAt":{"$$date":1594980165074},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bSw3Z8Ew5wjZaP3n"}
{"name":"andr-与其他 Fragment 通信 ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/basics/fragments/communicating\n与其他 Fragment 通信  |  Android 开发者  |  Android Developers\n7-9 minutes\n为了重复使用 Fragment 界面组件，您应将每个组件构建为一个完全独立的模块化组件，定义它自己的布局和行为。定义这些可重用的 Fragment 后，您可以将它们与 Activity 相关联，并将其与应用逻辑相关联以实现整个复合界面。\n\n您经常需要一个 Fragment 与另一个 Fragment 通信，比如为了根据用户事件更改内容。所有 Fragment 到 Fragment 的通信都是通过共享的 ViewModel 或关联的 Activity 来完成的。两个 Fragment 绝不能直接通信。\n\n如需在 Fragment 之间通信，建议创建一个共享的 ViewModel 对象。两个 Fragment 都可以通过所在的 Activity 访问 ViewModel。Fragment 可在 ViewModel 内更新数据，如果使用 LiveData 公开该数据，新状态会被推送至其他 Fragment（只要它正在从 ViewModel 观察 LiveData）。要了解如何实现这种通信机制，请参阅 ViewModel 指南中的“在 Fragment 之间共享数据”部分。\n\n如果无法使用共享的 ViewModel 在 Fragment 之间进行通信，可以使用接口手动实现通信机制。但是，这种方式最终需要实现更多的工作，并且无法在其他 Fragment 中轻松重用。\n\n定义接口\n要允许 Fragment 与其 Activity 进行通信，可以在 Fragment 类中定义接口并在 Activity 中实现该接口。Fragment 在其 onAttach() 生命周期方法中捕获接口实现，然后可以调用接口方法，以便与 Activity 通信。\n\n以下是 Fragment 到 Activity 通信的示例：\n\nHeadlinesFragment\n\n    class HeadlinesFragment : ListFragment() {\n        internal var callback: OnHeadlineSelectedListenerfun setOnHeadlineSelectedListener(callback: OnHeadlineSelectedListener) {\n            this.callback = callback\n        }// This interface can be implemented by the Activity, parent Fragment,\n        // or a separate test implementation.\n        interface OnHeadlineSelectedListener {\n            fun onArticleSelected(position: Int)\n        }// ...\n    }\n    \n    public class HeadlinesFragment extends ListFragment {\n        OnHeadlineSelectedListener callback;public void setOnHeadlineSelectedListener(OnHeadlineSelectedListener callback) {\n            this.callback = callback;\n        }// This interface can be implemented by the Activity, parent Fragment,\n        // or a separate test implementation.\n        public interface OnHeadlineSelectedListener {\n            public void onArticleSelected(int position);\n        }// ...\n    }\n    \nMainActivity\n\n    class MainActivity : Activity(), HeadlinesFragment.OnHeadlineSelectedListener {\n        // ...fun onAttachFragment(fragment: Fragment) {\n            if (fragment is HeadlinesFragment) {\n                fragment.setOnHeadlineSelectedListener(this)\n            }\n        }\n    }\n    \n    public static class MainActivity extends Activity\n            implements HeadlinesFragment.OnHeadlineSelectedListener{\n        // ...@Override\n        public void onAttachFragment(Fragment fragment) {\n            if (fragment instanceof HeadlinesFragment) {\n                HeadlinesFragment headlinesFragment = (HeadlinesFragment) fragment;\n                headlinesFragment.setOnHeadlineSelectedListener(this);\n            }\n        }\n    }\n    \n现在，Fragment 可以使用 OnHeadlineSelectedListener 接口的 mCallback 实例调用 onArticleSelected() 方法（或接口中的其他方法），从而向 Activity 传递消息。\n\n例如，当用户点击列表项时，系统会调用 Fragment 中的以下方法。Fragment 使用回调接口将事件传递给父 Activity。\n\n    override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) {\n        // Send the event to the host activity\n        callback.onArticleSelected(position)\n    }\n    \n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Send the event to the host activity\n        callback.onArticleSelected(position);\n    }\n    \n实现接口\n要从 Fragment 接收事件回调，托管它的 Activity 必须实现 Fragment 类中定义的接口。\n\n例如，以下 Activity 将实现上述示例中的接口。\n\n    class MainActivity : Activity(), HeadlinesFragment.OnHeadlineSelectedListener {\n        ...fun onArticleSelected(position: Int) {\n            // The user selected the headline of an article from the HeadlinesFragment\n            // Do something here to display that article\n        }\n    }\n    \n    public static class MainActivity extends Activity\n            implements HeadlinesFragment.OnHeadlineSelectedListener{\n        ...public void onArticleSelected(int position) {\n            // The user selected the headline of an article from the HeadlinesFragment\n            // Do something here to display that article\n        }\n    }\n    \n将消息传递到 Fragment\n托管 Activity 可通过使用 findFragmentById() 捕获 Fragment 实例，将消息传递到 Fragment，然后直接调用 Fragment 的公共方法。\n\n例如，假设上方所示的 Activity 可能包含另一个 Fragment，该 Fragment 用于显示由上述回调方法中返回的数据指定的项。在这种情况下，Activity 可以将回调方法中收到的信息传递给显示该项的另一个 Fragment：\n\n    class MainActivity : Activity(), HeadlinesFragment.OnHeadlineSelectedListener {\n        ...fun onArticleSelected(position: Int) {\n            // The user selected the headline of an article from the HeadlinesFragment\n            // Do something here to display that articleval articleFrag = supportFragmentManager.findFragmentById(R.id.article_fragment) as ArticleFragment?if (articleFrag != null) {\n                // If article frag is available, we're in two-pane layout...// Call a method in the ArticleFragment to update its content\n                articleFrag.updateArticleView(position)\n            } else {\n                // Otherwise, we're in the one-pane layout and must swap frags...\n                // Create fragment and give it an argument for the selected article\n                val newFragment = ArticleFragment()\n                val args = Bundle()\n                args.putInt(ArticleFragment.ARG_POSITION, position)\n                newFragment.arguments = argsval transaction = supportFragmentManager.beginTransaction()// Replace whatever is in the fragment_container view with this fragment,\n                // and add the transaction to the back stack so the user can navigate back\n                transaction.replace(R.id.fragment_container, newFragment)\n                transaction.addToBackStack(null)// Commit the transaction\n                transaction.commit()\n            }\n        }\n    }\n    \n    public static class MainActivity extends Activity\n            implements HeadlinesFragment.OnHeadlineSelectedListener{\n        ...public void onArticleSelected(int position) {\n            // The user selected the headline of an article from the HeadlinesFragment\n            // Do something here to display that articleArticleFragment articleFrag = (ArticleFragment)\n                    getSupportFragmentManager().findFragmentById(R.id.article_fragment);if (articleFrag != null) {\n                // If article frag is available, we're in two-pane layout...// Call a method in the ArticleFragment to update its content\n                articleFrag.updateArticleView(position);\n            } else {\n                // Otherwise, we're in the one-pane layout and must swap frags...// Create fragment and give it an argument for the selected article\n                ArticleFragment newFragment = new ArticleFragment();\n                Bundle args = new Bundle();\n                args.putInt(ArticleFragment.ARG_POSITION, position);\n                newFragment.setArguments(args);FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,\n                // and add the transaction to the back stack so the user can navigate back\n                transaction.replace(R.id.fragment_container, newFragment);\n                transaction.addToBackStack(null);// Commit the transaction\n                transaction.commit();\n            }\n        }\n    }\n    \n要详细了解如何实现 Fragment，请参阅 Fragment。 您还可以浏览相关示例应用了解详情。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243446745},"updatedAt":{"$$date":1597243931427},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bVPgc5Itbj0XOAoR"}
{"name":"html-HTML 元素","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\nHTML 元素\nHTML 文档由 HTML 元素定义。\n\nHTML 元素\n开始标签 *\t元素内容\t结束标签 *\n<p>\t这是一个段落\t</p>\n<a href=\"default.htm\">\t这是一个链接\t</a>\n<br>\t换行\t \n*开始标签常被称为起始标签（opening tag），结束标签常称为闭合标签（closing tag）。\n\nHTML 元素语法\nHTML 元素以开始标签起始\nHTML 元素以结束标签终止\n元素的内容是开始标签与结束标签之间的内容\n某些 HTML 元素具有空内容（empty content）\n空元素在开始标签中进行关闭（以开始标签的结束而结束）\n大多数 HTML 元素可拥有属性\n注释: 您将在本教程的下一章中学习更多有关属性的内容。\n\n嵌套的 HTML 元素\n大多数 HTML 元素可以嵌套（HTML 元素可以包含其他 HTML 元素）。\n\nHTML 文档由相互嵌套的 HTML 元素构成。\n\nHTML 文档实例\n<!DOCTYPE html>\n<html>\n\n<body>\n<p>这是第一个段落。</p>\n</body>\n\n</html>\n以上实例包含了三个 HTML 元素。\n\nHTML 实例解析\n<p> 元素:\n\n<p>这是第一个段落。</p>\n这个 <p> 元素定义了 HTML 文档中的一个段落。\n这个元素拥有一个开始标签 <p> 以及一个结束标签 </p>.\n元素内容是: 这是第一个段落。\n\n<body> 元素:\n\n<body>\n<p>这是第一个段落。</p>\n</body>\n<body> 元素定义了 HTML 文档的主体。\n这个元素拥有一个开始标签 <body> 以及一个结束标签 </body>。\n元素内容是另一个 HTML 元素（p 元素）。\n\n<html> 元素：\n\n<html>\n\n<body>\n<p>这是第一个段落。</p>\n</body>\n\n</html>\n<html> 元素定义了整个 HTML 文档。\n这个元素拥有一个开始标签 <html> ，以及一个结束标签 </html>.\n元素内容是另一个 HTML 元素（body 元素）。\n\n不要忘记结束标签\n即使您忘记了使用结束标签，大多数浏览器也会正确地显示 HTML：\n\n<p>这是一个段落\n<p>这是一个段落\n以上实例在浏览器中也能正常显示，因为关闭标签是可选的。\n\n但不要依赖这种做法。忘记使用结束标签会产生不可预料的结果或错误。\n\nHTML 空元素\n没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。\n\n<br> 就是没有关闭标签的空元素（<br> 标签定义换行）。\n\n在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。\n\n在开始标签中添加斜杠，比如 <br />，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。\n\n即使 <br> 在所有浏览器中都是有效的，但使用 <br /> 其实是更长远的保障。\n\nHTML 提示：使用小写标签\nHTML 标签对大小写不敏感：<P> 等同于 <p>。许多网站都使用大写的 HTML 标签。\n\n菜鸟教程使用的是小写标签，因为万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写。\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885693086},"updatedAt":{"$$date":1598885908947},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ba1n7WPTlFflUQ7B"}
{"name":"ad-ksmagicindicator","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\n\nandroid {\n  compileSdkVersion build_versions.compile_sdk\n  buildToolsVersion build_versions.tool_version\n\n  defaultConfig {\n      minSdkVersion build_versions.min_sdk\n      targetSdkVersion build_versions.target_sdk\n      versionCode 1\n      versionName \"1.0\"\n  }\n\n  buildTypes {\n    release {\n      minifyEnabled false\n      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n    }\n  }\n\n    lintOptions {\n        abortOnError false\n    }\n\n}\n\ndependencies {\n  implementation fileTree(dir: 'libs', include: ['*.jar'])\n  implementation deps.androidx.app_compat\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\nBezierPagerIndicator\nLinePagerIndicator\nTestPagerIndicator\nTriangularPagerIndicator\nWrapPagerIndicator\n\n\n\n\n\n\n\n\npublic class ViewPagerHelper {\n    public static void bind(final MagicIndicator magicIndicator, ViewPager viewPager) {\n        viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {\n\n            @Override\n            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n                magicIndicator.onPageScrolled(position, positionOffset, positionOffsetPixels);\n            }\n\n            @Override\n            public void onPageSelected(int position) {\n                magicIndicator.onPageSelected(position);\n            }\n\n            @Override\n            public void onPageScrollStateChanged(int state) {\n                magicIndicator.onPageScrollStateChanged(state);\n            }\n        });\n    }\n}\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521309427},"updatedAt":{"$$date":1598522101830},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bagQoSdXSXbA1FCF"}
{"name":"kotlin-SoundPoolUtil","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\npackage com.ks\n\nimport android.content.Context\nimport android.media.AudioManager\nimport android.media.SoundPool\nimport android.util.Log\nimport com.ks.component.ui.R\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author lulong\n * 邮箱：lulong@ksjgs.com\n * 创建时间: 2020-03-20     11:28\n * 用途\n ***************************************\n\n */\nclass SoundPoolUtil private constructor(context: Context){\n\n    private var soundPool: SoundPool? = null\n    init {\n        soundPool = SoundPool(3, AudioManager.STREAM_SYSTEM, 0)\n        soundPool!!.load(context, R.raw.clickmusic, 1)\n    }\n\n    companion object {\n        @Volatile private var instance: SoundPoolUtil? = null\n        fun getInstance(context: Context) =\n                instance ?: synchronized(this) {\n                    instance ?: SoundPoolUtil(context).also { instance = it }\n                }\n    }\n\n\n\n\n    fun play(number: Int) {\n        Log.d(\"tag\", \"number $number\")\n        soundPool!!.play(number, 1f, 1f, 0, 0, 1f)\n    }\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403212016},"updatedAt":{"$$date":1597404210771},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bcETpk7Av74u9dTv"}
{"name":"ad-kaishu依赖库","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\noppoReleaseUnitTestRuntimeClasspath - Dependencies for runtime/packaging\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_main_center/libs/du.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_main_center/libs/msa_mdid_1.0.13.aar\n+--- :ks_login_center (variant: release)\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_login_center/libs/GetuiSDK-support-HWP-PLUGIN-1.0.5.jar\n+--- :ks_home_center (variant: release)\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_home_center/libs/Msc.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_home_center/libs/android_audioPlayer.jar\n+--- :ks_course_center (variant: release)\n+--- :ks_mine_center (variant: release)\n+--- :ks_game_center (variant: release)\n+--- :ks_member_center (variant: release)\n+--- :ks_message_center (variant: release)\n+--- :ks_selfbuildecommerce_center (variant: release)\n+--- :ks_storymachine_center (variant: release)\n+--- :ks_payment_center (variant: release)\n+--- :ks_audio_player (variant: release)\n+--- :ks_live_video_center (variant: release)\n+--- :ks_base (variant: release)\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/umeng-share-QQ-simplify-6.9.8.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/protobuf-java-2.6.1.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/umeng-shareboard-widget-6.9.8.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/umeng-analytics-9.0.2.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/umeng-sharetool-6.9.8.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/umeng-share-sina-simplify-6.9.8.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/jglogin807_ks.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/umeng-share-core-6.9.8.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/pinyin4j-2.5.0.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/ks_base/libs/umeng-share-wechat-simplify-6.9.8.jar\n+--- org.aspectj:aspectjrt:1.9.5@jar\n+--- :ks_point_upload (variant: release)\n+--- com.ks.ksutils:ksutils:0.0.3@aar\n+--- com.ks.ksui:ksui:0.0.2@aar\n+--- com.ks.ksurirouter:ksurirouter:0.1.0@aar\n+--- com.ks.ksinit:ksinit:0.0.2@aar\n+--- com.ks.kswebview:kswebview:0.0.4@aar\n+--- :sobotsdk (variant: release)\n+--- /Users/yanglc/kaishuNNN/kaishustory/sobotsdk/libs/sobot_sdk_x_lib_2.8.5.jar\n+--- :ks_image_select (variant: release)\n+--- :ks_permissionrx (variant: release)\n+--- :ks_lib_down_course (variant: release)\n+--- :ks_provide_center (variant: release)\n+--- :libmedia (variant: release)\n+--- /Users/yanglc/kaishuNNN/kaishustory/libmedia/libs/ffmpeg-compress-video.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/libmedia/libs/mediacodec_compress_video.jar\n+--- /Users/yanglc/kaishuNNN/kaishustory/libmedia/libs/isoparser-1.0.6.jar\n+--- :lib_base (variant: release)\n+--- :ks_base_res (variant: release)\n+--- com.ks.kotlin:ks_component_theforcesystem:0.0.13.5@aar\n+--- com.ks.ksktxsupport:ktxsupport:0.0.1@aar\n+--- com.ks.kscityselector:kscityselector:0.0.2@aar\n+--- com.ks.kotlin:ks-component-net:1.2.0@aar\n+--- com.ks.ksbottomnavigationbar:bottomnavigationbar:0.0.1@aar\n+--- com.ks.ksflycotablayout:flytablayout:0.0.1@aar\n+--- com.ks.ksloadpic:ksloadpic:0.0.2@aar\n+--- com.ks.ksdiskframe:ksdiskframe:0.0.6@aar\n+--- com.ks.kotlin:ks-lib-net:1.0.7.9@aar\n+--- org.jetbrains.kotlin:kotlin-android-extensions-runtime:1.3.72@jar\n+--- cn.finalteam:toolsfinal:1.1.5@aar\n+--- cn.jiguang.sdk:jmlink:1.1.0@aar\n+--- com.growingio.android:vds-android-agent:autotrack-2.8.13@aar\n+--- com.ks.ksliulishuodownload:liulishuodownload:0.0.1@aar\n+--- junit:junit:4.12@jar\n+--- com.ks.baseRecyclerViewAdapterHelper:baseRecyclerViewAdapterHelper:0.0.11@aar\n+--- com.github.yyued:SVGAPlayer-Android:2.5.3@aar\n+--- org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.3.72@jar\n+--- org.jetbrains.kotlin:kotlin-reflect:1.3.72@jar\n+--- androidx.core:core-ktx:1.1.0@aar\n+--- org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.3@jar\n+--- org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.3@jar\n+--- org.jetbrains.kotlin:kotlin-stdlib:1.3.72@jar\n+--- com.ks.ksautosizebybd:ksautosizebybd:0.0.1@aar\n+--- com.ks.ksdialogplus:ksdialogplus:0.0.2@aar\n+--- com.ks.ksconvenientbanner:ksconvenientbanner:0.0.1@aar\n+--- com.xiaomi.account:oauth-android:2.0.10@aar\n+--- com.ks.reactnative:ks-rn-story-center-androidx-debug:0.0.27@aar\n+--- com.ks.reactnative:react-native-screens:1.0.2@aar\n+--- com.ks.ksxtablayout:xtablayout:0.0.1@aar\n+--- com.google.android.material:material:1.1.0@aar\n+--- com.github.1002326270xc:LayoutManager-FlowLayout:v1.8@aar\n+--- androidx.viewpager2:viewpager2:1.0.0@aar\n+--- com.ks.reactnative:ks-rn-loading-view:1.0.4@aar\n+--- com.ks.lcodecorex:twinklingRefreshLayout:1.0.7.7@aar\n+--- androidx.recyclerview:recyclerview:1.1.0@aar\n+--- com.ks.kszxing:kszxing:0.0.2@aar\n+--- com.ks.ksseekbar:seekbar:0.0.1@aar\n+--- com.github.barteksc:android-pdf-viewer:2.8.2@aar\n+--- com.github.barteksc:pdfium-android:1.7.1@aar\n+--- com.alibaba:arouter-api:1.4.0@aar\n+--- com.google.android.gms:play-services-appindexing:8.4.0@aar\n+--- com.google.android.gms:play-services-base:8.4.0@aar\n+--- com.google.android.gms:play-services-basement:8.4.0@aar\n+--- androidx.legacy:legacy-support-v4:1.0.0@aar\n+--- androidx.constraintlayout:constraintlayout:1.1.3@aar\n+--- com.ks.kstoast:kstoast:0.0.2@aar\n+--- com.ks.ksprogresshud:ksprogresshud:0.0.2@aar\n+--- cn.jiguang.sdk:jpush:3.4.1@aar\n+--- cn.jiguang.sdk:jcore:2.3.4@aar\n+--- cn.jiguang.sdk.plugin:xiaomi:3.4.1@aar\n+--- cn.jiguang.sdk.plugin:meizu:3.4.1@aar\n+--- cn.jiguang.sdk.plugin:vivo:3.4.1@aar\n+--- cn.jiguang.sdk.plugin:oppo:3.4.1@aar\n+--- cn.jiguang.sdk.plugin:huawei:3.4.1@aar\n+--- com.getui:gtc:2.1.0@aar\n+--- com.facebook.react:react-native:0.2.13@aar\n+--- com.facebook.fresco:fresco:1.11.0@aar\n+--- com.facebook.fresco:animated-gif:1.11.0@aar\n+--- me.relex:photodraweeview:2.0.0@aar\n+--- com.github.lzyzsd:circleprogress:1.2.1@aar\n+--- com.ks.kseasyrecyclerview:kseasyrecyclerview:0.0.2@aar\n+--- com.aliyun.dpa:oss-android-sdk:2.9.1@aar\n+--- com.networkbench.newlens.agent.android:nbs.newlens.nativecrash:1.0.0@aar\n+--- com.networkbench.newlens.agent.android:nbs.newlens.agent:2.14.2@jar\n+--- com.github.yalantis:ucrop:2.2.5@aar\n+--- com.android.volley:volley:1.1.0@aar\n+--- pl.droidsonroids.gif:android-gif-drawable:1.2.19@aar\n+--- :common_res (variant: release)\n+--- :mio_sdk_app_2.1.0:@aar\n+--- :gamesdk-20200312:@aar\n+--- :umeng-asms-v1.1.1:@aar\n+--- com.facebook.fresco:imagepipeline-okhttp3:1.11.0@aar\n+--- androidx.multidex:multidex:2.0.1@aar\n+--- com.tencent.mm.opensdk:wechat-sdk-android-without-mta:5.4.3@jar\n+--- com.tencent.bugly:crashreport:3.2.3@aar\n+--- com.mcxiaoke.packer-ng:helper:2.0.1@aar\n+--- com.ks.ksmp3recorder:mp3recorder:0.0.4@aar\n+--- com.ks.ksswipeback:ksswipeback:0.0.2@aar\n+--- com.github.tbruyelle:RxPermissions:0.10.2@aar\n+--- :elogin-1.1.0.0:@aar\n+--- :gysdk-1.6.0.0:@aar\n+--- com.ks.kswheelpicker:wheelpicker:0.0.1@aar\n+--- com.ks.ksmagicindicator:magicindicator:0.0.1@aar\n+--- androidx.palette:palette:1.0.0@aar\n+--- com.robinhood.ticker:ticker:2.0.2@aar\n+--- me.zhanghai.android.materialprogressbar:library:1.6.1@aar\n+--- com.github.jd-alexander:LikeButton:0.2.3@aar\n+--- com.ks.ksrclayout:rclayout:0.0.1@aar\n+--- com.ks.ksEmptyClassReplace:emptyclassreplace:0.0.2@aar\n+--- com.github.pinguo-zhouwei:CustomPopwindow:2.1.1@aar\n+--- com.github.zcweng:switch-button:0.0.3@aar\n+--- com.ks.ksmediahandler:ksmediahandler:0.0.4@aar\n+--- org.apmem.tools:layouts:1.10@aar\n+--- com.tencent.taisdk:taisdk:1.2.3.3@aar\n+--- com.ks.kscocos2dx:cocos2dx:0.0.2@aar\n+--- androidx.cardview:cardview:1.0.0@aar\n+--- com.tencent.yunxiaowei.dmsdk:tskm:2.1.4@aar\n+--- com.tencent.yunxiaowei.dmsdk:core:2.1.4@aar\n+--- :jl_bluetooth_ac692x_V2.3.2:@aar\n+--- :jl_speex_st_V1.6:@aar\n+--- :alipaySdk-15.6.5-20190718211159-noUtdid:@aar\n+--- :cmbsdk-release-1.0:@aar\n+--- com.xiaomi.account:passportsdk-diagnosis:1.0.3@aar\n+--- com.leo618:zip:0.0.1@aar\n+--- com.ks.ksliveimpl:liveimpl:0.0.1@aar\n+--- com.ks.kspolyvplayer:polyvplayer:0.0.1@aar\n+--- com.ks.kspolyvchat:polyvchat:0.0.1@aar\n+--- com.easefun.polyv:polyvSDKCloudClass:0.12.0.06@aar\n+--- com.trello.rxlifecycle2:rxlifecycle-components:2.1.0@aar\n+--- com.easefun.polyv:polyvSDKLinkMic:0.12.0.06@aar\n+--- com.easefun.polyv:polyvSDKBusiness:0.12.0.06@aar\n+--- com.easefun.polyv:polyvSDKFoundation:0.12.0.06@aar\n+--- androidx.appcompat:appcompat:1.2.0-alpha03@aar\n+--- com.growingio.android:gmonitor:1.2.0@jar\n+--- org.hamcrest:hamcrest-core:1.3@jar\n+--- org.jetbrains.kotlin:kotlin-stdlib-common:1.3.72@jar\n+--- org.jetbrains:annotations:13.0@jar\n+--- androidx.legacy:legacy-support-core-ui:1.0.0@aar\n+--- androidx.coordinatorlayout:coordinatorlayout:1.1.0@aar\n+--- androidx.lifecycle:lifecycle-extensions:2.2.0@aar\n+--- androidx.fragment:fragment:1.2.0@aar\n+--- androidx.viewpager:viewpager:1.0.0@aar\n+--- androidx.drawerlayout:drawerlayout:1.0.0@aar\n+--- androidx.slidingpanelayout:slidingpanelayout:1.0.0@aar\n+--- androidx.customview:customview:1.0.0@aar\n+--- com.ks.reactnative:react-native-video:1.0.5@aar\n+--- com.google.android.exoplayer:exoplayer:2.9.3@aar\n+--- com.google.android.exoplayer:exoplayer-ui:2.9.3@aar\n+--- androidx.media:media:1.0.0@aar\n+--- androidx.legacy:legacy-support-core-utils:1.0.0@aar\n+--- com.ks.reactnative:react-native-reanimated:1.0.2@aar\n+--- com.andkulikov:transitionseverywhere:2.0.0@aar\n+--- androidx.transition:transition:1.2.0@aar\n+--- androidx.appcompat:appcompat-resources:1.2.0-alpha03@aar\n+--- androidx.vectordrawable:vectordrawable-animated:1.1.0@aar\n+--- androidx.vectordrawable:vectordrawable:1.1.0@aar\n+--- androidx.exifinterface:exifinterface:1.1.0-beta01@aar\n+--- androidx.databinding:databinding-adapters:4.0.0@aar\n+--- androidx.databinding:databinding-runtime:4.0.0@aar\n+--- androidx.loader:loader:1.0.0@aar\n+--- androidx.swiperefreshlayout:swiperefreshlayout:1.0.0@aar\n+--- androidx.asynclayoutinflater:asynclayoutinflater:1.0.0@aar\n+--- androidx.activity:activity:1.1.0@aar\n+--- androidx.core:core:1.3.0-alpha02@aar\n+--- androidx.lifecycle:lifecycle-process:2.2.0@aar\n+--- androidx.lifecycle:lifecycle-service:2.2.0@aar\n+--- androidx.lifecycle:lifecycle-runtime:2.2.0@aar\n+--- androidx.lifecycle:lifecycle-viewmodel-savedstate:1.0.0@aar\n+--- androidx.lifecycle:lifecycle-viewmodel:2.2.0@aar\n+--- androidx.documentfile:documentfile:1.0.0@aar\n+--- androidx.localbroadcastmanager:localbroadcastmanager:1.0.0@aar\n+--- androidx.print:print:1.0.0@aar\n+--- androidx.interpolator:interpolator:1.0.0@aar\n+--- androidx.cursoradapter:cursoradapter:1.0.0@aar\n+--- androidx.versionedparcelable:versionedparcelable:1.1.0@aar\n+--- androidx.collection:collection:1.1.0@jar\n+--- com.google.android.exoplayer:extension-okhttp:2.9.3@aar\n+--- com.trello.rxlifecycle2:rxlifecycle-android:2.1.0@aar\n+--- com.tencent:mmkv-static:1.1.2@aar\n+--- androidx.databinding:viewbinding:4.0.0@aar\n+--- androidx.lifecycle:lifecycle-livedata:2.2.0@aar\n+--- androidx.lifecycle:lifecycle-livedata-core:2.2.0@aar\n+--- androidx.arch.core:core-runtime:2.1.0@aar\n+--- androidx.savedstate:savedstate:1.0.0@aar\n+--- androidx.arch.core:core-common:2.1.0@jar\n+--- androidx.lifecycle:lifecycle-common:2.2.0@jar\n+--- com.google.android.exoplayer:exoplayer-dash:2.9.3@aar\n+--- com.google.android.exoplayer:exoplayer-hls:2.9.3@aar\n+--- com.google.android.exoplayer:exoplayer-smoothstreaming:2.9.3@aar\n+--- com.google.android.exoplayer:exoplayer-core:2.9.3@aar\n+--- androidx.annotation:annotation:1.1.0@jar\n+--- androidx.constraintlayout:constraintlayout-solver:1.1.3@jar\n+--- androidx.annotation:annotation-experimental:1.0.0@aar\n+--- com.ks.reactnative:react-native-community-async-storage:1.0.4@aar\n+--- com.ks.reactnative:react-native-community-netinfo:1.0.9@aar\n+--- com.ks.reactnative:react-native-code-push:1.0.12@aar\n+--- com.ks.reactnative:react-native-gesture-handler:1.0.2@aar\n+--- com.ks.reactnative:react-native-linear-gradient:1.0.1@aar\n+--- com.ks.reactnative:react-native-safe-area-context:1.0.6@aar\n+--- com.ks.reactnative:react-native-community-viewpager:1.0.3@aar\n+--- com.squareup.picasso:picasso:2.5.2@jar\n+--- com.sobot.chat:sobotsupport-glidev4:1.0.10@aar\n+--- com.facebook.fresco:animated-base:1.11.0@aar\n+--- com.facebook.fresco:animated-drawable:1.11.0@aar\n+--- com.facebook.fresco:drawee:1.11.0@aar\n+--- com.facebook.fresco:nativeimagefilters:1.11.0@aar\n+--- com.facebook.fresco:imagepipeline:1.11.0@aar\n+--- com.facebook.fresco:imagepipeline-base:1.11.0@aar\n+--- com.facebook.fresco:fbcore:1.11.0@aar\n+--- com.facebook.soloader:soloader:0.8.0@aar\n+--- com.parse.bolts:bolts-tasks:1.4.0@jar\n+--- com.squareup.okhttp3:okhttp-urlconnection:3.12.1@jar\n+--- com.squareup.okhttp3:logging-interceptor:3.12.12@jar\n+--- com.squareup.retrofit2:adapter-rxjava2:2.3.0@jar\n+--- com.squareup.retrofit2:converter-scalars:2.3.0@jar\n+--- com.squareup.retrofit2:converter-gson:2.7.1@jar\n+--- com.squareup.retrofit2:retrofit:2.7.1@jar\n+--- io.socket:socket.io-client:1.0.0@jar\n+--- io.socket:engine.io-client:1.0.0@jar\n+--- com.squareup.okhttp3:okhttp:3.12.12@jar\n+--- com.squareup.wire:wire-runtime:2.3.0-RC1@jar\n+--- com.squareup.okio:okio:1.15.0@jar\n+--- pl.droidsonroids:relinker:1.3.1@aar\n+--- androidx.databinding:databinding-common:4.0.0@jar\n+--- com.tencent.tbs.tbssdk:sdk:43903@aar\n+--- id.zelory:compressor:2.1.0@aar\n+--- com.trello.rxlifecycle2:rxlifecycle:2.1.0@jar\n+--- io.reactivex.rxjava2:rxandroid:2.0.2@aar\n+--- com.jakewharton.rxrelay2:rxrelay:2.0.0@jar\n+--- io.reactivex.rxjava2:rxjava:2.2.12@jar\n+--- com.alibaba:fastjson:1.1.71.android@jar\n+--- com.ks.ksbsdiffpatcher:bsdiffpatcher:0.0.1@aar\n+--- com.ks.kschatframe:chatframe:0.0.1@aar\n+--- com.xiaomi.infra.galaxy:galaxy-fds-sdk-android:3.0.8@jar\n+--- com.google.code.gson:gson:2.8.5@jar\n+--- com.mcxiaoke.packer-ng:common:2.0.1@jar\n+--- commons-codec:commons-codec:1.6@jar\n+--- :sdk-lecast-release:@aar\n+--- com.ks.ksliveframe:liveframe:0.0.1@aar\n+--- org.greenrobot:eventbus:3.1.1@jar\n+--- com.facebook.infer.annotation:infer-annotation:0.11.2@jar\n+--- com.facebook.yoga:proguard-annotations:1.14.1@jar\n+--- javax.inject:javax.inject:1@jar\n+--- com.google.code.findbugs:jsr305:3.0.2@jar\n+--- com.facebook.fbjni:fbjni-java-only:0.0.3@jar\n+--- com.nimbusds:nimbus-jose-jwt:5.1@jar\n+--- com.sobot.chat:sobotsdk-imageloader:1.0.4@aar\n+--- com.aliyun.ams:alicloud-android-httpdns:1.3.2.3@aar\n+--- com.aliyun.ams:alicloud-android-utils:1.1.6.4@jar\n+--- com.aliyun.ams:alicloud-android-ut:5.4.3@jar\n+--- com.aliyun.ams:alicloud-android-beacon:1.0.4.3@jar\n+--- com.aliyun.ams:alicloud-android-utdid:1.5.2@jar\n+--- org.reactivestreams:reactive-streams:1.0.2@jar\n+--- com.facebook.soloader:annotation:0.8.0@aar\n+--- com.facebook.soloader:nativeloader:0.8.0@jar\n+--- com.github.stephenc.jcip:jcip-annotations:1.0-1@jar\n+--- net.minidev:json-smart:2.3@jar\n+--- com.alibaba:arouter-annotation:1.0.6@jar\n+--- com.xiaomi.infra.galaxy:galaxy-fds-core:3.0.8@jar\n+--- com.github.ctiao:DanmakuFlameMaster:0.9.25@aar\n+--- de.hdodenhof:circleimageview:2.2.0@aar\n+--- com.github.lzyzsd:jsbridge:1.0.4@aar\n+--- com.easefun.polyv:polyvSDKModuleABI:0.2.0@aar\n+--- io.agora.rtc:full-sdk:2.9.0.102@aar\n+--- net.minidev:accessors-smart:1.2@jar\n+--- com.google.guava:guava:18.0@jar\n+--- commons-lang:commons-lang:2.6@jar\n+--- org.ow2.asm:asm:5.0.4@jar\n\\--- org.json:json:20090211@jar\n:ks_main_center:androidDependencies spend 3303ms\n      00:03.30   :ks_main_center:androidDependencies\n\nDeprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.\nUse '--warning-mode all' to show the individual deprecation warnings.\nSee https://docs.gradle.org/6.5/userguide/command_line_interface.html#sec:command_line_warnings\n\nBUILD SUCCESSFUL in 3s\n1 actionable task: 1 executed\n4:21:59 PM: Task execution finished 'androidDependencies'.\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515774604},"updatedAt":{"$$date":1598516765769},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bnCAu9eHjYppwOFK"}
{"name":"ad-ksbottomnavigationbar","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\n\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n    }\n    //这个是解决lint报错的代码\n    lintOptions {\n        abortOnError false\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation deps.androidx.app_compat\n    implementation deps.androidx.design, {\n        exclude group: \"com.android.support\", module: \"multidex\"\n    }\n\n    implementation ks.ksloadpic\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\nbottomnavigation\nbehaviour\nutils\nBadgeItem\nBottomNavigationBar\nBottomNavigationHelper\nBottomNavigationItem\nBottomNavigationTab\nFixedBottomNavigationTab\nShiftingBottomNavigationTab\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522797334},"updatedAt":{"$$date":1598523792786},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bumsxnQb6zMYU5k8"}
{"name":"Untitled snippet","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598544473614},"updatedAt":{"$$date":1598544473614},"_id":"bxnt8pYsI3Y7UU9Y"}
{"name":"HTML5 拖放（Drag 和 Drop）","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\nHTML5 拖放（Drag 和 Drop）\n拖放（Drag 和 drop）是 HTML5 标准的组成部分。\n\n将 RUNOOB.COM 图标拖动到矩形框中。\n\n拖放\n拖放是一种常见的特性，即抓取对象以后拖到另一个位置。\n\n在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。\n\n浏览器支持\nInternet ExplorerFirefoxOperaGoogle ChromeSafari\n\nInternet Explorer 9+, Firefox, Opera, Chrome, 和 Safari 支持拖动。\n\n注意:Safari 5.1.2不支持拖动.\n\nHTML5 拖放实例\n下面的例子是一个简单的拖放实例：\n\n实例\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta charset=\"utf-8\"> \n<title>菜鸟教程(runoob.com)</title>\n<style type=\"text/css\">\n#div1 {width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;}\n</style>\n<script>\nfunction allowDrop(ev)\n{\n    ev.preventDefault();\n}\n \nfunction drag(ev)\n{\n    ev.dataTransfer.setData(\"Text\",ev.target.id);\n}\n \nfunction drop(ev)\n{\n    ev.preventDefault();\n    var data=ev.dataTransfer.getData(\"Text\");\n    ev.target.appendChild(document.getElementById(data));\n}\n</script>\n</head>\n<body>\n \n<p>拖动 RUNOOB.COM 图片到矩形框中:</p>\n \n<div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div>\n<br>\n<img id=\"drag1\" src=\"/images/logo.png\" draggable=\"true\" ondragstart=\"drag(event)\" width=\"336\" height=\"69\">\n \n</body>\n</html>\n\n尝试一下 »\n它看上去也许有些复杂，不过我们可以分别研究拖放事件的不同部分。\n\n设置元素为可拖放\n首先，为了使元素可拖动，把 draggable 属性设置为 true ：\n\n<img draggable=\"true\">\n\n拖动什么 - ondragstart 和 setData()\n然后，规定当元素被拖动时，会发生什么。\n\n在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。\n\ndataTransfer.setData() 方法设置被拖数据的数据类型和值：\n\nfunction drag(ev)\n{\n    ev.dataTransfer.setData(\"Text\",ev.target.id);\n}\nText 是一个 DOMString 表示要添加到 drag object 的拖动数据的类型。值是可拖动元素的 id (\"drag1\")。\n\n放到何处 - ondragover\nondragover 事件规定在何处放置被拖动的数据。\n\n默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。\n\n这要通过调用 ondragover 事件的 event.preventDefault() 方法：\n\nevent.preventDefault()\n\n进行放置 - ondrop\n当放置被拖数据时，会发生 drop 事件。\n\n在上面的例子中，ondrop 属性调用了一个函数，drop(event)：\n\nfunction drop(ev)\n{\n    ev.preventDefault();\n    var data=ev.dataTransfer.getData(\"Text\");\n    ev.target.appendChild(document.getElementById(data));\n}\n代码解释：\n\n调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）\n通过 dataTransfer.getData(\"Text\") 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。\n被拖数据是被拖元素的 id (\"drag1\")\n把被拖元素追加到放置元素（目标元素）中\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886961476},"updatedAt":{"$$date":1598887465069},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"c8y0WLunT8IbBfY3"}
{"name":"凯叔故事路由梳理","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"这次梳理的主要是首先需要看代码业务优化有多少，统一一下，另外该合并的合并，并且经过统一路由分发来处理这些跳转。\n经过梳理总体上上分为：\n• 轮播图+广告楼层+UFO+支付结果 支持跳转类型\n• Deeplink 支持类型\n• Cocos 游戏交互跳转类型\n• RN 交互跳转逻辑，自己约束的路由 page页面\n• H5 跳转类型@JavascriptInterface  方法\n一、轮播图+广告楼层+UFO+支付结果+推送类型 支持跳转类型\n优化点：\n这一个类型经过排查统共有四个个方法入口，需要仔细排查是否可以优化为一个路由方法来统一处理，可能有其他的历史原因。\n• homeFlowerAdaverJump（首页广告）\n• trainingEnglishCampDetail（训练营广告）\n• commonNormalSkip（UFO+Banner+广告+支付结果）\n• commonPathNewTask（推送单独处理）\n首页 楼层点击大致截图如下：\n总结几个大类型：\n• 首页推荐页 Bannner 轮播图（推荐+标签子频道+电商首页+搜索+开通会员）\n• UFO 点击（故事首页UFO+电商首页UFO+网页UFO）\n• 广告楼层 (首页，新手礼包)\n• 支付结果页（微信+阿里+KB 支付）\n     ADBANNER_WEB = \"web\"; // Webview \n     ADBANNER_ABLUM = \"ablum\";//免费专辑页面\n     ADBANNER_STORY = \"story\";// 播放页（专辑或者故事,并且处理是否可以收听的逻辑）\n     ADBANNER_ARTICLE = \"article\";\n     ADBANNER_SPECIAL = \"special\";//专题页面\n     ADBANNER_PRODUCT_STORY = \"product_story\";// 故事\n     ADBANNER_PRODUCT_ABLUM = \"product_ablum\";// 专辑\n     ADBANNER_PRODUCT_MMWK = \"product_mmwk\";// 妈妈微课\n     ADBANNER_PRODUCT_YEARPACKAGE = \"product_yearpackage\";//商品类型（年包）\n     ADBANNER_PRODUCT_MMWK_ABLUM = \"product_mmwk_ablum\";//商品类型（妈妈微课）\n     ADBANNER_PRODUCT_WKVIDEO_ABLUM = \"product_wkvideo_ablum\";//商品类型（专辑）\n     ADBANNER_ADVER = \"adver\";\n     ADBANNER_YOUZAN_WEB = \"youzan_web\";// 有赞\n     ADBANNER_PACKS = \"packs\";//新年活动\n     ADBANNER_SUBSCRIBE_STORY = \"subscribe_story\";//已购买页面\n     ADBANNER_PRODUCT_CAMP = \"product_camp\";// 训练营商品详情\n     ADBANNER_CAMP = \"camp\";// 训练营\n     ADBANNER_PRODUCT_SYSTEM_CAMP = \"product_system_camp\";//训练营系统课\n     ADBANNER_PRODUCT_ENGLISH_CAMP = \"product_english_camp\";//英语训练营\n     ADBANNER_MSG = \"user_message\"; //5.6增加push点击跳转我的消息界面\n     ADBANNER_CAMP_COMMENT = \"camp_comment\";//训练营评论\n     ADBANNER_CAMP_PUNCH = \"camp_punch\";//训练营+打卡记录页面\n     ADBANNER_CAMP_HOMEWORK = \"camp_homework\";// 训练营+课程详情页面+作业\n     ADBANNER_CAMP_QUESTION = \"camp_question\";// 训练营+课程详情页面+问题\n     ADBANNER_CAMP_SYSTEM = \"camp_system\";// 训练营系统课（广告类型）\n     ADBANNER_SUBSCRIBE_MMWK = \"subscribe_mmwk\";// 已购买（妈妈微课）\n     SUBSCRIBE_ALBUM_COLUMN = \"subscribe_album_column\";//已购买（故事专辑）\n     SUBSCRIBE_MMWK_COLUMN = \"subscribe_mmwk_column\";//已购买（妈妈微课专辑）\n     COLUMN_STORY = \"column_story\";   //跳转故事小知识  4.5新加\n     COLUMN_WK = \"column_wk\";   //跳转亲子小知识  4.5新加\n     SUBSCRIBE_CAMP = \"subscribe_camp\";   //训练营推送\n     MORNINGCALL = \"subscribe_callEarly\";   //叫早小知识\n     FM = \"fm\"; //电台\n     MORNING_CALL_GIFT = \"morningCall_gift\"; //叫早礼物\n     MEMBER_CENTER = \"member_center\";   //会员中心\n     MEMBER_BUY = \"member_buy\";   //会员购买\n     FUNLAND = \"funland\";   //凯叔乐园\n     TOP = \"top\";   //首页顶部\n     ALL_CATEGORIES = \"all_categories\";   //全部分类\n     JUMP_MALL_ORDER_DETAIL = \"mall_order_detail\";   //实物电商订单\n     JUMP_MALL_EXPRESS_DETAIL = \"mall_express_detail\";   // 跳转到物流详情\n     JUMP_MALL_HOME_PAGE = \"baigui_home\";   // 跳转商城首页\n     JUMP_MALL_GROUP_DETAIL = \"group_detail\";   // 跳转拼团详情页\n     JUMP_MALL_COUPON_LIST = \"c_product_list\";   // 跳转优惠券二级页\n     JUMP_TO_SIGNIN = \"sign\";   // 跳转H5 游戏页面  签到\n     JUMP_TO_MEMBER_BUY = \"member_buy\";   // 6.8 会员购买页\n     VIP_FREEZE = \"vip_freeze\";// 会员冻结\n     VIP_EXPIRE = \"vip_expire\";// 会员购买\n     ADBANNER_STATIC_PIC = \"static_pic\";//展示广告,不跳转\n     ADBANNER_MINI_PROGRAM = \"mini_program\";//展示广告,跳转小程序\n     ADBANNER_TEMPLETE_ID = \"app_weixin\";//调用微信，订阅模板消息\n     EC_PRODUCT = \"ecProduct\";//有赞电商\n     MALL_PRODUCT = \"mall_product\";//自建电商\n     HOME_SUB_CHANNEL = \"homelayout_group\";//子频道\n     SMALL_CLASS = \"product_smallclass\"; //小课\n二、DeepLink 支持类型\n     SCHEMAJUMP_HOME = \"home\";\n     SCHEMAJUMP_MMWK = \"mmwk\";\n     SCHEMAJUMP_MYPAGE = \"myPage\";\n     SCHEMAJUMP_VIPLIST = \"vipList\";\n     SCHEMAJUMP_TAGLIST = \"tagList\";\n     SCHEMAJUMP_DETAILPAGE = \"detailPage\";\n     SCHEMAJUMP_STORYLIST = \"storyList\";\n     SCHEMAJUMP_PLAYER = \"player\";\n     SCHEMAJUMP_LITTLEKNOWLEDGEPAGE = \"littleKnowledgePage\";\n     SCHEMAJUMP_MMWKKNOWLEDGEPAGE = \"mmwkKnowledgePage\";\n     SCHEMAJUMP_ACTIVITYDEEPLINK = \"activitydeeplink\";\n     SCHEMAJUMP_FEATURE = \"feature\";\n     SCHEMAJUMP_BUYVIP = \"buyVip\";\n     SCHEMAJUMP_LINKTOONLINESERVICE = \"linkToOnlineService\";\n     SCHEMAJUMP_ACHIEVEMENT = \"achievement\";\n     SCHEMAJUMP_MALLHOME = \"baigui_home\";\n     SCHEMAJUMP_GROUP_DETAIL = \"group_detail\";\n     SCHEMAJUMP_COUPON_SECOND = \"c_product_list\";//优惠券二级页\n     SCHEMAJUMP_TRAINING_CAMP_DETAIL = \"training_camp_detail\";//训练营商品详情页\n     SCHEMAJUMP_TRAINING_CAMP_DETAIL_LIST = \"training_camp_detail_list\";// 训练营课程列表页\n     SCHEMAJUMP_MALL_PRODUCT_DETAIL = \"mall_product_detail\";\n     SCHEMAJUMP_IP_CHANNEL = \"ipChannel\";//跳转ip频道\n三、Cocos 游戏交互跳转类型\n     YOUZAN_WEB = \"youzan_web\";// 有赞商城\n     FM = \"fm\";//电台\n     MORNINGCALL = \"subscribe_callEarly\";//叫早小知识\n     MORNING_CALL_GIFT = \"morningCall_gift\";//叫早礼物\n     CAMP_PRACTICE_VIDEO = \"camp_practice_video\";//训练营练习视频课程详情\n四、RN 交互跳转逻辑，自己约束的路由 page页面\n     // 播放页\n    PLAYER_PAGE =\"player\";\n    // 商品详情页\n    PRODUCT_PAGE =\"product\";\n    // 电商详情页\n    mallProduct_PAGE =\"mallProduct\";\n    // 跳转专题页面\n    feature_PAGE =\"feature\";\n    // 免费专辑\n    freeAlbum_PAGE =\"freeAlbum\";\n    // 网页\n    webview_PAGE =\"webview\";\n    // 会员购买页\n    buyVip_PAGE =\"buyVip\";\n    // 会员中心页\n    vipCenter_PAGE =\"vipCenter\";\n    // 付费故事列表\n    vipList_PAGE =\"vipList\";\n    // 最新故事列表\n    newestStoryList_PAGE =\"newestStoryList\";\n    // 专题汇总页面\n    featureList_PAGE =\"featureList\";\n    // 凯叔答题页面\n    answer_PAGE =\"answer\";\n    // 小知识页面\n    littleKnowledge_PAGE =\"littleKnowledge\";\n    // 微信小程序\n    wxapp_PAGE =\"wxapp\";\n    // 全部分类页面\n    allSort_PAGE =\"allSort\";\n    // 跳转排行榜页面\n    leaderBoard_PAGE =\"leaderBoard\";\n    // 底部tab\n    tab_PAGE =\"tab\";\n    // 频道切换\n    channel_PAGE =\"channel\";\n    // app登录页面\n    login_PAGE =\"login\";\n    // 绑定手机号页面\n    bindPhone_PAGE =\"bindPhone\";\n    // 楼层更多内容\n    layoutMore_PAGE =\"layoutMore\";\n    // 有赞链接\n    youzan_PAGE =\"youzan\";\n    // 商城搜索页面\n    mallSearch_PAGE =\"mallSearch\";\n    // 商城楼层二级列表页面\n    mallLayoutMore_PAGE =\"mallLayoutMore\";\n    // 会员购买记录\n    MEMEBER_PURCHASE_RECORDS_PAGE =\"memberPurchaseRecords\";\n    // 会员权益详情\n    MEMBER_BENEFITS_DETAIL_PAGE =\"memberBenefitsDetail\";\n    // 跳转定制会员礼品卡(会员礼品卡购买页面)\n    MEMBER_GIFT_CARD_BUY_PAGE =\"memberGiftCardBuy\";\n    // 兑换码\n    EXCHANGE_PAGE =\"exchange\";\n    // 智齿客服\n    SOBOTCHAT_PAGE =\"sobotChat\";\n    // 管理自动续费\n    MANAGE_AUTO_CHARGE_PAGE =\"manageAutoCharge\";\n    //跳转小课详情页\n    PRODUCT_SMALL_CLASS_PAGE =\"productSmallClass\";\n    //跳转小课播放页\n    PRODUCT_SMALL_CLASS_PLAY_PAGE =\"productSmallClassPlay\";\n五、 H5 跳转类型@JavascriptInterface  方法\nTodo"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598548094109},"updatedAt":{"$$date":1598548458300},"_id":"c9CNrOZxS13TO4UK","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"qk-ks_lib_picture","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1032\n        versionName \"1032\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n\n    }\n\n    buildTypes {\n        release {\n            consumerProguardFiles 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    implementation deps.fresco.fresco\n    implementation deps.fresco.imagepipeline_okhttp ,{\n        exclude group: \"com.squareup.okio\", module: \"okio\"\n    }\n    implementation deps.fresco.animated_gif\n\n}\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nobject FrescoUtils {\n\n    private val GIF_SUFFIX = \".gif\"\n    private var APP_PACKAGENAME_RES = \"res://packagename/\"\n    var sUserWebp = false\n\n    /**\n     * 初始化fresco\n     *\n     * @param context 上下文\n     * @param app_packagename_res 应用包名\n     */\n    fun init(context: Context, app_packagename_res: String) {\n        APP_PACKAGENAME_RES = app_packagename_res\n        Fresco.initialize(\n            context,\n            FrescoImagePipelineConfigFactory.getOkHttpImagePipelineConfig(context)\n        )\n    }\n\n    /**\n     * 通过资源id，加载图片\n     *\n     * @param draweeView 要显示的图片view\n     * @param id         图片id\n     */\n    fun loadFromResource(draweeView: SimpleDraweeView?, id: Int) {\n        if (id == -1) {\n            return\n        }\n        val uri = APP_PACKAGENAME_RES + id\n\n        val gifController = Fresco.newDraweeControllerBuilder()\n            .setUri(Uri.parse(uri))\n            .setAutoPlayAnimations(true)\n            .build()\n        draweeView!!.controller = gifController\n    }\n\n    /**\n     * 通过资源名称，加载本地图片gif\n     *\n     * @param draweeView 要显示的图片view\n     * @param id         图片id\n     */\n    fun loadGifFromAsset(draweeView: SimpleDraweeView, assetGifName: String) {\n        val uri = \"asset:///$assetGifName.gif\"\n        val gifController = Fresco.newDraweeControllerBuilder()\n            .setUri(Uri.parse(uri))\n            .setAutoPlayAnimations(true)\n            .build()\n        draweeView.controller = gifController\n    }\n\n    /**\n     * 通过资源 路径，加载内存卡 gif\n     *\n     * @param draweeView 要显示的图片view\n     * @param gifAbsolutePath         gif 绝对路径\n     */\n    fun loadGifFromSdcard(draweeView: SimpleDraweeView, gifAbsolutePath: String) {\n        val uri = if (gifAbsolutePath.startsWith(\"file\")) {\n            gifAbsolutePath\n        } else {\n            \"file://$gifAbsolutePath\"\n        }\n\n        val gifController = Fresco.newDraweeControllerBuilder()\n            .setUri(Uri.parse(uri))\n            .setAutoPlayAnimations(true)\n            .build()\n        draweeView.controller = gifController\n    }\n\n    /**\n     * 显示图片(包括是否是用webp)\n     *\n     * @param draweeView 显示图片的view\n     * @param url        图片的原始链接\n     * @param onGetWidthAndHeight? 获取到宽高 的回调\n     */\n    fun loadWebpImg(\n        draweeView: SimpleDraweeView, url: String,\n        onGetWidthAndHeight: ((width: Int, height: Int) -> Unit)?=null\n    ) {\n        if (url.endsWith(GIF_SUFFIX)) {\n            val imageRequest = ImageRequestBuilder.newBuilderWithSource(Uri.parse(url))\n                .build()\n            val draweeController = Fresco.newDraweeControllerBuilder()\n                .setImageRequest(imageRequest)\n                .setOldController(draweeView.controller)\n                .setControllerListener(object : ControllerListener<ImageInfo> {\n                    override fun onFinalImageSet(\n                        id: String?,\n                        imageInfo: ImageInfo?,\n                        animatable: Animatable?\n                    ) {\n                        onGetWidthAndHeight?.invoke(imageInfo?.width ?: -1, imageInfo?.height ?: -1)\n                    }\n\n                    override fun onFailure(id: String?, throwable: Throwable?) {\n                    }\n\n                    override fun onRelease(id: String?) {\n                    }\n\n                    override fun onSubmit(id: String?, callerContext: Any?) {\n                    }\n\n                    override fun onIntermediateImageSet(id: String?, imageInfo: ImageInfo?) {\n                    }\n\n                    override fun onIntermediateImageFailed(id: String?, throwable: Throwable?) {\n                    }\n\n                })\n                .setAutoPlayAnimations(true)\n\n                .setTapToRetryEnabled(true)\n                .build()\n            draweeView.controller = draweeController\n        } else {\n            val uri = imageConvertWebp(url)\n            draweeView.setImageURI(Uri.parse(uri))\n        }\n    }\n\n\n    /**\n     * 显示图片带有高斯模糊功能\n     *\n     * @param draweeView 显示图片的view\n     * @param url        图片的原始链接\n     * @param radius     模糊半径\n     */\n    fun loadImgWithBlur(\n        simpleDraweeView: SimpleDraweeView,\n        url: String,\n        radius: Int\n    ) {\n        try {\n            blur(simpleDraweeView, Uri.parse(url), radius)\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n\n    }\n\n    private fun blur(bandImage: SimpleDraweeView, uri: Uri?, radius: Int) {\n\n        try {\n            val request = ImageRequestBuilder.newBuilderWithSource(uri)\n                .setPostprocessor(IterativeBoxBlurPostProcessor(6, radius))\n                .build()\n            val controller = Fresco.newDraweeControllerBuilder()\n                .setOldController(bandImage.controller)\n                .setImageRequest(request)\n                .build()\n            bandImage.controller = controller\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n\n    /**\n     * 根据逻辑返回相应的图片链接\n     *\n     * @param picUrl 图片的原始链接\n     * @return 处理后的图片链接\n     */\n    private fun imageConvertWebp(picUrl: String): String {\n        var url = picUrl\n        val stringBuilder: StringBuilder\n\n        if (!url.contains(\".mp4\")) {\n            //容错，如果后端图片链接返回了webp\n            if (url.contains(\"?\")) {\n                val split = url.split(\"\\\\?\".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()\n                if (split.size > 1) {\n                    url = split[0]\n                }\n            }\n            stringBuilder = StringBuilder(url)\n        } else {\n            //阿里云视频首帧服务跟webp服务不能同时存在\n            stringBuilder = StringBuilder(url)\n            return stringBuilder.toString()\n        }\n\n        //后端返回的配置是否用webp\n        if (!sUserWebp) {\n            return stringBuilder.toString()\n        }\n\n        stringBuilder.append(FrescoConfigConstants.OSS_WEBP)\n        return stringBuilder.toString()\n    }\n\n    /**\n     * 当前图片链接转换成带有webp形式的链接\n     *\n     * @param picUrl 图片的原始链接\n     * @return 处理后的图片链接\n     */\n    fun converToWebp(picUrl: String): String {\n        var url = picUrl\n        val stringBuilder: StringBuilder\n\n        if (!url.contains(\".mp4\")) {\n            //容错，如果后端图片链接返回了webp\n            if (url.contains(\"?\")) {\n                val split = url.split(\"\\\\?\".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()\n                if (split.size > 1) {\n                    url = split[0]\n                }\n            }\n            stringBuilder = StringBuilder(url)\n        } else {\n            //阿里云视频首帧服务跟webp服务不能同时存在\n            stringBuilder = StringBuilder(url)\n            return stringBuilder.toString()\n        }\n\n        //后端返回的配置是否用webp\n        if (!sUserWebp) {\n            return stringBuilder.toString()\n        }\n\n        stringBuilder.append(FrescoConfigConstants.OSS_WEBP)\n        return stringBuilder.toString()\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobject FrescoImagePipelineConfigFactory {\n\n    private var sImagePipelineConfig: ImagePipelineConfig? = null\n    private var sOkHttpImagePipelineConfig: ImagePipelineConfig? = null\n\n//    private val unsafeOkHttpClient: OkHttpClient\n//        get() {\n//            try {\n//                val trustAllCerts = arrayOf<TrustManager>(object : X509TrustManager {\n//                    override fun checkClientTrusted(\n//                        chain: Array<X509Certificate>,\n//                        authType: String\n//                    ) {\n//                    }\n//\n//                    override fun checkServerTrusted(\n//                        chain: Array<X509Certificate>,\n//                        authType: String\n//                    ) {\n//                    }\n//\n//                    override fun getAcceptedIssuers(): Array<X509Certificate?> {\n//                        return arrayOfNulls(0)\n//                    }\n//                })\n//                val sslContext = SSLContext.getInstance(\"TLS\")\n//                sslContext.init(null, trustAllCerts, SecureRandom())\n//                val sslSocketFactory = sslContext.socketFactory\n//                val builder = OkHttpClient().newBuilder()\n//                builder.sslSocketFactory(sslSocketFactory)\n//                builder.hostnameVerifier { hostname, session -> true }\n//                return builder.build()\n//            } catch (e: Exception) {\n//                throw RuntimeException(e)\n//            }\n//\n//        }\n\n    /**\n     * Creates config using android http stack as network backend.\n     */\n    fun getImagePipelineConfig(context: Context): ImagePipelineConfig? {\n        if (sImagePipelineConfig == null) {\n            val configBuilder = ImagePipelineConfig.newBuilder(context)\n            configureCaches(configBuilder, context)\n            configureLoggingListeners(configBuilder)\n            sImagePipelineConfig = configBuilder.build()\n        }\n        return sImagePipelineConfig\n    }\n\n    /**\n     * Creates config using OkHttp as network backed.\n     */\n    fun getOkHttpImagePipelineConfig(context: Context): ImagePipelineConfig? {\n        if (sOkHttpImagePipelineConfig == null) {\n            try {\n                // OkhttpClient\n                val trustAllCerts = arrayOf<TrustManager>(object : X509TrustManager {\n                    override fun checkClientTrusted(\n                        chain: Array<X509Certificate>,\n                        authType: String\n                    ) {\n                    }\n\n                    override fun checkServerTrusted(\n                        chain: Array<X509Certificate>,\n                        authType: String\n                    ) {\n                    }\n\n                    override fun getAcceptedIssuers(): Array<X509Certificate?> {\n                        return arrayOfNulls(0)\n                    }\n                })\n                val sslContext = SSLContext.getInstance(\"TLS\")\n                sslContext.init(null, trustAllCerts, SecureRandom())\n                val sslSocketFactory = sslContext.socketFactory\n                val builder = OkHttpClient().newBuilder()\n                builder.sslSocketFactory(sslSocketFactory)\n                builder.hostnameVerifier { hostname, session -> true }\n                val okHttpClient = builder.build()\n                // set OkhttpClient\n                val configBuilder =\n                    OkHttpImagePipelineConfigFactory.newBuilder(context, okHttpClient)\n                configBuilder.setBitmapsConfig(Bitmap.Config.RGB_565)\n                configBuilder.isDownsampleEnabled = true\n                configureCaches(configBuilder, context)\n                configureLoggingListeners(configBuilder)\n                sOkHttpImagePipelineConfig = configBuilder.build()\n            }catch (e:Exception){\n                e.printStackTrace()\n            }\n        }\n        return sOkHttpImagePipelineConfig\n    }\n\n\n    /**\n     * Configures disk and memory cache not to exceed common limits\n     */\n    private fun configureCaches(\n        configBuilder: ImagePipelineConfig.Builder,\n        context: Context\n    ) {\n        val bitmapCacheParams = MemoryCacheParams(\n            FrescoConfigConstants.MAX_MEMORY_CACHE_SIZE, // 内存缓存中总图片的最大大小,以字节为单位。\n            Integer.MAX_VALUE, // 内存缓存中图片的最大数量。\n            FrescoConfigConstants.MAX_MEMORY_CACHE_SIZE, //内存缓存中准备清除但尚未被删除的总图片的最大大小,以字节为单位。\n            Integer.MAX_VALUE, // Max length of eviction queue\n            Integer.MAX_VALUE\n        )                    // Max cache entry size\n        configBuilder\n            .setBitmapMemoryCacheParamsSupplier { bitmapCacheParams }\n            .setMainDiskCacheConfig(\n                DiskCacheConfig.newBuilder(context)\n                    .setBaseDirectoryPath(context.cacheDir)\n                    .setBaseDirectoryName(FrescoConfigConstants.IMAGE_PIPELINE_CACHE_DIR)\n                    .setMaxCacheSize(FrescoConfigConstants.MAX_DISK_CACHE_SIZE.toLong())\n                    .build()\n            )\n    }\n\n    private fun configureLoggingListeners(configBuilder: ImagePipelineConfig.Builder) {\n        configBuilder.setRequestListeners(\n            Sets.newHashSet(RequestLoggingListener() as RequestListener)\n        )\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\nobject FrescoConfigConstants {\n    //最大堆大小\n    private var MAX_HEAP_SIZE = Runtime.getRuntime().maxMemory().toInt()\n    //磁盘缓存40m\n    val MAX_DISK_CACHE_SIZE = 40 * 1048576\n\n    var MAX_MEMORY_CACHE_SIZE = MAX_HEAP_SIZE / 4\n\n    //图片换图路径\n    const val IMAGE_PIPELINE_CACHE_DIR = \"ks_imagepipeline_cache\"\n    //webp后缀\n    const val OSS_WEBP = \"?x-oss-process=image/format,webp\"\n\n}\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580905635},"updatedAt":{"$$date":1598582231481},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cJTwYRtHmJCHFDZ8"}
{"name":"kqapp-lightlearn_module_base","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion BuildVersion.compile_sdk\n    buildToolsVersion BuildVersion.tool_version\n\n    defaultConfig {\n        minSdkVersion BuildVersion.min_sdk\n        targetSdkVersion BuildVersion.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        multiDexEnabled true\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n        //ARouter\n        javaCompileOptions {\n            annotationProcessorOptions {\n                arguments = [AROUTER_MODULE_NAME: project.getName()]\n            }\n        }\n        //可以使用kotlin 实验特性，比如Parcelize ，直接生成Parcelable\n        androidExtensions {\n            experimental = true\n        }\n        externalNativeBuild {\n            ndkBuild {\n                arguments 'NDK_DEBUG=0'\n            }\n        }\n\n        ndk {\n            abiFilters 'armeabi-v7a'\n        }\n    }\n\n    buildTypes {\n        //线上环境\n        release {\n            debuggable false\n\n            minifyEnabled false   //开启混淆\n            zipAlignEnabled false  //压缩优化\n\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"3\"\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"\n            buildConfigField \"boolean\", \"OPEN_TINGYUN\", \"true\"\n            buildConfigField \"boolean\", \"IS_OPEN_TRACK\", \"true\"\n            if (isMineModule.toBoolean()) {\n                buildConfigField \"int\", \"isMineModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isMineModule\", \"0\"\n            }\n\n            if (isLoginModule.toBoolean()) {\n                buildConfigField \"int\", \"isLoginModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isLoginModule\", \"0\"\n            }\n\n            if (isCourseModule.toBoolean()) {\n                buildConfigField \"int\", \"isCourseModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isCourseModule\", \"0\"\n            }\n\n            if (isProductModule.toBoolean()) {\n                buildConfigField \"int\", \"isProductModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isProductModule\", \"0\"\n            }\n\n            if (isHomeModule.toBoolean()) {\n                buildConfigField \"int\", \"isHomeModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isHomeModule\", \"0\"\n            }\n\n            if (isPictureSelectModule.toBoolean()) {\n                buildConfigField \"int\", \"isPictureSelectModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isPictureSelectModule\", \"0\"\n            }\n\n            externalNativeBuild {\n                ndkBuild {\n                    arguments 'NDK_DEBUG=0'\n                }\n            }\n            manifestPlaceholders = [\n                    //友盟\n                    UMENG_APPKEY: Placeholder.UMENG_APPKEY, //暂时填写默认值即可.\n            ]\n        }\n\n        debug {\n            debuggable true\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"0\"\n            buildConfigField \"boolean\", \"OPEN_TINGYUN\", \"false\"\n            buildConfigField \"boolean\", \"IS_OPEN_TRACK\", \"${isOpenTrack}\"\n            externalNativeBuild {\n                ndkBuild {\n                    arguments 'NDK_DEBUG=1'\n                }\n            }\n            if (isMineModule.toBoolean()) {\n                buildConfigField \"int\", \"isMineModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isMineModule\", \"0\"\n            }\n\n            if (isLoginModule.toBoolean()) {\n                buildConfigField \"int\", \"isLoginModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isLoginModule\", \"0\"\n            }\n\n            if (isCourseModule.toBoolean()) {\n                buildConfigField \"int\", \"isCourseModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isCourseModule\", \"0\"\n            }\n\n            if (isProductModule.toBoolean()) {\n                buildConfigField \"int\", \"isProductModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isProductModule\", \"0\"\n            }\n\n            if (isHomeModule.toBoolean()) {\n                buildConfigField \"int\", \"isHomeModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isHomeModule\", \"0\"\n            }\n\n            if (isPictureSelectModule.toBoolean()) {\n                buildConfigField \"int\", \"isPictureSelectModule\", \"1\"\n            } else {\n                buildConfigField \"int\", \"isPictureSelectModule\", \"0\"\n            }\n\n            manifestPlaceholders = [\n                    UMENG_APPKEY: Placeholder.UMENG_APPKEY, //暂时填写默认值即可.\n            ]\n\n        }\n\n        gama.initWith(debug)\n        gama {\n            buildConfigField \"boolean\", \"OPEN_TINGYUN\", \"false\"\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"2\"\n            debuggable true\n            matchingFallbacks = ['debug', 'release']\n        }\n\n        CDGama.initWith(gama)\n        CDGama {\n            buildConfigField \"boolean\", \"OPEN_TINGYUN\", \"true\"\n            debuggable true\n            matchingFallbacks = ['release', 'debug']\n        }\n\n        CDDebug.initWith(debug)\n        CDDebug {\n            buildConfigField \"boolean\", \"OPEN_TINGYUN\", \"true\"\n            signingConfig signingConfigs.debug\n            matchingFallbacks = ['release', 'debug']\n        }\n\n        dapi.initWith(debug)\n        dapi {\n            buildConfigField \"boolean\", \"OPEN_TINGYUN\", \"false\"\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"1\"\n            matchingFallbacks = ['debug', 'release']\n        }\n\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    buildFeatures.dataBinding = true\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation Kotlin.stdlib_jdk\n    implementation Kotlin.coroutines_core\n\n    //test\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test:runner:1.2.0'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    api Androidx.recyclerview\n    api Androidx.constraintlayout\n    api Androidx.cardview\n    api Androidx.multidex\n\n    //livedata ktx\n//    implementation deps.archLifecycle.lifecycle_livedata_ktx\n    //打渠道包用\n    implementation Deps.packer_ng\n//    //viewmodel ktx\n    api ArchLifecycle.lifecycle_viewmodel_ktx\n    api ArchLifecycle.lifecycle_runtime_ktx\n\n    //友盟 分析\n    implementation Deps.analytics\n\n    //路由\n    kapt Router.arouter_compiler\n    api Router.arouter_api\n\n    api(Ks_component.component_net) { changing = true }\n    implementation(Ks_lib.lib_route) { changing = true }\n\n//// Koin for Android\n//    api deps.koin.android\n//// Koin Android Scope features\n//    api deps.koin.android_scope\n\n// Koin Android ViewModel features\n    api Koin.android_viewmodel\n\n    api Deps.eventbus\n\n    api(Ks_lib.lib_share) { changing = true }\n    // 适配库-最小密度\n    api(Ks_lib.lib_autosize) { changing = true }\n    // 通用资源\n    api(Ks_component.component_resource) { changing = true }\n    // RecycleView 适配库\n    api Deps.ksladapter\n    // 图片库\n    api(Ks_lib.lib_picture) { changing = true }\n    // 扩展库\n    api(Ks_lib.lib_ktx) { changing = true }\n    // dialogplus\n    api Deps.dialogplus\n//    api deps.fastjson\n    // 持久化\n    api(Ks_lib.lib_persistence) { changing = true }\n    // 组件化 Application Core\n//    api (ks.lib_appmerge){ changing = true }\n    // 数据打点库\n    api(Ks_component.component_tracker) { changing = true }\n    // 空布局+错误布局\n    api(Ks_lib.lib_loading) { changing = true }\n    // fastjson 空构造函数需要，必要依赖\n//    api deps.kotlin.reflect\n    // 下拉刷新，上拉加载更多组件\n    api(Ks_lib.lib_pull_refresh) { changing = true }\n\n    api Deps.oss_android_sdk\n    //bugly\n    api Bugly.crashreport\n    implementation Bugly.nativecrashreport\n    //权限库\n    api Deps.andrpermission\n    //播放器\n    api(Ks_component.component_mediaplayer) { changing = true }\n\n    api Deps.gifdrawable\n\n    api (Ks_lib.lib_disk){ changing = true }\n\n    //glide\n    api Deps.glide\n    kapt Deps.glide_compile\n    //权限控制\n    api Deps.permissionDispatcher\n    kapt Deps.permissionDispatcher_compile\n\n//    启动优化 第三方库\n    implementation Deps.appStartFaster\n    //原力系统\n    api(Ks_component.component_theforcesystem) { changing = true }\n\n    api Deps.ucrop\n    /** 图片选择 */\n    api (Ks_lib.lib_media){\n        changing = true\n        exclude(group:'com.orhanobut', module:'dialogplus')\n        exclude(group:'com.ks.ksdialogplus', module:'ksdialogplus')\n    }\n    //多种webview\n    api Ks.kswebview\n}\n\n\n\n\n\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    package=\"com.ks.lightlearn.base\">\n\n\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    <uses-permission android:name=\"android.permission.CALL_PHONE\" />\n    <uses-permission android:name=\"android.permission.READ_LOGS\" />\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <uses-permission android:name=\"android.permission.REQUEST_INSTALL_PACKAGES\" />\n\n    <application>\n        <!--x5-->\n        <service\n            android:name=\"com.tencent.smtt.export.external.DexClassLoaderProviderService\"\n            android:label=\"dexopt\"\n            android:process=\":dexopt\"></service>\n\n        <!-- 拍照适配权限-->\n        <provider\n            android:name=\".provider.TakepictureProvider\"\n            android:authorities=\"${applicationId}.takepictureprovider\"\n            android:exported=\"false\"\n            android:grantUriPermissions=\"true\"\n            tools:replace=\"android:authorities\">\n            <meta-data\n                android:name=\"android.support.FILE_PROVIDER_PATHS\"\n                android:resource=\"@xml/filepaths\" />\n        </provider>\n\n        <activity\n            android:name=\"com.ks.lightlearn.wxapi.WXEntryActivity\"\n            android:configChanges=\"keyboardHidden|orientation|screenSize\"\n            android:exported=\"true\"\n            android:screenOrientation=\"fullSensor\"\n            />\n\n        <meta-data\n            android:name=\"UMENG_APPKEY\"\n            android:value=\"${UMENG_APPKEY}\"\n            tools:replace=\"android:value\" />\n        <meta-data\n            android:name=\"UMENG_CHANNEL\"\n            android:value=\"${UMENG_CHANNEL_VALUE}\" />\n    </application>\n</manifest>\n\n\n\n\n\n\n\nxml\nfilepaths.xml\nnetwork_security_config.xml\n\n\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<paths>\n    <external-path\n        path=\"/takepicture\"\n        name=\"external-path\" />\n    <root-path\n        name=\"root_path\"\n        path=\".\" />\n</paths>\n\n\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <base-config cleartextTrafficPermitted=\"true\" />\n</network-security-config>\n\n\n\n\n\n\n\n\n\nassets\n    cdn_kaishuhe_com.pem\n    charles-ssl-proxying-certificate.pem\n    kaishustorycom.pem\n    ksjgs_com.pem\n    new_kaishustorycom.pem\n    new_ksjgs_com.pem\n    sourceConfig.properties\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass BusMsg<T : Any?> {\n\n    var code: Int = 0\n    var data: T? = null\n\n\n    constructor(code: Int, data: T) {\n        this.code = code\n        this.data = data\n    }\n\n    override fun toString(): String {\n        return \"EventMessage{code=$code, data=$data}\"\n    }\n\n    companion object {\n\n        /**********************************************商品模块 Start*****************************************************************/\n        const val PRODUCT_ADDRESS_SELECT_EVENT = 0x20001\n        const val PRODUCT_ADDRESS_ADD_SELECT_EVENT = 0x20002\n        const val PRODUCT_ADDRESS_UPDATE_SELECT_EVENT = 0x20003\n        const val PRODUCT_ADDRESS_DELETE_ALL_EVENT = 0x20004\n        /**********************************************商品模块 End*****************************************************************/\n\n        /**********************************************登录模块 Start*****************************************************************/\n        const val SIGN_IN = 0x30001\n        const val SIGN_OUT = 0x30002\n        const val UPDATE_USER_INFO = 0x30003\n        const val LOGIN_CLOSE_LOGIN_PAGE_EVENT = 0x30004\n        const val JUMP_LIMIT_LOGIN_PAGE = 0x30005\n        const val JUMP_WRITTEN_OFF_PAGE = 0x30006\n\n        /**********************************************登录模块 End*****************************************************************/\n\n        /**********************************************支付模块 Start*****************************************************************/\n        const val PAY_COURSE_RESULT_EVENT = 0x40000\n        /**********************************************支付模块 End*****************************************************************/\n\n        /**********************************************图片选择模块 Start*****************************************************************/\n        const val PICTURE_SELECT_EVENT = 0x50000\n        /**********************************************图片选择模块 End*****************************************************************/\n\n        /**********************************************首页模块 Start*****************************************************************/\n        const val REC_COURSE_REFRESH = 0x60000\n        //首页完全展示出来后\n        const val MAINTAB_RESUME = 0x60001\n        //宠物满级，点击更换按钮跳转到h5,时发送次事件\n        const val NEED_REFRESH_CURRENT_PET = 0x60002\n        /**********************************************首页模块 End*****************************************************************/\n\n\n        /**********************************************课中模块 Start*****************************************************************/\n        const val NET_CHANGE_TO_WIFI = 0x70000\n        const val STUDY_ACCOMPANY_STATUS = 0x70001\n\n//        课中 挽留弹窗显示了\n        const val COURSE_DETAIN_DIALOG_SHOW = 0x70002\n        //        课中 挽留弹窗隐藏了\n        const val COURSE_DETAIN_DIALOG_HIDE = 0x70003\n\n\n\n        /**********************************************课中模块 End*****************************************************************/\n        /**********************************************线下作业 start*****************************************************************/\n        // 线下作业 返回课程页面\n        const val COURSE_LIST_TO_HOMEWORK_TAB = 0x80001\n        //上传失败\n        const val UPLOAD_FAILED = 0x80002\n\n        /**********************************************线下作业 End*****************************************************************/\n        /**\n         * 网络已连接\n         */\n        const val NET_WORK_IS_CONNECTED = 0x90001\n\n        /**\n         * 网络断开\n         */\n        const val NET_WORK_DIS_CONNECTED = 0x90002\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n@IntDef({\n            SdkPayResult.PAY_FINISH,\n            SdkPayResult.PAY_CANCEL,\n            SdkPayResult.PAY_FAIL\n    })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface SdkPayResult {\n        int PAY_FINISH = 0;\n        int PAY_CANCEL = -2;\n        int PAY_FAIL = -1;\n    }\n\n\n\n\n\n\nsealed class KsPayResult {\n    //成功\n    object SUCCEED : KsPayResult()\n    //失败\n    class FAILED(val errCode:String=\"\",val errMsg:String=\"\") : KsPayResult()\n    //取消\n    object CANCELED : KsPayResult()\n\n}\n\n\n\n\n\n\n\nenum class BasePayResult(val result: Int) {\n    SUCCESS(1),\n    CANCLE(0),\n    FAIL(-1)\n}\n\n\n\n\n\n\n@Parcelize\ndata class ProductConfirmOrderBean(val productId: Long? = -1, val skuParams: List<ProductSkuBean>? = null,\n                                   val stageId: String? = \"\", var productName: String? = \"\",\n                                   var iconUrl: String? = \"\", var termStartTime: Long = -1,\n                                   var showPrice: String? = \"\", var specialPrice: String? = \"\",\n                                   var realPayPrice: String? = \"\") : Parcelable\n\n\n\n\n\n\n\n\n\n\nobject GlobalConstants {\n    const val APP_PACKAGENAME: String = \"com.ks.lightlearn\"\n    //带有报名的资源路径\n    const val APP_PACKAGENAME_RES = \"res://com.ks.lightlearn/\"\n\n    const val imageStar = \"image/*\"\n\n   // const val FILE_DIRECTORY = \"/downloadFile\"\n\n    const val KEY_FROM_ACTIVITY = \"key_origin_activity\"\n\n\n    //友盟\n    const val UMENG_APP_KEY = \"5e4664fb0cafb24c060000c3\"\n    //微信\n    const val WX_APP_ID = \"wx0d919bf5e2c117dc\"\n    const val WX_APP_SECRET = \"6fe8ad6937c5bd83b7d4a4cba74b4211\"\n    //数盟\n    const val SM_ID = \"MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAM7ZGxc0CUT0iWX/IaJlW9LTSixYXwdnrxbBRH0Rq3brEuvSpcmEcXFx8CEtHLOrsJytb/P/2rNrgxIBhcdVW5MCAwEAAQ==\"\n    //听云\n    const val NBS_APP_ID = \"89d84638ea594c15a004e7896f96bd7f\"\n    //bugly\n    const val BUGLY_ID = \"c90ac2699e\"\n    //智聆\n    const val kOralEvaluationAppId = \"1255565373\"\n    const val kOralEvaluationSecretId = \"AKIDnMk296QfBfjgW2vd1ylwKRI2h9MNfZiQ\"\n    const val kOralEvaluationSecretKey = \"nJZ4NPBgwwf7TfeOr52iAXfYha2FApOm\"\n    //oss\n    const val OSSAccessKeyId = \"LTAIFV6tPAL2UHnG\"\n    const val OSSAccessKeySecret = \"fNTFHqD9ehYWnvQ8fafmXBqkBWIrdP\"\n    //智齿\n    const val SOBOT_APP_ID = \"fa80061a5aed4daea4a4393801cd70bb\"\n\n    const val REQUEST_CODE_SETTING = 101\n\n\n}\n\n\n\n\n\n\n\nobject ProductConstants {\n    // 路由跳转 带参\n    const val NEW_USER_ADDRESS_FLAG = \"new_user_address_flag\"\n    const val IS_FROM_CONFIRMORDER_FLAG = \"is_from_confirmorder_flag\"\n    const val EDIT_USER_ADDRESS_ADDRID = \"edit_user_address_addrid\"\n    // 选择地址页面 参数\n    const val USER_ADDRESS_FROM_CONFIRM_PAGE_FLAG = \"user_address_from_confirm_page_flag\"\n    const val USER_ADDRESS_FROM_CONFIRM_PAGE_ADDRID = \"user_address_from_confirm_page_addrid\"\n    // 确定订单页面 参数\n    const val CONFIRM_PAGE_PRODUCTID = \"confirm_page_productid\"\n    const val CONFIRM_PAGE_SKUPARAMS = \"confirm_page_skuparams\"\n    const val CONFIRM_PAGE_STAGEID = \"confirm_page_stageid\"\n    const val CONFIRM_PAGE_PERIODID = \"confirm_page_periodid\"\n    // 报名成功页面 参数\n    const val REGISTER_SUCCESS_PAGE_STAGEID = \"register_success_page_stageid\"\n    const val REGISTER_SUCCESS_PAGE_TRADENO = \"register_success_page_tradeno\"\n    const val REGISTER_SUCCESS_PAGE_FROM = \"register_success_page_from\"\n\n    // 0 是 确认订单页面  1 是商品详情页(Integer)\n    enum class RegisterPage(val value: Int) {\n        ProductDetailPage(1),\n        ConfirmOrderPage(0)\n    }\n\n    // 物流信息页面\n    const val PRODUCT_LOGISTICS_INFO_TRADENO = \"product_logistics_info_tradeno\"\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 扩展bundle argments 传值就比较方便了\n *\n * -------------------------before---------------------\n *    arguments = Bundle().apply {\n *      putString(ARG_PARAM1, param1)\n *      putInt(ARG_PARAM2, param2)\n *     }\n *\n * --------------------------after-------------------\n *     arguments = Bundle().apply {\n *     put(ARG_PARAM1,param1)\n *     put(ARG_PARAM2,param2)\n *     }\n *\n */\n\n\n\n\n\n\n\n\nfun <T> Bundle.put(key: String, value: T) {\n    when (value) {\n        is Boolean -> putBoolean(key, value)\n        is String -> putString(key, value)\n        is Int -> putInt(key, value)\n        is Short -> putShort(key, value)\n        is Long -> putLong(key, value)\n        is Byte -> putByte(key, value)\n        is ByteArray -> putByteArray(key, value)\n        is Char -> putChar(key, value)\n        is CharArray -> putCharArray(key, value)\n        is CharSequence -> putCharSequence(key, value)\n        is Float -> putFloat(key, value)\n        is Bundle -> putBundle(key, value)\n        is Parcelable -> putParcelable(key, value)\n        is Serializable -> putSerializable(key, value)\n        else -> throw IllegalStateException(\"Type of property $key is not supported\")\n    }\n}\n\n\nclass FragmentBundleDataDelegate<T : Any> : ReadWriteProperty<Fragment, T> {\n    /**\n     * Returns the value of the property for the given object.\n     * @param thisRef the object for which the value is requested.\n     * @param property the metadata for the property.\n     * @return the property value.\n     */\n    override fun getValue(thisRef: Fragment, property: KProperty<*>): T {\n        return thisRef.arguments?.get(property.name) as? T ?:  throw IllegalStateException(\"Property ${property.name} could not be read\")\n    }\n\n    /**\n     * Sets the value of the property for the given object.\n     * @param thisRef the object for which the value is requested.\n     * @param property the metadata for the property.\n     * @param value the value to set.\n     */\n    override fun setValue(thisRef: Fragment, property: KProperty<*>, value: T) {\n        val args = thisRef.arguments ?: Bundle().also { thisRef::setArguments }\n        args.put(property.name, value)\n    }\n}\n\n\nclass FragmentBundleNullAbleDelegate<T:Any?>:ReadWriteProperty<Fragment,T?>{\n    /**\n     * Sets the value of the property for the given object.\n     * @param thisRef the object for which the value is requested.\n     * @param property the metadata for the property.\n     * @param value the value to set.\n     */\n    override fun setValue(thisRef: Fragment, property: KProperty<*>, value: T?) {\n        val args = thisRef.arguments ?: Bundle().also(thisRef::setArguments)\n\n        value?.let { args.put(property.name, it) } ?: args.remove(property.name)\n    }\n\n    override fun getValue(thisRef: Fragment, property: KProperty<*>): T? {\n        return thisRef.arguments?.get(property.name) as? T\n\n    }\n\n}\n\nfun <T : Any> argument(): ReadWriteProperty<Fragment, T> = FragmentBundleDataDelegate()\n\nfun <T : Any> argumentNullable(): ReadWriteProperty<Fragment, T?> = FragmentBundleNullAbleDelegate()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass NetComponentConfigImpl : NetComponent.NetConfig {\n\n    val userInfoProvider: UserInfoProvider? by lazy { KsRouterHelper.buildUserInfoProvider() as? UserInfoProvider }\n\n    private var mMac: String by Preference(\"mac\", \"\")\n\n    override fun isNeedSSL(): Boolean {\n        return true\n    }\n\n\n    override fun getMac(): String {\n        return mMac\n    }\n\n    override fun getPemFile(): File {\n      return DiskManager.getInstance().getType(DiskManager.DIR_TYPE_PEM).file\n    }\n\n\n    override fun saveMac(mac: String) {\n        mMac = mac\n    }\n\n    override fun baseUrl(): String {\n        return HttpConfigManager.baseUrl()\n    }\n\n    override fun getAssetsPems(): MutableList<InputStream> {\n        val certificates: MutableList<InputStream> = ArrayList()\n\n        try {\n            //old *.kaishustory\n            val kaishu = BaseApplication.instance.assets.open(\"kaishustorycom.pem\")\n            certificates.add(kaishu)\n            //new *.kaishustory\n            val newkaishu = BaseApplication.instance.assets.open(\"new_kaishustorycom.pem\")\n            certificates.add(newkaishu)\n            // charles\n            val charles = BaseApplication.instance.assets.open(\"charles-ssl-proxying-certificate.pem\")\n            certificates.add(charles)\n            // cdn\n            val hezi = BaseApplication.instance.assets.open(\"cdn_kaishuhe_com.pem\")\n            certificates.add(hezi)\n            //old  ksjgs(短域名)\n            val ksjgs = BaseApplication.instance.assets.open(\"ksjgs_com.pem\")\n            certificates.add(ksjgs)\n            //new ksjgs(短域名)\n            val newksjgs = BaseApplication.instance.assets.open(\"new_ksjgs_com.pem\")\n            certificates.add(newksjgs)\n\n        } catch (e: Exception) {\n        }\n\n        return certificates\n    }\n\n    override fun getHeaderMap(): Map<String, String> {\n        return HashMap<String, String>().apply {\n            put(NetConstants.TOKEN, TokenHolder.token)\n            put(NetConstants.DEVICE_ID, DeviceIdHolder.deviceId!!)\n            put(NetConstants.APP_DEVICE_ID, DeviceIdHolder.appDeviceId!!)\n            put(NetConstants.APPVERSION, BaseApplication.instance.versionName)\n            put(NetConstants.ACCEPT_ENCODING, \"identity\")\n            put(NetConstants.APIVER, \"2.4\")\n            put(NetConstants.APPID, HttpConfigManager.getAppId())\n            put(NetConstants.CHANNELID, HttpConfigManager.getUmengChannel())\n            put(NetConstants.CLIENTFORM, HttpConfigManager.getClientFrom())\n            put(NetConstants.USERSOURCE, HttpConfigManager.getAppName())\n            put(NetConstants.USERID, userInfoProvider?.getUserId().toString())\n            put(NetConstants.DEVICE, \"android\")\n            put(NetConstants.PLATFORM, HttpConfigManager.getAppName())\n            if (ActivityCompat.checkSelfPermission(NetComponent.application, Manifest.permission.READ_PHONE_STATE)\n                    == PackageManager.PERMISSION_GRANTED) { //有权限，去加上mcccode\n                BaseApplication.instance.telephonyManager?.run {\n                    put(NetConstants.MCCCODE, this.getMobileMCC(NetComponent.application))\n                }\n            }\n        }\n    }\n\n    override fun application(): Application {\n        return BaseApplication.instance\n    }\n\n    override fun netRequestTarget(): Int {\n        return HttpConfigManager.env\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass NetLoginCallbackImpl : NetComponent.LogingCallback {\n\n    override fun handleLoginCode(code: Int) {\n        when (code) {\n            //多人登录\n            LoginConstants.DEVICE_LIMITE_CODE -> {\n                BusProvider.instance?.post(BusMsg(BusMsg.JUMP_LIMIT_LOGIN_PAGE, LoginConstants.EXTRA_DATA_CODE_EXIT))\n            }\n            //封杀登录\n            LoginConstants.DEVICE_BLOCK_LOGIN_CODE -> {\n                BusProvider.instance?.post(BusMsg(BusMsg.JUMP_LIMIT_LOGIN_PAGE, LoginConstants.EXTRA_DATA_CODE_BLOCK_LOGIN))\n            }\n            //账号注销\n            LoginConstants.ACCOUNTCANCELLATION_CODE -> {\n                BusProvider.instance?.post(BusMsg(BusMsg.JUMP_WRITTEN_OFF_PAGE, null))\n            }\n        }\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\nclass TheForceSystemConfigImpl : TheForceSystemDelegate.TheForceSystemConfig {\n\n    override fun createRequestBody(jsonObject: JSONObject): RequestBody {\n        return jsonObject.toString().toRequestBody()\n    }\n\n    override fun getAppName(): String {\n        return \"kschinese\"\n    }\n\n    override fun getEnv(): Int {\n        return HttpConfigManager.env()\n    }\n\n    /**\n     * 请求原力资源h5host\n     * @return String?\n     */\n    override fun getH5Host(): String? {\n        return HttpH5Manager.getH5Domain()\n    }\n\n    /**\n     * 需要进行原力加载的路径资源\n     * @return List<File>\n     */\n    override fun getNeedCheckLocalSourceFile(): List<File> {\n        var files = arrayListOf<File>()\n        val h5PageType = DiskManager.getInstance().getType(IDiskManager.DIR_TYPE_H5_RES)\n        val downloadPageType = DiskManager.getInstance().getType(IDiskManager.DIR_TYPE_DOWNLAOD)\n        files.add(h5PageType.file)\n        files.add(downloadPageType.file)\n        return files\n    }\n\n    /**\n     * 原力系统的根目录\n     * @return File?\n     */\n    override fun getTheForceRootFile(): File? {\n        return DiskManager.getInstance().getType(IDiskManager.DIR_TYPE_H5_RES).file\n    }\n\n    override fun getVersionName(): String {\n        return BaseApplication.instance.versionName\n    }\n\n    override fun webviewResourceOptimization(createJson: JsonObject) {\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author guanhuawei\n * 邮箱：guanhuawei@ksjgs.com\n * 创建时间: 2020/3/5     2:50 PM\n * 用途  打点的代理\n ***************************************\n\n */\nclass TrackerDelegateImpl : KsTrackerDelegate.KsTrackerConfig {\n\n    val userInfoProvider: UserInfoProvider? by lazy { KsRouterHelper.buildUserInfoProvider() as? UserInfoProvider }\n\n    override fun getDynamicSuperProperties(): JSONObject {\n\n        return JSONObject().apply {\n            put(\"uid\", userInfoProvider?.getUserId() ?: \"-\")\n            put(\"app_version\", BaseApplication.instance.versionName)\n            if (TimeZone.getDefault() != null) {\n                put(\"tz\", TimeZone.getDefault().id)\n                put(\"sid\", sid)\n                put(\"ssid\", ssid)\n                put(\"cdid\", DeviceIdHolder.cdid)\n                put(\"pm\", Build.MODEL)\n                put(\"pdc\", DeviceUtils.getDeviceIdSameImei(BaseApplication.instance))\n            }\n        }\n    }\n\n    companion object {\n        private const val KEY_MAX_COUNT = \"key_max_count\"\n        private const val KEY_INTERVAL = \"key_interval\"\n        var sid: Long = 0\n        var ssid: Long = 0\n        var maxCount: Int by Preference(KEY_MAX_COUNT, 1000)\n        var interval: Int by Preference(KEY_INTERVAL, 15)\n    }\n\n    override fun getProjectName(): String {\n        return \"android-story\"\n    }\n\n    override fun getDeviceId(): String {\n        return DeviceIdHolder.deviceId!!\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\nobject UserInfoHolder {\n    private val userInfoProvider by lazy { KsRouterHelper.buildUserInfoProvider() as? UserInfoProvider }\n\n    fun getUserId(): Int?{\n        return userInfoProvider?.getUserId()\n    }\n\n    fun clearUserInfo(){\n        userInfoProvider?.clearUserInfo()\n    }\n\n    fun isLogined(): Boolean{\n        return userInfoProvider?.isLogined()?:false\n    }\n\n    fun saveUser(userinfo: BaseUserInfoVO){\n        userInfoProvider?.saveUser(userinfo)\n    }\n\n    fun login(){\n        userInfoProvider?.login()\n    }\n\n    fun getUserJson(): String?{\n        return userInfoProvider?.getUserJson()\n    }\n\n    suspend fun loginOut(): Boolean{\n        return userInfoProvider?.loginOut()?:false\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author Saifei\n * 邮箱：liangsaifei@ksjgs.com\n * 创建时间: 2019/12/31     2:10 PM\n * 用途\n ***************************************\n\n */\nobject HttpConfigManager {\n\n    /////////////////不同环境的 baseurl///////////////////////////\n    /**\n     * 轻课baseurl各个环境\n     */\n    private const val TEST_SERVER_URL = \"https://tyuwen.kaishustory.com\"\n    private const val DEVELOP_SERVER_URL = \"https://dyuwen.kaishustory.com\"\n    private const val GAMA_SERVER_URL = \"https://gyuwen.kaishustory.com\"\n    private const val NORMAL_SERVER_URL = \"https://yuwen.kaishustory.com\"\n\n    /**\n     * 轻课打点上报各个环境\n     */\n    private const val DBDPLOG_SERVER_URL = \"https://ddyw-bdplog.kaishustory.com\"\n    private const val TBDPLOG_SERVER_URL = \"https://tdyw-bdplog.kaishustory.com\"\n    private const val GBDPLOG_SERVER_URL = \"https://gdyw-bdplog.kaishustory.com\"\n    private const val BDPLOG_SERVER_URL = \"https://dyw-bdplog.kaishustory.com\"\n\n    /**\n     * 通用接口\n     */\n    private const val TEST_API_URL = \"https://tapi.kaishustory.com\"\n    private const val DEVELOP_API_URL = \"https://dapi.kaishustory.com\"\n    private const val GAMA_API_URL = \"https://gapi.kaishustory.com\"\n    private const val NORMAL_API_URL = \"https://api.kaishustory.com\"\n\n    //测试\n    const val ENV_DEBUG = 0\n    //开发\n    const val ENV_DAPI = 1\n    //预上线\n    const val ENV_GAMA = 2\n    //线上\n    const val ENV_RELEASE = 3\n    ////////////////////////////////////////////\n\n    var env = BuildConfig.NET_REQUEST_TARGET\n\n    fun getBaseUrlMap(): MutableMap<String, String> {\n        return hashMapOf(\n                Pair(\"accesslogs\", accessBaseUrl()),\n                Pair(\"common\", commonBaseUrl())\n        )\n    }\n\n    private fun commonBaseUrl(): String =\n            when (env()) {\n                ENV_DEBUG ->\n                    TEST_API_URL\n                ENV_DAPI ->\n                    DEVELOP_API_URL\n                ENV_GAMA ->\n                    GAMA_API_URL\n                ENV_RELEASE ->\n                    NORMAL_API_URL\n                else ->\n                    NORMAL_API_URL\n            }\n\n    fun baseUrl(): String {\n        Log.d(javaClass.simpleName, \"baseUrl: \" + getUrlByEnv())\n        return getUrlByEnv()\n    }\n\n\n    fun env(): Int {\n        Log.d(javaClass.simpleName, \"env: $env\")\n        return env\n    }\n\n    /**\n     * 打点的baseurl\n     * @return String\n     */\n    private fun accessBaseUrl(): String {\n        return getaccessUrlByEnv()\n    }\n\n    private fun getaccessUrlByEnv(): String =\n            when (env()) {\n                ENV_DEBUG ->\n                    TBDPLOG_SERVER_URL\n                ENV_DAPI ->\n                    DBDPLOG_SERVER_URL\n                ENV_GAMA ->\n                    GBDPLOG_SERVER_URL\n                ENV_RELEASE ->\n                    BDPLOG_SERVER_URL\n                else ->\n                    BDPLOG_SERVER_URL\n            }\n\n    /**\n     * 根据环境返回对应的url\n     */\n    private fun getUrlByEnv(): String =\n            when (env()) {\n                //\n                ENV_DEBUG ->\n                    TEST_SERVER_URL\n                ENV_DAPI ->\n                    DEVELOP_SERVER_URL\n                ENV_GAMA ->\n                    GAMA_SERVER_URL\n                ENV_RELEASE ->\n                    NORMAL_SERVER_URL\n                else ->\n                    NORMAL_SERVER_URL\n            }\n\n\n    fun getAppId(): String =\n            when (env()) {\n                ENV_DEBUG, ENV_DAPI -> {\n                    \"112233\"\n                }\n                ENV_GAMA, ENV_RELEASE -> {\n                    \"528613\"\n                }\n                else -> \"528613\"\n            }\n\n    /**\n     * 获取友盟返回的渠道\n     *\n     * @return 返回的渠道\n     */\n    fun getUmengChannel(): String {\n        BaseApplication.instance?.let {\n            val channel: String? = AnalyticsConfig.getChannel(it)\n            if (!TextUtils.isEmpty(channel)) {\n                return channel?:\"ks\"\n            }\n        }\n        val marketChannel = BaseApplication.marketChannel\n        return if (marketChannel.isNullOrEmpty()) \"ks\" else marketChannel\n    }\n\n    fun getClientFrom(): String {\n        return \"android\"\n    }\n\n    fun getAppName(): String {\n        return \"ksyuwen\"\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * **************************************\n * 项目名称:KsLightLearn\n *\n * @Author guanhuawei\n * 邮箱：guanhuawei@ksjgs.com\n * 创建时间: 2020-3-14     18:37\n * 用途：h5的链接统一管理\n * **************************************\n */\nobject HttpH5Manager {\n\n    /**\n     * h5的各个开发环境\n     */\n    private const val RELEASE_H5_DOMAIN = \"weixin.kaishustory.com\"\n    private const val GAMA_H5_DOMAIN = \"gweixin.kaishustory.com\"\n    private const val DEBUG_H5_DOMAIN = \"tweixin.kaishustory.com\"\n\n    /**\n     * 隐私协议\n     */\n    object Secret {\n        const val debug = \"https://tweixin.kaishustory.com/frequent/staticPage/mtest/pgPrivacyAgreement\"\n        const val gama = \"https://gweixin.kaishustory.com/frequent/staticPage/gtest/pgPrivacyAgreement\"\n        const val release = \"https://weixin.kaishustory.com/frequent/staticPage/kspage/pgPrivacyAgreement\"\n    }\n\n    /**\n     * 服务协议\n     */\n    object Service {\n        const val debug = \"https://tweixin.kaishustory.com/frequent/staticPage/mtest/pgServiceAgreement\"\n        const val gama = \"https://gweixin.kaishustory.com/frequent/staticPage/gtest/pgServiceAgreement\"\n        const val release = \"https://weixin.kaishustory.com/frequent/staticPage/kspage/pgServiceAgreement\"\n    }\n\n    /**\n     * 儿童保护协议\n     */\n    object ChildProtect {\n        const val debug = \"https://tweixin.kaishustory.com/frequent/staticPage/mtest/pgProtectionPolicye\"\n        const val gama = \"https://gweixin.kaishustory.com/frequent/staticPage/gtest/pgProtectionPolicye\"\n        const val release = \"https://weixin.kaishustory.com/frequent/staticPage/kspage/pgProtectionPolicye\"\n    }\n\n\n    /**\n     * 注销页\n     */\n    object WriteOff {\n        const val debug = \"https://tweixin.kaishustory.com/frequent/staticPage/mtest/pgLogoutAgreement\"\n        const val gama = \"https://gweixin.kaishustory.com/frequent/staticPage/gtest/pgLogoutAgreement\"\n        const val release = \"https://weixin.kaishustory.com/frequent/staticPage/kspage/pgLogoutAgreement\"\n    }\n\n\n    fun getH5Domain(): String {\n        when (HttpConfigManager.env()) {\n            0, 1 -> return DEBUG_H5_DOMAIN\n            2 -> return GAMA_H5_DOMAIN\n            3 -> return RELEASE_H5_DOMAIN\n        }\n        return RELEASE_H5_DOMAIN\n    }\n\n    /**\n     * 获取学习报告的接口\n     * @param courseId Long\n     */\n    fun getStudyReport(courseId: String): String {\n        return \"https://${getH5Domain()}/pangu/studyReport?courseId=$courseId\"\n    }\n\n    /**\n     * 学习伙伴（宠物列表）的接口\n     */\n    fun getStudyPartner(): String {\n        return \"https://${getH5Domain()}/pangu/studyPartner\"\n    }\n\n\n    /**\n     * 获取小程序环境\n     * @return Int\n     */\n    fun getSmallProgram(): Int {\n        return when (HttpConfigManager.env()) {\n            HttpConfigManager.ENV_DEBUG,\n            HttpConfigManager.ENV_DAPI -> 1\n            else -> 0\n        }\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author jiaruihua\n * 邮箱：jiaruihua@ksjgs.com\n * 创建时间: 2020/8/10     2:19 PM\n * 用途:\n ***************************************\n */\nclass FrescoImageEngine : IPicLoader {\n    override fun loadImage(context: Context? , imageview: ImageView? , path: String?) {\n        loadImage(context,imageview,path,0,false)\n    }\n\n    override fun loadImage(context: Context? , imageview: ImageView? , path: String? , conners: Int,isFitCenter:Boolean) {\n        loadImage(context,imageview,path,conners,false,null)\n    }\n\n    override fun loadImage(context: Context? , imageView: ImageView? , path: String? , corners:Int,isFitCenter:Boolean,listener: PicLoadListener?) {\n\n\n        var params = imageView?.layoutParams\n        if (params == null) {\n            params = ViewGroup.LayoutParams(200, 200)\n        }\n\n        if (params.width == ViewGroup.LayoutParams.WRAP_CONTENT) {\n            params.width = ViewGroup.LayoutParams.MATCH_PARENT\n        }\n        if (params.height == ViewGroup.LayoutParams.WRAP_CONTENT) {\n            params.height = ViewGroup.LayoutParams.MATCH_PARENT\n        }\n        imageView?.layoutParams = params\n        var hierarchy: GenericDraweeHierarchy? = null\n        val hierarchyBuilder = GenericDraweeHierarchyBuilder.newInstance(imageView?.context?.resources)\n        var draweeHolder: DraweeHolder<*>? = null\n        val tag = imageView?.getTag(R.id.baseline)\n        if(tag!=null) {\n            draweeHolder = tag  as DraweeHolder<*>\n        }\n        var uri: Uri? = null\n        if (!TextUtils.isEmpty(path) && !path!!.contains(\"http\")) {\n            // 本地文件\n            uri = Uri.parse(\"file://\" + path)\n        } else {\n            uri =  Uri.parse(path)\n        }\n        if (uri == null) {\n            return\n        }\n\n        if (hierarchy == null) {\n            hierarchy = hierarchyBuilder.build()\n        }\n        if (isFitCenter) {\n            // 宽适配\n            hierarchy?.setActualImageScaleType(ScalingUtils.ScaleType.FIT_CENTER)\n        }\n        val controllerBuilder = Fresco.newDraweeControllerBuilder().setUri(uri).setAutoPlayAnimations(true)\n        val imageRequestBuilder = ImageRequestBuilder.newBuilderWithSource(uri)\n\n        val request = imageRequestBuilder.build()\n        controllerBuilder.setImageRequest(request)\n\n        if (listener!=null) {\n            controllerBuilder.controllerListener = object : ControllerListener<Any> {\n                override fun onSubmit(id: String?, callerContext: Any?) {}\n                override fun onFinalImageSet(id: String?, imageInfo: Any?, animatable: Animatable?) {\n\n                    listener?.onSuccess()\n                }\n\n                override fun onIntermediateImageFailed(id: String?, throwable: Throwable?) {\n\n                    listener?.onFail()\n                }\n                override fun onFailure(id: String?, throwable: Throwable?) {\n                    listener?.onFail()\n                }\n\n                override fun onRelease(id: String?) {}\n                override fun onIntermediateImageSet(id: String?, imageInfo: Any?) {\n\n                }\n            }\n        }\n        val controller: DraweeController\n\n        if (draweeHolder == null) {\n            draweeHolder = DraweeHolder.create(hierarchy,context)\n            controller = controllerBuilder.build()\n        } else {\n            controller = controllerBuilder.setOldController(draweeHolder.controller).build()\n        }\n        // 请求\n        draweeHolder?.controller = controller\n\n\n        val mStatesListener = ViewStatesListener(draweeHolder)\n\n        imageView?.addOnAttachStateChangeListener(mStatesListener)\n\n        // 判断是否ImageView已经 attachToWindow\n        if (imageView!=null&& ViewCompat.isAttachedToWindow(imageView)) {\n            draweeHolder?.onAttach()\n        }\n\n        // 保证每一个ImageView中只存在一个draweeHolder\n        imageView?.setTag(R.id.baseline, draweeHolder)\n        // 拿到数据\n        // 拿到数据\n        imageView?.setImageDrawable(draweeHolder?.topLevelDrawable)\n    }\n\n    override fun loadGif(context: Context?, imageView: ImageView?, path: String?, conners: Int, isFitCenter: Boolean, listener: PicLoadListener?) {\n        loadImage(context,imageView,path, conners,isFitCenter,listener)\n    }\n\n\n    class ViewStatesListener(private val holder: DraweeHolder<*> ?) : View.OnAttachStateChangeListener {\n        override fun onViewAttachedToWindow(v: View?) {\n            holder?.onAttach()\n\n        }\n\n        override fun onViewDetachedFromWindow(v: View?) {\n            holder?.onDetach()\n\n        }\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\nclass GlideImageEngine : IPicLoader {\n\n    override fun loadGif(context: Context?, imageView: ImageView?, path: String?, conners: Int, isFitCenter: Boolean, listener: PicLoadListener?) {\n        if (context != null && imageView != null && path != null) {\n            Glide.with(context)\n                    .load(path)\n                    .placeholder(R.drawable.default_can_scale_bg)\n                    .fitCenter()\n                    .addListener(object : RequestListener<Drawable> {\n\n                        override fun onLoadFailed(e: GlideException?, model: Any?, target: Target<Drawable>?, isFirstResource: Boolean): Boolean {\n                            listener?.onFail()\n                            return true\n                        }\n\n\n                        override fun onResourceReady(resource: Drawable?, model: Any?, target: Target<Drawable>?, dataSource: DataSource?, isFirstResource: Boolean): Boolean {\n                            listener?.onSuccess()\n                            return true\n                        }\n\n                    })\n                    .into(imageView)\n        }\n\n\n    }\n\n\n    override fun loadImage(context: Context?, imageView: ImageView?, path: String?) {\n        if (context != null && imageView != null && path != null) {\n            Glide.with(context)\n                    .load(path)\n                    .placeholder(R.drawable.default_can_scale_bg)\n                    .fitCenter()\n                    .into(imageView)\n\n        }\n    }\n\n    override fun loadImage(context: Context?, imageview: ImageView?, path: String?, conners: Int, isFitCenter: Boolean) {\n        if (context != null && imageview != null && path != null) {\n            Glide.with(context)\n                    .load(path)\n                    .placeholder(R.drawable.default_can_scale_bg)\n                    .fitCenter()\n                    .apply(RequestOptions.bitmapTransform(RoundedCorners(if (conners > 0) conners else 1)))\n                    .into(imageview)\n\n        }\n    }\n\n    override fun loadImage(context: Context?, imageview: ImageView?, path: String?, conners: Int, isFitCenter: Boolean, listener: PicLoadListener?) {\n        if (context != null && imageview != null && path != null) {\n            Glide.with(context)\n                    .load(path)\n                    .placeholder(R.drawable.default_can_scale_bg)\n                    .fitCenter()\n                    .addListener(object : RequestListener<Drawable> {\n\n                        override fun onLoadFailed(e: GlideException?, model: Any?, target: Target<Drawable>?, isFirstResource: Boolean): Boolean {\n                            listener?.onFail()\n                            return true\n                        }\n\n\n                        override fun onResourceReady(resource: Drawable?, model: Any?, target: Target<Drawable>?, dataSource: DataSource?, isFirstResource: Boolean): Boolean {\n                            listener?.onSuccess()\n                            return true\n                        }\n\n                    })\n                    .apply(RequestOptions.bitmapTransform(RoundedCorners(if (conners > 0) conners else 1)))\n                    .into(imageview)\n\n        }\n    }\n}\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593259821},"updatedAt":{"$$date":1598595214194},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cOuocbG1WeKKot1Z"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973266120},"updatedAt":{"$$date":1594973266120},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cPPproC0uX9yAiHJ"}
{"name":"kotlin-基本类型：数字、字符串、数组 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/basic-types.html\n基本类型：数字、字符串、数组 - Kotlin 语言中文站\n32-39 minutes\n改进翻译\n在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。 一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。 在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。\n\nKotlin 提供了一组表示数字的内置类型。 对于整数，有四种不同大小的类型，因此值的范围也不同。\n\n类型\t大小（比特数）\t最小值\t最大值\nByte\t8\t-128\t127\nShort\t16\t-32768\t32767\nInt\t32\t-2,147,483,648 (-231)\t2,147,483,647 (231 - 1)\nLong\t64\t-9,223,372,036,854,775,808 (-263)\t9,223,372,036,854,775,807 (263 - 1)\n所有以未超出 Int 最大值的整型值初始化的变量都会推断为 Int 类型。如果初始值超过了其最大值，那么推断为 Long 类型。 如需显式指定 Long 型值，请在该值后追加 L 后缀。\n\nval one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1\n对于浮点数，Kotlin 提供了 Float 与 Double 类型。 根据 IEEE 754 标准， 两种浮点类型的十进制位数（即可以存储多少位十进制数）不同。 Float 反映了 IEEE 754 单精度，而 Double 提供了双精度。\n\n类型\t大小（比特数）\t有效数字比特数\t指数比特数\t十进制位数\nFloat\t32\t24\t8\t6-7\nDouble\t64\t53\t11\t15-16\n对于以小数初始化的变量，编译器会推断为 Double 类型。 如需将一个值显式指定为 Float 类型，请添加 f 或 F 后缀。 如果这样的值包含多于 6～7 位十进制数，那么会将其舍入。\n\nval pi = 3.14 // Double\nval e = 2.7182818284 // Double\nval eFloat = 2.7182818284f // Float，实际值为 2.7182817\n请注意，与一些其他语言不同，Kotlin 中的数字没有隐式拓宽转换。 例如，具有 Double 参数的函数只能对 Double 值调用，而不能对 Float、 Int 或者其他数字值调用。\n\nfun main() {\n    fun printDouble(d: Double) { print(d) }\n\n    val i = 1    \n    val d = 1.1\n    val f = 1.1f \n\n    printDouble(d)\n//    printDouble(i) // 错误：类型不匹配\n//    printDouble(f) // 错误：类型不匹配\n}\n如需将数值转换为不同的类型，请使用显示转换。\n\n数值常量字面值有以下几种:\n\n十进制: 123\nLong 类型用大写 L 标记: 123L\n十六进制: 0x0F\n二进制: 0b00001011\n注意: 不支持八进制\n\nKotlin 同样支持浮点数的常规表示方法:\n\n默认 double：123.5、123.5e10\nFloat 用 f 或者 F 标记: 123.5f\n你可以使用下划线使数字常量更易读：\n\nval oneMillion = 1_000_000\nval creditCardNumber = 1234_5678_9012_3456L\nval socialSecurityNumber = 999_99_9999L\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n在 Java 平台数字是物理存储为 JVM 的原生类型，除非我们需要一个可空的引用（如 Int?）或泛型。 后者情况下会把数字装箱。\n\n注意数字装箱不一定保留同一性:\n\nfun main() {\n//sampleStart\n    val a: Int = 100\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    \n    val b: Int = 10000\n    val boxedB: Int? = b\n    val anotherBoxedB: Int? = b\n    \n    println(boxedA === anotherBoxedA) // true\n    println(boxedB === anotherBoxedB) // false\n//sampleEnd\n}\n另一方面，它保留了相等性:\n\nfun main() {\n//sampleStart\n    val a: Int = 10000\n    println(a == a) // 输出“true”\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    println(boxedA == anotherBoxedA) // 输出“true”\n//sampleEnd\n}\n由于不同的表示方式，较小类型并不是较大类型的子类型。 如果它们是的话，就会出现下述问题：\n\n// 假想的代码，实际上并不能编译：\nval a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)\nval b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)\nprint(b == a) // 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long\n所以相等性会在所有地方悄无声息地失去，更别说同一性了。\n\n因此较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。\n\nfun main() {\n//sampleStart\n    val b: Byte = 1 // OK, 字面值是静态检测的\n    val i: Int = b // 错误\n//sampleEnd\n}\n我们可以显式转换来拓宽数字\n\nfun main() {\n    val b: Byte = 1\n//sampleStart\n    val i: Int = b.toInt() // OK：显式拓宽\n    print(i)\n//sampleEnd\n}\n每个数字类型支持如下的转换:\n\ntoByte(): Byte\ntoShort(): Short\ntoInt(): Int\ntoLong(): Long\ntoFloat(): Float\ntoDouble(): Double\ntoChar(): Char\n缺乏隐式类型转换很少会引起注意，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如：\n\nval l = 1L + 3 // Long + Int => Long\nKotlin支持数字运算的标准集（+ - * / %），运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。 参见运算符重载。\n\n请注意，整数间的除法总是返回整数。会丢弃任何小数部分。例如：\n\nfun main() {\n//sampleStart\n    val x = 5 / 2\n    //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'\n    println(x == 2)\n//sampleEnd\n}\n对于任何两个整数类型之间的除法来说都是如此。\n\nfun main() {\n//sampleStart\n    val x = 5L / 2\n    println(x == 2L)\n//sampleEnd\n}\n如需返回浮点类型，请将其中的一个参数显式转换为浮点类型。\n\nfun main() {\n//sampleStart\n    val x = 5 / 2.toDouble()\n    println(x == 2.5)\n//sampleEnd\n}\n对于位运算，没有特殊字符来表示，而只可用中缀方式调用具名函数，例如:\n\nval x = (1 shl 2) and 0x000FF000\n这是完整的位运算列表（只用于 Int 与 Long）：\n\nshl(bits) – 有符号左移\nshr(bits) – 有符号右移\nushr(bits) – 无符号右移\nand(bits) – 位与\nor(bits) – 位或\nxor(bits) – 位异或\ninv() – 位非\n本节讨论的浮点数操作如下：\n\n相等性检测：a == b 与 a != b\n比较操作符：a < b、 a > b、 a <= b、 a >= b\n区间实例以及区间检测：a..b、 x in a..b、 x !in a..b\n当其中的操作数 a 与 b 都是静态已知的 Float 或 Double 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者智能类型转换的结果是该类型），两数字所形成的操作或者区间遵循 IEEE 754 浮点运算标准。\n\n然而，为了支持泛型场景并提供全序支持，当这些操作数并非静态类型为浮点数（例如是 Any、 Comparable<……>、 类型参数）时，这些操作使用为 Float 与 Double 实现的不符合标准的 equals 与 compareTo，这会出现：\n\n认为 NaN 与其自身相等\n认为 NaN 比包括正无穷大（POSITIVE_INFINITY）在内的任何其他元素都大\n认为 -0.0 小于 0.0\n字符用 Char 类型表示。它们不能直接当作数字\n\nfun check(c: Char) {\n    if (c == 1) { // 错误：类型不兼容\n        // ……\n    }\n}\n字符字面值用单引号括起来: '1'。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\\t、 \\b、\\n、\\r、\\'、\\\"、\\\\ 与 \\$。 编码其他字符要用 Unicode 转义序列语法：'\\uFF00'。\n\n我们可以显式把字符转换为 Int 数字：\n\nfun decimalDigitValue(c: Char): Int {\n    if (c !in '0'..'9')\n        throw IllegalArgumentException(\"Out of range\")\n    return c.toInt() - '0'.toInt() // 显式转换为数字\n}\n当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。\n\n布尔用 Boolean 类型表示，它有两个值：true 与 false。\n\n若需要可空引用布尔会被装箱。\n\n内置的布尔运算有：\n\n|| – 短路逻辑或\n&& – 短路逻辑与\n! - 逻辑非\n数组在 Kotlin 中使用 Array 类来表示，它定义了 get 与 set 函数（按照运算符重载约定这会转变为 []）以及 size 属性，以及一些其他有用的成员函数：\n\nclass Array<T> private constructor() {\n    val size: Int\n    operator fun get(index: Int): T\n    operator fun set(index: Int, value: T): Unit\n\n    operator fun iterator(): Iterator<T>\n    // ……\n}\n我们可以使用库函数 arrayOf() 来创建一个数组并传递元素值给它，这样 arrayOf(1, 2, 3) 创建了 array [1, 2, 3]。 或者，库函数 arrayOfNulls() 可以用于创建一个指定大小的、所有元素都为空的数组。\n\n另一个选项是用接受数组大小以及一个函数参数的 Array 构造函数，用作参数的函数能够返回给定索引的每个元素初始值：\n\nfun main() {\n//sampleStart\n    // 创建一个 Array<String> 初始化为 [\"0\", \"1\", \"4\", \"9\", \"16\"]\n    val asc = Array(5) { i -> (i * i).toString() }\n    asc.forEach { println(it) }\n//sampleEnd\n}\n如上所述，[] 运算符代表调用成员函数 get() 与 set()。\n\nKotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 Array<String> 赋值给 Array<Any>，以防止可能的运行时失败（但是你可以使用 Array<out Any>, 参见类型投影）。\n\nKotlin 也有无装箱开销的专门的类来表示原生类型数组: ByteArray、 ShortArray、IntArray 等等。这些类与 Array 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法:\n\nval x: IntArray = intArrayOf(1, 2, 3)\nx[0] = x[1] + x[2]\n// 大小为 5、值为 [0, 0, 0, 0, 0] 的整型数组\nval arr = IntArray(5)\n\n// 例如：用常量初始化数组中的值\n// 大小为 5、值为 [42, 42, 42, 42, 42] 的整型数组\nval arr = IntArray(5) { 42 }\n\n// 例如：使用 lambda 表达式初始化数组中的值\n// 大小为 5、值为 [0, 1, 2, 3, 4] 的整型数组（值初始化为其索引值）\nvar arr = IntArray(5) { it * 1 } \n无符号类型自 Kotlin 1.3 起才可用，并且目前是实验性的。详见下文\n\nKotlin 为无符号整数引入了以下类型：\n\nkotlin.UByte: 无符号 8 比特整数，范围是 0 到 255\nkotlin.UShort: 无符号 16 比特整数，范围是 0 到 65535\nkotlin.UInt: 无符号 32 比特整数，范围是 0 到 2^32 - 1\nkotlin.ULong: 无符号 64 比特整数，范围是 0 到 2^64 - 1\n无符号类型支持其对应有符号类型的大多数操作。\n\n请注意，将类型从无符号类型更改为对应的有符号类型（反之亦然）是二进制不兼容变更\n\n无符号类型是使用另一个实验性特性（即内联类）实现的。\n\n与原生类型相同，每个无符号类型都有相应的为该类型特化的表示数组的类型：\n\nkotlin.UByteArray: 无符号字节数组\nkotlin.UShortArray: 无符号短整型数组\nkotlin.UIntArray: 无符号整型数组\nkotlin.ULongArray: 无符号长整型数组\n与有符号整型数组一样，它们提供了类似于 Array 类的 API 而没有装箱开销。\n\n此外，区间与数列也支持 UInt 与 ULong（通过这些类 kotlin.ranges.UIntRange、 kotlin.ranges.UIntProgression、 kotlin.ranges.ULongRange、 kotlin.ranges.ULongProgression）\n\n为使无符号整型更易于使用，Kotlin 提供了用后缀标记整型字面值来表示指定无符号类型（类似于 Float/Long）：\n\n后缀 u 与 U 将字面值标记为无符号。确切类型会根据预期类型确定。如果没有提供预期的类型，会根据字面值大小选择 UInt 或者 ULong\nval b: UByte = 1u  // UByte，已提供预期类型\nval s: UShort = 1u // UShort，已提供预期类型\nval l: ULong = 1u  // ULong，已提供预期类型\n\nval a1 = 42u // UInt：未提供预期类型，常量适于 UInt\nval a2 = 0xFFFF_FFFF_FFFFu // ULong：未提供预期类型，常量不适于 UInt\n后缀 uL 与 UL 显式将字面值标记为无符号长整型。\nval a = 1UL // ULong，即使未提供预期类型并且常量适于 UInt\n无符号类型的设计是实验性的，这意味着这个特性改进很快并且没有给出兼容性保证。当在 Kotlin 1.3+ 中使用无符号算术时，会报出警告表明这个特性是实验性的。如需移除警告，必须选择加入（opt-in）无符号类型的实验性使用。\n\n选择加入无符号整型有两种可行的方式：将 API 标记为实验性的，或者无需标记。\n\n如需传播实验性，请以 @ExperimentalUnsignedTypes 标注使用了无符号整型的声明。\n如需选择加入而不传播实验性，要么使用 @OptIn(ExperimentalUnsignedTypes::class) 注解标注声明，要么将 -Xopt-in=kotlin.ExperimentalUnsignedTypes 传给编译器。\n你的客户是否必须选择使用你的 API 取决于你，不过请记住，无符号整型是一个实验性特性，因此使用它们的 API 可能会因语言的变更而发生突然破坏。\n\n技术细节也参见实验性 API KEEP。\n\n关于技术细节与深入探讨请参见无符号类型的语言提案。\n\n字符串用 String 类型表示。字符串是不可变的。 字符串的元素——字符可以使用索引运算符访问: s[i]。 可以用 for 循环迭代字符串:\n\nfun main() {\nval str = \"abcd\"\n//sampleStart\nfor (c in str) {\n    println(c)\n}\n//sampleEnd\n}\n可以用 + 操作符连接字符串。这也适用于连接字符串与其他类型的值， 只要表达式中的第一个元素是字符串：\n\nfun main() {\n//sampleStart\nval s = \"abc\" + 1\nprintln(s + \"def\")\n//sampleEnd\n}\n请注意，在大多数情况下，优先使用字符串模板或原始字符串而不是字符串连接。\n\nKotlin 有两种类型的字符串字面值: 转义字符串可以有转义字符， 以及原始字符串可以包含换行以及任意文本。以下是转义字符串的一个示例:\n\nval s = \"Hello, world!\\n\"\n转义采用传统的反斜杠方式。参见上面的 字符 查看支持的转义序列。\n\n原始字符串 使用三个引号（\"\"\"）分界符括起来，内部没有转义并且可以包含换行以及任何其他字符:\n\nval text = \"\"\"\n    for (c in \"foo\")\n        print(c)\n\"\"\"\n你可以通过 trimMargin() 函数去除前导空格：\n\nval text = \"\"\"\n    |Tell me and I forget.\n    |Teach me and I remember.\n    |Involve me and I learn.\n    |(Benjamin Franklin)\n    \"\"\".trimMargin()\n默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(\">\")。\n\n字符串字面值可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:\n\nfun main() {\n//sampleStart\n    val i = 10\n    println(\"i = $i\") // 输出“i = 10”\n//sampleEnd\n}\n或者用花括号括起来的任意表达式:\n\nfun main() {\n//sampleStart\n    val s = \"abc\"\n    println(\"$s.length is ${s.length}\") // 输出“abc.length is 3”\n//sampleEnd\n}\n原始字符串与转义字符串内部都支持模板。 如果你需要在原始字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：\n\nval price = \"\"\"\n${'\n   \n  \n  \n  \n\n\n}9.99\n\"\"\""}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306173070},"updatedAt":{"$$date":1597307591670},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cdD7N3rMe5Z28cr9"}
{"name":"kotlin-Java 中调用 Kotlin","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/java-to-kotlin-interop.html\nJava 中调用 Kotlin - Kotlin 语言中文站\n35-43 minutes\n改进翻译\nJava 可以轻松调用 Kotlin 代码。 例如，可以在 Java 方法中无缝创建与操作 Kotlin 类的实例。 然而，在将 Kotlin 代码集成到 Java 中时， 需要注意 Java 与 Kotlin 之间的一些差异。 在本页，我们会描述定制 Kotlin 代码与其 Java 客户端的互操作的方法。\n\nKotlin 属性会编译成以下 Java 元素：\n\n一个 getter 方法，名称通过加前缀 get 算出；\n一个 setter 方法，名称通过加前缀 set 算出（只适用于 var 属性）；\n一个私有字段，与属性名称相同（仅适用于具有幕后字段的属性）。\n例如，var firstName: String 编译成以下 Java 声明：\n\nprivate String firstName;\n\npublic String getFirstName() {\n    return firstName;\n}\n\npublic void setFirstName(String firstName) {\n    this.firstName = firstName;\n}\n如果属性的名称以 is 开头，则使用不同的名称映射规则：getter 的名称与属性名称相同，并且 setter 的名称是通过将 is 替换为 set 获得。 例如，对于属性 isOpen，其 getter 会称做 isOpen()，而其 setter 会称做 setOpen()。 这一规则适用于任何类型的属性，并不仅限于 Boolean。\n\n在 org.example 包内的 app.kt 文件中声明的所有的函数和属性，包括扩展函数， 都编译成一个名为 org.example.AppKt 的 Java 类的静态方法。\n\n// app.kt\npackage org.example\n\nclass Util\n\nfun getTime() { /*……*/ }\n\n// Java\nnew org.example.Util();\norg.example.AppKt.getTime();\n可以使用 @JvmName 注解修改生成的 Java 类的类名：\n\n@file:JvmName(\"DemoUtils\")\n\npackage org.example\n\nclass Util\n\nfun getTime() { /*……*/ }\n\n// Java\nnew org.example.Util();\norg.example.DemoUtils.getTime();\n如果多个文件中生成了相同的 Java 类名（包名相同并且类名相同或者有相同的 @JvmName 注解）通常是错误的。然而，编译器能够生成一个单一的 Java 外观类，它具有指定的名称且包含来自所有文件中具有该名称的所有声明。 要启用生成这样的外观，请在所有相关文件中使用 @JvmMultifileClass 注解。\n\n// oldutils.kt\n@file:JvmName(\"Utils\")\n@file:JvmMultifileClass\n\npackage org.example\n\nfun getTime() { /*……*/ }\n// newutils.kt\n@file:JvmName(\"Utils\")\n@file:JvmMultifileClass\n\npackage org.example\n\nfun getDate() { /*……*/ }\n// Java\norg.example.Utils.getTime();\norg.example.Utils.getDate();\n如果需要在 Java 中将 Kotlin 属性作为字段暴露，那就使用 @JvmField 注解对其标注。 该字段将具有与底层属性相同的可见性。如果一个属性有幕后字段（backing field）、非私有、没有 open /override 或者 const 修饰符并且不是被委托的属性，那么你可以用 @JvmField 注解该属性。\n\nclass User(id: String) {\n    @JvmField val ID = id\n}\n// Java\nclass JavaClient {\n    public String getID(User user) {\n        return user.ID;\n    }\n}\n延迟初始化的属性（在Java中）也会暴露为字段。 该字段的可见性与 lateinit 属性的 setter 相同。\n\n在具名对象或伴生对象中声明的 Kotlin 属性会在该具名对象或包含伴生对象的类中具有静态幕后字段。\n\n通常这些字段是私有的，但可以通过以下方式之一暴露出来：\n\n@JvmField 注解；\nlateinit 修饰符；\nconst 修饰符。\n使用 @JvmField 标注这样的属性使其成为与属性本身具有相同可见性的静态字段。\n\nclass Key(val value: Int) {\n    companion object {\n        @JvmField\n        val COMPARATOR: Comparator<Key> = compareBy<Key> { it.value }\n    }\n}\n// Java\nKey.COMPARATOR.compare(key1, key2);\n// Key 类中的 public static final 字段\n在具名对象或者伴生对象中的一个延迟初始化的属性具有与属性 setter 相同可见性的静态幕后字段。\n\nobject Singleton {\n    lateinit var provider: Provider\n}\n// Java\nSingleton.provider = new Provider();\n// 在 Singleton 类中的 public static 非-final 字段\n（在类中以及在顶层）以 const 声明的属性在 Java 中会成为静态字段：\n\n// 文件 example.kt\n\nobject Obj {\n    const val CONST = 1\n}\n\nclass C {\n    companion object {\n        const val VERSION = 9\n    }\n}\n\nconst val MAX = 239\n在 Java 中：\n\nint const = Obj.CONST;\nint max = ExampleKt.MAX;\nint version = C.VERSION;\n如上所述，Kotlin 将包级函数表示为静态方法。 Kotlin 还可以为具名对象或伴生对象中定义的函数生成静态方法，如果你将这些函数标注为 @JvmStatic 的话。 如果你使用该注解，编译器既会在相应对象的类中生成静态方法，也会在对象自身中生成实例方法。 例如：\n\nclass C {\n    companion object {\n        @JvmStatic fun callStatic() {}\n        fun callNonStatic() {}\n    }\n}\n现在，callStatic() 在 Java 中是静态的，而 callNonStatic() 不是：\n\nC.callStatic(); // 没问题\nC.callNonStatic(); // 错误：不是一个静态方法\nC.Companion.callStatic(); // 保留实例方法\nC.Companion.callNonStatic(); // 唯一的工作方式\n对于具名对象也同样：\n\nobject Obj {\n    @JvmStatic fun callStatic() {}\n    fun callNonStatic() {}\n}\n在 Java 中：\n\nObj.callStatic(); // 没问题\nObj.callNonStatic(); // 错误\nObj.INSTANCE.callNonStatic(); // 没问题，通过单例实例调用\nObj.INSTANCE.callStatic(); // 也没问题\n自 Kotlin 1.3 起，@JvmStatic 也适用于在接口的伴生对象中定义的函数。 这类函数会编译为接口中的静态方法。请注意，接口中的静态方法是 Java 1.8 中引入的， 因此请确保使用相应的编译目标。\n\ninterface ChatBot {\n    companion object {\n        @JvmStatic fun greet(username: String) {\n            println(\"Hello, $username\")\n        }\n    }\n}\n@JvmStatic　注解也可以应用于对象或伴生对象的属性， 使其 getter 和 setter 方法在该对象或包含该伴生对象的类中是静态成员。\n\n默认方法仅适用于面向 JVM 1.8 及更高版本。\n\n@JvmDefault 注解在 Kotlin 1.3 中是实验性的。其名称与行为都可能发生变化，导致将来不兼容。\n\n自 JDK 1.8 起，Java 中的接口可以包含默认方法。 可以将 Kotlin 接口的非抽象成员为实现它的 Java 类声明为默认。 如需将一个成员声明为默认，请使用 @JvmDefault 注解标记之。 这是一个带有默认方法的 Kotlin 接口的一个示例：\n\ninterface Robot {\n    @JvmDefault fun move() { println(\"~walking~\") }\n    fun speak(): Unit\n}\n默认实现对于实现该接口的 Java 类都可用。\n\n//Java 实现\npublic class C3PO implements Robot {\n    // 来自 Robot 的 move() 实现隐式可用\n    @Override\n    public void speak() {\n        System.out.println(\"I beg your pardon, sir\");\n    }\n}\nC3PO c3po = new C3PO();\nc3po.move(); // 来自 Robot 接口的默认实现\nc3po.speak();\n接口的实现者可以覆盖默认方法。\n\n//Java\npublic class BB8 implements Robot {\n    //自己实现默认方法\n    @Override\n    public void move() {\n        System.out.println(\"~rolling~\");\n    }\n\n    @Override\n    public void speak() {\n        System.out.println(\"Beep-beep\");\n    }\n}\n为了让 @JvmDefault 生效，编译该接口必须带有 -Xjvm-default 参数。 根据添加注解的情况，指定下列值之一：\n\n-Xjvm-default=enabled 只添加带有 @JvmDefault 注解的新方法时使用。 这包括为 API 添加整个接口。\n-Xjvm-default=compatibility 将 @JvmDefault 添加到以往 API 中就有的方法时使用。 这种模式有助于避免兼容性破坏：为先前版本编写的所有接口实现都会与新版本完全兼容。 然而，兼容模式可能会增大生成字节码的规模并且影响性能。\n关于兼容性的更多详情请参见 @JvmDefault 参考页。\n\n请注意，如果将带有 @JvmDefault 的方法的接口用作委托， 那么即是实际的委托类型提供了自己的实现，也会调用默认方法的实现。\n\ninterface Producer {\n    @JvmDefault fun produce() {\n        println(\"interface method\")\n    }\n}\n\nclass ProducerImpl: Producer {\n    override fun produce() {\n        println(\"class method\")\n    }\n}\n\nclass DelegatedProducer(val p: Producer): Producer by p {\n}\n\nfun main() {\n    val prod = ProducerImpl()\n    DelegatedProducer(prod).produce() // 输出“interface method”\n}\n关于 Kotlin 中接口委托的更多详情，请参见委托。\n\nKotlin 的可见性以下列方式映射到 Java：\n\nprivate 成员编译成 private 成员；\nprivate 的顶层声明编译成包级局部声明；\nprotected 保持 protected（注意 Java 允许访问同一个包中其他类的受保护成员， 而 Kotlin 不能，所以 Java 类会访问更广泛的代码）；\ninternal 声明会成为 Java 中的 public。internal 类的成员会通过名字修饰，使其更难以在 Java 中意外使用到，并且根据 Kotlin 规则使其允许重载相同签名的成员而互不可见；\npublic 保持 public。\n有时你需要调用有 KClass 类型参数的 Kotlin 方法。 因为没有从 Class 到 KClass 的自动转换，所以你必须通过调用 Class<T>.kotlin 扩展属性的等价形式来手动进行转换：\n\nkotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.class)\n有时我们想让一个 Kotlin 中的具名函数在字节码中有另外一个 JVM 名称。 最突出的例子是由于类型擦除引发的：\n\nfun List<String>.filterValid(): List<String>\nfun List<Int>.filterValid(): List<Int>\n这两个函数不能同时定义，因为它们的 JVM 签名是一样的：filterValid(Ljava/util/List;)Ljava/util/List;。 如果我们真的希望它们在 Kotlin 中用相同名称，我们需要用 @JvmName 去标注其中的一个（或两个），并指定不同的名称作为参数：\n\nfun List<String>.filterValid(): List<String>\n\n@JvmName(\"filterValidInt\")\nfun List<Int>.filterValid(): List<Int>\n在 Kotlin 中它们可以用相同的名称 filterValid 来访问，而在 Java 中，它们分别是 filterValid 和 filterValidInt。\n\n同样的技巧也适用于属性 x 和函数 getX() 共存：\n\nval x: Int\n    @JvmName(\"getX_prop\")\n    get() = 15\n\nfun getX() = 10\n如需在没有显式实现 getter 与 setter 的情况下更改属性生成的访问器方法的名称，可以使用 @get:JvmName 与 @set:JvmName：\n\n@get:JvmName(\"x\")\n@set:JvmName(\"changeX\")\nvar x: Int = 23\n通常，如果你写一个有默认参数值的 Kotlin 函数，在 Java 中只会有一个所有参数都存在的完整参数签名的方法可见，如果希望向 Java 调用者暴露多个重载，可以使用 @JvmOverloads 注解。\n\n该注解也适用于构造函数、静态方法等。它不能用于抽象方法，包括在接口中定义的方法。\n\nclass Circle @JvmOverloads constructor(centerX: Int, centerY: Int, radius: Double = 1.0) {\n    @JvmOverloads fun draw(label: String, lineWidth: Int = 1, color: String = \"red\") { /*……*/ }\n}\n对于每一个有默认值的参数，都会生成一个额外的重载，这个重载会把这个参数和它右边的所有参数都移除掉。在上例中，会生成以下代码 ：\n\n// 构造函数：\nCircle(int centerX, int centerY, double radius)\nCircle(int centerX, int centerY)\n\n// 方法\nvoid draw(String label, int lineWidth, String color) { }\nvoid draw(String label, int lineWidth) { }\nvoid draw(String label) { }\n请注意，如次构造函数中所述，如果一个类的所有构造函数参数都有默认值，那么会为其生成一个公有的无参构造函数。这就算没有 @JvmOverloads 注解也有效。\n\n如上所述，Kotlin 没有受检异常。 所以，通常 Kotlin 函数的 Java 签名不会声明抛出异常。 于是如果我们有一个这样的 Kotlin 函数：\n\n// example.kt\npackage demo\n\nfun writeToFile() {\n    /*……*/\n    throw IOException()\n}\n然后我们想要在 Java 中调用它并捕捉这个异常：\n\n// Java\ntry {\n  demo.Example.writeToFile();\n}\ncatch (IOException e) { // 错误：writeToFile() 未在 throws 列表中声明 IOException\n  // ……\n}\n因为 writeToFile() 没有声明 IOException，我们从 Java 编译器得到了一个报错消息。 为了解决这个问题，要在 Kotlin 中使用 @Throws 注解。\n\n@Throws(IOException::class)\nfun writeToFile() {\n    /*……*/\n    throw IOException()\n}\n当从 Java 中调用 Kotlin 函数时，没人阻止我们将 null 作为非空参数传递。 这就是为什么 Kotlin 给所有期望非空参数的公有函数生成运行时检测。 这样我们就能在 Java 代码里立即得到 NullPointerException。\n\n当 Kotlin 的类使用了声明处型变，有两种选择可以从 Java 代码中看到它们的用法。让我们假设我们有以下类和两个使用它的函数：\n\nclass Box<out T>(val value: T)\n\ninterface Base\nclass Derived : Base\n\nfun boxDerived(value: Derived): Box<Derived> = Box(value)\nfun unboxBase(box: Box<Base>): Base = box.value\n一种看似理所当然地将这俩函数转换成 Java 代码的方式可能会是：\n\nBox<Derived> boxDerived(Derived value) { …… }\nBase unboxBase(Box<Base> box) { …… }\n问题是，在 Kotlin 中我们可以这样写 unboxBase(boxDerived(\"s\"))，但是在 Java 中是行不通的，因为在 Java 中类 Box 在其泛型参数 T 上是不型变的，于是 Box<Derived> 并不是 Box<Base> 的子类。 要使其在 Java 中工作，我们按以下这样定义 unboxBase：\n\nBase unboxBase(Box<? extends Base> box) { …… }\n这里我们使用 Java 的通配符类型（? extends Base）来通过使用处型变来模拟声明处型变，因为在 Java 中只能这样。\n\n当它作为参数出现时，为了让 Kotlin 的 API 在 Java 中工作，对于协变定义的 Box 我们生成 Box<Super> 作为 Box<? extends Super> （或者对于逆变定义的 Foo 生成 Foo<? super Bar>）。当它是一个返回值时， 我们不生成通配符，因为否则 Java 客户端将必须处理它们（并且它违反常用 Java 编码风格）。因此，我们的示例中的对应函数实际上翻译如下：\n\n// 作为返回类型——没有通配符\nBox<Derived> boxDerived(Derived value) { …… }\n \n// 作为参数——有通配符\nBase unboxBase(Box<? extends Base> box) { …… }\n当参数类型是 final 时，生成通配符通常没有意义，所以无论在什么地方 Box<String>始终转换为 Box<String>。\n\n如果我们在默认不生成通配符的地方需要通配符，我们可以使用 @JvmWildcard 注解：\n\nfun boxDerived(value: Derived): Box<@JvmWildcard Derived> = Box(value)\n// 将被转换成\n// Box<? extends Derived> boxDerived(Derived value) { …… }\n另一方面，如果我们根本不需要默认的通配符转换，我们可以使用@JvmSuppressWildcards\n\nfun unboxBase(box: Box<@JvmSuppressWildcards Base>): Base = box.value\n// 会翻译成\n// Base unboxBase(Box<Base> box) { …… }\n@JvmSuppressWildcards 不仅可用于单个类型参数，还可用于整个声明（如函数或类），从而抑制其中的所有通配符。\n\n类型 Nothing 是特殊的，因为它在 Java 中没有自然的对应。确实，每个 Java 引用类型，包括 java.lang.Void 都可以接受 null 值，但是 Nothing 不行。因此，这种类型不能在 Java 世界中准确表示。这就是为什么在使用 Nothing 参数的地方 Kotlin 生成一个原始类型：\n\nfun emptyList(): List<Nothing> = listOf()\n// 会翻译成\n// List emptyList() { …… }"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386580281},"updatedAt":{"$$date":1597397587637},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ceb6CSKV01UMQlkq"}
{"name":"css-CSS 图像拼合技术","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 图像拼合技术\n图像拼合\n图像拼合就是单个图像的集合。\n\n有许多图像的网页可能需要很长的时间来加载和生成多个服务器的请求。\n\n使用图像拼合会降低服务器的请求数量，并节省带宽。\n\n图像拼合 - 简单实例\n与其使用三个独立的图像，不如我们使用这种单个图像（\"img_navsprites.gif\"）：\n\nnavigation images\n\n有了CSS，我们可以只显示我们需要的图像的一部分。\n\n在下面的例子CSS指定显示 \"img_navsprites.gif\" 的图像的一部分：\n\n实例\nimg.home\n{\nwidth:46px;\nheight:44px;\nbackground:url(img_navsprites.gif) 0 0;\n}\n\n尝试一下 »\n实例解析：\n\n<img class=\"home\" src=\"img_trans.gif\" /> -因为不能为空,src属性只定义了一个小的透明图像。显示的图像将是我们在CSS中指定的背景图像\n宽度：46px;高度：44px; - 定义我们使用的那部分图像\nbackground:url(img_navsprites.gif) 0 0; - 定义背景图像和它的位置（左0px，顶部0px）\n这是使用图像拼合最简单的方法，现在我们使用链接和悬停效果。\n\n图像拼合 - 创建一个导航列表\n我们想使用拼合图像 (\"img_navsprites.gif\")，以创建一个导航列表。\n\n我们将使用一个HTML列表，因为它可以链接，同时还支持背景图像：\n\n实例\n#navlist{position:relative;}\n#navlist li{margin:0;padding:0;list-style:none;position:absolute;top:0;}\n#navlist li, #navlist a{height:44px;display:block;}\n\n#home{left:0px;width:46px;}\n#home{background:url('img_navsprites.gif') 0 0;}\n\n#prev{left:63px;width:43px;}\n#prev{background:url('img_navsprites.gif') -47px 0;}\n\n#next{left:129px;width:43px;}\n#next{background:url('img_navsprites.gif') -91px 0;}\n\n尝试一下 »\n实例解析：\n\n#navlist{position:relative;} - 位置设置相对定位，让里面的绝对定位\n#navlist li{margin:0;padding:0;list-style:none;position:absolute;top:0;} - margin和padding设置为0，列表样式被删除，所有列表项是绝对定位\n#navlist li, #navlist a{height:44px;display:block;} - 所有图像的高度是44px\n现在开始每个具体部分的定位和样式：\n\n#home{left:0px;width:46px;} - 定位到最左边的方式，以及图像的宽度是46px\n#home{background:url(img_navsprites.gif) 0 0;} - 定义背景图像和它的位置（左0px，顶部0px）\n#prev{left:63px;width:43px;} - 右侧定位63px（＃home宽46px+项目之间的一些多余的空间），宽度为43px。\n#prev{background:url('img_navsprites.gif') -47px 0;} - 定义背景图像右侧47px（＃home宽46px+分隔线的1px）\n#next{left:129px;width:43px;}- 右边定位129px(#prev 63px + #prev宽是43px + 剩余的空间), 宽度是43px.\n#next{background:url('img_navsprites.gif') no-repeat -91px 0;} - 定义背景图像右边91px（＃home 46px+1px的分割线+＃prev宽43px+1px的分隔线）\n图像拼合s - 悬停效果\n现在，我们希望我们的导航列表中添加一个悬停效果。\n\nlamp\t:hover 选择器用于鼠标悬停在元素上的显示的效果\n\n提示： :hover 选择器可以运用于所有元素。\n我们的新图像 (\"img_navsprites_hover.gif\") 包含三个导航图像和三幅图像：\n\nnavigation images\n\n因为这是一个单一的图像，而不是6个单独的图像文件，当用户停留在图像上不会有延迟加载。\n\n我们添加悬停效果只添加三行代码：\n\n实例\n#home a:hover{background: url('img_navsprites_hover.gif') 0 -45px;}\n#prev a:hover{background: url('img_navsprites_hover.gif') -47px -45px;}\n#next a:hover{background: url('img_navsprites_hover.gif') -91px -45px;}\n\n尝试一下 »\n实例解析：\n\n由于该列表项包含一个链接，我们可以使用：hover伪类\n#home a:hover{background: transparent url(img_navsprites_hover.gif) 0 -45px;} - 对于所有三个悬停图像，我们指定相同的背景位置，只是每个再向下45px"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973621915},"updatedAt":{"$$date":1598974362755},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cj7Dg4EIoLLiszTX"}
{"name":"kotlin-集合写操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-write.html\n集合写操作 - Kotlin 语言中文站\n9-11 minutes\n改进翻译\n可变集合支持更改集合内容的操作，例如添加或删除元素。 在此页面上，我们将描述实现 MutableCollection 的所有写操作。 有关 List 与 Map 可用的更多特定操作，请分别参见 List 相关操作与 Map 相关操作。\n\n要将单个元素添加到列表或集合，请使用 add() 函数。指定的对象将添加到集合的末尾。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    println(numbers)\n//sampleEnd\n}\naddAll() 将参数对象的每个元素添加到列表或集合中。参数可以是 Iterable、Sequence 或 Array。 接收者的类型和参数可能不同，例如，你可以将所有内容从 Set 添加到 List。\n\n当在列表上调用时，addAll() 会按照在参数中出现的顺序添加各个新元素。 你也可以调用 addAll() 时指定一个元素位置作为第一参数。 参数集合的第一个元素会被插入到这个位置。 其他元素将跟随在它后面，将接收者元素移到末尾。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 5, 6)\n    numbers.addAll(arrayOf(7, 8))\n    println(numbers)\n    numbers.addAll(2, setOf(3, 4))\n    println(numbers)\n//sampleEnd\n}\n你还可以使用 plus 运算符 - plusAssign (+=) 添加元素。 当应用于可变集合时，+= 将第二个操作数(一个元素或另一个集合)追加到集合的末尾。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\")\n    numbers += \"three\"\n    println(numbers)\n    numbers += listOf(\"four\", \"five\")    \n    println(numbers)\n//sampleEnd\n}\n若要从可变集合中移除元素，请使用 remove() 函数。 remove() 接受元素值，并删除该值的一个匹配项。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4, 3)\n    numbers.remove(3)                    // 删除了第一个 `3`\n    println(numbers)\n    numbers.remove(5)                    // 什么都没删除\n    println(numbers)\n//sampleEnd\n}\n要一次删除多个元素，有以下函数：\n\nremoveAll() 移除参数集合中存在的所有元素。 或者，你可以用谓词作为参数来调用它；在这种情况下，函数移除谓词产生 true 的所有元素。\nretainAll() 与 removeAll() 相反：它移除除参数集合中的元素之外的所有元素。 当与谓词一起使用时，它只留下与之匹配的元素。\nclear() 从列表中移除所有元素并将其置空。\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    println(numbers)\n    numbers.retainAll { it >= 3 }\n    println(numbers)\n    numbers.clear()\n    println(numbers)\n\n    val numbersSet = mutableSetOf(\"one\", \"two\", \"three\", \"four\")\n    numbersSet.removeAll(setOf(\"one\", \"two\"))\n    println(numbersSet)\n//sampleEnd\n}\n从集合中移除元素的另一种方法是使用 minusAssign (-=) ——原地修改版的 minus 操作符。 minus 操作符。 第二个参数可以是元素类型的单个实例或另一个集合。 右边是单个元素时，-= 会移除它的第一个匹配项。 反过来，如果它是一个集合，那么它的所有元素的每次出现都会删除。 例如，如果列表包含重复的元素，它们将被同时删除。 第二个操作数可以包含集合中不存在的元素。这些元素不会影响操作的执行。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"three\", \"four\")\n    numbers -= \"three\"\n    println(numbers)\n    numbers -= listOf(\"four\", \"five\")    \n    //numbers -= listOf(\"four\")    // 与上述相同\n    println(numbers)    \n//sampleEnd\n}\nlist 和 map 还提供更新元素的操作。 它们在 List 相关操作与 Map 相关操作中有所描述。 对于 set 来说，更新没有意义，因为它实际上是移除一个元素并添加另一个元素。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382136115},"updatedAt":{"$$date":1597385754756},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cnO122tqe2FtXBH7"}
{"name":"CSS3 文本效果","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 文本效果\nCSS3 文本效果\nCSS3中包含几个新的文本特征。\n\n在本章中您将了解以下文本属性：\n\ntext-shadow\nbox-shadow\ntext-overflow\nword-wrap\nword-break\n浏览器支持\n属性\t\t\t\t\t\ntext-shadow\t4.0\t10.0\t3.5\t4.0\t9.5\nbox-shadow\t10.0\n4.0 -webkit-\t9.0\t4.0\n3.5 -moz-\t5.1\n3.1 -webkit-\t10.5\ntext-overflow\t4.0\t6.0\t7.0\t3.1\t11.0\n9.0 -o-\nword-wrap\t23.0\t5.5\t3.5\t6.1\t12.1\nword-break\t4.0\t5.5\t15.0\t3.1\t15.0\nCSS3 的文本阴影\nCSS3 中，text-shadow属性适用于文本阴影。\n\n阴影效果!\n\n您指定了水平阴影，垂直阴影，模糊的距离，以及阴影的颜色：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n给标题添加阴影:\n\nh1\n{\n    text-shadow: 5px 5px 5px #FF0000;\n}\n\n尝试一下 »\n\nCSS3 box-shadow属性\nCSS3 中 CSS3 box-shadow 属性适用于盒子阴影\n\n实例\ndiv {\n    box-shadow: 10px 10px 5px #888888;\n}\n\n尝试一下 »\n\n接下来给阴影添加颜色\n实例\ndiv {\n    box-shadow: 10px 10px grey;\n}\n\n尝试一下 »\n\n接下来给阴影添加一个模糊效果\n实例\ndiv {\n    box-shadow: 10px 10px 5px grey;\n}\n\n尝试一下 »\n\n你也可以在 ::before 和 ::after 两个伪元素中添加阴影效果\n实例\n#boxshadow {\n    position: relative;\n    b ox-shadow: 1px 2px 4px rgba(0, 0, 0, .5);\n    pa dding: 10px;\n    bac kground: white;\n} \n#boxshadow img {\n     width: 100%;\n     border: 1px solid #8a4419;\n     border-style: inset;\n} \n#boxshadow::after {\n     content: '';\n    position: absolute;\n    z-index: -1; /* hide shadow behind image */\n    box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); \n    width: 70%; \n    left: 15%; /* one half of the remaining 30% */\n    height: 100px;\n    bottom: 0;\n}\n\n尝试一下 »\n\n阴影的一个使用特例是卡片效果\n实例\ndiv.card {\n    width: 250px;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n    text-align: center;\n}\n\n文字卡片 » 图片卡片 »\n\nCSS3 Text Overflow属性\nCSS3文本溢出属性指定应向用户如何显示溢出内容\n\n实例\np.test1 {\n    white-space: nowrap; \n    width: 200px; \n    border: 1px solid #000000;\n    overflow: hidden;\n    text-overflow: clip; \n}\n \np.test2 {\n    white-space: nowrap; \n    width: 200px; \n    border: 1px solid #000000;\n    overflow: hidden;\n    text-overflow: ellipsis; \n}\n\n尝试一下 »\n\nCSS3的换行\n如果某个单词太长，不适合在一个区域内，它扩展到外面：\n\nCSS3中，自动换行属性允许您强制文本换行 - 即使这意味着分裂它中间的一个字：\n\nCSS代码如下：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n允许长文本换行:\n\np {word-wrap:break-word;}\n\n尝试一下 »\n\nCSS3 单词拆分换行\nCSS3 单词拆分换行属性指定换行规则：\n\nCSS代码如下：\n\n实例\np.test1 {\n    word-break: keep-all;\n}\n \np.test2 {\n    word-break: break-all;\n}\n\n尝试一下 »\n\n新文本属性\n属性\t描述\tCSS\nhanging-punctuation\t规定标点字符是否位于线框之外。\t3\npunctuation-trim\t规定是否对标点字符进行修剪。\t3\ntext-align-last\t设置如何对齐最后一行或紧挨着强制换行符之前的行。\t3\ntext-emphasis\t向元素的文本应用重点标记以及重点标记的前景色。\t3\ntext-justify\t规定当 text-align 设置为 \"justify\" 时所使用的对齐方法。\t3\ntext-outline\t规定文本的轮廓。\t3\ntext-overflow\t规定当文本溢出包含元素时发生的事情。\t3\ntext-shadow\t向文本添加阴影。\t3\ntext-wrap\t规定文本的换行规则。\t3\nword-break\t规定非中日韩文本的换行规则。\t3\nword-wrap\t允许对长的不可分割的单词进行分割并换行到下一行。\t3\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974614021},"updatedAt":{"$$date":1598974828609},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"coeJRYZoydq2K9Gy"}
{"name":"kotlin-Kotlin 条件控制 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-condition-control.html\nKotlin 条件控制 | 菜鸟教程\n3-4 minutes\nIF 表达式\n一个 if 语句包含一个布尔表达式和一条或多条语句。\n\n// 传统用法\nvar max = a \nif (a < b) max = b\n\n// 使用 else \nvar max: Int\nif (a > b) {\n    max = a\n} else {\n    max = b\n}\n \n// 作为表达式\nval max = if (a > b) a else b\n我们也可以把 IF 表达式的结果赋值给一个变量。\n\nval max = if (a > b) {\n    print(\"Choose a\")\n    a\n} else {\n    print(\"Choose b\")\n    b\n}\n这也说明我也不需要像Java那种有一个三元操作符，因为我们可以使用它来简单实现：\n\nval c = if (condition) a else b\n实例\nfun main(args: Array<String>) {\n    var x = 0\n    if(x>0){\n        println(\"x 大于 0\")\n    }else if(x==0){\n        println(\"x 等于 0\")\n    }else{\n        println(\"x 小于 0\")\n    }\n\n    var a = 1\n    var b = 2\n    val c = if (a>=b) a else b\n    println(\"c 的值为 $c\")\n}\n输出结果为：\n\nx 等于 0\nc 的值为 2\n使用区间\n使用 in 运算符来检测某个数字是否在指定区间内，区间格式为 x..y ：\n\n实例\n\nfun main(args: Array<String>) {\n    val x = 5\n    val y = 9\n    if (x in 1..8) {\n        println(\"x 在区间内\")\n    }\n}\n输出结果为：\n\nx 在区间内\nWhen 表达式\nwhen 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。\n\nwhen 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。\n\nwhen 类似其他语言的 switch 操作符。其最简单的形式如下：\n\nwhen (x) {\n    1 -> print(\"x == 1\")\n    2 -> print(\"x == 2\")\n    else -> { // 注意这个块\n        print(\"x 不是 1 ，也不是 2\")\n    }\n}\n在 when 中，else 同 switch 的 default。如果其他分支都不满足条件将会求值 else 分支。\n\n如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：\n\nwhen (x) {\n    0, 1 -> print(\"x == 0 or x == 1\")\n    else -> print(\"otherwise\")\n}\n我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：\n\nwhen (x) {\n    in 1..10 -> print(\"x is in the range\")\n    in validNumbers -> print(\"x is valid\")\n    !in 10..20 -> print(\"x is outside the range\")\n    else -> print(\"none of the above\")\n}\n另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测。\n\nfun hasPrefix(x: Any) = when(x) {\n    is String -> x.startsWith(\"prefix\")\n    else -> false\n}\nwhen 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：\n\nwhen {\n    x.isOdd() -> print(\"x is odd\")\n    x.isEven() -> print(\"x is even\")\n    else -> print(\"x is funny\")\n}\n实例\nfun main(args: Array<String>) {\n    var x = 0\n    when (x) {\n        0, 1 -> println(\"x == 0 or x == 1\")\n        else -> println(\"otherwise\")\n    }\n\n    when (x) {\n        1 -> println(\"x == 1\")\n        2 -> println(\"x == 2\")\n        else -> { // 注意这个块\n            println(\"x 不是 1 ，也不是 2\")\n        }\n    }\n\n    when (x) {\n        in 0..10 -> println(\"x 在该区间范围内\")\n        else -> println(\"x 不在该区间范围内\")\n    }\n}\n输出结果：\n\nx == 0 or x == 1\nx 不是 1 ，也不是 2\nx 在该区间范围内\nwhen 中使用 in 运算符来判断集合内是否包含某实例：\n\nfun main(args: Array<String>) {\n    val items = setOf(\"apple\", \"banana\", \"kiwi\")\n    when {\n        \"orange\" in items -> println(\"juicy\")\n        \"apple\" in items -> println(\"apple is fine too\")\n    }\n}\n输出结果：\n\napple is fine too"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303689818},"updatedAt":{"$$date":1597303879714},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"czCnKTgTnWd6ixVL"}
{"name":"kotlin-Kotlin-Java 互操作指南  |  Android 开发者  |  Android Developers","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /kotlin/interop\nKotlin-Java 互操作指南  |  Android 开发者  |  Android Developers\n7-9 minutes\n本文档提供了关于用 Java 和 Kotlin 编写公共 API 的一系列规则，目的是让您从另一种语言使用代码时感觉其符合语言习惯。\n\n上次更新日期：2018 年 5 月 18 日\n\nJava（供 Kotlin 使用）\n不得使用硬关键字\n请勿将 Kotlin 的任何硬关键字用作方法或字段的名称。从 Kotlin 调用时，这些硬关键字需要使用反引号进行转义。允许使用软关键字、修饰符关键字和特殊标识符。\n\n例如，从 Kotlin 使用时，Mockito 的 when 函数需要使用反引号：\n\nval callable = Mockito.mock(Callable::class.java)\nMockito.`when`(callable.call()).thenReturn(/* … */)\n避免使用 Any 的扩展函数或属性的名称\n除非绝对必要，否则应避免对方法使用 Any 的扩展函数的名称或对字段使用 Any 的扩展属性的名称。虽然成员方法和字段始终优先于 Any 的扩展函数或属性，但读取代码时可能很难知道调用的是哪个。\n\n可为 null 性注释\n公共 API 中的每个非基元参数类型、返回类型和字段类型都应具有可为 null 性注释。不带注释的类型会被解释为“平台”类型，而后者的可为 null 性不明确。\n\nJSR 305 软件包注释可用于设置合理的默认值，但目前不建议这样做。这类注释要求编译器遵循一个选择启用标志，而这与 Java 9 的模块系统存在冲突。\n\nLambda 参数位于最后\n符合 SAM 转换条件的参数类型应位于最后。\n\n例如，RxJava 2’s Flowable.create() 方法签名定义为：\n\npublic static  Flowable create(\n    FlowableOnSubscribe source,\n    BackpressureStrategy mode) { /* … */ }\n由于 FlowableOnSubscribe 符合 SAM 转换条件，因此从 Kotlin 对此方法进行的函数调用如下所示：\n\nFlowable.create({ /* … */ }, BackpressureStrategy.LATEST)\n不过，如果该方法签名中的参数颠倒顺序，则函数调用可以使用尾随 lambda 语法：\n\nFlowable.create(BackpressureStrategy.LATEST) { /* … */ }\n属性前缀\n要使方法在 Kotlin 中表示为属性，必须使用严格的“bean”样式的前缀。\n\n访问器方法需要“get”前缀，而对于布尔值返回方法，可以使用“is”前缀。\n\npublic final class User {\n  public String getName() { /* … */ }\n  public boolean isActive() { /* … */ }\n}\nval name = user.name // Invokes user.getName()\nval active = user.active // Invokes user.isActive()\n关联的更改器方法需要“set”前缀。\n\npublic final class User {\n  public String getName() { /* … */ }\n  public void setName(String name) { /* … */ }\n}\nuser.name = \"Bob\" // Invokes user.setName(String)\n如果要将方法作为属性提供，请勿使用“has”/“set”之类的非标准前缀或不带“get”前缀的访问器。带有非标准前缀的方法仍可作为函数进行调用，这种情况或许可以接受，具体取决于方法的行为。\n\n运算符过载\n请注意在 Kotlin 中允许使用特殊调用点语法（即运算符过载）的方法名称。确保这样的方法名称可以有效地与缩短的语法一起使用。\n\npublic final class IntBox {\n  private final int value;\n  public IntBox(int value) {\n    this.value = value;\n  }\n  public IntBox plus(IntBox other) {\n    return new IntBox(value + other.value);\n  }\n}\nval one = IntBox(1)\nval two = IntBox(2)\nval three = one + two // Invokes one.plus(two)\nKotlin（供 Java 使用）\n文件名\n当文件包含顶级函数或属性时，应始终使用 @file:JvmName(\"Foo\") 对其进行注释，以提供一个合适的名称。\n\n默认情况下，MyClass.kt 文件中的顶级成员最终会进入一个名为 MyClassKt 的类中，此名称没有吸引力，并且会泄露作为实现细节的语言。\n\n不妨考虑添加 @file:JvmMultifileClass，以将多个文件中的顶级成员组合到一个类中。\n\nLambda 参数\n需要从 Java 中使用的函数类型应避免返回类型 Unit。这样做要求指定明确的 return Unit.INSTANCE; 语句，但该语句不符合语言习惯。\n\nfun sayHi(callback: (String) -> Unit) = /* … */\n// Kotlin caller:\ngreeter.sayHi { Log.d(\"Greeting\", \"Hello, $it!\") }\n// Java caller:\ngreeter.sayHi(name -> {\n    Log.d(\"Greeting\", \"Hello, \" + name + \"!\");\n    return Unit.INSTANCE;\n});\n此语法也不允许提供从语义上命名的类型以便在其他类型上实现。\n\n在 Kotlin 中为 lambda 类型定义命名的单一抽象方法 (SAM) 接口可以为 Java 更正此问题，但这样就无法在 Kotlin 中使用 lambda 语法。\n\ninterface GreeterCallback {\n    fun greetName(name: String): Unit\n}fun sayHi(callback: GreeterCallback) = /* … */\n// Kotlin caller:\ngreeter.sayHi(object : GreeterCallback {\n    override fun greetName(name: String) {\n        Log.d(\"Greeting\", \"Hello, $name!\")\n    }\n})\n// Java caller:\ngreeter.sayHi(name -> Log.d(\"Greeting\", \"Hello, \" + name + \"!\"))\n在 Java 中定义命名的 SAM 接口就可以使用稍低版本的 Kotlin lambda 语法，其中必须明确指定接口类型。\n\n// Defined in Java:\ninterface GreeterCallback {\n    void greetName(String name);\n}\nfun sayHi(greeter: GreeterCallback) = /* … */\n// Kotlin caller:\ngreeter.sayHi(GreeterCallback { Log.d(\"Greeting\", \"Hello, $it!\") })\n// Java caller:\ngreeter.sayHi(name -> Log.d(\"Greeter\", \"Hello, \" + name + \"!\"));\n要定义一个在 Java 和 Kotlin 中用作 lambda 的参数类型，又要求在这两种语言中使用时都感觉其符合语言习惯，这在目前还无法做到。当前的建议是优先选用函数类型，虽然当返回类型为 Unit 时在 Java 中的体验会受到影响。\n\n避免使用 Nothing 类属\n类属参数为 Nothing 的类型会作为原始类型提供给 Java。原始类型在 Java 中很少使用，应避免使用。\n\n记录异常\n会抛出受检异常的函数应使用 @Throws 记录这些异常。运行时异常应记录在 KDoc 中。\n\n请注意函数委托给的 API，因为它们可能会抛出 Kotlin 本来会以静默方式允许传播的受检异常。\n\n防御性复制\n从公共 API 返回共享或无主的只读集合时，应将其封装在不可修改的容器中或执行防御性复制。虽然 Kotlin 强制要求它们具备只读属性，但在 Java 端没有这样的强制性要求。如果没有封装容器或不执行防御性复制，可能会因返回长期存在的集合引用而违反不变量。\n\n伴生函数\n伴生对象中的公共函数必须带有 @JvmStatic 注释才能作为静态方法公开。\n\n如果没有该注释，则这些函数只能作为静态 Companion 字段中的实例方法使用。\n\n不正确：没有注释\n\nclass KotlinClass {\n    companion object {\n        fun doWork() {\n            /* … */\n        }\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        KotlinClass.Companion.doWork();\n    }\n}\n正确：@JvmStatic 注释\n\nclass KotlinClass {\n    companion object {\n        @JvmStatic fun doWork() {\n            /* … */\n        }\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        KotlinClass.doWork();\n    }\n}\n伴生常量\n在 companion object 中作为有效常量的公共非 const 属性必须带有 @JvmField 注释才能作为静态字段公开。\n\n如果没有该注释，则这些属性只能作为静态 Companion 字段中命名奇怪的“getter”实例使用。使用 @JvmStatic 而不是 @JvmField 可将命名奇怪的“getter”移至类的静态方法，但这样仍然不正确。\n\n不正确：没有注释\n\nclass KotlinClass {\n    companion object {\n        const val INTEGER_ONE = 1\n        val BIG_INTEGER_ONE = BigInteger.ONE\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        System.out.println(KotlinClass.INTEGER_ONE);\n        System.out.println(KotlinClass.Companion.getBIG_INTEGER_ONE());\n    }\n}\n不正确：@JvmStatic 注释\n\nclass KotlinClass {\n    companion object {\n        const val INTEGER_ONE = 1\n        @JvmStatic val BIG_INTEGER_ONE = BigInteger.ONE\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        System.out.println(KotlinClass.INTEGER_ONE);\n        System.out.println(KotlinClass.getBIG_INTEGER_ONE());\n    }\n}\n正确：@JvmField 注释\n\nclass KotlinClass {\n    companion object {\n        const val INTEGER_ONE = 1\n        @JvmField val BIG_INTEGER_ONE = BigInteger.ONE\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        System.out.println(KotlinClass.INTEGER_ONE);\n        System.out.println(KotlinClass.BIG_INTEGER_ONE);\n    }\n}\n符合语言习惯的命名\nKotlin 的调用规范与 Java 不同，这可能会改变您为函数命名的方式。请使用 @JvmName 设计名称，使其符合这两种语言的规范或与各自的标准库命名保持一致。\n\n扩展函数和扩展属性最常出现这种情况，因为接收器类型的位置不同。\n\nsealed class Optional\ndata class Some(val value: T): Optional()\nobject None : Optional()@JvmName(\"ofNullable\")\nfun  T?.asOptional() = if (this == null) None else Some(this)\n// FROM KOTLIN:\nfun main(vararg args: String) {\n    val nullableString: String? = \"foo\"\n    val optionalString = nullableString.asOptional()\n}\n// FROM JAVA:\npublic static void main(String... args) {\n    String nullableString = \"Foo\";\n    Optional optionalString =\n          Optionals.ofNullable(nullableString);\n}\n默认值的函数过载\n参数具有默认值的函数必须使用 @JvmOverloads。如果没有此注释，则无法使用任何默认值来调用函数。\n\n使用 @JvmOverloads 时，应检查生成的方法，以确保它们每个都有意义。如果它们没有意义，请执行以下一种或两种重构，直到满意为止：\n\n更改参数顺序，使具有默认值的参数尽量接近末尾。\n将默认值移至手动函数过载。\n不正确：没有 @JvmOverloads\n\nclass Greeting {\n    fun sayHello(prefix: String = \"Mr.\", name: String) {\n        println(\"Hello, $prefix $name\")\n    }\n}\npublic class JavaClass {\n    public static void main(String... args) {\n        Greeting greeting = new Greeting();\n        greeting.sayHello(\"Mr.\", \"Bob\");\n    }\n}\n正确：@JvmOverloads 注释\n\nclass Greeting {\n    @JvmOverloads\n    fun sayHello(prefix: String = \"Mr.\", name: String) {\n        println(\"Hello, $prefix $name\")\n    }\n}\npublic class JavaClass {\n    public static void main(String... args) {\n        Greeting greeting = new Greeting();\n        greeting.sayHello(\"Bob\");\n    }\n}\nLint 检查\n要求\nAndroid Studio 版本：3.2 Canary 10 或更高版本\nAndroid Gradle 插件版本：3.2 或更高版本\n支持的检查\n现在有一些 Android Lint 检查可帮助您检测并标记上述某些互操作性问题。目前只检测到了 Java（供 Kotlin 使用）中的问题。具体来说，支持的检查包括：\n\n未知 Null 性\n属性访问\n不得使用 Kotlin 硬关键字\nLambda 参数位于最后\nAndroid Studio\n要启用这些检查，请依次转到 File > Preferences > Editor > Inspections，然后在“Kotlin Interoperability”下勾选要启用的规则：\n\n\n\n图 1.Android Studio 中的 Kotlin 互操作性设置。\n\n勾选要启用的规则后，当您运行代码检查（依次转到 Analyze > Inspect Code…）时，将运行新的检查。\n\n命令行 build\n要通过命令行 build 启用这些检查，请在 build.gradle 文件中添加以下代码行：\n\nandroid {...\n    lintOptions \n\n{\n        enable 'Interoperability'\n    }\n}\n如需了解 lintOptions 内支持的全部配置，请参阅 Android Gradle DSL 参考。\n\n然后，从命令行运行 ./gradlew lint。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397420927},"updatedAt":{"$$date":1597399552938},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"d9Lb2Wi9VGkIQkQk"}
{"name":"qk-","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598586258946},"updatedAt":{"$$date":1598586258946},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"dE7DxItpoGhnontI"}
{"name":"kotlin-为大型团队采用 Kotlin  |  Android 开发者  |  Android Developers","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /kotlin/adopt-for-large-teams\n为大型团队采用 Kotlin  |  Android 开发者  |  Android Developers\n6-8 minutes\nKotlin 是一种编程语言，其语法简洁，并提供了一些新型功能，包括 lambda 支持、可为 null 性（作为类型系统的核心功能）、对属性的一流支持、协程等等。Kotlin 本身支持许多常见的设计模式，包括单例模式和委托模式。\n\n除了语言功能之外，它还由 IntelliJ 的制造商 JetBrains 创建和支持，而 IntelliJ 是 Android Studio 的基石。这种 IDE 集成为 Kotlin 开发提供了很大的支持，可让您的团队实现更高的工作效率。\n\n在 Android 开发中使用 Kotlin\nKotlin 简洁的语法和轻松扩展现有 API 的能力使其既适用于新的 Android API，又适用于现有的 Android API。Kotlin 已通过 Android KTX 扩展项目进入许多核心 Android API。此外，同时支持 Java 和 Kotlin 的许多 Jetpack 组件都包含此库的 KTX 版本，为 Kotlin 开发者提供惯用的 API。许多库（例如 Jetpack 基准库）也已开始用 Kotlin 编写。\n\n并发\nKotlin 支持使用协程进行异步编程。Android 还在许多架构组件（包括 LiveData、ViewModel、Lifecycle 和 WorkManager）中对 Kotlin 协程提供一流的支持。如需了解详情，请参阅将 Kotlin 协程与架构组件一起使用。\n\n行业趋势\n在组织层面考虑编程语言时，一定要从长远的角度来考虑。Kotlin 目前是 GitHub 生态系统中增长最快的语言，正以每年 2.6 倍的速度增长，如图 1 所示。\n\n显示 Kotlin 比其他许多语言增长更快的图表\n图 1.Kotlin 正以指数级的速度增长。\n如果您一直在等待行业走向 Kotlin，那么现在正是放手一搏的大好时机。\n\n迁移途径\n改用任何新语言都是一项艰巨的任务。成功的秘诀在于缓慢起步、循序渐进和经常测试，以使您的团队走向成功。这通常很容易做到，因为 Kotlin 编译成 JVM 字节码，并且可与 Java 完全互操作。\n\n组建团队\n迁移前的第一步是让您的团队建立共同的基本认识。有很多入门资源。下面给出了一些提示，您可能会发现它们对于加快团队的学习进度很有用。\n\n组建学习小组\n学习小组是促进学习和加强记忆的一种有效方法。研究表明，以小组的形式背诵所学内容有助于巩固学到的知识。为每个小组成员分发一本 Kotlin 图书或其他学习资料，并让小组成员每周学习几章。每次聚在一起学习时，小组成员都应该比较他们所学的内容，并讨论任何疑问或发现。\n\n营造教学文化\n虽然并不是每个人都认为自己是老师，但每个人都可以教授知识。从技术或团队领导到个人贡献者，每个人都可以促成一种有助于确保取得成功的学习环境。要促进形成这种学习环境，一种方法是定期举行演讲，指定团队中的一个人谈谈他们已经学到或想要分享的内容。您可以利用学习小组，每周邀请组员自愿讲述一个新的章节，直到团队熟悉这种语言为止。\n\n指定带头人\n最后，指定一个带头人来带领其他人学习。当您开始采用过程时，此人可充当主题专家 (SME)。请务必让此人参加与 Kotlin 相关的所有实践会议。带头人最好热衷于 Kotlin 并且已经具备一些相关实践知识。\n\n缓集成\n缓慢起步并从战略上思考最先迁移生态系统的哪些部分是关键所在。通常，最好将此工作隔离到组织内的单个应用（而不是旗舰应用）中。在迁移选定的应用方面，每种情况不尽相同，但都可以参考下面这些常见的起步方法。\n\n数据模型\n您的数据模型可能包含大量的状态信息以及一些方法。数据模型还可能包含一些常见方法，例如 toString()、equals() 和 hashcode()。这些方法通常可以在隔离的环境中轻松地进行转换和单元测试。\n\n例如，假设有以下 Java 代码段：\n\npublic class Person {private String firstName;\n   private String lastName;\n   // ...public String getFirstName() {\n       return firstName;\n   }\n   public void setFirstName(String firstName) {\n       this.firstName = firstName;\n   }\n   public String getLastName() {\n       return lastName;\n   }\n   public void setLastName(String lastName) {\n       this.lastName = lastName;\n   }\n   \n   @Override\n   public boolean equals(Object o) {\n       if (this == o) return true;\n       if (o == null || getClass() != o.getClass()) return false;\n       Person person = (Person) o;\n       return Objects.equals(firstName, person.firstName) &&\n               Objects.equals(lastName, person.lastName);\n   }\n   @Override\n   public int hashCode() {\n       return Objects.hash(firstName, lastName);\n   }\n   @Override\n   public String toString() {\n       return \"Person{\" +\n               \"firstName='\" + firstName + '\\'' +\n               \", lastName='\" + lastName + '\\'' +\n               '}';\n   }\n}\n您可以将其转换为等效的 Kotlin 代码，如下所示：\n\ndata class Person(var firstName: String?, var lastName : String?)\n随后可以针对当前的测试套件对此代码进行单元测试。我们的想法是从小规模入手，一次迁移一个模型，并转换大部分是状态而非行为的类。请务必在此过程中进行测试。\n\n迁移测试\n需要考虑的另一个起步途径是转换现有的测试并开始用 Kotlin 编写新的测试。这样能让您的团队有时间先熟悉这种语言，然后再编写计划随 APK 一起提供的代码。\n\n将实用程序方法移至扩展函数\n任何静态实用程序类（StringUtils、IntegerUtils、DateUtils、YourCustomTypeUtils 等等）均可表示为 Kotlin 扩展函数并供现有 Java 代码库使用。\n\n例如，假设您有一个 StringUtils 类，它包含一些方法：\n\npackage com.java.project;public class StringUtils {public static String foo(String receiver) {\n       return receiver...;  // Transform the receiver in some way\n   }\n   public static String bar(String receiver) {\n       return receiver...;  // Transform the receiver in some way\n   }\n}\n这些方法随后可能会在应用中的其他位置使用，如以下示例所示：\n\n...String myString = ...\nString fooString = StringUtils.foo(myString);...\n使用 Kotlin 扩展函数，可以向 Java 调用方提供相同的 Utils 接口，同时又能为不断增长的 Kotlin 代码库提供更简洁的 API。\n\n为此，您可以先使用 IDE 提供的自动转换功能将此 Utils 类转换为 Kotlin 代码。示例输出可能与以下代码类似：\n\npackage com.java.projectobject StringUtils {fun foo(receiver: String): String {\n       return receiver...;  // Transform the receiver in some way\n   }fun bar(receiver: String): String {\n       return receiver...;  // Transform the receiver in some way\n   }}\n接下来，移除类或对象定义，在每个函数名称前面加上应该应用此函数的类型作为前缀，并用其引用函数内的类型，如以下示例所示：\n\npackage com.java.projectfun String.foo(): String {\n    return this...;  // Transform the receiver in some way\n}fun String.bar(): String {\n    return this...;  // Transform the receiver in some way\n}\n最后，将 JvmName 注释添加到源文件的顶部，以使编译的名称与应用的其余部分兼容，如以下示例所示：\n\n@file:JvmName(\"StringUtils\")\npackage com.java.project\n...\n最终版本应与以下代码类似：\n\n@file:JvmName(\"StringUtils\")\npackage com.java.projectfun String.foo(): String {\n    return this...;  // Transform `this` string in some way\n}fun String.bar(): String {\n    return this...;  // Transform `this` string in some way\n}\n请注意，现在可以按照与每种语言匹配的惯例，使用 Java 或 Kotlin 调用这些函数。\n\n...\nval myString: String = ...\nval fooString = myString.foo()\n...\n...\nString myString = ...\nString fooString = StringUtils.foo(myString);\n...\n完成迁移\n您的团队熟悉 Kotlin 并且您迁移了较小的部分后，您可以继续处理较大的组件，如 Fragment、Activity、ViewModel 对象，以及与业务逻辑相关的其他类。\n\n注意事项\n就像 Java 有特定的样式一样，Kotlin 也有自己的惯用样式，正是这种样式促成了它的简洁。不过，一开始您可能会发现，您的团队生成的 Kotlin 代码看起来更像是要替换的 Java 代码。随着您的团队不断积累使用 Kotlin 的经验，这种情况会随着时间的推移而改变。切记，逐步改变是取得成功的关键。\n\n随着 Kotlin 代码库不断增长，您可以采取以下几项措施来保持一致性：\n\n通用编码标准\n请务必在采用过程中尽早制定一套标准的编码规范。只要合理，您的规范可以背离 Android Kotlin 样式指南。\n\n静态分析工具\n使用 Android Lint 和其他静态分析工具强制执行为您的团队制定的编码标准。第三方 Kotlin Linter klint 也针对 Kotlin 提供了额外的规则。\n\n持续集成\n请确保符合通用编码标准，并为 Kotlin 代码提供足够的测试覆盖范围。将此纳入自动构建流程有助于确保一致性和遵循这些标准。\n\n互操作性\nKotlin 在大多数情况下可与 Java 无缝互操作，但请注意以下几点。\n\n可为 null 性\nKotlin 依靠编译的代码中的可为 null 性注释在 Kotlin 端推断可为 null 性。如果未提供注释，则 Kotlin 默认采用平台类型（可将其视为可为 null 类型，也可将其视为不可为 null 类型）。不过，如果不小心处理，这可能会导致运行时 NullPointerException 问题。\n\n采用新功能\nKotlin 提供了许多新库和语法糖以减少样板代码，这有助于提高开发速度。即便如此，在使用 Kotlin 的标准库函数（例如集合函数、协程和 lambda）时，还是应该小心谨慎并且讲究条理。\n\n下面是新手 Kotlin 开发者经常遇到的一个陷阱。假设有以下 Kotlin 代码：\n\nval nullableFoo: Foo? = ...// This lambda executes only if nullableFoo is not null\n// and `foo` is of the non-nullable Foo type\nnullableFoo?.let { foo ->\n   foo.baz()\n   foo.zap()\n}\n本例的目的是在 nullableFoo 不为 null 的情况下执行 foo.baz() 和 foo.zap()，从而避免出现 NullPointerException。虽然这段代码可以发挥预期的作用，但读起来不如简单的 null 检查和智能类型转换直观，如以下示例所示：\n\nval nullableFoo: Foo? = null\nif (nullableFoo != null) {\n    nullableFoo.baz() // Using !! or ?. isn't required; the Kotlin compiler infers non-nullability\n    nullableFoo.zap() // from guard condition; smart casts nullableFoo to Foo inside this block\n}\n测试\n在 Kotlin 中，默认情况下，类及其函数处于关闭状态，不能扩展。您必须明确打开要子类化的类和函数。此行为是一种语言设计决策，旨在促进代码的编写而不是继承。Kotlin 具有内置支持，可通过委托实现行为，以帮助简化代码的编写。\n\n此行为会给依靠接口实现或继承在测试期间替换行为的模拟框架（如 Mockito）带来问题。对于单元测试，您可以启用 Mockito 的 Mock Maker Inline 功能，该功能可让您模拟最终类和方法。或者，您也可以使用 All-Open 编译器插件在编译过程中打开要测试的任何 Kotlin 类及其成员。使用此插件的主要优势在于，它既支持单元测试，又支持插桩测试。\n\n更多信息\n如需详细了解如何使用 Kotlin，请参阅以下链接：\n\nKotlin 编程语言"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397427028},"updatedAt":{"$$date":1597400537289},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"dFqdxJqZIbqrh5qR"}
{"name":"kqapp-","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593279705},"updatedAt":{"$$date":1598593279705},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"dU3g8S6zGGqHRHXt"}
{"name":"HTML5 表单元素","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\nHTML5 表单元素\nHTML5 新的表单元素\nHTML5 有以下新的表单元素:\n\n<datalist>\n<keygen>\n<output>\n注意:不是所有的浏览器都支持HTML5 新的表单元素，但是你可以在使用它们，即使浏览器不支持表单属性，仍然可以显示为常规的表单元素。\n\nHTML5 <datalist> 元素\n<datalist> 元素规定输入域的选项列表。\n\n<datalist> 属性规定 form 或 input 域应该拥有自动完成功能。当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项：\n\n使用 <input> 元素的列表属性与 <datalist> 元素绑定.\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n<input> 元素使用<datalist>预定义值:\n\n<input list=\"browsers\">\n \n<datalist id=\"browsers\">\n  <option value=\"Internet Explorer\">\n  <option value=\"Firefox\">\n  <option value=\"Chrome\">\n  <option value=\"Opera\">\n  <option value=\"Safari\">\n</datalist>\n\n尝试一下 »\n\nHTML5 <keygen> 元素\n<keygen> 元素的作用是提供一种验证用户的可靠方法。\n\n<keygen>标签规定用于表单的密钥对生成器字段。\n\n当提交表单时，会生成两个键，一个是私钥，一个公钥。\n\n私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n带有keygen字段的表单:\n\n<form action=\"demo_keygen.asp\" method=\"get\">\n用户名: <input type=\"text\" name=\"usr_name\">\n加密: <keygen name=\"security\">\n<input type=\"submit\">\n</form>\n\n尝试一下 »\n\nHTML5 <output> 元素\n<output> 元素用于不同类型的输出，比如计算或脚本输出：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n将计算结果显示在 <output> 元素:\n\n<form oninput=\"x.value=parseInt(a.value)+parseInt(b.value)\">0\n<input type=\"range\" id=\"a\" value=\"50\">100 +\n<input type=\"number\" id=\"b\" value=\"50\">=\n<output name=\"x\" for=\"a b\"></output>\n</form>\n\n尝试一下 »\n\nHTML5 新表单元素\n标签\t描述\n<datalist>\t<input>标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。\n<keygen>\t<keygen> 标签规定用于表单的密钥对生成器字段。\n<output>\t<output> 标签定义不同类型的输出，比如脚本的输出。\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887689864},"updatedAt":{"$$date":1598887849833},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"dp3jSoziSr3Fr6h6"}
{"name":"kotlin-泛型：in、out、where - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/generics.html\n泛型：in、out、where - Kotlin 语言中文站\n25-31 minutes\n改进翻译\n与 Java 类似，Kotlin 中的类也可以有类型参数：\n\nclass Box<T>(t: T) {\n    var value = t\n}\n一般来说，要创建这样类的实例，我们需要提供类型参数：\n\nval box: Box<Int> = Box<Int>(1)\n但是如果类型参数可以推断出来，例如从构造函数的参数或者从其他途径，允许省略类型参数：\n\nval box = Box(1) // 1 具有类型 Int，所以编译器知道我们说的是 Box<Int>。\nJava 类型系统中最棘手的部分之一是通配符类型（参见 Java Generics FAQ）。 而 Kotlin 中没有。 相反，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。\n\n首先，让我们思考为什么 Java 需要那些神秘的通配符。在 《Effective Java》第三版 解释了该问题——第 31 条：利用有限制通配符来提升 API 的灵活性。 首先，Java 中的泛型是不型变的，这意味着 List<String> 并不是 List<Object> 的子类型。 为什么这样？ 如果 List 不是不型变的，它就没比 Java 的数组好到哪去，因为如下代码会通过编译然后导致运行时异常：\n\n// Java\nList<String> strs = new ArrayList<String>();\nList<Object> objs = strs; // ！！！此处的编译器错误让我们避免了之后的运行时异常\nobjs.add(1); // 这里我们把一个整数放入一个字符串列表\nString s = strs.get(0); // ！！！ ClassCastException：无法将整数转换为字符串\n因此，Java 禁止这样的事情以保证运行时的安全。但这样会有一些影响。例如，考虑 Collection 接口中的 addAll() 方法。该方法的签名应该是什么？直觉上，我们会这样：\n\n// Java\ninterface Collection<E> …… {\n  void addAll(Collection<E> items);\n}\n但随后，我们就无法做到以下简单的事情（这是完全安全）：\n\n// Java\nvoid copyAll(Collection<Object> to, Collection<String> from) {\n  to.addAll(from);\n  // ！！！对于这种简单声明的 addAll 将不能编译：\n  // Collection<String> 不是 Collection<Object> 的子类型\n}\n（在 Java 中，我们艰难地学到了这个教训，参见《Effective Java》第三版，第 28 条：列表优先于数组）\n\n这就是为什么 addAll() 的实际签名是以下这样：\n\n// Java\ninterface Collection<E> …… {\n  void addAll(Collection<? extends E> items);\n}\n通配符类型参数 ? extends E 表示此方法接受 E 或者 E 的 一些子类型对象的集合，而不只是 E 自身。 这意味着我们可以安全地从其中（该集合中的元素是 E 的子类的实例）读取 E，但不能写入， 因为我们不知道什么对象符合那个未知的 E 的子类型。 反过来，该限制可以让Collection<String>表示为Collection<? extends Object>的子类型。 简而言之，带 extends 限定（上界）的通配符类型使得类型是协变的（covariant）。\n\n理解为什么这个技巧能够工作的关键相当简单：如果只能从集合中获取项目，那么使用 String 的集合， 并且从其中读取 Object 也没问题 。反过来，如果只能向集合中 放入 项目，就可以用 Object 集合并向其中放入 String：在 Java 中有 List<? super String> 是 List<Object> 的一个超类。\n\n后者称为逆变性（contravariance），并且对于 List <? super String> 你只能调用接受 String 作为参数的方法 （例如，你可以调用 add(String) 或者 set(int, String)），当然如果调用函数返回 List<T> 中的 T，你得到的并非一个 String 而是一个 Object。\n\nJoshua Bloch 称那些你只能从中读取的对象为生产者，并称那些你只能写入的对象为消费者。他建议：“为了灵活性最大化，在表示生产者或消费者的输入参数上使用通配符类型”，并提出了以下助记符：\n\nPECS 代表生产者-Extens，消费者-Super（Producer-Extends, Consumer-Super）。\n\n注意：如果你使用一个生产者对象，如 List<? extends Foo>，在该对象上不允许调用 add() 或 set()。但这并不意味着该对象是不可变的：例如，没有什么阻止你调用 clear()从列表中删除所有项目，因为 clear() 根本无需任何参数。通配符（或其他类型的型变）保证的唯一的事情是类型安全。不可变性完全是另一回事。\n\n假设有一个泛型接口 Source<T>，该接口中不存在任何以 T 作为参数的方法，只是方法返回 T 类型值：\n\n// Java\ninterface Source<T> {\n  T nextT();\n}\n那么，在 Source <Object> 类型的变量中存储 Source <String> 实例的引用是极为安全的——没有消费者-方法可以调用。但是 Java 并不知道这一点，并且仍然禁止这样操作：\n\n// Java\nvoid demo(Source<String> strs) {\n  Source<Object> objects = strs; // ！！！在 Java 中不允许\n  // ……\n}\n为了修正这一点，我们必须声明对象的类型为 Source<? extends Object>，这是毫无意义的，因为我们可以像以前一样在该对象上调用所有相同的方法，所以更复杂的类型并没有带来价值。但编译器并不知道。\n\n在 Kotlin 中，有一种方法向编译器解释这种情况。这称为声明处型变：我们可以标注 Source 的类型参数 T 来确保它仅从 Source<T> 成员中返回（生产），并从不被消费。 为此，我们提供 out 修饰符：\n\ninterface Source<out T> {\n    fun nextT(): T\n}\n\nfun demo(strs: Source<String>) {\n    val objects: Source<Any> = strs // 这个没问题，因为 T 是一个 out-参数\n    // ……\n}\n一般原则是：当一个类 C 的类型参数 T 被声明为 out 时，它就只能出现在 C 的成员的输出-位置，但回报是 C<Base> 可以安全地作为 C<Derived>的超类。\n\n简而言之，他们说类 C 是在参数 T 上是协变的，或者说 T 是一个协变的类型参数。 你可以认为 C 是 T 的生产者，而不是 T 的消费者。\n\nout修饰符称为型变注解，并且由于它在类型参数声明处提供，所以我们称之为声明处型变。 这与 Java 的使用处型变相反，其类型用途通配符使得类型协变。\n\n另外除了 out，Kotlin 又补充了一个型变注释：in。它使得一个类型参数逆变：只可以被消费而不可以被生产。逆变类型的一个很好的例子是 Comparable：\n\ninterface Comparable<in T> {\n    operator fun compareTo(other: T): Int\n}\n\nfun demo(x: Comparable<Number>) {\n    x.compareTo(1.0) // 1.0 拥有类型 Double，它是 Number 的子类型\n    // 因此，我们可以将 x 赋给类型为 Comparable <Double> 的变量\n    val y: Comparable<Double> = x // OK！\n}\n我们相信 in 和 out 两词是自解释的（因为它们已经在 C# 中成功使用很长时间了）， 因此上面提到的助记符不是真正需要的，并且可以将其改写为更高的目标：\n\n存在性（The Existential） 转换：消费者 in, 生产者 out! :-)\n\n将类型参数 T 声明为 out 非常方便，并且能避免使用处子类型化的麻烦，但是有些类实际上不能限制为只返回 T！ 一个很好的例子是 Array：\n\nclass Array<T>(val size: Int) {\n    fun get(index: Int): T { …… }\n    fun set(index: Int, value: T) { …… }\n}\n该类在 T 上既不能是协变的也不能是逆变的。这造成了一些不灵活性。考虑下述函数：\n\nfun copy(from: Array<Any>, to: Array<Any>) {\n    assert(from.size == to.size)\n    for (i in from.indices)\n        to[i] = from[i]\n}\n这个函数应该将项目从一个数组复制到另一个数组。让我们尝试在实践中应用它：\n\nval ints: Array<Int> = arrayOf(1, 2, 3)\nval any = Array<Any>(3) { \"\" } \ncopy(ints, any)\n//   ^ 其类型为 Array<Int> 但此处期望 Array<Any>\n这里我们遇到同样熟悉的问题：Array <T> 在 T 上是不型变的，因此 Array <Int> 和 Array <Any> 都不是另一个的子类型。为什么？ 再次重复，因为 copy 可能做坏事，也就是说，例如它可能尝试写一个 String 到 from， 并且如果我们实际上传递一个 Int 的数组，一段时间后将会抛出一个 ClassCastException 异常。\n\n那么，我们唯一要确保的是 copy() 不会做任何坏事。我们想阻止它写到 from，我们可以：\n\nfun copy(from: Array<out Any>, to: Array<Any>) { …… }\n这里发生的事情称为类型投影：我们说from不仅仅是一个数组，而是一个受限制的（投影的）数组：我们只可以调用返回类型为类型参数 T 的方法，如上，这意味着我们只能调用 get()。这就是我们的使用处型变的用法，并且是对应于 Java 的 Array<? extends Object>、 但使用更简单些的方式。\n\n你也可以使用 in 投影一个类型：\n\nfun fill(dest: Array<in String>, value: String) { …… }\nArray<in String> 对应于 Java 的 Array<? super String>，也就是说，你可以传递一个 CharSequence 数组或一个 Object 数组给 fill() 函数。\n\n有时你想说，你对类型参数一无所知，但仍然希望以安全的方式使用它。 这里的安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化将是该投影的子类型。\n\nKotlin 为此提供了所谓的星投影语法：\n\n对于 Foo <out T : TUpper>，其中 T 是一个具有上界 TUpper 的协变类型参数，Foo <*> 等价于 Foo <out TUpper>。 这意味着当 T 未知时，你可以安全地从 Foo <*> 读取 TUpper 的值。\n对于 Foo <in T>，其中 T 是一个逆变类型参数，Foo <*> 等价于 Foo <in Nothing>。 这意味着当 T 未知时，没有什么可以以安全的方式写入 Foo <*>。\n对于 Foo <T : TUpper>，其中 T 是一个具有上界 TUpper 的不型变类型参数，Foo<*> 对于读取值时等价于 Foo<out TUpper> 而对于写值时等价于 Foo<in Nothing>。\n如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 interface Function <in T, out U>，我们可以想象以下星投影：\n\nFunction<*, String> 表示 Function<in Nothing, String>；\nFunction<Int, *> 表示 Function<Int, out Any?>；\nFunction<*, *> 表示 Function<in Nothing, out Any?>。\n注意：星投影非常像 Java 的原始类型，但是安全。\n\n不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前：\n\nfun <T> singletonList(item: T): List<T> {\n    // ……\n}\n\nfun <T> T.basicToString(): String {  // 扩展函数\n    // ……\n}\n要调用泛型函数，在调用处函数名之后指定类型参数即可：\n\nval l = singletonList<Int>(1)\n可以省略能够从上下文中推断出来的类型参数，所以以下示例同样适用：\n\n能够替换给定类型参数的所有可能类型的集合可以由泛型约束限制。\n\n最常见的约束类型是与 Java 的 extends 关键字对应的 上界：\n\nfun <T : Comparable<T>> sort(list: List<T>) {  …… }\n冒号之后指定的类型是上界：只有 Comparable<T> 的子类型可以替代 T。 例如：\n\nsort(listOf(1, 2, 3)) // OK。Int 是 Comparable<Int> 的子类型\nsort(listOf(HashMap<Int, String>())) // 错误：HashMap<Int, String> 不是 Comparable<HashMap<Int, String>> 的子类型\n默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，我们需要一个单独的 where-子句：\n\nfun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>\n    where T : CharSequence,\n          T : Comparable<T> {\n    return list.filter { it > threshold }.map { it.toString() }\n}\n所传递的类型必须同时满足 where 子句的所有条件。在上述示例中，类型 T 必须既实现了 CharSequence 也实现了 Comparable。\n\nKotlin 为泛型声明用法执行的类型安全检测仅在编译期进行。 运行时泛型类型的实例不保留关于其类型实参的任何信息。 其类型信息称为被擦除。例如，Foo<Bar> 与 Foo<Baz?> 的实例都会被擦除为 Foo<*>。\n\n因此，并没有通用的方法在运行时检测一个泛型类型的实例是否通过指定类型参数所创建 ，并且编译器禁止这种 is 检测。\n\n类型转换为带有具体类型参数的泛型类型，如 foo as List<String> 无法在运行时检测。 当高级程序逻辑隐含了类型转换的类型安全而无法直接通过编译器推断时， 可以使用这种非受检类型转换。编译器会对非受检类型转换发出警告，并且在运行时只对非泛型部分检测（相当于 foo as List<*>）。\n\n泛型函数调用的类型参数也同样只在编译期检测。在函数体内部， 类型参数不能用于类型检测，并且类型转换为类型参数（foo as T）也是非受检的。然而， 内联函数的具体化的类型参数会由调用处内联函数体中的类型实参所代入，因此可以用于类型检测与转换， 与上述泛型类型的实例具有相同限制。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307924262},"updatedAt":{"$$date":1597308042376},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"e8ey8GNQuBhjUP1B"}
{"name":"kqapp-lightlearn_module_base2","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n/**\n * 使BaseViewHolder中  SimpleDraweeView 可以 setImageUri\n * @receiver BaseViewHolder\n * @param viewId Int\n * @param imgUrl String?\n * @return BaseViewHolder\n */\nfun BaseViewHolder.setImageURI(@IdRes viewId: Int, @Nullable imgUrl: String?): BaseViewHolder {\n    getView<SimpleDraweeView>(viewId).setImageURI(imgUrl)\n    return this\n}\n\n/**\n *设置透明值\n * @receiver BaseViewHolder\n * @param viewId Int\n * @param alpha Float 0-255\n * @return BaseViewHolder\n */\nfun BaseViewHolder.setAlpha(@IdRes viewId: Int, alpha: Float): BaseViewHolder {\n    getView<View>(viewId).alpha = alpha\n    return this\n}\n\n/**\n * 反转 view visibility\n * @receiver BaseViewHolder\n * @param viewId Int\n * @return BaseViewHolder\n */\nfun BaseViewHolder.reverseViewVisible(@IdRes viewId: Int): BaseViewHolder {\n    getView<View>(viewId).reverseVisibility()\n    return this\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author liangsaifei\n * 邮箱：liangsaifei@ksjgs.com\n * 创建时间: 2020/5/9     4:47 PM\n * 用途:\n ***************************************\n\n */\n\nfun Context.getColorKt(@ColorRes color:Int):Int{\n    return ContextCompat.getColor(this,color)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninline fun <reified T : View> DialogPlus.findView(@IdRes resId: Int): T? {\n    return findViewById(resId) as T?\n}\n\ninline fun <reified T : TextView> DialogPlus.setText(@IdRes resId: Int, text: String): DialogPlus {\n    findView<T>(resId)?.text = text\n    return this\n}\n\ninline fun <reified T : SimpleDraweeView> DialogPlus.setImageURI(@IdRes resId: Int, imgUri: String?): DialogPlus {\n    val view = findView<T>(resId)\n    val isStartWithFile = imgUri?.startsWith(\"file\") ?: false\n    val isStartWithHttp = imgUri?.startsWith(\"http\") ?: false\n    when {\n        isStartWithFile -> { //本地图片\n            view?.let { FrescoUtils.loadGifFromSdcard(it, imgUri ?: \"\") }\n        }\n        isStartWithHttp -> { //在线图片\n            view?.let { FrescoUtils.loadWebpImg(it, imgUri ?: \"\") }\n        }\n        else -> {//asset 文件\n            view?.let {\n//                FrescoUtils.loadGifFromAsset(it, imgUri ?: \"\")\n                it.setGif(imgUri ?: \"\")\n            }\n        }\n    }\n\n    return this\n}\n\ninline fun <reified T : ImageView> DialogPlus.setImageResource(@IdRes resId: Int, @IdRes imgRes: Int): DialogPlus {\n    findView<T>(resId)?.setImageResource(imgRes)\n    return this\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage com.ks.lightlearn.base.ktx\n\nimport androidx.lifecycle.ViewModel\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.transform\n\n/**\n ***************************************\n * 项目名称:jrhApplication\n * @Author jiaruihua\n * 邮箱：jiaruihua@ksjgs.com\n * 创建时间: 2020/8/21     3:20 PM\n * 用途:\n *\n *     viewModel.uiState.onEachEvent {\n *          when (it) {\n *              is UiState.ContentShow -> {\n *                  tvContent.text = it.content + \"${System.currentTimeMillis()}\"\n *              }\n *              is UiState.SubmitShow -> {\n *                  tvContent.text = \"object---${System.currentTimeMillis()}\"\n *              }\n *          }\n *      }.launchIn(lifecycleScope)\n *\n *\n ****************************************************************************************\n * Demo\n * _________________________________________________________________________________\n *\n *      class FlowViewModel : ViewModel() {\n *\n *       val uiState: StateFlow<Event<UiState>> get() = _state\n *\n *       var _state = MutableStateFlow<Event<UiState>>(Event(UiState.None))\n *\n *       var submitVersion = 0\n *\n *       /**\n *        * 每次submitVersion 的值更新 ，会实时收到刷新\n *       */\n *       fun submit() {\n *          _state.value = Event(UiState.ContentShow(\"${++submitVersion}show-time\"))\n *       }\n *\n *       fun submitSame() {\n *          val state = UiState.ContentShow(\"${submitVersion}show-time\")\n *           _state.value = Event(state)\n *       }\n *\n *       fun submitObjectValue() {\n *           _state.value = Event(UiState.SubmitShow)\n *           }\n *       }\n *\n *__________________________________________________________________________________\n *\n *\n *       sealed class UiState(var id: Long = System.currentTimeMillis()) {\n *\n *           object None : UiState()\n *           object SubmitShow : UiState()\n *           data class ContentShow(val content: String) : UiState()\n *       }\n *\n *  ******************************************************************************\n *\n */\n\n\n/**\n *  T 使用一次既失效\n */\nopen class Event<out T>(private val content: T) {\n\n    private var hasBeenHandled = false\n\n\n    /**\n     * Returns the content and prevents its use again.\n     */\n    fun getContentIfNotHandled(): T? {\n        return if (hasBeenHandled) {\n            null\n        } else {\n            hasBeenHandled = true\n            content\n        }\n    }\n\n    /**\n     * Returns the content, even if it's already been handled.\n     */\n    fun peekContent(): T = content\n}\n\n\n/**\n *  为了捕获每次发送的event状态，扩展 ，\n *\n * Returns a flow which performs the given [action] on each value of the original flow's [Event].\n */\nfun <T> Flow<Event<T?>>.onEachEvent(action: suspend (T) -> Unit): Flow<T> = transform { value ->\n    value.getContentIfNotHandled()?.let {\n        action(it)\n        return@transform emit(it)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 设置图片 的动画\n * @param gifFile String gif名称， asset目录下的gif，要以gif结尾\n */\nfun ImageView.setGif(gifFile: String){\n    if (gifFile.isNotEmpty()){\n        val gifName = if (gifFile.endsWith(\"gif\",true)) gifFile else \"$gifFile.gif\"\n        val imageDrawable = GifDrawable(context.assets, gifName)\n        setImageDrawable(imageDrawable)\n    }\n}\n\n\nfun ImageView.setStopGif(gifFile: String){\n    if (gifFile.isNotEmpty()){\n        val gifName = if (gifFile.endsWith(\"gif\",true)) gifFile else \"$gifFile.gif\"\n        val imageDrawable = GifDrawable(context.assets, gifName)\n        setImageDrawable(imageDrawable)\n        imageDrawable.stop()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author liangsaifei\n * 邮箱：liangsaifei@ksjgs.com\n * 创建时间: 2020/8/26     6:12 PM\n * 用途: postCard 的扩展，方便使用\n *\n *\n *\n *      KsRouter.getInstance().build(RouterPath.Course.COURSE_SCHEDULE_PAGE)\n *           .withVararg(RouterExtra.ID to periodId,\n *           RouterExtra.TYPE to courseType,\n *          RouterExtra.KEY_STAGE_ID to stageId)\n *           .navigation()\n *\n *\n ***************************************\n\n */\n\n/**\n *\n * @receiver KsPostcard\n * @param pairs Array<out Pair<String, V>>\n * @return KsPostcard\n */\nfun <V> KsPostcard.withVararg(vararg pairs: Pair<String, V>): KsPostcard {\n    pairs.onEach {\n        with(it.first, it.second)\n    }\n    return this\n}\n\nprivate fun <T> KsPostcard.with(key: String, value: T): KsPostcard {\n    when (value) {\n        is String ->\n            withString(key, value)\n        is Boolean ->\n            withBoolean(key, value)\n        is Int ->\n            withInt(key, value)\n        is Serializable ->\n            withSerializable(key, value)\n        is Parcelable ->\n            withParcelable(key, value)\n        is Short ->\n            withShort(key, value)\n        is Long ->\n            withLong(key, value)\n    }\n    return this\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author yangjilai\n * 邮箱：cangming@126.com\n * 创建时间: 2020-02-26     12:58\n * 用途：\n ***************************************\n *\n */\n// 登录模块是否单独调试\nfun isLoginModuleDebugAlone(): Boolean {\n    return BuildConfig.isLoginModule == 1\n}\n\n// 我的模块是否单独调试\nfun isMineModuleDebugAlone(): Boolean {\n    return BuildConfig.isMineModule == 1\n}\n\n// 首页模块是否单独调试\nfun isHomeModuleDebugAlone(): Boolean {\n    return BuildConfig.isHomeModule == 1\n}\n\n// 售卖模块是否单独调试\nfun isProductModuleDebugAlone(): Boolean {\n    return BuildConfig.isProductModule == 1\n}\n\n// 课程模块是否单独调试\nfun isCourseModuleDebugAlone(): Boolean {\n    return BuildConfig.isCourseModule == 1\n}\n\n// 图片选择模块是否单独调试\nfun isPictureSelectModuleDebugAlone(): Boolean {\n    return BuildConfig.isPictureSelectModule == 1\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nobject PermissionUtil {\n\n    fun badRom() = Rom.isSmartisan() || Rom.isOppo() || Rom.isVivo()\n\n    fun hasCameraPermission(): Boolean {\n        try {\n            if (!isCameraCanUse()) {\n                return false\n            }\n            if (!isHasCameraPermission()) {\n                return false\n            }\n        } catch (e: Exception) {\n            return false\n        }\n\n        return true\n    }\n\n    /**\n     * 通过反射获取 是否有相机权限\n     *\n     * vivo oppo 手机不管授权与否都会\n     * 返回PackageManager.PERMISSION_GRANTED（已授权）故作特殊处理\n     * @return Boolean\n     */\n    fun isHasCameraPermission(): Boolean {\n        val fieldPassword: Field\n        var camera: Camera? = null\n        return try {\n            camera = Camera.open()\n            //通过反射去拿相机是否获得了权限\n            fieldPassword = camera.javaClass.getDeclaredField(\"mHasPermission\")\n            fieldPassword.isAccessible = true\n            val result = fieldPassword.get(camera) as Boolean\n            camera?.release()\n            result\n\n\n        } catch (e: java.lang.Exception) {\n            e.printStackTrace()\n            true\n        } finally {\n            camera?.release()\n        }\n    }\n\n    /**\n     * 相机是否可用\n     * ps:有些手机即使禁掉拍照权限获取到的camera也不为null（比如魅族，oppoR9s）\n     *\n     * @return\n     */\n    fun isCameraCanUse(): Boolean {\n        var canUse = true\n        try {\n            val camera = Camera.open()\n            val mParameters = camera.parameters\n            camera.parameters = mParameters\n        } catch (e: Exception) {\n            canUse = false\n        }\n        return canUse\n    }\n}\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author liangsaifei\n * 邮箱：liangsaifei@ksjgs.com\n * 创建时间: 2020/3/11     7:12 PM\n * 用途: SimpleDraweeView 扩展\n ***************************************\n\n */\n\n\nfun SimpleDraweeView.setImageUriWebp(uri: String?) {\n    uri?.let {\n        FrescoUtils.loadWebpImg(this, uri)\n    }\n\n}\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author yangjilai\n * 邮箱：cangming@126.com\n * 创建时间: 2020-03-17     17:20\n * 用途：\n ***************************************\n *\n */\n\n/**\n * 数据打点Show 事件\n * @receiver BaseActivity\n */\nfun BaseActivity.uploadShowEvent(pageCode: String = \"\", map: Map<String, String>? = null) {\n    var json = JSONObject()\n    if (map != null) {\n        for (key in map.keys) {\n            json.put(key, map[key])\n        }\n    }\n    Tracker.instance.trackEvent(if (pageCode.isEmpty()) getPageCode() else pageCode, \"show\", getSourceName(), json)\n}\n\n\n/**\n * 数据打点 Back 事件\n * @receiver BaseActivity\n */\nfun BaseActivity.uploadBackEvent(map: Map<String, String>? = null) {\n    var json = JSONObject()\n    Tracker.instance.trackEvent(getPageCode(), \"back\", getSourceName(), json)\n}\n\n\n/**\n * 数据打点  popup_show 事件\n * @receiver BaseActivity\n */\nfun BaseActivity.uploadPoupShowEvent(pageCode: String = \"\", map: Map<String, String>? = null) {\n    var json = JSONObject()\n    if (map != null) {\n        for (key in map.keys) {\n            json.put(key, map[key])\n        }\n    }\n    Tracker.instance.trackEvent(if (pageCode.isEmpty()) getPageCode() else pageCode, \"popup_show\", getSourceName(), json)\n}\n\n/**\n * 数据打点  popup_showClick 事件\n * @receiver BaseActivity\n */\nfun BaseActivity.uploadPoupClickEvent(pageCode: String = \"\", map: Map<String, String>? = null) {\n    var json = JSONObject()\n    if (map != null) {\n        for (key in map.keys) {\n            json.put(key, map[key])\n        }\n    }\n    Tracker.instance.trackEvent(if (pageCode.isEmpty()) getPageCode() else pageCode, \"popup_click\", getSourceName(), json)\n}\n\n\n/**\n * 数据上报 Activity 点击事件\n * @receiver BaseActivity\n * @param action String\n */\nfun BaseActivity.uploadButtonClickEvent(action: String, pageCode: String = \"\", map: MutableMap<String, String>? = null) {\n    uploadButtonClickEventForAny(if (pageCode.isEmpty()) getPageCode() else pageCode, action, map)\n}\n\n/**\n *   数据上报 Activity 点击事件 Any\n * @param pageCode String?\n * @param action String\n */\nfun uploadButtonClickEventForAny(pageCode: String?, action: String, map: Map<String, String>? = null) {\n    var json = JSONObject()\n    json.put(\"button_name\", action)\n    if (map != null) {\n        for (key in map.keys) {\n            json.put(key, map[key])\n        }\n    }\n    Tracker.instance.trackEvent(pageCode, \"button_click\", \"\", json)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author liangsaifei\n * 邮箱：liangsaifei@ksjgs.com\n * 创建时间: 2020/3/24     4:29 PM\n * 用途: 请求 权限的 dialog\n ***************************************\n\n */\n\nclass RequestPermissionDialog(val context: Activity, permissionName: String, val onCancel: () -> Unit) {\n    init {\n        val message = \"请在\\\"设置\\\"-\\\"权限管理\\\"中打开以下权限，保证程序正常运行\"\n\n\n        val contentView = context.layoutInflater.inflate(R.layout.base_permission_dialog, null, false)\n        val dialog = AlertDialog.Builder(context).setView(contentView)\n                .setCancelable(false)\n                .create()\n        contentView.findViewById<TextView>(R.id.dialog_title)?.text = \"权限申请\"\n        contentView.findViewById<TextView>(R.id.version_detail)?.text = message\n        contentView.findViewById<TextView>(R.id.tvPermissionName)?.text = permissionName\n        contentView.findViewById<View>(R.id.btn_ok)?.click(true) {\n            dialog.dismiss()\n            toSetting()\n        }\n        contentView.findViewById<View>(R.id.btn_cancel)?.click(true) {\n            dialog.dismiss()\n//                        context.finish()\n            onCancel()\n        }\n\n        dialog.show()\n        //此处设置位置窗体大小，我这里设置为了手机屏幕宽度的3/4  注意一定要在show方法调用后再写设置窗口大小的代码，否则不起效果会\n        dialog?.window?.setLayout(context.screenWidth / 4 * 3, LinearLayout.LayoutParams.WRAP_CONTENT)\n    }\n\n    /**\n     * 去系统的权限设置页面\n     */\n    private fun toSetting() {\n        AndPermission\n                .with(context)\n                .runtime()\n                .setting()\n                .start(REQUEST_CODE_SETTING)\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprovider\nAppConfigProvider\nAppUpdateProvider\nBusProvider\nCourseWebViewSourceProvider\nGlobalMusicProvider\nHomeModuleWebViewProvider\nInitCourseProvider\nInitHomeProvider\nInitLoginProvider\nInitMineProvider\nInitPayProvider\nInitProductProvider\nMittProvider\nPayProvider\nPetSourceProvider\nProductProvider\nSplashProvider\nTakepictureProvider\nUserAgreementProvider\nUserInfoProvider\n\n\n\n\n\n\n\n\n\n\n\nclass NetStateReceiver : BroadcastReceiver() {\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {\n            val connMgr = context?.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager\n            val wifiNetworkInfo = connMgr?.getNetworkInfo(ConnectivityManager.TYPE_WIFI)\n            val dataNetworkInfo = connMgr?.getNetworkInfo(ConnectivityManager.TYPE_MOBILE)\n\n\n            if (wifiNetworkInfo?.isConnected == true || dataNetworkInfo?.isConnected == true) {\n                BusProvider.instance?.post(BusMsg(BusMsg.NET_WORK_IS_CONNECTED, null))\n                println(\"connected---net-----\")\n            } else {\n                BusProvider.instance?.post(BusMsg(BusMsg.NET_WORK_DIS_CONNECTED, null))\n                println(\"disconnected---net-----\")\n            }\n\n        } else {\n            val connMgr = context?.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager\n            //获取所有网络连接的信息\n            val connectedSize = connMgr?.allNetworks?.filter { connMgr?.getNetworkInfo(it)?.isConnected == true }?.size ?: 0\n            println(\"connectedSize==$connectedSize---net-----\")\n            BusProvider.instance?.post(BusMsg(if (connectedSize > 0) BusMsg.NET_WORK_IS_CONNECTED else BusMsg.NET_WORK_DIS_CONNECTED, null))\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * adapter item点击事件\n * @param needBgMusic Boolean 点击是否需要背景音乐\n * @param action Function0<Unit> block\n */\nfun BaseQuickAdapter<*, *>.onItemClick(needBgMusic: Boolean = false, action: (a: BaseQuickAdapter<*, *>, v: View, pos: Int) -> Unit) {\n    setOnItemClickListener { adapter, view, position ->\n        if (needBgMusic) {\n            SoundPoolUtil.getInstance(view.context).play(1)\n        }\n        action(adapter, view, position)\n    }\n}\n\n/**\n * adapter itemchild点击事件\n * @param needBgMusic Boolean 点击是否需要背景音乐\n * @param action Function0<Unit> block\n */\nfun BaseQuickAdapter<*, *>.onItemChildClick(needBgMusic: Boolean = false, action: (a: BaseQuickAdapter<*, *>, v: View, pos: Int) -> Unit) {\n    setOnItemChildClickListener { adapter: BaseQuickAdapter<*, *>, view: View, position: Int ->\n        if (needBgMusic) {\n            SoundPoolUtil.getInstance(view.context).play(1)\n        }\n        action(adapter, view, position)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage com.ks.lightlearn.base.utils\n\nimport android.annotation.SuppressLint\nimport android.app.Activity\nimport android.app.ActivityManager.RunningAppProcessInfo\nimport android.content.Context\nimport android.content.Intent\nimport android.graphics.Bitmap\nimport android.net.ConnectivityManager\nimport android.net.Uri\nimport android.os.Process\nimport android.provider.MediaStore\nimport android.text.TextUtils\nimport androidx.annotation.Nullable\nimport com.facebook.common.executors.UiThreadImmediateExecutorService\nimport com.facebook.common.references.CloseableReference\nimport com.facebook.datasource.DataSource\nimport com.facebook.drawee.backends.pipeline.Fresco\nimport com.facebook.imagepipeline.datasource.BaseBitmapDataSubscriber\nimport com.facebook.imagepipeline.image.CloseableImage\nimport com.facebook.imagepipeline.request.ImageRequest\nimport com.ks.lib.ktx.ext.activityManager\nimport com.ks.lib.ktx.ext.connectivityManager\nimport com.ks.lib.ktx.ext.toast\nimport com.ks.lightlearn.base.constants.GlobalConstants\nimport com.ks.lightlearn.base.http.HttpH5Manager\nimport com.ks.lightlearn.base.provider.UserInfoProvider\nimport com.ks.lightlearn.base.route.KsRouterHelper\nimport com.tencent.mm.opensdk.constants.Build\nimport com.tencent.mm.opensdk.modelbiz.WXLaunchMiniProgram\nimport com.tencent.mm.opensdk.openapi.WXAPIFactory\nimport java.io.File\nimport java.io.FileNotFoundException\nimport java.io.FileOutputStream\nimport java.io.IOException\nimport java.util.*\nimport kotlin.system.exitProcess\n\n/**\n * 注释掉的代码 已下沉base-lib, 验证没问题后，可以删除\n *\n */\n\n///**\n// * 1\n// * 判断设备是否安装微信APP\n// *\n// * @return boolean\n// */\n//fun Context.isWeixinAvilible(): Boolean {\n//    val pinfo = packageManager.getInstalledPackages(0)// 获取所有已安装程序的包信息\n//    if (pinfo != null) {\n//        for (i in pinfo.indices) {\n//            val pn = pinfo[i].packageName\n//            if (\"com.tencent.mm\" == pn) {\n//                return true\n//            }\n//        }\n//    }\n//    return false\n//}\n//\n//\n///**\n// * 是否有网络连接\n// * @receiver Context\n// * @return Boolean\n// */\n//@SuppressLint(\"MissingPermission\")\n//fun Context.isNetworkAvailable(): Boolean {\n//    val mNetworkInfo = connectivityManager?.activeNetworkInfo\n//    return mNetworkInfo != null && mNetworkInfo.isAvailable\n//}\n//\n//\n///**\n// * 检测网络是否是Mobile\n// *\n// * @return\n// */\n//fun Context.isMobile(): Boolean {\n//    val mNetworkInfo = connectivityManager?.activeNetworkInfo\n//    return mNetworkInfo != null\n//            && mNetworkInfo.type == ConnectivityManager.TYPE_MOBILE\n//            && mNetworkInfo.isConnected\n//}\n//\n///**\n// * 判断wifi是否连接\n// *\n// * @return\n// */\n//fun Context.isWifiConnected(): Boolean {\n//    val activeNetInfo = connectivityManager?.activeNetworkInfo\n//    return activeNetInfo != null\n//            && activeNetInfo.type == ConnectivityManager.TYPE_WIFI\n//            && activeNetInfo.isConnected\n//}\n//\n///**\n// * 是否有运行的服务\n// * @receiver Context\n// * @param className String\n// * @return Boolean\n// */\n//fun Context.isServiceRunning(className: String): Boolean {\n//    var isRunning = false\n//    val serviceList = activityManager?.getRunningServices(Int.MAX_VALUE)\n//    if (serviceList == null || serviceList.size <= 0) {\n//        return false\n//    }\n//    for (i in serviceList.indices) {\n//        if (serviceList[i] != null && serviceList[i].service != null) {\n//            val cName = serviceList[i].service.className\n//            if (cName.contains(className)) {\n//                isRunning = true\n//                break\n//            }\n//        }\n//    }\n//    return isRunning\n//}\n\n/**\n * 判断登录之后\n * @receiver Context\n * @param action Function0<Unit>\n */\nfun Context.loginAfter(action: () -> Unit) {\n    val userInfoProvider = KsRouterHelper.buildUserInfoProvider() as UserInfoProvider\n    if (!userInfoProvider.isLogined()) {\n        KsRouterHelper.loginPage()\n    } else {\n        action()\n    }\n}\n//\n///**\n// * 包名判断是否为主进程\n// *\n// * @param context\n// * @return\n// */\n//fun Context.isMainProcess(): Boolean {\n//    return packageName == getProcessName()\n//}\n//\n///**\n// * 获取进程名称\n// *\n// * @param context\n// * @return\n// */\n//fun Context.getProcessName(): String? {\n//    try {\n//        val runningApps = activityManager?.runningAppProcesses ?: return null\n//        for (proInfo in runningApps) {\n//            if (proInfo.pid == Process.myPid()) {\n//                if (proInfo.processName != null) {\n//                    return proInfo.processName\n//                }\n//            }\n//        }\n//    } catch (e: Exception) {\n//        e.printStackTrace()\n//    }\n//    return null\n//}\n//\n///**\n// * 判断当前app是否存活\n// * @receiver Context\n// * @param packageName String\n// * @return Boolean\n// */\n//fun Context.isAppAlive(packageName: String): Boolean {\n//    val processInfos = activityManager?.runningAppProcesses\n//    if (processInfos != null) {\n//        for (i in processInfos.indices) {\n//            if (processInfos[i].processName == packageName) {\n//                return true\n//            }\n//        }\n//    }\n//    return false\n//}\n\n/**\n * 下载bitmap\n * @receiver Context\n * @param imgUrl String\n * @param success Function1<[@kotlin.ParameterName] Bitmap, Unit?>\n * @param fail Function0<Unit>\n */\nfun Context.downloadBitmap(imgUrl: String, success: (bitmap: Bitmap) -> Unit?, fail: () -> Unit) {\n    val imagePipeline = Fresco.getImagePipeline()\n    val imageRequest = ImageRequest.fromUri(imgUrl)\n    val dataSource = imagePipeline.fetchDecodedImage(imageRequest, this)\n    dataSource.subscribe(object : BaseBitmapDataSubscriber() {\n        override fun onFailureImpl(dataSource: DataSource<CloseableReference<CloseableImage>>?) {\n            try {\n                fail()\n            } catch (e: java.lang.Exception) {\n                toast(\"下载失败${e}\")\n                e.printStackTrace()\n            }\n        }\n\n        override fun onNewResultImpl(@Nullable bitmap: Bitmap?) {\n            if (bitmap != null && !bitmap.isRecycled) {\n                try {\n                    success(bitmap)\n                } catch (e: java.lang.Exception) {\n                    e.printStackTrace()\n                }\n            }\n        }\n\n    }, UiThreadImmediateExecutorService.getInstance())\n}\n\n/**\n * 图片存放本地\n * @receiver Context\n * @param bmp Bitmap?\n * @param fileName String?\n */\nfun Context.saveImageToGallery(bmp: Bitmap?, fileName: String?) {\n    var fileName = fileName\n    if (this == null || bmp == null) {\n        return\n    }\n    val dirName = \"Kaishu_Doc\"\n    val appDir = File(this.getExternalCacheDir(), dirName)\n    if (!appDir.exists()) {\n        appDir.mkdir()\n    }\n    if (TextUtils.isEmpty(fileName)) {\n        fileName = System.currentTimeMillis().toString() + \".jpg\"\n    }\n    val file = File(appDir, fileName)\n    try {\n        val fos = FileOutputStream(file)\n        bmp.compress(Bitmap.CompressFormat.JPEG, 100, fos)\n        fos.flush()\n        fos.close()\n    } catch (e: FileNotFoundException) {\n        toast(\"保存失败\")\n        e.printStackTrace()\n    } catch (e: IOException) {\n        toast(\"保存失败\")\n        e.printStackTrace()\n    }\n    // 把文件插入到系统图库\n    try {\n        val insertImage: String = MediaStore.Images.Media.insertImage(this.contentResolver,\n                file.absolutePath, fileName, null)\n        //            // 通知图库更新\n        val file1 = File(getRealPathFromURI(Uri.parse(insertImage)))\n        val intent = Intent()\n        intent.action = Intent.ACTION_MEDIA_SCANNER_SCAN_FILE\n        intent.data = Uri.fromFile(file1)\n        this.sendBroadcast(intent)\n        toast(\"保存成功\")\n    } catch (e: java.lang.Exception) {\n        toast(\"保存失败\")\n        e.printStackTrace()\n    }\n}\n\nfun Context.getRealPathFromURI(contentUri: Uri): String? {\n    val proj = arrayOf(MediaStore.Images.Media.DATA)\n    val cursor = this.contentResolver.query(contentUri, proj, null, null, null)\n    val column_index = cursor?.getColumnIndexOrThrow(MediaStore.Images.Media.DATA)\n    cursor?.moveToFirst()\n    column_index?.let {\n        val fileStr = cursor.getString(column_index)\n        cursor.close()\n        return fileStr\n    }\n    return null\n}\n\n///**\n// * 清楚当前所有的activity\n// */\n//fun Context.clearAllActivity() {\n//    val allActivitys = getAllActivitys()\n//    for (i in allActivitys.indices) {\n//        allActivitys.get(i).finish()\n//    }\n//}\n//\n///**\n// * 获取当前所有的activity\n// *\n// * @return activity列表\n// */\n//@SuppressLint(\"PrivateApi\", \"DiscouragedPrivateApi\")\n//fun Context.getAllActivitys(): List<Activity> {\n//    val list = ArrayList<Activity>()\n//    try {\n//        val activityThread = Class.forName(\"android.app.ActivityThread\")\n//        val currentActivityThread = activityThread.getDeclaredMethod(\"currentActivityThread\")\n//        currentActivityThread.isAccessible = true\n//        //获取主线程对象\n//        val activityThreadObject = currentActivityThread.invoke(null)\n//        val mActivitiesField = activityThread.getDeclaredField(\"mActivities\")\n//        mActivitiesField.isAccessible = true\n//        val mActivities = mActivitiesField.get(activityThreadObject) as Map<Any, Any>\n//        for ((_, value) in mActivities) {\n//            val activityClientRecordClass = value.javaClass\n//            val activityField = activityClientRecordClass.getDeclaredField(\"activity\")\n//            activityField.isAccessible = true\n//            val o = activityField.get(value)\n//            list.add(o as Activity)\n//        }\n//    } catch (e: Exception) {\n//        e.printStackTrace()\n//    }\n//\n//    return list\n//}\n\n///**\n// * 注意：不能先杀掉主进程，否则逻辑代码无法继续执行，需先杀掉相关进程最后杀掉主进程\n// */\n//fun Context.killAppProcess() {\n//    val mList = activityManager?.runningAppProcesses\n//    for (runningAppProcessInfo in mList!!) {\n//        if (runningAppProcessInfo.pid != Process.myPid()) {\n//            Process.killProcess(runningAppProcessInfo.pid)\n//        }\n//    }\n//    Process.killProcess(Process.myPid())\n//    exitProcess(0)\n//}\n\n/**\n * 跳转微信小程序\n * @receiver Context\n * @param programId String?\n * @param programUrl String?\n */\nfun Context.jumpWechatProgram(programId: String?, programUrl: String?) {\n    val msgApi = WXAPIFactory.createWXAPI(this, GlobalConstants.WX_APP_ID)\n    if (!msgApi.isWXAppInstalled) {\n        return\n    }\n    val isPaySupported = msgApi.wxAppSupportAPI >= Build.PAY_SUPPORTED_SDK_INT\n    if (!isPaySupported) {\n        return\n    }\n    val req = WXLaunchMiniProgram.Req()\n    req.userName = programId // 填小程序原始id\n    req.path = programUrl //拉起小程序页面的可带参路径，不填默认拉起小程序首页\n    req.miniprogramType = HttpH5Manager.getSmallProgram() // 可选打开 开发版，体验版和正式版\n    // req.miniprogramType = WXLaunchMiniProgram.Req.MINIPTOGRAM_TYPE_RELEASE;// 可选打开 开发版，体验版和正式版\n    msgApi.sendReq(req)\n}\n\n\n///**\n// * 开启一个service之前需要判断是否开启\n// * @receiver Context\n// * @param className String\n// * @param action Function0<Unit>\n// */\n//fun Context.onServiceNotRunning(className: String, action: () -> Unit) {\n//    try {\n//        if (isAppInForground()) {\n//            val downloadPetServiceRunning: Boolean = isServiceRunning(className)\n//            if (!downloadPetServiceRunning) {\n//                action()\n//            }\n//        }\n//    } catch (e: IllegalStateException) {\n//        e.printStackTrace()\n//    } catch (e: SecurityException) {\n//        e.printStackTrace()\n//    }\n//}\n//\n///**\n// * 判断app是否在前台\n// * @receiver Context\n// * @return Boolean\n// */\n//fun Context.isAppInForground(): Boolean {\n//    val processes = activityManager?.runningAppProcesses ?: return false\n//    for (tmp in processes) {\n//        if (tmp.processName == this.packageName) {\n//            return tmp.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND\n//        }\n//    }\n//    return false\n//}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 当前设备是否为平板设备\n * @return true, 平板；false，手机\n */\nfun isTablet(context: Context): Boolean {\n    return (context.resources.configuration.screenLayout\n            and Configuration.SCREENLAYOUT_SIZE_MASK) >= Configuration.SCREENLAYOUT_SIZE_LARGE\n}\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author guanhuawei\n * 邮箱：guanhuawei@ksjgs.com\n * 创建时间: 2020/3/17     16:37 PM\n * 用途  获取properties文件\n ***************************************\n\n */\nobject ProPertiesUtils {\n\n    private var properties: Properties = Properties()\n\n    init {\n        try {\n            properties?.let {\n                it.load(BaseApplication.instance.assets.open(\"sourceConfig.properties\"))\n            }\n        } catch (e: Exception) {\n        }\n    }\n\n    fun getValue(key: String): String {\n        if (properties != null && properties.containsKey(key)) {\n            return properties.getProperty(key)\n        }\n        return \"\"\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class Rom {\n\n    private static final String TAG = \"Rom\";\n\n    public static final String ROM_MIUI = \"MIUI\";\n    public static final String ROM_EMUI = \"EMUI\";\n    public static final String ROM_FLYME = \"FLYME\";\n    public static final String ROM_OPPO = \"OPPO\";\n    public static final String ROM_SMARTISAN = \"SMARTISAN\";\n    public static final String ROM_VIVO = \"VIVO\";\n    public static final String ROM_QIKU = \"QIKU\";\n\n    private static final String KEY_VERSION_MIUI = \"ro.miui.ui.version.name\";\n    private static final String KEY_VERSION_EMUI = \"ro.build.version.emui\";\n    private static final String KEY_VERSION_OPPO = \"ro.build.version.opporom\";\n    private static final String KEY_VERSION_SMARTISAN = \"ro.smartisan.version\";\n    private static final String KEY_VERSION_VIVO = \"ro.vivo.os.version\";\n\n    private static String sName;\n    private static String sVersion;\n\n    public static boolean isEmui() {\n        return check(ROM_EMUI);\n    }\n\n    public static boolean isMiui() {\n        return check(ROM_MIUI);\n    }\n\n    public static boolean isVivo() {\n        return check(ROM_VIVO);\n    }\n\n    public static boolean isOppo() {\n        return check(ROM_OPPO);\n    }\n\n    public static boolean isFlyme() {\n        return check(ROM_FLYME);\n    }\n\n    public static boolean is360() {\n        return check(ROM_QIKU) || check(\"360\");\n    }\n\n    public static boolean isSmartisan() {\n        return check(ROM_SMARTISAN);\n    }\n\n    public static String getName() {\n        if (sName == null) {\n            check(\"\");\n        }\n        return sName;\n    }\n    \n    public static String getVersion() {\n        if (sVersion == null) {\n            check(\"\");\n        }\n        return sVersion;\n    }\n\n    public static boolean check(String rom) {\n        if (sName != null) {\n            return sName.equals(rom);\n        }\n\n        if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_MIUI))) {\n            sName = ROM_MIUI;\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_EMUI))) {\n            sName = ROM_EMUI;\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_OPPO))) {\n            sName = ROM_OPPO;\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_VIVO))) {\n            sName = ROM_VIVO;\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_SMARTISAN))) {\n            sName = ROM_SMARTISAN;\n        } else {\n            sVersion = Build.DISPLAY;\n            if (sVersion.toUpperCase().contains(ROM_FLYME)) {\n                sName = ROM_FLYME;\n            } else {\n                sVersion = Build.UNKNOWN;\n                sName = Build.MANUFACTURER.toUpperCase();\n            }\n        }\n        return sName.equals(rom);\n    }\n\n    public static String getProp(String name) {\n        String line = null;\n        BufferedReader input = null;\n        try {\n            Process p = Runtime.getRuntime().exec(\"getprop \" + name);\n            input = new BufferedReader(new InputStreamReader(p.getInputStream()), 1024);\n            line = input.readLine();\n            input.close();\n        } catch (IOException ex) {\n//            Log.e(TAG, \"Unable to read prop \" + name, ex);\n            return null;\n        } finally {\n            if (input != null) {\n                try {\n                    input.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return line;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author jiaruihua\n * 邮箱：jiaruihua@ksjgs.com\n * 创建时间: 2020/4/13     2:00 PM\n * 用途:控制ViewPager 的滑动速度\n ***************************************\n */\n\nobject ScrollUtil {\n\n    var speedScroller:SpeedScroller?=null\n\n    fun setViewPagerSpeed(context: Context,vp:ViewPager,duration: Int){\n        try {\n            val filed = ViewPager::class.java.getDeclaredField(\"mScroller\").apply {\n                isAccessible = true\n            }\n\n            speedScroller = SpeedScroller(context).apply { mDefaultDuration = duration }\n            filed.set(vp, speedScroller)\n        }catch (e:Exception){\n            e.printStackTrace()\n        }\n\n    }\n\n\n}\n\nclass SpeedScroller(context: Context?) : Scroller(context) {\n\n    var mDefaultDuration = 1500\n\n\n    override fun startScroll(startX: Int, startY: Int, dx: Int, dy: Int) {\n        super.startScroll(startX, startY, dx, dy, mDefaultDuration)\n    }\n\n    override fun startScroll(startX: Int, startY: Int, dx: Int, dy: Int, duration: Int) {\n        super.startScroll(startX, startY, dx, dy, mDefaultDuration)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author lulong\n * 邮箱：lulong@ksjgs.com\n * 创建时间: 2020-03-20     11:28\n * 用途\n * edit by jiaruihua 2020-04-08\n * 1.修改音频最大数量 MAX_STREAMS\n * 2. 增加 Method loadSource() 用于其他业务播放短音需求\n ***************************************\n\n */\nclass SoundPoolUtil private constructor(val context: Context){\n\n    private var soundPool: SoundPool? = null\n    /** 音频最大数量*/\n    private val MAX_STREAMS = 30\n    init {\n        soundPool = SoundPool(MAX_STREAMS, AudioManager.STREAM_MUSIC, 0)\n        soundPool?.load(context, R.raw.clickmusic, 1)\n    }\n\n    companion object {\n        @Volatile private var instance: SoundPoolUtil? = null\n        fun getInstance(context: Context) =\n                instance ?: synchronized(this) {\n                    instance ?: SoundPoolUtil(context).also { instance = it }\n                }\n    }\n\n\n    /**\n     * 播放音频的id\n     */\n    fun play(audioId: Int) {\n//        Log.d(\"tag\", \"number $audioId\")\n        if(BaseApplication.buttonClickVoiceEnable){\n            soundPool?.play(audioId, 1f, 1f, 1, 0, 2f)\n        }\n\n    }\n\n    /**\n     * 预加载音频资源id，返回音频的播放id 用此id可以通过paly(id)播放\n     */\n    fun loadSource(sourceId:Int) = soundPool?.load(context,sourceId,1)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称:kaishuvideo\n * @Author guanhuawei\n * 邮箱：guanhuawei@ksjgs.com\n * 创建时间: 2020/3/16     16:10 PM\n * 用途 保存数据\n ***************************************\n */\n\nobject SpUtils {\n\n    private val prefs: SharedPreferences by lazy {\n        PreferenceManager.getDefaultSharedPreferences(NetComponent.application)\n    }\n    /**\n     * 获取存放数据\n     * @return 值\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    fun getValue(key: String, default: Any): Any = with(prefs) {\n        return when (default) {\n            is Int -> getInt(key, default)\n            is String -> getString(key, default)\n            is Long -> getLong(key, default)\n            is Float -> getFloat(key, default)\n            is Boolean -> getBoolean(key, default)\n            else -> throw IllegalArgumentException(\"SharedPreferences 类型错误\")\n        }\n    }\n\n    fun getString(key: String, default: String = \"\"): String {\n        return getValue(key, default) as String\n    }\n\n    fun getInt(key: String, default: Int = 0): Int {\n        return getValue(key, default) as Int\n    }\n\n    fun getLong(key: String, default: Long = 0): Long {\n        return getValue(key, default) as Long\n    }\n\n    fun getBoolean(key: String, default: Boolean = false): Boolean {\n        return getValue(key, default) as Boolean\n    }\n\n    fun getFloat(key: String, default: Float = 0f): Float {\n        return getValue(key, default) as Float\n    }\n\n    /**\n     * 存放SharedPreferences\n     * @param key 键\n     * @param value 值\n     */\n    fun saveValue(key: String, value: Any) = with(prefs.edit()) {\n        when (value) {\n            is Long -> putLong(key, value)\n            is Int -> putInt(key, value)\n            is String -> putString(key, value)\n            is Float -> putFloat(key, value)\n            is Boolean -> putBoolean(key, value)\n            else -> throw IllegalArgumentException(\"SharedPreferences 类型错误\")\n        }.apply()\n    }\n\n    /**\n     * 清除\n     */\n    fun clear() {\n        prefs.edit().clear().apply()\n    }\n\n    /**\n     * 删除某Key的值\n     */\n    fun remove(key: String) {\n        prefs.edit().remove(key).apply()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 【说明】 判断字符串是否为手机号<br></br>\n *\n * @return str 判断字符串\n */\nfun String.isMobilestr(): Boolean {\n    if (TextUtils.isEmpty(this)) {\n        return false\n    }\n    //测试白名单\n    if (this.startsWith(\"90000\")) {\n        return true\n    }\n    val num = \"1[123456789]([0-9]){9}\"//\"[1]\"代表第1位为数字1，\"\\\\d{10}\"代表后面是可以是0～9的数字，有10位。\n    return this.matches(num.toRegex())\n}\n\n/**\n * 手机号自己按照自己业务加密\n * @receiver String\n * @return String\n */\nfun String.secretPhoneNumber(): String {\n    return this.replaceRange(3, 7, \"****\")\n}\n\n\n\n\n\n\n\n\n\n/**\n * view的点击事件\n * @receiver View 当前点击的view\n * @param needBgMusic Boolean 点击是否需要背景音乐\n * @param action Function0<Unit> block\n */\nfun View.click(needBgMusic: Boolean = true, action: () -> Unit) {\n\n    setOnClickListener {\n\n        println(\"needBGMusic--------------------id=${this.id}\")\n        if (needBgMusic) {\n            SoundPoolUtil.getInstance(context).play(1)\n        }\n        if (hashCode() != ViewClickDelay.hash) {\n            ViewClickDelay.hash = hashCode()\n            ViewClickDelay.lastClickTime = System.currentTimeMillis()\n            action()\n        } else {\n            val currentTime = System.currentTimeMillis()\n            if (currentTime - ViewClickDelay.lastClickTime > ViewClickDelay.SPACE_TIME) {\n                ViewClickDelay.lastClickTime = System.currentTimeMillis()\n                action()\n            }\n        }\n    }\n}\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593262873},"updatedAt":{"$$date":1598598193102},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"eLKDEV2NMbpMttA9"}
{"name":"kqapp-lightlearn_module_base3","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n/** 基础 Activity封装，使用时不要直接继承这个，\n * 请使用下面这两个。\n * @see BaseActivityWithCoroutineScope\n * @see BaseVMActivity\n */\n\nabstract class BaseActivity : AppCompatActivity() {\n    companion object {\n        var accountCancellationObj = false\n    }\n\n    protected val loadingLayout: LoadingLayout by lazy {\n        LoadingLayout.wrap(wrapView()).apply {\n            setEmpty(R.layout.base_layout_empty)\n            setLoading(R.layout.base_layout_loading)\n            setRetryListener(View.OnClickListener { onRetry() })\n        }\n    }\n    protected val mUserInfoProvider by lazy {\n        KsRouterHelper.buildUserInfoProvider() as UserInfoProvider\n    }\n\n    /**\n     * 权限map\n     * key： Manifest.permision.. 权限，value：对应的中文名称，比如存储权限\n     */\n    private var permissionMap: MutableMap<String, String>? = null\n    private var deniedPermissionCount: Int = 0\n    private var isOnPausing = false\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        setContentViewBefore()\n        super.onCreate(savedInstanceState)\n\n        if (isFirstReload()) {\n            return\n        }\n        MobclickAgent.onPageStart(getPageCode())\n        ARouter.getInstance().inject(this)\n\n        //修复8.0 transparent 主题 崩溃问题\n        if (Build.VERSION.SDK_INT == Build.VERSION_CODES.O && isTranslucentOrFloating()) {\n            val result = fixOrientation()\n        }\n\n        try {\n            setStatusBarColor()\n            setLightBarColor(true)\n        } catch (e: java.lang.Exception) {\n            e.printStackTrace()\n        }\n\n\n        if (isSwipteBackEnable()) {//TODO 先预留着，现在 滑动返回貌似都没有完美的方案，后面有时间 调研 加上合适的。\n//            SwipeBackHelper.onCreate(this)\n//            SwipeBackHelper.getCurrentPage(this)\n//                    .setSwipeBackEnable(true)\n//                    .setSwipeSensitivity(0.5f)\n//                    .setSwipeRelateEnable(true)\n//                    .setSwipeRelateOffset(300)\n//            //                    .setDisallowInterceptTouchEvent(true);//不抢占事件，默认关（事件将先由子View处理再由滑动关闭处理）\n        }\n\n        setLayoutView()\n        initView()\n        initData()\n\n    }\n\n    override fun getResources(): Resources {\n\n\n        val res = super.getResources()\n        val config = Configuration().apply { setToDefaults() }\n\n        return res.apply { updateConfiguration(config, res.displayMetrics) }\n    }\n\n    /** 第一次启动，home键后，点击icon => app重启问题  */\n    private fun isFirstReload(): Boolean {\n        if (!isTaskRoot) {\n            val intent = intent\n            val intentAction = intent.action\n            if (intent.hasCategory(Intent.CATEGORY_LAUNCHER)\n                    && intentAction != null && intentAction == Intent.ACTION_MAIN) {\n                finish()\n                return true\n            }\n        }\n        return false\n    }\n\n    open fun setContentViewBefore() {\n\n    }\n\n\n    abstract fun setLayoutView()\n\n\n    abstract fun initView()\n    abstract fun initData()\n\n    override fun onResume() {\n        isOnPausing = false\n        super.onResume()\n        MobclickAgent.onResume(this)\n\n        handlerMessage()\n\n    }\n\n    private fun handlerMessage() {\n        //TODO 这块儿逻辑有问题，应该是从凯叔app 拷贝过来的，后面 想办法优化。 恒等于 true。。也估计没测试\n        if (BaseApplication.showAbnormalExitTip) {\n            BusProvider.instance?.post(BusMsg(BusMsg.JUMP_LIMIT_LOGIN_PAGE, BaseApplication.CODE))\n        }\n        //账号注销\n        if (accountCancellationObj) {\n            try {\n                BusProvider.instance?.post(BusMsg(BusMsg.JUMP_WRITTEN_OFF_PAGE, null))\n            } catch (e: java.lang.Exception) {\n                e.printStackTrace()\n            }\n        }\n    }\n\n    override fun onPause() {\n        isOnPausing = true\n        super.onPause()\n        MobclickAgent.onPause(this)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        UMShareAPI.get(this).release()\n        MobclickAgent.onPageEnd(getPageCode())\n    }\n\n    private fun isTranslucentOrFloating(): Boolean {\n        var isTranslucentOrFloating = false\n        try {\n            val styleableRes = Class.forName(\"com.android.internal.R\\$styleable\").getField(\"Window\").get(null) as IntArray\n            val ta = obtainStyledAttributes(styleableRes)\n            val m = ActivityInfo::class.java.getMethod(\"isTranslucentOrFloating\", TypedArray::class.java)\n            m.isAccessible = true\n            isTranslucentOrFloating = m.invoke(null, ta) as Boolean\n            m.isAccessible = false\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n\n        return isTranslucentOrFloating\n    }\n\n    private fun fixOrientation(): Boolean {\n        try {\n            val field = Activity::class.java.getDeclaredField(\"mActivityInfo\")\n            field.isAccessible = true\n            val o = field.get(this) as ActivityInfo\n            o.screenOrientation = -1\n            field.isAccessible = false\n            return true\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n\n        return false\n    }\n\n    /**\n     * 设置状态栏颜色\n     *\n     * @param color\n     */\n    fun setStatusBarColor(color: Int = statusBarColor()) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            val window = this.window\n            //状态栏改变颜色。\n            window.statusBarColor = color\n        }\n    }\n\n    open protected fun statusBarColor(): Int {\n        return Color.WHITE\n    }\n\n\n    /**\n     * 背景浅色时，改变状态栏字体颜色\n     *\n     * @param lightStatusBar\n     */\n    fun setLightBarColor(lightStatusBar: Boolean) {\n        val decor = this.window.decorView\n        var ui = decor.systemUiVisibility\n        ui = if (lightStatusBar) {\n            ui or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR\n        } else {\n            ui and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv()\n        }\n        decor.systemUiVisibility = ui\n    }\n\n    protected open fun isSwipteBackEnable(): Boolean {\n        return false\n    }\n\n\n    fun showLoading() {\n        loadingLayout.showLoading()\n    }\n\n    fun dismissLoading() {\n        loadingLayout.showContent()\n    }\n\n    fun showError() {\n        loadingLayout.showError()\n    }\n\n    fun showEmpty() {\n        loadingLayout.showEmpty()\n    }\n\n    /**\n     * 空白页 包裹哪个view\n     * 一般 返回 除了 title的 剩下的view\n     * @return View\n     */\n    open fun wrapView(): View {\n        return (findViewById<ViewGroup>(android.R.id.content)).getChildAt(0)\n    }\n\n    /**\n     * 无数据时或者网络错误 时，重试\n     */\n    open fun onRetry() {\n\n    }\n\n    /**\n     * 页面来源\n     *\n     * @return 来源名城\n     */\n    fun getSourceName(): String {\n        val intent = intent\n        if (intent != null && intent.hasExtra(GlobalConstants.KEY_FROM_ACTIVITY)) {\n            var sName = intent.getStringExtra(GlobalConstants.KEY_FROM_ACTIVITY)\n            if (sName == null) {\n                sName = \"\"\n            }\n            return sName\n        }\n        return \"\"\n    }\n\n    override fun startActivity(intent: Intent) {\n        try {\n            intent.putExtra(GlobalConstants.KEY_FROM_ACTIVITY, getPageCode())\n            super.startActivity(intent)\n        } catch (e: ActivityNotFoundException) {\n            e.printStackTrace()\n        }\n    }\n\n    open fun getPageCode(): String? {\n        val simpleName = this::class.java.simpleName\n        return getKsStatisticPageName(simpleName)\n    }\n\n    open fun getKsStatisticPageName(simpleName: String): String? {\n        return ProPertiesUtils.getValue(simpleName)\n    }\n\n    /**\n     * 封装的 权限请求，上层调用 只需关心 权限同意后的 情况，拒绝，不再提示等 全部处理过\n     * 自己Activity 通过  override onPermissionsGranted ,去处理同意后的逻辑\n     *@param permissionMap ，key 对应Manifest.permission...,value对应的是 权限中文名称\n     * @param isAutoTry 是否自动重试  请求权限校验放在 onResume() 中，当手机自带权限弹框消失后，会重新再走 onResume()的生命周期，所以会自动重试 需将 isAutoTry = false\n     * example: mutableMapOf(Manifest.permission.WRITE_EXTERNAL_STORAGE to \"存储权限\",Manifest.permission.READ_PHONE_STATE to \"电话权限\")\n     */\n    open fun baseRequestPermission(permissionMap: MutableMap<String, String>, isAutoTry: Boolean = true) {\n\n        if (deniedPermissionCount >= 2) {\n            finish()\n            return\n        }\n        this.permissionMap = permissionMap\n\n\n        //先把同意了的权限过略掉，弹窗只显示没有同意的\n        val nonGranted = permissionMap.filter { !AndPermission.hasPermissions(this, it.key) }\n\n        if (nonGranted.isEmpty()) {\n            onPermissionsGranted()\n            return\n        }\n        nonGranted.keys.toTypedArray().run {\n\n            AndPermission.with(this@BaseActivity).runtime().permission(this)\n                    .rationale(RuntimeRationale())\n                    .onGranted {\n                        onPermissionsGranted()\n                    }.onDenied {\n                        deniedPermissionCount++\n                        //选择过 不再询问的\n                        if (AndPermission.hasAlwaysDeniedPermission(this@BaseActivity, it)) {\n\n                            val permissionNames = nonGranted.values.joinToString(prefix = \"[\", postfix = \"]\")\n                            RequestPermissionDialog(this@BaseActivity, permissionNames) {\n                                onPermissionCanceled(isAutoTry)\n                            }\n                        } else {\n                            if (isAutoTry) {\n                                if (isOnPausing) {\n                                    return@onDenied\n                                }\n                                if (isFinishing) {\n                                    return@onDenied\n                                }\n                                window.decorView.postDelayed({\n                                    if (isFinishing || isOnPausing) {\n                                        return@postDelayed\n                                    }\n                                    baseRequestPermission(permissionMap)\n                                }, 100)\n                            }\n                        }\n                    }.start()\n        }\n\n    }\n\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        UMShareAPI.get(this).onActivityResult(requestCode, resultCode, data)\n\n        if (requestCode == GlobalConstants.REQUEST_CODE_SETTING) { //从设置回来的\n            toSettingAfter()\n        }\n    }\n\n    /**\n     * 从设置 权限管理 回来后，自己实现，判断自己要的权限是否有了，没有的话继续 调用\n     * fun requestPermission(permissions: Array<String>, permissionChineseName: MutableList<String>)\n     */\n    private fun toSettingAfter() {\n        permissionMap?.run {\n            val isAllGranted = AndPermission.hasPermissions(this@BaseActivity, this.keys.toTypedArray())\n            if (!isAllGranted) { //没有全部同意，再走一遍请求\n                baseRequestPermission(this)\n            } else {\n                onPermissionsGranted()\n            }\n        }\n    }\n\n    protected open fun onPermissionsGranted() {\n\n        \"权限同意了，请override当前方法 来实现自己的功能\".loge()\n    }\n\n    protected open fun onPermissionCanceled(isAutoTry: Boolean = true) {\n        \"申请权限取消，请override当前方法 来实现自己的功能,默认关闭当前页\".loge()\n\n    }\n\n//    private val onPermissionCancel: () -> Unit = {\n//        onPermissionCanceled()\n//    }\n\n}\n\n\n\n\n\n\n\n\nabstract class BaseActivityWithCoroutineScope : BaseActivity(), CoroutineScope by MainScope() {\n\n\n    override fun setLayoutView() {\n        setContentView(getLayoutResId())\n    }\n\n    abstract fun getLayoutResId(): Int\n\n    override fun onDestroy() {\n        super.onDestroy()\n        cancel()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nabstract class BaseApplication : MultiDexApplication() {\n    companion object {\n        var CODE: Int = 0\n        var instance: BaseApplication by Delegates.notNull()\n        var marketChannel: String? = null\n        var countActivity: Int = 0\n        var isActivityInFrontGound: Boolean = true\n        var currentActivity: String = \"\"\n        var showAbnormalExitTip = false\n        var openTingYun: Boolean = false\n        var currentActivityStatisticPageName: String? = null\n\n        private val SP_KEY_STOP_BG_MUSIC: String = \"sp_key_stop_bg_music\"\n        var stopPlayBgMusic: Boolean by Preference(SP_KEY_STOP_BG_MUSIC, false)\n        private val SP_KEY_BUTTON_VOICE: String = \"sp_key_button_voice\"\n        var buttonClickVoiceEnable: Boolean by Preference(SP_KEY_BUTTON_VOICE, true)\n    }\n\n\n    var toastBlackList = listOf<String>()\n\n    val mGlobalBG: GlobalMusicProvider? by lazy { KsRouterHelper.globalBG() as? GlobalMusicProvider }\n\n    override fun onCreate() {\n        super.onCreate()\n        instance = this\n        showLog = BuildConfig.DEBUG\n        var mainProcess = isMainProcess()\n\n        if (mainProcess) {\n            initFile()\n            initEnv()\n            initStarter()\n//            initARouter()\n//            initNetComponents()\n//            intiAppConfig()\n\n//            initUmengStatistics()\n//            initUmengChannel()\n//            initUmengShare()\n//            initFresco()\n            //打点\n//            initTracker()\n//            initSidYouh()\n            registAllActivityLife()\n            initTheForceSystem()\n            initUrlToastBlackList()\n        }\n        //给不同的进程设置不同的webview缓存目录\n        initWebView()\n    }\n\n    private val PROCESSNAME = \"com.ks.lightlearn\"\n    /**\n     * https://bugly.qq.com/v2/crash-reporting/crashes/c90ac2699e/159111?pid=1\n     */\n    private fun initWebView() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n            var processName: String? = this.getProcessName()\n            processName?.let {\n                if (PROCESSNAME != processName) {\n                    WebView.setDataDirectorySuffix(processName)\n                }\n            }\n        }\n    }\n\n\n    /**\n     * 接口添加黑名单,不显示接口的错误提示\n     */\n    private fun initUrlToastBlackList() {\n        toastBlackList = mutableListOf<String>().also {\n            it.add(\"/web-force/v1/package/record/download\")\n            it.add(\"/pangu/homework/offline/submit\")\n        }\n    }\n\n    private fun initStarter() {\n\n\n        AppStartTaskDispatcher.getInstance()\n                .setContext(this)\n                .addAppStartTask(InitArouterTask())\n                .addAppStartTask(InitCourseModuleTask())\n                .addAppStartTask(InitHomeModuleTask())\n                .addAppStartTask(InitLoginModuleTask())\n                .addAppStartTask(InitMineModuleTask())\n                .addAppStartTask(InitPayModuleTask())\n                .addAppStartTask(InitProductModuleTask())\n                .addAppStartTask(InitFrescoTask())\n                .addAppStartTask(InitTrackerTask())\n                .addAppStartTask(InitUmengChannelTask())\n                .addAppStartTask(InitUmengShareTask())\n                .addAppStartTask(InitUmengStatisticTask())\n                .addAppStartTask(InitNetComponentTask())\n                .addAppStartTask(InitWebViewX5Task())\n                .start()\n                .await()\n    }\n\n    /**\n     * 原力系统代理\n     */\n    private fun initTheForceSystem() {\n        TheForceSystemDelegate.init(TheForceSystemConfigImpl())\n    }\n\n    /**\n     * 声明周期回调\n     */\n    private fun registAllActivityLife() {\n        registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacks {\n            override fun onActivityPaused(activity: Activity?) {\n                globalBGPause()\n            }\n\n            override fun onActivityResumed(activity: Activity?) {\n                currentActivity = activity!!::class.java.simpleName\n\n                if (activity is BaseActivity) {\n                    currentActivityStatisticPageName = activity.getKsStatisticPageName(currentActivity)\n                }\n\n                globalBGStart(currentActivity)\n\n            }\n\n\n            override fun onActivityStarted(activity: Activity?) {\n                if (countActivity == 0) {\n                    isActivityInFrontGound = true\n                    //初始化ssid\n                    val ssidLong: Long = System.currentTimeMillis() + DiffTimeUtils.diffMs\n                    TrackerDelegateImpl.ssid = ssidLong\n                }\n                countActivity++\n\n            }\n\n            override fun onActivityDestroyed(activity: Activity?) {\n                var simpleName = activity!!::class.java.simpleName\n\n                globalBGStop(simpleName)\n\n            }\n\n            override fun onActivitySaveInstanceState(activity: Activity?, outState: Bundle?) {\n            }\n\n            override fun onActivityStopped(activity: Activity?) {\n                countActivity--\n                if (countActivity == 0) {\n                    isActivityInFrontGound = false\n                }\n\n            }\n\n            override fun onActivityCreated(activity: Activity?, savedInstanceState: Bundle?) {\n            }\n        })\n    }\n\n    /**\n     * 全局背景音停止\n     * @param simpleName String\n     */\n    private fun globalBGStop(simpleName: String) {\n        when (simpleName) {\n            \"MainTabActivity\" -> {\n                mGlobalBG?.stop()\n            }\n        }\n    }\n\n    /**\n     * 全局背景音暂停\n     */\n    private fun globalBGPause() {\n        mGlobalBG?.pause()\n    }\n\n    /**\n     * 全局背景音开始\n     * @param currentActivity String\n     */\n    private fun globalBGStart(currentActivity: String) {\n        when (currentActivity) {\n            \"FirstActivity\" -> {\n\n            }\n            \"CourseMiddleActivity\" -> {\n                mGlobalBG?.pause()\n            }\n            \"CommonWebviewActivity\" -> {\n                mGlobalBG?.pause()\n            }\n            \"CourseOfflineHomeworkActivity\", \"DefaultRecordActivity\" -> {\n                mGlobalBG?.pause()\n            }\n            else -> {\n                if (!stopPlayBgMusic) {\n                    mGlobalBG?.start()\n                }\n            }\n        }\n    }\n\n    //*****************login********************************\n    open fun isForeground(): Boolean {\n        return countActivity > 0\n    }\n\n    private fun initFile() {\n        // FileUtil.initFile(this)\n        DiskManager.init(this)\n\n        //todo 迁移目录\n        GlobalScope.launch {\n            withContext(Dispatchers.IO) {\n                // old  \"${FileUtil.rootCachePath}/course_middle_record\"  \"${FileUtil.rootCachePath}/downloadFile\"\n                var oldVoice = File(DiskManager.getRootFile(DiskManager.ROOT_TYPE_EXTERNAL_CACHE), \"course_middle_record\");\n                if (oldVoice.exists()) {\n                    FileUtils.copyDir(oldVoice.absolutePath, DiskManager.getInstance().voiceDir)\n                    //删除 old文件夹\n                    FileUtils.delete(oldVoice)\n                }\n                // 从cache 目录迁移到 files 目录\n                var oldDownlaod = File(DiskManager.getRootFile(DiskManager.ROOT_TYPE_EXTERNAL_CACHE), \"downloadFile\");\n                if (oldDownlaod.exists()) {\n                    FileUtils.copyDir(oldDownlaod.absolutePath, DiskManager.getInstance().downloadDir)\n                    //删除 old文件夹\n                    FileUtils.delete(oldDownlaod)\n                }\n            }\n        }\n        cacheDir\n\n\n    }\n\n\n    private fun initEnv() {\n        val env = BuildConfig.NET_REQUEST_TARGET\n        GlobalUrlManager.instance.mDomain = HttpConfigManager.getBaseUrlMap()\n        openTingYun = BuildConfig.OPEN_TINGYUN\n        if (env === HttpConfigManager.ENV_RELEASE) {\n            HttpConfigManager.env = HttpConfigManager.ENV_RELEASE\n        }\n\n    }\n\n\n    /**\n     * 修复 FinalizerWatchdogDaemon 崩溃的问题\n     * com.ks.kaishustory:pushcore#FinalizerWatchdogDaemon(2989)\n     * https://stackoverflow.com/questions/24021609/how-to-handle-java-util-concurrent-timeoutexception-android-os-binderproxy-fin\n     * https://bugly.qq.com/v2/crash-reporting/crashes/a623795eab/416?pid=1\n     */\n    protected fun fix() {\n        if (!isOPPO()) {\n            return\n        }\n        try {\n            val clazz = Class.forName(\"java.lang.Daemons\\$FinalizerWatchdogDaemon\")\n            val method = clazz.superclass.getDeclaredMethod(\"stop\")\n            method.isAccessible = true\n            val field = clazz.getDeclaredField(\"INSTANCE\")\n            field.isAccessible = true\n            method.invoke(field[null])\n        } catch (e: Throwable) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun isOPPO(): Boolean {\n        return Build.BRAND.toUpperCase(Locale.ROOT).contains(\"OPPO\")\n    }\n\n\n    var showToastMsg = true\n        get() = field\n\n    open fun setShowToast(isShowToastMsg: Boolean) {\n        showToastMsg = isShowToastMsg\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Fragment\n */\nabstract class BaseFragment : Fragment() {\n\n    protected val mUserInfoProvider by lazy {\n        KsRouterHelper.buildUserInfoProvider() as UserInfoProvider\n    }\n\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n        setContentViewBefore()\n        return inflater.inflate(getLayoutResId(), container, false)\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        initView()\n        initData()\n        super.onViewCreated(view, savedInstanceState)\n    }\n\n    protected open fun setContentViewBefore() {\n\n    }\n\n    abstract fun getLayoutResId(): Int\n\n    abstract fun initView()\n\n    abstract fun initData()\n\n    override fun onDestroy() {\n        super.onDestroy()\n    }\n}\n\n\n\n\n\n\n\n/ * 继承 这个类，可以方法中使用suspend\n * BaseFragment 如下：\n * Vm这个 是利用viewModelScope 来实现协程。而此类 是直接继承MainScope\n */\nabstract class BaseFragmentWithCoroutineScope : BaseFragment(), CoroutineScope by MainScope() {\n\n    override fun onDestroy() {\n        super.onDestroy()\n        cancel()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * ViewModel\n */\nopen class BaseViewModel : ViewModel() {\n\n    open class BaseUiModel<T>(\n            var showLoading: Boolean = false,\n            var showError: String? = null,\n            var showSuccess: T? = null,\n            var showEnd: Boolean = false, // 加载更多\n            var isRefresh: Boolean = false // 刷新\n\n    )\n\n    val mException: MutableLiveData<Throwable> = MutableLiveData()\n\n    suspend fun runOnUI(block: () -> Unit) {\n        withContext(Dispatchers.Main) {\n            block()\n        }\n    }\n\n    private fun launchOnUI(block: suspend CoroutineScope.() -> Unit) {\n\n        viewModelScope.launch(Dispatchers.Main) { block() }\n\n    }\n\n    fun <T> launchOnIO(block: suspend CoroutineScope.() -> T) {\n        viewModelScope.launch(Dispatchers.IO) {\n            block()\n        }\n    }\n\n    fun launch(tryBlock: suspend CoroutineScope.() -> Unit) {\n        launchOnUI {\n            tryCatch(tryBlock, {}, {}, true)\n        }\n    }\n\n\n    fun launchOnUITryCatch(tryBlock: suspend CoroutineScope.() -> Unit,\n                           catchBlock: suspend CoroutineScope.(Throwable) -> Unit,\n                           finallyBlock: suspend CoroutineScope.() -> Unit,\n                           handleCancellationExceptionManually: Boolean\n    ) {\n        launchOnUI {\n            tryCatch(tryBlock, catchBlock, finallyBlock, handleCancellationExceptionManually)\n        }\n    }\n\n    fun launchOnUITryCatch(tryBlock: suspend CoroutineScope.() -> Unit,\n                           handleCancellationExceptionManually: Boolean = false\n    ) {\n        launchOnUI {\n            tryCatch(tryBlock, {}, {}, handleCancellationExceptionManually)\n        }\n    }\n\n\n    private suspend fun tryCatch(\n            tryBlock: suspend CoroutineScope.() -> Unit,\n            catchBlock: suspend CoroutineScope.(Throwable) -> Unit,\n            finallyBlock: suspend CoroutineScope.() -> Unit,\n            handleCancellationExceptionManually: Boolean = false) {\n        coroutineScope {\n            try {\n                tryBlock()\n            } catch (e: Throwable) {\n                if (e !is CancellationException || handleCancellationExceptionManually) {\n                    mException.value = e\n                    catchBlock(e)\n                } else {\n                    throw e\n                }\n            } finally {\n                finallyBlock()\n            }\n        }\n    }\n\n    private var timeJob: Job? = null\n\n    /** 倒计时*/\n    fun timeDown(seconds: Int, action: () -> Unit) {\n        timeJob?.cancel()\n        launch {\n            timeJob = launch {\n\n                flow {\n                    for (i in 0..seconds) {\n                        emit(i)\n                        delay(1000)\n                    }\n                }.collect { time ->\n                    \"倒计时--------$time\".loge(\"倒计时------------\")\n                    if (time == seconds) {\n                        action()\n                    }\n                }\n            }\n        }\n    }\n\n    /** 取消倒计时*/\n    fun cancelTimer() = timeJob?.cancel()\n}\n\n\n\n\n\n\n\n\n\n\nabstract class BaseVMActivity<VM : ViewModel>(useBinding: Boolean = false) : BaseActivity() {\n\n    private val _useBinding = useBinding\n\n\n    override fun setLayoutView() {\n\n\n        startObserve()\n        if (_useBinding) {\n            mBinding = DataBindingUtil.setContentView<ViewDataBinding>(this, getLayoutResId())\n            mBinding.lifecycleOwner =this\n        } else setContentView(getLayoutResId())\n    }\n\n    protected lateinit var mBinding: ViewDataBinding\n    abstract fun startObserve()\n\n    abstract fun getLayoutResId(): Int\n\n\n}\n\n\n\n\n\n\n\n\n\nabstract class BaseVMFragmentWithCoroutineScope<VM : ViewModel>(val useBinding: Boolean = false) : Fragment(), CoroutineScope by MainScope() {\n\n    protected lateinit var mBinding: ViewDataBinding\n\n    protected val mUserInfoProvider by lazy {\n        KsRouterHelper.buildUserInfoProvider() as UserInfoProvider\n    }\n\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n        return if (useBinding) {\n            mBinding = DataBindingUtil.inflate(inflater, getLayoutResId(), container, false)\n            mBinding.root\n        } else\n            inflater.inflate(getLayoutResId(), container, false)\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        initView()\n        initData()\n        startObserve()\n        super.onViewCreated(view, savedInstanceState)\n    }\n\n    abstract fun getLayoutResId(): Int\n    abstract fun initView()\n    abstract fun initData()\n    abstract fun startObserve()\n\n    override fun onDestroy() {\n        super.onDestroy()\n        cancel()\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593267695},"updatedAt":{"$$date":1598598806371},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"eLqglciXO7CqEG5L"}
{"name":"css-CSS 布局 - Overflow","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 布局 - Overflow\nCSS overflow 属性用于控制内容溢出元素框时显示的方式。\n\n这里的文本内容是可以滚动的，滚动条方向是垂直方向。\n\n这里的文本内容是可以滚动的，滚动条方向是垂直方向。\n\n这里的文本内容是可以滚动的，滚动条方向是垂直方向。\n\n这里的文本内容是可以滚动的，滚动条方向是垂直方向。\n\n这里的文本内容是可以滚动的，滚动条方向是垂直方向。\n\n这里的文本内容是可以滚动的，滚动条方向是垂直方向。\n\n尝试一下 »\n\nCSS Overflow\nCSS overflow 属性可以控制内容溢出元素框时在对应的元素区间内添加滚动条。\n\noverflow属性有以下值：\n\n值\t描述\nvisible\t默认值。内容不会被修剪，会呈现在元素框之外。\nhidden\t内容会被修剪，并且其余内容是不可见的。\nscroll\t内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。\nauto\t如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。\ninherit\t规定应该从父元素继承 overflow 属性的值。\n注意:overflow 属性只工作于指定高度的块元素上。\n\n注意: 在 OS X Lion ( Mac 系统) 系统上，滚动条默认是隐藏的，使用的时候才会显示 (设置 \"overflow:scroll\" 也是一样的)。\n\noverflow: visible\n默认情况下，overflow 的值为 visible， 意思是内容溢出元素框：\n\n这里的文本内容会溢出元素框。\n\n这里的文本内容会溢出元素框。\n\n这里的文本内容会溢出元素框。\n\n这里的文本内容会溢出元素框。\n\n这里的文本内容会溢出元素框。\n\n这里的文本内容会溢出元素框。\n\n这里的文本内容会溢出元素框。\n\n实例\ndiv {\n    width: 200px;\n    height: 50px;\n    background-color: #eee;\n    overflow: visible;\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598889303570},"updatedAt":{"$$date":1598973701836},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ePwgUMwItUvxJ2pd"}
{"name":"kotlin-操作符重载 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/operator-overloading.html\n操作符重载 - Kotlin 语言中文站\n11-14 minutes\n改进翻译\nKotlin 允许我们为自己的类型提供预定义的一组操作符的实现。这些操作符具有固定的符号表示 （如 + 或 *）和固定的优先级。为实现这样的操作符，我们为相应的类型（即二元操作符左侧的类型和一元操作符的参数类型）提供了一个固定名字的成员函数或扩展函数。 重载操作符的函数需要用 operator 修饰符标记。\n\n另外，我们描述为不同操作符规范操作符重载的约定。\n\n表达式\t翻译为\n+a\ta.unaryPlus()\n-a\ta.unaryMinus()\n!a\ta.not()\n这个表是说，当编译器处理例如表达式 +a 时，它执行以下步骤：\n\n确定 a 的类型，令其为 T；\n为接收者 T 查找一个带有 operator 修饰符的无参函数 unaryPlus（），即成员函数或扩展函数；\n如果函数不存在或不明确，则导致编译错误；\n如果函数存在且其返回类型为 R，那就表达式 +a 具有类型 R；\n注意 这些操作以及所有其他操作都针对基本类型做了优化，不会为它们引入函数调用的开销。\n\n以下是如何重载一元减运算符的示例：\n\ndata class Point(val x: Int, val y: Int)\n\noperator fun Point.unaryMinus() = Point(-x, -y)\n\nval point = Point(10, 20)\n\nfun main() {\n   println(-point)  // 输出“Point(x=-10, y=-20)”\n}\n\n表达式\t翻译为\na++\ta.inc() + 见下文\na--\ta.dec() + 见下文\ninc() 和 dec() 函数必须返回一个值，它用于赋值给使用 ++ 或 -- 操作的变量。它们不应该改变在其上调用 inc() 或 dec() 的对象。\n\n编译器执行以下步骤来解析后缀形式的操作符，例如 a++：\n\n确定 a 的类型，令其为 T；\n查找一个适用于类型为 T 的接收者的、带有 operator 修饰符的无参数函数 inc()；\n检测函数的返回类型是 T 的子类型。\n计算表达式的步骤是：\n\n把 a 的初始值存储到临时存储 a0 中；\n把 a.inc() 结果赋值给 a；\n把 a0 作为表达式的结果返回。\n对于 a--，步骤是完全类似的。\n\n对于前缀形式 ++a 和 --a 以相同方式解析，其步骤是：\n\n把 a.inc() 结果赋值给 a；\n把 a 的新值作为表达式结果返回。\n表达式\t翻译为\na + b\ta.plus(b)\na - b\ta.minus(b)\na * b\ta.times(b)\na / b\ta.div(b)\na % b\ta.rem(b)、 a.mod(b) （已弃用）\na..b\ta.rangeTo(b)\n对于此表中的操作，编译器只是解析成翻译为列中的表达式。\n\n请注意，自 Kotlin 1.1 起支持 rem 运算符。Kotlin 1.0 使用 mod 运算符，它在 Kotlin 1.1 中被弃用。\n\n下面是一个从给定值起始的 Counter 类的示例，它可以使用重载的 + 运算符来增加计数：\n\ndata class Counter(val dayIndex: Int) {\n    operator fun plus(increment: Int): Counter {\n        return Counter(dayIndex + increment)\n    }\n}\n表达式\t翻译为\na in b\tb.contains(a)\na !in b\t!b.contains(a)\n对于 in 和 !in，过程是相同的，但是参数的顺序是相反的。\n\n表达式\t翻译为\na[i]\ta.get(i)\na[i, j]\ta.get(i, j)\na[i_1, ……, i_n]\ta.get(i_1, ……, i_n)\na[i] = b\ta.set(i, b)\na[i, j] = b\ta.set(i, j, b)\na[i_1, ……, i_n] = b\ta.set(i_1, ……, i_n, b)\n方括号转换为调用带有适当数量参数的 get 和 set。\n\n表达式\t翻译为\na()\ta.invoke()\na(i)\ta.invoke(i)\na(i, j)\ta.invoke(i, j)\na(i_1, ……, i_n)\ta.invoke(i_1, ……, i_n)\n圆括号转换为调用带有适当数量参数的 invoke。\n\n表达式\t翻译为\na += b\ta.plusAssign(b)\na -= b\ta.minusAssign(b)\na *= b\ta.timesAssign(b)\na /= b\ta.divAssign(b)\na %= b\ta.remAssign(b), a.modAssign(b)（已弃用）\n对于赋值操作，例如 a += b，编译器执行以下步骤：\n\n如果右列的函数可用\n如果相应的二元函数（即 plusAssign() 对应于 plus()）也可用，那么报告错误（模糊），\n确保其返回类型是 Unit，否则报告错误，\n生成 a.plusAssign(b) 的代码；\n否则试着生成 a = a + b 的代码（这里包含类型检测：a + b 的类型必须是 a 的子类型）。\n注意：赋值在 Kotlin 中不是表达式。\n\n表达式\t翻译为\na == b\ta?.equals(b) ?: (b === null)\na != b\t!(a?.equals(b) ?: (b === null))\n这些操作符只使用函数 equals(other: Any?): Boolean，可以覆盖它来提供自定义的相等性检测实现。不会调用任何其他同名函数（如 equals(other: Foo)）。\n\n注意：=== 和 !==（同一性检测）不可重载，因此不存在对他们的约定。\n\n这个 == 操作符有些特殊：它被翻译成一个复杂的表达式，用于筛选 null 值。 null == null 总是 true，对于非空的 x，x == null 总是 false 而不会调用 x.equals()。\n\n表达式\t翻译为\na > b\ta.compareTo(b) > 0\na < b\ta.compareTo(b) < 0\na >= b\ta.compareTo(b) >= 0\na <= b\ta.compareTo(b) <= 0\n所有的比较都转换为对 compareTo 的调用，这个函数需要返回 Int 值\n\nprovideDelegate、 getValue 以及 setValue 操作符函数已在委托属性中描述。\n\n我们可以通过中缀函数的调用 来模拟自定义中缀操作符。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386573893},"updatedAt":{"$$date":1597396999317},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"eb9g4bcCzLv56HFI"}
{"name":"kotlin-Kotlin 接口 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-interface.html\nKotlin 接口 | 菜鸟教程\n2-3 minutes\nKotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：\n\ninterface MyInterface { fun bar() fun foo() { println(\"foo\") } }\n\n实现接口\n一个类或者对象可以实现一个或多个接口。\n\nclass Child : MyInterface { override fun bar() { } }\n\n实例\ninterface MyInterface { fun bar() fun foo() { println(\"foo\") } } class Child : MyInterface { override fun bar() { println(\"bar\") } } fun main(args: Array<String>) { val c = Child() c.foo(); c.bar(); }\n\n输出结果为：\n\nfoo\nbar\n接口中的属性\n接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：\n\ninterface MyInterface{ var name:String } class MyImpl:MyInterface{ override var name: String = \"runoob\" }\n\n实例\ninterface MyInterface { var name:String fun bar() fun foo() { println(\"foo\") } } class Child : MyInterface { override var name: String = \"runoob\" override fun bar() { println(\"bar\") } } fun main(args: Array<String>) { val c = Child() c.foo(); c.bar(); println(c.name) }\n\n输出结果为：\n\nfoo\nbar\nrunoob\n函数重写\n实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如:\n\n实例\ninterface A { fun foo() { print(\"A\") } fun bar() } interface B { fun foo() { print(\"B\") } fun bar() { print(\"bar\") } } class C : A { override fun bar() { print(\"bar\") } } class D : A, B { override fun foo() { super<A>.foo() super<B>.foo() } override fun bar() { super<B>.bar() } } fun main(args: Array<String>) { val d = D() d.foo(); d.bar(); }\n\n输出结果为：\n\nABbar\n实例中接口 A 和 B 都定义了方法 foo() 和 bar()， 两者都实现了 foo(), B 实现了 bar()。因为 C 是一个实现了 A 的具体类，所以必须要重写 bar() 并实现这个抽象方法。\n\n然而，如果我们从 A 和 B 派生 D，我们需要实现多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则 既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303694355},"updatedAt":{"$$date":1597304161561},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"eg3iqh70CcnryrQW"}
{"name":"kqapp-","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593278668},"updatedAt":{"$$date":1598593278668},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"esLU5ityd3nEtEMX"}
{"name":"ad-ksprogresshud","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 120\n        versionName \"1.2.0\"\n\n    }\n\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\nkprogresshud\nAnnularView\nBackgroundLayout\nBarView\nDeterminate\nHelper\nIndeterminate\nKProgressHUD\nPieView\nSpinView\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598519926804},"updatedAt":{"$$date":1598521360775},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"f1FOOKX8lGEbLKar"}
{"name":"okr","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"移动端团队Q3\nO1：为用户提供流畅的应用体验\nKR1：开发人员使用性能分析工具（Instruments，Android待定）MainThread方法调用200ms以内。\nKR2：配合测试团队对卡顿问题及现象进行性能分析，排查及优化有据可依。\nKR3：针对历史遗留核心模块进行排查，首页，播放页，详情页。\nO2：成就卓越的自我\nKR1：提升提测模块质量，提测主流程无阻塞。\nKR2：提测Bug数量可控，测试用例中的Case不再出现Bug。\nKR3：提升质量的同时维持现有开发效率。\nO3：移动端走向平台化\nKR1：产品需求质量提升，业务开发高可用，高复用，易维护。\nKR2：中台组件优化及部分组件解耦重构，支撑平台业务。\nO4：中台人员专业化\nKR1：组件优化及组件解耦方案设计实现，必须提供类图，时序图/流程图，使用Demo。（沉淀文档）\nKR2：中台人员UML类图，时序图，性能分析工具熟练使用。\nO5：\b专利申请\nKR1：专利申请2个（功能侧专利）\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598543672498},"updatedAt":{"$$date":1598543677285},"_id":"fMSHPHClb6B18KTD","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"qk-ks_lib_net","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 102\n        versionName \"102\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    buildTypes {\n//线上环境\n        release {\n            consumerProguardFiles 'proguard-rules.pro'\n        }\n\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    api deps.kotlin.stdlib_jdk\n    api deps.androidx.core_ktx\n    api deps.androidx.appcompat\n    api deps.kotlin.coroutines_core\n    api deps.kotlin.coroutines_android\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    api deps.retrofit.retrofit\n    api deps.retrofit.converter_gson\n    api deps.okhttp3.logging_interceptor\n}\n////这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\nabstract class BaseRepository {\n\n//    suspend fun <T : Any> apiCall(call: suspend () -> KsResponse<T>): KsResponse<T> {\n//        return call.invoke()\n//    }\n\n    /**\n     *  对网络请求过程中的异常进行了捕获，并返回自定义exception。\n     *  @param call 实际进行网络请求 的方法 引用\n     * @param errorMessage 调用方自定义 错误信息提示，比如错误了，就提示这个消息\n     * @return KsResult ,\n     */\n    suspend fun <T : Any> safeApiCall(\n        call: suspend () -> KsResult<T>,\n        errorMessage: String? = null\n    ): KsResult<T> {\n        return try {\n            val result = call()\n            if(result is KsResult.Error){\n                return handleException(result.exception,errorMessage,call)\n            }\n            return result\n        } catch (e: Exception) {\n            // An exception was thrown when calling the API so we're converting this to an IOException\n            KsResult.Error(\n                exception = IOException(\n                    if (errorMessage.isNullOrEmpty()) e.message else errorMessage,\n                    e\n                )\n            )\n        }\n    }\n\n    /**\n     * 处理 异常，加入了 是否重试 选项\n     * @param exception Exception 异常类\n     * @param errorMessage String? 错误信息\n     * @param call SuspendFunction0<KsResult<T>> ，重试需要调用的方法\n     * @return KsResult<T> 返回结果\n     */\n    private suspend fun <T : Any> handleException(\n        exception: Exception,\n        errorMessage: String?,\n        c\n        sult<T>\n    ): KsResult<T> {\n        if(exception is BaseException){\n            println(\"handleException..........need retry:${exception.isNeedRetry},exception:$exception\")\n        }\n\n        return if(exception is BaseException){\n            if(exception.isNeedRetry){\n               call()\n            }else{\n               KsResult.Error(code = exception.code,exception = exception)\n            }\n\n        }else  {\n            println(\"不需要重试，返回错误 exception:${if (errorMessage.isNullOrEmpty()) exception.message else errorMessage}\")\n            KsResult.Error(\n                exception = IOException(\n                    if (errorMessage.isNullOrEmpty()) exception.message else errorMessage,\n                    exception\n                )\n            )\n        }\n    }\n\n    /**\n     * @param\n     */\n    suspend fun <T : Any> executeResponse(\n        response: KsResponse<T>, successBlock: (suspend CoroutineScope.() -> Unit)? = null,\n        errorBlock: (suspend CoroutineScope.() -> Unit)? = null\n    ): KsResult<T> {\n        return coroutineScope {\n            //\n            when (val result = handleCode(response)) {\n                is Exception -> {\n                    errorBlock?.let { it() }\n                    KsResult.Error(correctCode(response), result)\n                }\n                else -> {\n                    successBlock?.let { it() }\n                    KsResult.Success(\n                        data = correctData(response),\n                        code = correctCode(response),\n                        message = correctMessage(response)\n                    )\n                }\n            }\n        }\n    }\n\n\n    abstract suspend fun <T> handleCode(response: KsResponse<T>): Any\n\n\n    protected fun <T> correctCode(response: KsResponse<T>): Int {\n        return response.code ?: response.errcode ?: Int.MAX_VALUE\n    }\n\n    protected fun <T> correctMessage(response: KsResponse<T>): String {\n        return response.message ?: response.errmsg ?: \"\"\n    }\n\n    private fun <T> correctData(response: KsResponse<T>): T? = with(response) {\n        data ?: result\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\nabstract class BaseRetrofitClient {\n\n    private val client: OkHttpClient by lazy {\n        val builder = OkHttpClient.Builder()\n        handleBuilder(builder)\n        builder.build()\n    }\n\n    private val retrofit:Retrofit by lazy { Retrofit.Builder()\n            .client(client)\n            .addConverterFactory(GsonConverterFactory.create())\n//                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n//                .addCallAdapterFactory(CoroutineCallAdapterFactory.invoke())\n            .baseUrl(baseUrl())\n            .build() }\n\n    protected abstract fun handleBuilder(builder: OkHttpClient.Builder)\n    protected abstract fun baseUrl():String\n\n    fun <S> getService(serviceClass: Class<S>): S {\n        return retrofit.create(serviceClass)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n@Keep\ndata class KsResponse<out T>(\n    val code: Int?,\n    val message: String? = \"\",\n    val data: T? = null,\n    val fail: Boolean? = false,\n    val success: Boolean? = false,\n    //兼容老接口\n    val errcode: Int?,\n    //兼容老接口\n    val errmsg: String? = \"\",\n    //兼容老接口\n    val result: T? = null\n)\n\n\n\n\n\n\n\n\n\n@Keep\nsealed class KsResult<out T : Any> {\n\n    data class Success<out T : Any>(val data: T?=null, val code: Int = 0, val message: String = \"\") : KsResult<T>()\n    data class Error(val code:Int = -1,val exception: Exception) : KsResult<Nothing>()\n\n    override fun toString(): String {\n        return when (this) {\n            is Success<*> -> \"Success[data=$data]\"\n            is Error -> \"Error[exception=$exception]\"\n        }\n    }\n\n    /**\n     * 请求数据 正确返回，没有异常code\n     */\n    fun isOk(): Boolean {\n        if (this is Success) {\n            return code == 0\n        }\n        return false\n    }\n}\n\n\n\n\n\n\nopen class BaseException(override val message: String = \"\", val isNeedRetry: Boolean = false,\n                         open val code:Int = 0) :\n    Exception(message)\n\n\n\n\n\n\n\n\n\n\n    public class DynamicTimeoutInterceptor implements Interceptor {\n\n    public static final int MINI_TIME = 5;\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n\n        Request request = chain.request();\n        boolean needMiniTimeout = (\"1\".equals(request.header(\"xTimeout\")));\n\n        if (needMiniTimeout) {\n            return chain.withConnectTimeout(MINI_TIME, TimeUnit.SECONDS)\n                    .withReadTimeout(MINI_TIME, TimeUnit.SECONDS)\n                    .withReadTimeout(MINI_TIME, TimeUnit.SECONDS)\n                    .proceed(request);\n        }\n\n        return chain.proceed(request);\n    }\n}\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580908737},"updatedAt":{"$$date":1599014580019},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"feGzQnVvWLiwF5BS"}
{"name":"ad-kschatframe","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\n/**\n * 聊天抽象lib\n * notice ： 不要依赖Support 包\n *\n */\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 5\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n\n    testImplementation deps.androidx.junit\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n    implementation deps.eventbus\n    implementation deps.google_gson\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic interface EventConfig {\n\n    /**\n     * 消息优先级Leve\n     */\n    int PRIORITY_LEVEL_LOW = 1;\n    int PRIORITY_LEVEL_HIGH = 2;\n    /**\n     * 普通消息\n     */\n    String TYPE_MSG = \"msg\";\n    /**\n     * 分享消息\n     */\n    String TYPE_SHARE_LIVE = \"KSShareLive\";\n    /**\n     * 用户登入\n     */\n    String TYPE_LOGININ = \"loginin\";\n    String TYPE_LOGINOUT = \"loginout\";\n    /**\n     * 用户去购物\n     */\n    String TYPE_GO_SHOP = \"KSGoBuy\";\n\n\n    /**\n     * 系统公告消息\n     */\n    String TYPE_SYTEM_BULLETIN = \"Bulletin\";\n    /**\n     * 系统公告移除\n     */\n    String TYPE_SYTEM_BULLETIN_REMOVE = \"BulletinRemove\";\n\n    /**\n     * 主播发言\n     */\n    String TYPE_ANCHOR_MSG = \"Anchor\";\n\n    /**房管消息*/\n    String ROOM_MANAGER = \"RoomManager\";\n\n    /**\n     * 后台推送\n     */\n    String TYPE_PUSH = \"PUSH\";\n\n\n    /*********IM 连接事件 ******/\n    /**\n     * 连接失败\n     */\n    int DISCONNECT = 0x200;\n    int CONNECTED = 0x201;\n    int LOGINSUCCESS = 0x202;\n    int RECONNECTING = 0x203;\n    int RECONNECTSUCCESS = 0x204;\n    int CONNECTING = 0x205;\n\n/********** 房间事件*********************/\n    /**\n     * 剔除房间\n     */\n    int EVENT_KICK = 0x301;\n    /**\n     * 拒绝加入房间房间\n     */\n    int EVENT_REFUSE = 0x302;\n    /**\n     * 禁言\n     */\n    int EVENT_MUTE = 0x303;\n    /**\n     * 房间关闭\n     */\n    int EVENT_ROOM_CLOSE = 0x304;\n    /**\n     * 直播结束\n     */\n    int EVENT_LIVE_FINISH = 0x305;\n    /**\n     * 房间禁言\n     */\n    int EVENT_ROOM_MUTE = 0x307;\n    /**\n     * 房间解除禁言\n     */\n    int EVENT_ROOM_UNMUTE = 0x308;\n\n    /**\n     * 服务器推送 直播结束\n     */\n    int EVENT_LIVE_END = 0x320;\n\n    /**\n     * 服务器推送 切换直播间\n     */\n    int EVENT_SWITCH_CHANNEL = 0x330;\n\n    /********************刷新事件*****************/\n\n    /**\n     * 刷新商品列表\n     */\n    int TYPE_FRESH_GOODS = 0x401;\n    /**\n     * 刷新礼物列表\n     */\n    int TYPE_FRESH_GIFT = 0x402;\n\n    /**\n     * 刷新直播间信息\n     */\n    int TYPE_FRESH_ROOM = 0x403;\n\n    /**\n     * 刷新文字颜色\n     */\n    int TYPE_FRESH_FONT_COLOR = 0x404;\n\n    /**\n     * 发言间隔 cd 冷却\n     */\n    int TYPE_FRESH_SPEAK_INTERVAL = 0x405;\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nim\nconfig\nEventConfig\nentity\nBaseMsg\nEmptyMsg\nGiftMsg\nIMessage\nMessage\nServerMsg\nShopMsg\nTagMsg\nTextMsg\nevent\nColorConfigEvent\nGiftJsonEvent\nImEvent\nImTextEvent\nLiveRefreshEvent\nRoomEvent\nRoomNumVarEvent\nutil\nObjectPool\nObjFactory\nAbsImManager\nConnectListener\nIManager\nIMessageListener\nMsgDispatch\nSendMsgListener\nSimpleUserInfo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522794626},"updatedAt":{"$$date":1598523665574},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"fhgB88PmO4MOYWDJ"}
{"name":"kotlin-LessonsProgressView","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\npackage com.ks.component.ui.view\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport android.widget.ImageView\nimport android.widget.LinearLayout\nimport androidx.annotation.DrawableRes\nimport com.ks.component.ui.R\nimport com.ks.lib.ktx.ext.dp2px\n\n/**\n ***************************************\n * 项目名称:KsLightLearn\n * @Author liangsaifei\n * 邮箱：liangsaifei@ksjgs.com\n * 创建时间: 2020/2/11 0011     11:01\n * 用途:学习进度 or 当前课程 打多少颗星星\n ***************************************\n\n */\nclass LessonsProgressView  @JvmOverloads constructor(context: Context,attributes: AttributeSet?=null,defStyleAttr:Int=0 ) : LinearLayout(context,attributes, defStyleAttr) {\n   private var iconCheckedResId = 0\n    private var iconUncheckedResId = 0\n    private var marginRight = 0f\n    init {\n        orientation = HORIZONTAL\n        attributes?.run {\n            val typedArray = context.obtainStyledAttributes(this, R.styleable.LessonsProgressView )\n            val count = typedArray.getInt(R.styleable.LessonsProgressView_progress_total_count,3)\n            val checkedCount = typedArray.getInt(R.styleable.LessonsProgressView_progress_checked_count,0)\n            marginRight = typedArray.getDimension(R.styleable.LessonsProgressView_progress_item_margin_right,dp2px(5).toFloat())\n            iconCheckedResId = typedArray.getResourceId(R.styleable.LessonsProgressView_progress_item_checked_icon, 0)\n            iconUncheckedResId = typedArray.getResourceId(R.styleable.LessonsProgressView_progress_item_unchecked_icon, 0)\n            typedArray.recycle()\n            val unCheckedCount = count - checkedCount\n            addCheckedView(checkedCount,iconCheckedResId)\n            addUnCheckedView(unCheckedCount,iconUncheckedResId)\n            invalidate()\n        }\n\n\n    }\n\n    private fun addUnCheckedView( unCheckedCount: Int, iconUncheckedResId: Int) {\n        addCheckedView(unCheckedCount,iconUncheckedResId)\n    }\n\n    private fun createItem(): ImageView {\n        return ImageView(context).apply{\n            layoutParams = LayoutParams(MarginLayoutParams.WRAP_CONTENT,MarginLayoutParams.WRAP_CONTENT).apply {\n                this.rightMargin = marginRight.toInt()\n            }\n            scaleType = ImageView.ScaleType.FIT_CENTER\n        }\n    }\n\n    private fun addCheckedView( count: Int,@DrawableRes resId:Int) {\n        repeat(count) {\n            addView(createItem().apply {\n                setImageResource(resId)\n            } )\n        }\n    }\n\n    fun setupView(checkedCount:Int,totalCount:Int){\n        removeAllViews()\n        addCheckedView(checkedCount,iconCheckedResId)\n        addUnCheckedView(totalCount-checkedCount,iconUncheckedResId)\n        invalidate()\n    }\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403209887},"updatedAt":{"$$date":1597404008950},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"fkTx03oYIxkKyjrZ"}
{"name":"andr-设备兼容性概览","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/practices/compatibility\n设备兼容性概览  |  Android 开发者  |  Android Developers\n6-7 minutes\nAndroid 适用于众多类型的设备，从手机到平板电脑和电视都能搭载使用。作为开发者，如此广泛的设备类型能为您的应用带来广大的潜在受众群体。为了能在所有这些设备上顺利运行，应用应该容许部分设备功能的变化，并提供可适应不同屏幕配置的灵活界面。\n\n为了帮助您实现这一目标，Android 提供了一个动态应用框架，供您在静态文件中提供特定于配置的应用资源（例如针对不同屏幕尺寸的不同 XML 布局）。然后，Android 会根据当前设备配置加载适当的资源。因此，在对应用设计和一些额外的应用资源进行一些事先规划后，您可以发布单个应用软件包 (APK)，并在各种设备上提供优化的用户体验。\n\n但是，您可以根据需要指定应用的功能要求，并控制哪些类型的设备可以通过 Google Play 商店安装您的应用。本页介绍了如何控制哪些设备可以访问您的应用，以及如何准备您的应用以确保它们覆盖合适的受众群体。如需详细了解如何让您的应用适应不同的设备，请参阅支持不同的设备。\n\n“兼容性”是什么意思？\n随着您进一步阅读 Android 开发相关内容，您可能会在各种语境下遇到“兼容性”一词。兼容性有两种类型：设备兼容性和应用兼容性。\n\n由于 Android 是一个开源项目，因此任何硬件制造商都可以制造搭载 Android 操作系统的设备。不过，设备“兼容 Android”的前提是它可以正常运行针对 Android 执行环境编写的应用。Android 执行环境的具体细节由 Android 兼容性计划定义，每台设备都必须通过兼容性测试套件 (CTS) 测试才能被视为兼容。\n\n作为应用开发者，您无需担心设备是否兼容 Android，因为只有与 Android 兼容的设备才会附带 Google Play 商店。因此，您可以放心，通过 Google Play 商店安装您的应用的用户使用的是 Android 兼容设备。\n\n不过，您确实需要考虑您的应用是否兼容每一种可能的设备配置。由于 Android 以各种设备配置运行，因此部分功能并不适用于所有设备。例如，某些设备可能未配备罗盘传感器。如果应用的核心功能需要使用罗盘传感器，那么应用只能与带有罗盘传感器的设备兼容。\n\n控制应用在设备上的可用性\n应用可通过平台 API 利用 Android 支持的各种功能。有些功能基于硬件（例如罗盘传感器），有些功能基于软件（如应用窗口微件），有些功能则依赖于平台版本。并非每台设备都支持所有功能，因此您可能需要根据应用所需的功能控制应用在设备上的可用性。\n\n要尽可能扩大应用的用户群，您应设法使用单个 APK 支持尽可能多的设备配置。在大多数情况下，要实现这一目标，您可以在运行时停用可选功能，并为应用资源提供针对不同配置的替代选项（例如针对不同屏幕尺寸的不同布局）。不过，如果需要，您可以根据以下设备特征，通过 Google Play 商店限制应用在设备上的可用性：\n\n设备功能\n平台版本\n屏幕配置\n设备功能\n为了让您根据设备功能管理应用的可用性，Android 为可能并不适用于所有设备的任何硬件或软件功能定义了功能 ID。例如，罗盘传感器的功能 ID 为 FEATURE_SENSOR_COMPASS，而应用微件的功能 ID 为 FEATURE_APP_WIDGETS。\n\n根据需要，要在用户的设备不具备特定功能时阻止用户安装您的应用，您可以通过应用清单文件中的 <uses-feature> 元素声明这一点。\n\n例如，如果您的应用在没有罗盘传感器的设备上没有意义，您可以使用以下清单标记声明需要罗盘传感器：\n\n    <manifest ... >\n        <uses-feature android:name=\"android.hardware.sensor.compass\"\n                      android:required=\"true\" />\n        ...\n    </manifest>\n    \nGoogle Play 商店会将您的应用所需的功能与每个用户的设备上可用的功能进行比较，以确定您的应用是否与每台设备兼容。如果设备不具备您的应用所需的所有功能，则用户无法安装您的应用。\n\n但是，如果应用的主要功能不需要某项设备功能，则应将 required 属性设置为 \"false\" 并在运行时检查是否有该设备功能。如果应用功能在当前设备上不可用，请适当降级相应的应用功能。例如，您可以通过调用 hasSystemFeature() 来查询功能是否可用，如下所示：\n\n    if (!packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) {\n        // This device does not have a compass, turn off the compass feature\n        disableCompassFeature()\n    }\n    \n    PackageManager pm = getPackageManager();\n    if (!pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) {\n        // This device does not have a compass, turn off the compass feature\n        disableCompassFeature();\n    }\n    \n如需了解您可以用来通过 Google Play 商店控制应用对用户是否可用的所有过滤器，请参阅 Google Play 上的过滤器文档。\n\n注意：一些系统权限会隐式要求具备某项设备功能。例如，如果您的应用请求对 BLUETOOTH 的访问权限，这就隐式要求具备 FEATURE_BLUETOOTH 设备功能。要停用基于此功能的过滤，并使您的应用可用于没有蓝牙的设备，您可以在 <uses-feature> 标记中将 required 属性设置为 \"false\"。如需详细了解隐式要求的设备功能，请参阅隐含功能要求的权限。\n\n平台版本\n不同的设备可能会运行不同版本的 Android 平台，例如 Android 4.0 或 Android 4.4。每个后续的平台版本通常会添加之前版本中不可用的新 API。为表明可用的 API 集，每个平台版本都会指定 API 级别。例如，Android 1.0 是 API 级别 1，而 Android 4.4 是 API 级别 19。\n\n通过 API 级别，您可以使用 <uses-sdk> 清单标记及其 minSdkVersion 属性来声明应用兼容的最低版本。例如，Android 4.0（API 级别 14）中添加了日历提供程序 API。如果您的应用在没有这些 API 的情况下无法运行，您应将 API 级别 14 声明为应用的最低支持版本。\n\nminSdkVersion 属性声明应用兼容的最低版本，targetSdkVersion 属性声明应用经过优化后适用的最高版本。\n\n不过，请注意 <uses-sdk> 元素中的属性会被替换为 build.gradle 文件中的相应属性。因此，如果您使用的是 Android Studio，则必须在其中指定 minSdkVersion 和 targetSdkVersion 值：\n\n    android {\n      defaultConfig {\n        applicationId 'com.example.myapp'// Defines the minimum API level required to run the app.\n        minSdkVersion 15// Specifies the API level used to test the app.\n        targetSdkVersion 28...\n      }\n    }\n    \n要详细了解 build.gradle 文件，请参阅如何配置编译版本。\n\n每个后续版本的 Android 都为使用之前平台版本的 API 构建的应用提供兼容性，因此您的应用应始终与未来版本的 Android 兼容，同时使用已记录的 Android API。\n\n注意：targetSdkVersion 属性不会阻止您的应用安装在高于指定值的平台版本上，但它很重要，因为它向系统指示您的应用是否应继承较新版本中的行为更改。如果您不将 targetSdkVersion 更新到最新版本，则系统会认为您的应用在最新版本上运行时需要一些向后兼容性行为。例如，在 Android 4.4 中的行为更改中，使用 AlarmManager API 创建的闹钟现在默认不精确，因此系统可以批量处理应用闹钟并节省系统电量，但如果您的目标 API 级别低于“19”，则系统会为您的应用保留之前的 API 行为。\n\n不过，如果您的应用使用的是较新平台版本中添加的 API，但其主要功能并不需要这些 API，则应在运行时检查 API 级别，并在 API 级别过低时适当降级相应的功能。在这种情况下，请将 minSdkVersion 尽量设置为适用于应用主要功能的最低值，然后将当前系统的版本 SDK_INT 与 Build.VERSION_CODES 中对应于您要检查的 API 级别的一个代号常量进行比较。例如：\n\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n        // Running on something older than API level 11, so disable\n        // the drag/drop features that use <code><a href=\"/reference/android/content/ClipboardManager.html\">ClipboardManager</a></code> APIs\n        disableDragAndDrop()\n    }\n    \n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n        // Running on something older than API level 11, so disable\n        // the drag/drop features that use <code><a href=\"/reference/android/content/ClipboardManager.html\">ClipboardManager</a></code> APIs\n        disableDragAndDrop();\n    }\n    \n屏幕配置\nAndroid 可在各种尺寸的设备上运行，包括手机、平板电脑和电视。为了按照屏幕类型对设备进行分类，Android 为每种设备定义了两个特征：屏幕尺寸（屏幕的物理尺寸）和屏幕密度（屏幕上像素的物理密度，称为 DPI）。为了简化不同的配置，Android 将这些变体归纳成组，使它们更容易作为定位目标：\n\n四种广义的尺寸：小、标准、大和特大。\n还有几种广义的密度：mdpi（中）、hdpi（高）、xhdpi（超高）、xxhdpi（超超高）等。\n默认情况下，您的应用会兼容所有屏幕尺寸和密度，因为系统会根据需要对各个屏幕的界面布局和图片资源进行相应的调整。不过，您应针对不同的屏幕尺寸添加专门的布局，针对常见的屏幕密度添加优化的位图图片，以优化每种屏幕配置的用户体验。\n\n如需了解如何针对不同屏幕创建备用资源以及如何在必要时将应用限制为特定屏幕尺寸，请参阅支持不同屏幕。\n\n出于业务原因控制应用的可用性\n除了根据设备特征限制应用的可用性之外，您还可能需要出于业务或法律方面的原因限制应用的可用性。例如，显示伦敦地铁列车时刻表的应用不太可能适用于英国以外的用户。针对此类情况，Google Play 商店在 Play 管理中心提供了过滤选项，供您出于非技术原因（例如用户的语言区域或无线运营商）控制应用的可用性。\n\n针对技术兼容性（例如必需的硬件组件）的过滤始终基于 APK 文件中包含的信息。但是，出于非技术原因（如地理语言区域）的过滤始终在 Google Play 管理中心中处理。\n\n继续阅读以下内容：\n提供资源\n介绍了 Android 应用如何采用将应用资源与应用代码分开的结构，包括如何为特定设备配置提供备用资源。\nGoogle Play 上的过滤器\n介绍了 Google Play 商店阻止您的应用安装在不同设备上的不同方式。\n您可能还对以下内容感兴趣：\n系统权限\nAndroid 如何通过权限系统要求应用在获得用户同意后才能使用特定 API，从而限制应用对这些 API 的访问权限。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243438504},"updatedAt":{"$$date":1597243628229},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"fpEAxoblhvcFircI"}
{"name":"kotlin-异常：try、catch、finally、throw、Nothing - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/exceptions.html\n异常：try、catch、finally、throw、Nothing - Kotlin 语言中文站\n8-10 minutes\n改进翻译\nKotlin 中所有异常类都是 Throwable 类的子孙类。 每个异常都有消息、堆栈回溯信息以及可选的原因。\n\n使用 throw-表达式来抛出异常：\n\n\nfun main() {\n//sampleStart\n    throw Exception(\"Hi There!\")\n//sampleEnd\n}\n使用 try-表达式来捕获异常：\n\ntry {\n    // 一些代码\n}\ncatch (e: SomeException) {\n    // 处理程序\n}\nfinally {\n    // 可选的 finally 块\n}\n可以有零到多个 catch 块。finally 块可以省略。 但是 catch 与 finally 块至少应该存在一个。\n\ntry 是一个表达式，即它可以有一个返回值：\n\nval a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }\ntry-表达式的返回值是 try 块中的最后一个表达式或者是（所有）catch 块中的最后一个表达式。 finally 块中的内容不会影响表达式的结果。\n\nKotlin 没有受检的异常。这其中有很多原因，但我们会提供一个简单的例子。\n\n以下是 JDK 中 StringBuilder 类实现的一个示例接口：\n\nAppendable append(CharSequence csq) throws IOException;\n这个签名是什么意思？ 它是说，每次我追加一个字符串到一些东西（一个 StringBuilder、某种日志、一个控制台等）上时我就必须捕获那些 IOException。 为什么？因为它可能正在执行 IO 操作（Writer 也实现了 Appendable）…… 所以它导致这种代码随处可见的出现：\n\ntry {\n    log.append(message)\n}\ncatch (IOException e) {\n    // 必须要安全\n}\n这并不好，参见《Effective Java》第三版 第 77 条：不要忽略异常。\n\nBruce Eckel says about checked exceptions:\n\n通过一些小程序测试得出的结论是异常规范会同时提高开发者的生产力与代码质量，但是大型软件项目的经验表明一个不同的结论——生产力降低、代码质量很少或没有提高。\n\n其他相关引证：\n\n《Java 的受检异常是一个错误》（Java's checked exceptions were a mistake）（Rod Waldhoff）\n《受检异常的烦恼》（The Trouble with Checked Exceptions）（Anders Hejlsberg）\nIf you want to alert callers of possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the @Throws annotation. Read more about using this annotation for Java as well as for Swift and Objective-C.\n\n在 Kotlin 中 throw 是表达式，所以你可以使用它（比如）作为 Elvis 表达式的一部分：\n\nval s = person.name ?: throw IllegalArgumentException(\"Name required\")\nthrow 表达式的类型是特殊类型 Nothing。 该类型没有值，而是用于标记永远不能达到的代码位置。 在你自己的代码中，你可以使用 Nothing 来标记一个永远不会返回的函数：\n\nfun fail(message: String): Nothing {\n    throw IllegalArgumentException(message)\n}\n当你调用该函数时，编译器会知道在该调用后就不再继续执行了：\n\nval s = person.name ?: fail(\"Name required\")\nprintln(s)     // 在此已知“s”已初始化\n可能会遇到这个类型的另一种情况是类型推断。这个类型的可空变体 Nothing? 有一个可能的值是 null。如果用 null 来初始化一个要推断类型的值，而又没有其他信息可用于确定更具体的类型时，编译器会推断出 Nothing? 类型：\n\nval x = null           // “x”具有类型 `Nothing?`\nval l = listOf(null)   // “l”具有类型 `List<Nothing?>\n与 Java 互操作性相关的信息，请参见 Java 互操作性章节中的异常部分。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386576954},"updatedAt":{"$$date":1597397089253},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"fvXEjHZ3wLg5qKRv"}
{"name":"ad-ks_imageload_fresco","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\napply plugin: 'com.android.library'\n// 上传插件\napply from: rootProject.file(\"./gradle/upload_local_maven.gradle\")\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n//    api deps.fresco.fresco\n//    api deps.fresco.imagepipeline_okhttp\n//    api deps.fresco.animated_gif\n\n    //implementation project(path: ':ks_imageload_core')\n    api 'com.ks.frame:imageload-core:0.0.1.1-SNAPSHOT'\n\n    api 'com.facebook.fresco:fresco:2.2.0'\n    //implementation 'om.facebook.fresco:webpsupport:1.3.0'\n    // http\n    api 'com.facebook.fresco:imagepipeline-okhttp3:2.2.0'\n    api 'com.facebook.fresco:animated-webp:2.2.0'\n    api 'com.facebook.fresco:animated-gif:2.2.0'\n\n}\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539544782},"updatedAt":{"$$date":1598539862696},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"fxmeXOAxzvVtBEyi"}
{"name":"py-整数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\nPython可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。\n\n计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。\n\n浮点数\n浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。\n\n整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973910549},"updatedAt":{"$$date":1594973973120},"_id":"g0IVVihOupc9H0F2","folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-解构声明 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/multi-declarations.html\n解构声明 - Kotlin 语言中文站\n8-10 minutes\n改进翻译\n有时把一个对象 解构 成很多变量会很方便，例如:\n\n这种语法称为 解构声明 。一个解构声明同时创建多个变量。 我们已经声明了两个新变量： name 和 age，并且可以独立使用它们：\n\nprintln(name)\nprintln(age)\n一个解构声明会被编译成以下代码：\n\nval name = person.component1()\nval age = person.component2()\n其中的 component1() 和 component2() 函数是在 Kotlin 中广泛使用的 约定原则 的另一个例子。 （参见像 + 和 *、for-循环等操作符）。 任何表达式都可以出现在解构声明的右侧，只要可以对它调用所需数量的 component 函数即可。 当然，可以有 component3() 和 component4() 等等。\n\n请注意，componentN() 函数需要用 operator 关键字标记，以允许在解构声明中使用它们。\n\n解构声明也可以用在 for-循环中：当你写：\n\nfor ((a, b) in collection) { …… }\n变量 a 和 b 的值取自对集合中的元素上调用 component1() 和 component2() 的返回值。\n\n让我们假设我们需要从一个函数返回两个东西。例如，一个结果对象和一个某种状态。 在 Kotlin 中一个简洁的实现方式是声明一个数据类 并返回其实例：\n\ndata class Result(val result: Int, val status: Status)\nfun function(……): Result {\n    // 各种计算\n\n    return Result(result, status)\n}\n\n// 现在，使用该函数：\nval (result, status) = function(……)\n因为数据类自动声明 componentN() 函数，所以这里可以用解构声明。\n\n注意：我们也可以使用标准类 Pair 并且让 function() 返回 Pair<Int, Status>， 但是让数据合理命名通常更好。\n\n可能遍历一个映射（map）最好的方式就是这样：\n\nfor ((key, value) in map) {\n   // 使用该 key、value 做些事情\n}\n为使其能用，我们应该\n\n通过提供一个 iterator() 函数将映射表示为一个值的序列；\n通过提供函数 component1() 和 component2() 来将每个元素呈现为一对。\n当然事实上，标准库提供了这样的扩展：\n\noperator fun <K, V> Map<K, V>.iterator(): Iterator<Map.Entry<K, V>> = entrySet().iterator()\noperator fun <K, V> Map.Entry<K, V>.component1() = getKey()\noperator fun <K, V> Map.Entry<K, V>.component2() = getValue()\n因此你可以在 for-循环中对映射（以及数据类实例的集合等）自由使用解构声明。\n\n如果在解构声明中你不需要某个变量，那么可以用下划线取代其名称：\n\nval (_, status) = getResult()\n对于以这种方式跳过的组件，不会调用相应的 componentN() 操作符函数。\n\n你可以对 lambda 表达式参数使用解构声明语法。 如果 lambda 表达式具有 Pair 类型（或者 Map.Entry 或任何其他具有相应 componentN 函数的类型）的参数，那么可以通过将它们放在括号中来引入多个新参数来取代单个新参数：\n\nmap.mapValues { entry -> \"${entry.value}!\" }\nmap.mapValues { (key, value) -> \"$value!\" }\n注意声明两个参数和声明一个解构对来取代单个参数之间的区别：\n\n{ a //-> …… } // 一个参数\n{ a, b //-> …… } // 两个参数\n{ (a, b) //-> …… } // 一个解构对\n{ (a, b), c //-> …… } // 一个解构对以及其他参数\n如果解构的参数中的一个组件未使用，那么可以将其替换为下划线，以避免编造其名称：\n\nmap.mapValues { (_, value) -> \"$value!\" }\n你可以指定整个解构的参数的类型或者分别指定特定组件的类型：\n\nmap.mapValues { (_, value): Map.Entry<Int, String> -> \"$value!\" }\n\nmap.mapValues { (_, value: String) -> \"$value!\" }"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386568106},"updatedAt":{"$$date":1597393185563},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"g3O79pwZYOgLfoso"}
{"name":"三方平台账号","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"https://kaishu.yuque.com/bu8pzp/qtpdtp/ocvqsu#UYM4l"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598547157614},"updatedAt":{"$$date":1598547158607},"_id":"gDydMUwcBAokysBV","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598525727921},"updatedAt":{"$$date":1598538088316},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"gIsIPljWj9h70PDa"}
{"name":"Untitled snippet","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580859694},"updatedAt":{"$$date":1598580859694},"_id":"gWJONu2dCKsiyL7r"}
{"name":"ad-ksadapter","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    api fileTree(dir: 'libs', include: ['*.jar'])\n    compileOnly deps.androidx.app_compat\n    compileOnly deps.androidx.recyclerview_v7\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\nanimation\ncallback\nentity\nlistener\nloadmore\nutil\nBaseItemDraggableAdapter\nBaseMultiItemQuickAdapter\nBaseQuickAdapter\nBaseSectionQuickAdapter\nBaseViewHolder\nKsAdapter\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522799625},"updatedAt":{"$$date":1598523990233},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"gWZtGmiy12zVZa42"}
{"name":"kqapp-lightlearn_module_product","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\nif (isProductModule.toBoolean()) {\n    apply plugin: 'com.android.application'\n} else {\n    apply plugin: 'com.android.library'\n}\napply from: \"$rootDir/common_submodule_config.gradle\"\nandroid {\n    defaultConfig {\n        if (isProductModule.toBoolean()) {\n            applicationId \"com.ks.lightlearn.product\"\n            multiDexEnabled true\n        }\n\n    }\n\n\n    sourceSets {\n        main {\n            if (isProductModule.toBoolean()) {\n                manifest.srcFile 'src/main/module/AndroidManifest.xml'\n            } else {\n                manifest.srcFile 'src/main/AndroidManifest.xml'\n                //集成开发模式下排除debug文件夹中的所有Java文件\n                java {\n                    exclude 'debug/**'\n                }\n            }\n        }\n    }\n\n    buildFeatures.dataBinding = true\n}\n\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    implementation project(':lightlearn_module_base')\n    implementation project(path: ':ks_component_ui')\n\n    //Arouter\n    kapt Router.arouter_compiler\n    //magic_indicator\n    implementation(Ks_lib.lib_magic_indicator) { changing = true }\n    implementation(Ks_lib.lib_address_selector) { changing = true }\n    implementation(Ks_component.component_share) { changing = true }\n\n    if (isProductModule.toBoolean() && !isLoginModule.toBoolean()) {\n        implementation project(':lightlearn_module_login')\n    }\n\n    if (isProductModule.toBoolean() && !isPayModule.toBoolean()) {\n        implementation project(':lightlearn_module_payment')\n    }\n\n\n    implementation Deps.photodraweeview\n    implementation 'com.yanzhenjie.recyclerview:x:1.3.2'\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593258822},"updatedAt":{"$$date":1598593629047},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ghv4Rb0pjx9dynCE"}
{"name":"kotlin-属性与字段：Getters、Setters、const、lateinit - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/properties.html\n属性与字段：Getters、Setters、const、lateinit - Kotlin 语言中文站\n12-15 minutes\n改进翻译\nKotlin 类中的属性既可以用关键字 var 声明为可变的，也可以用关键字 val 声明为只读的。\n\n要使用一个属性，只要用名称引用它即可：\n\nfun copyAddress(address: Address): Address {\n    val result = Address() // Kotlin 中没有“new”关键字\n    result.name = address.name // 将调用访问器\n    result.street = address.street\n    // ……\n    return result\n}\n声明一个属性的完整语法是\n\nvar <propertyName>[: <PropertyType>] [= <property_initializer>]\n    [<getter>]\n    [<setter>]\n其初始器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始器 （或者从其 getter 返回值，如下文所示）中推断出来，也可以省略。\n\n例如:\n\nvar allByDefault: Int? // 错误：需要显式初始化器，隐含默认 getter 和 setter\nvar initialized = 1 // 类型 Int、默认 getter 和 setter\n一个只读属性的语法和一个可变的属性的语法有两方面的不同：1、只读属性的用 val开始代替var 2、只读属性不允许 setter\n\nval simple: Int? // 类型 Int、默认 getter、必须在构造函数中初始化\nval inferredType = 1 // 类型 Int 、默认 getter\n我们可以为属性定义自定义的访问器。如果我们定义了一个自定义的 getter，那么每次访问该属性时都会调用它 （这让我们可以实现计算出的属性）。以下是一个自定义 getter 的示例：\n\nval isEmpty: Boolean\n    get() = this.size == 0\n如果我们定义了一个自定义的 setter，那么每次给属性赋值时都会调用它。一个自定义的 setter 如下所示：\n\nvar stringRepresentation: String\n    get() = this.toString()\n    set(value) {\n        setDataFromString(value) // 解析字符串并赋值给其他属性\n    }\n按照惯例，setter 参数的名称是 value，但是如果你喜欢你可以选择一个不同的名称。\n\n自 Kotlin 1.1 起，如果可以从 getter 推断出属性类型，则可以省略它：\n\nval isEmpty get() = this.size == 0  // 具有类型 Boolean\n如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现， 你可以定义访问器而不定义其实现:\n\nvar setterVisibility: String = \"abc\"\n    private set // 此 setter 是私有的并且有默认实现\n\nvar setterWithAnnotation: Any? = null\n    @Inject set // 用 Inject 注解此 setter\n在 Kotlin 类中不能直接声明字段。然而，当一个属性需要一个幕后字段时，Kotlin 会自动提供。这个幕后字段可以使用field标识符在访问器中引用：\n\nvar counter = 0 // 注意：这个初始器直接为幕后字段赋值\n    set(value) {\n        if (value >= 0) field = value\n    }\nfield 标识符只能用在属性的访问器内。\n\n如果属性至少一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段，将会为该属性生成一个幕后字段。\n\n例如，下面的情况下， 就没有幕后字段：\n\nval isEmpty: Boolean\n    get() = this.size == 0\n如果你的需求不符合这套“隐式的幕后字段”方案，那么总可以使用 幕后属性（backing property）：\n\nprivate var _table: Map<String, Int>? = null\npublic val table: Map<String, Int>\n    get() {\n        if (_table == null) {\n            _table = HashMap() // 类型参数已推断出\n        }\n        return _table ?: throw AssertionError(\"Set to null by another thread\")\n    }\n对于 JVM 平台：通过默认 getter 和 setter 访问私有属性会被优化， 所以本例不会引入函数调用开销。\n\n如果只读属性的值在编译期是已知的，那么可以使用 const 修饰符将其标记为编译期常量。 这种属性需要满足以下要求：\n\n位于顶层或者是 object 声明 或 companion object 的一个成员\n以 String 或原生类型值初始化\n没有自定义 getter\n这些属性可以用在注解中：\n\nconst val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"\n\n@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { …… }\n一般地，属性声明为非空类型必须在构造函数中初始化。 然而，这经常不方便。例如：属性可以通过依赖注入来初始化， 或者在单元测试的 setup 方法中初始化。 这种情况下，你不能在构造函数内提供一个非空初始器。 但你仍然想在类体中引用该属性时避免空检测。\n\n为处理这种情况，你可以用 lateinit 修饰符标记该属性：\n\npublic class MyTest {\n    lateinit var subject: TestSubject\n\n    @SetUp fun setup() {\n        subject = TestSubject()\n    }\n\n    @Test fun test() {\n        subject.method()  // 直接解引用\n    }\n}\n该修饰符只能用于在类体中的属性（不是在主构造函数中声明的 var 属性，并且仅当该属性没有自定义 getter 或 setter 时），而自 Kotlin 1.2 起，也用于顶层属性与局部变量。该属性或变量必须为非空类型，并且不能是原生类型。\n\n在初始化前访问一个 lateinit 属性会抛出一个特定异常，该异常明确标识该属性被访问及它没有初始化的事实。\n\n要检测一个 lateinit var 是否已经初始化过，请在该属性的引用上使用 .isInitialized：\n\nif (foo::bar.isInitialized) {\n    println(foo.bar)\n}\n此检测仅对可词法级访问的属性可用，即声明位于同一个类型内、位于其中一个外围类型中或者位于相同文件的顶层的属性。\n\n参见覆盖属性\n\n最常见的一类属性就是简单地从幕后字段中读取（以及可能的写入）。 另一方面，使用自定义 getter 和 setter 可以实现属性的任何行为。 介于两者之间，属性如何工作有一些常见的模式。一些例子：惰性值、 通过键值从映射读取、访问数据库、访问时通知侦听器等等。\n\n这些常见行为可以通过使用委托属性实现为库。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306186755},"updatedAt":{"$$date":1597307802069},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"glRD0BT7IDjNjByo"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973272211},"updatedAt":{"$$date":1594973272211},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"gyT7qTv1AKKFmgmm"}
{"name":"ad-easyrecyclerview","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    // 鲁班图片压缩\n    implementation 'top.zibin:Luban:1.1.8'\n}\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598525723677},"updatedAt":{"$$date":1598537849366},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"gzrVRQ695bOk4NNX"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980156160},"updatedAt":{"$$date":1594980156160},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"h01xFxflOBwzjOSd"}
{"name":"qk-ks_lib_xtablayout","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            consumerProguardFiles 'consumer-rules.pro'\n        }\n    }\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.support.app_compat\n    implementation deps.support.design, {\n        exclude group: \"com.android.support\", module: \"multidex\"\n    }\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580896694},"updatedAt":{"$$date":1598581197709},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"h0ZDWqEwSLqMfHGJ"}
{"name":"jquery-jQuery 安装","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n网页中添加 jQuery\n可以通过多种方法在网页中添加 jQuery。 您可以使用以下方法：\n\n从 jquery.com 下载 jQuery 库\n从 CDN 中载入 jQuery, 如从 Google 中加载 jQuery\n下载 jQuery\n有两个版本的 jQuery 可供下载：\n\nProduction version - 用于实际的网站中，已被精简和压缩。\nDevelopment version - 用于测试和开发（未压缩，是可读的代码）\n以上两个版本都可以从 jquery.com 中下载。\n\njQuery 库是一个 JavaScript 文件，您可以使用 HTML 的 <script> 标签引用它：\n\n<head>\n<script src=\"jquery-1.10.2.min.js\"></script>\n</head>\n提示： 将下载的文件放在网页的同一目录下，就可以使用jQuery。\n\nlamp\t您是否很疑惑为什么我们没有在 <script> 标签中使用 type=\"text/javascript\" ？\n\n在 HTML5 中，不必那样做了。JavaScript 是 HTML5 以及所有现代浏览器中的默认脚本语言！\n\n替代方案\n如果您不希望下载并存放 jQuery，那么也可以通过 CDN（内容分发网络） 引用它。\n\nStaticfile CDN、百度、又拍云、新浪、谷歌和微软的服务器都存有 jQuery 。\n\n如果你的站点用户是国内的，建议使用百度、又拍云、新浪等国内CDN地址，如果你站点用户是国外的可以使用谷歌和微软。\n\n注：本站实例均采用菜鸟教程 CDN 库。\n\n如需从 Staticfile CDN、又拍云、新浪、谷歌或微软引用 jQuery，请使用以下代码之一：\n\nStaticfile CDN:\n<head>\n<script src=\"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\">\n</script>\n</head>\n\n尝试一下 »\n\n百度 CDN:\n<head>\n<script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\">\n</script>\n</head>\n\n尝试一下 »\n\n又拍云 CDN:\n<head>\n<script src=\"https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js\">\n</script>\n</head>\n\n尝试一下 »\n\n新浪 CDN:\n<head>\n<script src=\"https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js\">\n</script>\n</head>\n\n尝试一下 »\n\nGoogle CDN:\n<head>\n<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\">\n</script>\n</head>\n\n尝试一下 »\n\nlamp\t不大推荐使用Google CDN来获取版本，因为Google产品在中国很不稳定。\n\nMicrosoft CDN:\n<head>\n<script src=\"https://ajax.aspnetcdn.com/ajax/jquery/jquery-1.9.0.min.js\"></script>\n</head>\n\n尝试一下 »\n\nlamp\t使用 Staticfile CDN、百度、又拍云、新浪、谷歌或微软的 jQuery，有一个很大的优势：\n\n许多用户在访问其他站点时，已经从百度、又拍云、新浪、谷歌或微软加载过 jQuery。所以结果是，当他们访问您的站点时，会从缓存中加载 jQuery，这样可以减少加载时间。同时，大多数 CDN 都可以确保当用户向其请求文件时，会从离用户最近的服务器上返回响应，这样也可以提高加载速度。\njQuery 使用版本\n我们可以在浏览器的 Console 窗口中使用 $.fn.jquery 命令查看当前 jQuery 使用的版本：\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975858195},"updatedAt":{"$$date":1598975929944},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"hImnR2US0V1zBHru"}
{"name":"css-CSS 列表","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 列表\nCSS列表属性作用如下：\n\n设置不同的列表项标记为有序列表\n设置不同的列表项标记为无序列表\n设置列表项标记为图像\n\n列表\n在HTML中，有两种类型的列表：\n\n无序列表 - 列表项标记用特殊图形（如小黑点、小方框等）\n有序列表 - 列表项的标记有数字或字母\n使用CSS，可以列出进一步的样式，并可用图像作列表项标记。\n\n不同的列表项标记\nlist-style-type属性指定列表项标记的类型是：\n\n实例\nul.a {list-style-type: circle;}\nul.b {list-style-type: square;}\n \nol.c {list-style-type: upper-roman;}\nol.d {list-style-type: lower-alpha;}\n\n尝试一下 »\n一些值是无序列表，以及有些是有序列表。\n\n作为列表项标记的图像\n要指定列表项标记的图像，使用列表样式图像属性：\n\n实例\nul\n{\n    list-style-image: url('sqpurple.gif');\n}\n\n尝试一下 »\n上面的例子在所有浏览器中显示并不相同，IE和Opera显示图像标记比火狐，Chrome和Safari更高一点点。\n\n如果你想在所有的浏览器放置同样的形象标志，就应使用浏览器兼容性解决方案，过程如下\n\n浏览器兼容性解决方案\n同样在所有的浏览器，下面的例子会显示的图像标记：\n\n实例\nul\n{\n    list-style-type: none;\n    padding: 0px;\n    margin: 0px;\n}\nul li\n{\n    background-image: url(sqpurple.gif);\n    background-repeat: no-repeat;\n    background-position: 0px 5px; \n    padding-left: 14px; \n}\n\n尝试一下 »\n例子解释：\n\nul:\n设置列表类型为没有列表项标记\n设置填充和边距0px（浏览器兼容性）\nul中所有li:\n设置图像的URL，并设置它只显示一次（无重复）\n您需要的定位图像位置（左0px和上下5px）\n用padding-left属性把文本置于列表中\n列表 -简写属性\n在单个属性中可以指定所有的列表属性。这就是所谓的简写属性。\n\n为列表使用简写属性，列表样式属性设置如下：\n\n实例\nul\n{\n    list-style: square url(\"sqpurple.gif\");\n}\n\n尝试一下 »\n可以按顺序设置如下属性：\n\nlist-style-type\nlist-style-position (有关说明，请参见下面的CSS属性表)\nlist-style-image\n如果上述值丢失一个，其余仍在指定的顺序，就没关系。\n\nExamples\n更多实例\n所有不同的列表项标记\n这个例子演示了所有不同的CSS列表项标记。\n\n所有的CSS列表属性\n属性\t描述\nlist-style\t简写属性。用于把所有用于列表的属性设置于一个声明中\nlist-style-image\t将图像设置为列表项标志。\nlist-style-position\t设置列表中列表项标志的位置。\nlist-style-type\t设置列表项标志的类型。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888549658},"updatedAt":{"$$date":1598888878906},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"hR4xAFicOqA6AT8h"}
{"name":"list","folderId":"IIjkbB6Kw","content":[{"label":"Fragment 1","value":"import 'dart:core';\n\nvoid main() {\n  var list = [\"黄药师\", \"郭靖\", \"小龙女\"];\n\n  void printElement(element) {\n    print(element);\n  }\n  list.forEach(printElement); \n}"},{"label":"Fragment 2","language":null,"value":null}],"tags":["e9Ui6C8xPeORK6VD"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594709021096},"updatedAt":{"$$date":1594709290835},"_id":"hRs5arDmrjxbidwH","tagsPopulated":[{"name":"dart","_id":"e9Ui6C8xPeORK6VD","text":"dart"}],"folder":{"id":"IIjkbB6Kw","name":"dart","open":false,"defaultLanguage":"text"}}
{"name":"css-CSS 尺寸 (Dimension)","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 尺寸 (Dimension)\nCSS 尺寸 (Dimension) 属性允许你控制元素的高度和宽度。同样，它允许你增加行间距。\n\nExamples\n更多实例\n设置元素的高度\n\n这个例子演示了如何设置不同元素的高度。\n\n使用百分比设置图像的高度\n\n这个例子演示了如何使用百分比值设置元素的高度。\n\n使用像素值来设置元素的宽度\n\n本例演示如何使用像素值来设置元素的宽度。\n\n设置元素的最大高度\n\n此示例演示如何设置元素的最大高度。\n\n使用百分比来设置元素的最大宽度\n\n本例演示如何使用百分比值来设置元素的最大宽度。\n\n设置元素的最低高度\n\n此示例演示如何设置元素的最小高度。\n\n使用像素值设置元素的最小宽度\n\n这个例子演示了如何使用像素值设置元素的最小宽度。\n\n所有CSS 尺寸 (Dimension)属性\n属性\t描述\nheight\t设置元素的高度。\nline-height\t设置行高。\nmax-height\t设置元素的最大高度。\nmax-width\t设置元素的最大宽度。\nmin-height\t设置元素的最小高度。\nmin-width\t设置元素的最小宽度。\nwidth\t设置元素的宽度。\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888559458},"updatedAt":{"$$date":1598973564331},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"hVF3USvjFm2ks29A"}
{"name":"kotlin-返回与跳转：break 与 continue - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/returns.html\n返回与跳转：break 与 continue - Kotlin 语言中文站\n9-11 minutes\n改进翻译\nKotlin 有三种结构化跳转表达式：\n\nreturn。默认从最直接包围它的函数或者匿名函数返回。\nbreak。终止最直接包围它的循环。\ncontinue。继续下一次最直接包围它的循环。\n所有这些表达式都可以用作更大表达式的一部分：\n\nval s = person.name ?: return\n这些表达式的类型是 Nothing 类型。\n\n在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签（参见语法）。 要为一个表达式加标签，我们只要在其前加标签即可。\n\nloop@ for (i in 1..100) {\n    // ……\n}\n现在，我们可以用标签限制 break 或者continue：\n\nloop@ for (i in 1..100) {\n    for (j in 1..100) {\n        if (……) break@loop\n    }\n}\n标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。\n\nKotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：\n\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return // 非局部直接返回到 foo() 的调用者\n        print(it)\n    }\n    println(\"this point is unreachable\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。\n\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach lit@{\n        if (it == 3) return@lit // 局部返回到该 lambda 表达式的调用者，即 forEach 循环\n        print(it)\n    }\n    print(\" done with explicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。\n\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return@forEach // 局部返回到该 lambda 表达式的调用者，即 forEach 循环\n        print(it)\n    }\n    print(\" done with implicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回\n\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {\n        if (value == 3) return  // 局部返回到匿名函数的调用者，即 forEach 循环\n        print(value)\n    })\n    print(\" done with anonymous function\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n请注意，前文三个示例中使用的局部返回类似于在常规循环中使用 continue。并没有 break 的直接等价形式，不过可以通过增加另一层嵌套 lambda 表达式并从其中非局部返回来模拟：\n\n//sampleStart\nfun foo() {\n    run loop@{\n        listOf(1, 2, 3, 4, 5).forEach {\n            if (it == 3) return@loop // 从传入 run 的 lambda 表达式非局部返回\n            print(it)\n        }\n    }\n    print(\" done with nested loop\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n当要返一个回值的时候，解析器优先选用标签限制的 return，即\n\n意为“返回 1 到 @a”，而不是“返回一个标签标注的表达式 (@a 1)”。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306184602},"updatedAt":{"$$date":1597307740987},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"haS6Y1o1pKgqFtic"}
{"name":"kotlin-Kotlin 扩展 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-extensions.html\nKotlin 扩展 | 菜鸟教程\n4-5 minutes\nKotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。\n\n扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。\n\n扩展函数\n扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：\n\nfun receiverType.functionName(params){\n    body\n}\nreceiverType：表示函数的接收者，也就是函数扩展的对象\nfunctionName：扩展函数的名称\nparams：扩展函数的参数，可以为NULL\n以下实例扩展 User 类 ：\n\nclass User(var name:String)\n\n/**扩展函数**/\nfun User.Print(){\n    print(\"用户名 $name\")\n}\n\nfun main(arg:Array<String>){\n    var user = User(\"Runoob\")\n    user.Print()\n}\n实例执行输出结果为：\n\n用户名 Runoob\n下面代码为 MutableList 添加一个swap 函数：\n\n// 扩展函数 swap,调换不同位置的值\nfun MutableList<Int>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1]     //  this 对应该列表\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n\nfun main(args: Array<String>) {\n\n    val l = mutableListOf(1, 2, 3)\n    // 位置 0 和 2 的值做了互换\n    l.swap(0, 2) // 'swap()' 函数内的 'this' 将指向 'l' 的值\n\n    println(l.toString())\n}\n实例执行输出结果为：\n\n[3, 2, 1]\nthis关键字指代接收者对象(receiver object)(也就是调用扩展函数时, 在点号之前指定的对象实例)。\n\n扩展函数是静态解析的\n扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的:\n\nopen class C\n\nclass D: C()\n\nfun C.foo() = \"c\"   // 扩展函数 foo\n\nfun D.foo() = \"d\"   // 扩展函数 foo\n\nfun printFoo(c: C) {\n    println(c.foo())  // 类型是 C 类\n}\n\nfun main(arg:Array<String>){\n    printFoo(D())\n}\n实例执行输出结果为：\n\nc\n若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。\n\nclass C {\n    fun foo() { println(\"成员函数\") }\n}\n\nfun C.foo() { println(\"扩展函数\") }\n\nfun main(arg:Array<String>){\n    var c = C()\n    c.foo()\n}\n实例执行输出结果为：\n\n成员函数\n扩展一个空对象\n在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如:\n\nfun Any?.toString(): String {\n    if (this == null) return \"null\"\n    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()\n    // 解析为 Any 类的成员函数\n    return toString()\n}\nfun main(arg:Array<String>){\n    var t = null\n    println(t.toString())\n}\n实例执行输出结果为：\n\nnull\n扩展属性\n\n除了函数，Kotlin 也支持属性对属性进行扩展:\n\nval <T> List<T>.lastIndex: Int\n    get() = size - 1\n \n扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。\n\nval Foo.bar = 1 // 错误：扩展属性不能有初始化器\n扩展属性只能被声明为 val。\n\n伴生对象的扩展\n如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。\n\n伴生对象通过\"类名.\"形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用：\n\nclass MyClass {\n    companion object { }  // 将被称为 \"Companion\"\n}\n\nfun MyClass.Companion.foo() {\n    println(\"伴随对象的扩展函数\")\n}\n\nval MyClass.Companion.no: Int\n    get() = 10\n\nfun main(args: Array<String>) {\n    println(\"no:${MyClass.no}\")\n    MyClass.foo()\n}\n实例执行输出结果为：\n\nno:10\n伴随对象的扩展函数\n扩展的作用域\n通常扩展函数或属性定义在顶级包下:\n\npackage foo.bar\n\nfun Baz.goo() { …… } \n要使用所定义包之外的一个扩展, 通过import导入扩展的函数名进行使用:\n\npackage com.example.usage\n\nimport foo.bar.goo // 导入所有名为 goo 的扩展\n                   // 或者\nimport foo.bar.*   // 从 foo.bar 导入一切\n\nfun usage(baz: Baz) {\n    baz.goo()\n}\n扩展声明为成员\n在一个类内部你可以为另一个类声明扩展。\n\n在这个扩展中，有个多个隐含的接受者，其中扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。\n\nclass D {\n    fun bar() { println(\"D bar\") }\n}\n\nclass C {\n    fun baz() { println(\"C baz\") }\n\n    fun D.foo() {\n        bar()   // 调用 D.bar\n        baz()   // 调用 C.baz\n    }\n\n    fun caller(d: D) {\n        d.foo()   // 调用扩展函数\n    }\n}\n\nfun main(args: Array<String>) {\n    val c: C = C()\n    val d: D = D()\n    c.caller(d)\n\n}\n实例执行输出结果为：\n\nD bar\nC baz\n在 C 类内，创建了 D 类的扩展。此时，C 被成为分发接受者，而 D 为扩展接受者。从上例中，可以清楚的看到，在扩展函数中，可以调用派发接收者的成员函数。\n\n假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法。\n\nclass D {\n    fun bar() { println(\"D bar\") }\n}\n\nclass C {\n    fun bar() { println(\"C bar\") }  // 与 D 类 的 bar 同名\n\n    fun D.foo() {\n        bar()         // 调用 D.bar()，扩展接收者优先\n        this@C.bar()  // 调用 C.bar()\n    }\n\n    fun caller(d: D) {\n        d.foo()   // 调用扩展函数\n    }\n}\n\nfun main(args: Array<String>) {\n    val c: C = C()\n    val d: D = D()\n    c.caller(d)\n\n}\n实例执行输出结果为：\n\nD bar\nC bar\n以成员的形式定义的扩展函数, 可以声明为 open , 而且可以在子类中覆盖. 也就是说, 在这类扩展函数的派 发过程中, 针对分发接受者是虚拟的(virtual), 但针对扩展接受者仍然是静态的。\n\nopen class D {\n}\n\nclass D1 : D() {\n}\n\nopen class C {\n    open fun D.foo() {\n        println(\"D.foo in C\")\n    }\n\n    open fun D1.foo() {\n        println(\"D1.foo in C\")\n    }\n\n    fun caller(d: D) {\n        d.foo()   // 调用扩展函数\n    }\n}\n\nclass C1 : C() {\n    override fun D.foo() {\n        println(\"D.foo in C1\")\n    }\n\n    override fun D1.foo() {\n        println(\"D1.foo in C1\")\n    }\n}\n\n\nfun main(args: Array<String>) {\n    C().caller(D())   // 输出 \"D.foo in C\"\n    C1().caller(D())  // 输出 \"D.foo in C1\" —— 分发接收者虚拟解析\n    C().caller(D1())  // 输出 \"D.foo in C\" —— 扩展接收者静态解析\n\n}\n实例执行输出结果为：\n\nD.foo in C\nD.foo in C1\nD.foo in C"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304144146},"updatedAt":{"$$date":1597304181918},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"hk5ucGUJbeahqFeX"}
{"name":"ad-android studio设置Http Proxy","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\nwww.jianshu.com /p/6ba60be77855\nandroid studio设置Http Proxy\n2-2 minutes\n\n\n22019.02.12 15:31:00字数 300阅读 73,253\n\nAndroid Studio在打开新项目或者是导入其他项目的时候，难免需要从Android官网下载一些东西，在这种情况下如果我们不对android studio进行一些配置，那很有可能会导致下载失败；配置的方式有两种，一种是通过配置Android国内镜像网站，这个可以参考Android Studio设置国内镜像网站，另外一种方式就是配置Android studio的Http Proxy，让Android studio能够访问Android官网，在这里介绍Android studio配置V2ray代理的步骤\n\n1.首先打开V2ray客户端，确保电脑可以访问Android官网\n\n\n2.打开Android Studio，通过File =》 Setting =》Appearance & Behavior =》System Setting =》 Http Proxy打开Http Proxy配置页面\n\n\n3.勾选Manual Proxy configuration，因为v2ray默认监听本地1081端口，并且是Http，所以这里选择Http单选框，\n\n\n\n\n\n\n\n\n\n\nHostname填入回环地址 127.0.0.1，Port number填入 1081\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.检测是否配置成功，点击下方的check connection，并输入https://www.android.com/，确认后可以看到能够访问Android官网\n\n\n\n\n\n\"小礼物走一走，来简书关注我\"\n\n还没有人赞赏，支持一下\n\n  \n\n总资产10 (约0.97元)共写了1.8W字获得141个赞共30个粉丝\n\n被以下专题收入，发现更多相似内容\n推荐阅读更多精彩内容\n目前的Android studio 版本为3.1.3 ,settings已备份到GitHub上,有需要的童鞋也可以...\n\n\n是不是很多同学已经有烦恼出现了？电脑配置已经很高了，但是每次运行Android程序的时候就很卡，而且每次安装运行程...\n\n鑫鱻阅读 1,224评论 8赞 32\n\n\nafinalAfinal是一个android的ioc，orm框架 https://github.com/yangf...\n\n0安装教程 按下面教程进行下载安装配置（Windows 10 64位） Android Studio 和 SDK ...\n\nkamin阅读 1,410评论 0赞 19\n\n\n原文地址：Android Studio 简单介绍和使用问题小结 Google在2013的I/O开发者大会上引入的该...\n\n如若成枫阅读 1,039评论 0赞 3\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241219081},"updatedAt":{"$$date":1598519905484},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"hvzY338QTHq5hxBA"}
{"name":"故事项目HTTP系统状态码统一","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"前言：由于目前项目中没有对于网络框架抛出的系统错误码做统一的提示，这样出现错误的时候就不便于分析，为了便于排查问题，在网络框架做了错误码统一出口，如果是系统错误码就直接使用，没有错误码的根据Exception自定义错误码。\n目标：统一处理除业务状态码以外的系统级的网络状态码，统一弹出\"和服务器失联了，宝贝再试试(CODE)\"文案。\n过程：1，区别处理业务、系统状态码。\n         2，项目中业务状态码都已在Retrofit的ConverterFactory中处理了。\n         3，基于现有的网络框架的中的ProxyHandler和ResponseTransformer和LocalException拿到所有的状态码，再分别统一处理。\n         4，LocalException中根据需求对ConnectException、UnknownHostException、SocketTimeoutException、HttpException几种Exception做了处理。\n         5，自测达到了预期目标。\n         6，附录是常用状态码和几个自定义状态码\n下面是自定义的异常码（由于没有对应的code所以根据异常自定义了码）\n2001 - 解析错误 - JsonParseException || JSONException|| ParseException\n2002 - 网络连接错误 - ConnectException\n2003 - 网络超时（Socket）- UnknownHostException || SocketTimeoutException\n下面是常见的HTTP状态码（HttpException）：\n200 - 请求成功\n301 - 资源（网页等）被永久转移到其它URL\n404 - 请求的资源（网页等）不存在\n500 - 内部服务器错误\nHTTP状态码分类\nHTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\nHTTP状态码分类\n分类  分类描述\n1** 信息，服务器收到请求，需要请求者继续执行操作\n2** 成功，操作被成功接收并处理\n3** 重定向，需要进一步的操作以完成请求\n4** 客户端错误，请求包含语法错误或无法完成请求\n5** 服务器错误，服务器在处理请求的过程中发生了错误\nHTTP状态码列表:\nHTTP状态码列表\n状态码 状态码英文名称 中文描述\n100 Continue    继续。客户端应继续其请求\n101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议\n200 OK  请求成功。一般用于GET与POST请求\n201 Created 已创建。成功请求并创建了新的资源\n202 Accepted    已接受。已经接受请求，但未处理完成\n203 Non-Authoritative Information   非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本\n204 No Content  无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n205 Reset Content   重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域\n206 Partial Content 部分内容。服务器成功处理了部分GET请求\n300 Multiple Choices    多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择\n301 Moved Permanently   永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\n302 Found   临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI\n303 See Other   查看其它地址。与301类似。使用GET和POST请求查看\n304 Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n305 Use Proxy   使用代理。所请求的资源必须通过代理访问\n306 Unused  已经被废弃的HTTP状态码\n307 Temporary Redirect  临时重定向。与302类似。使用GET请求重定向\n400 Bad Request 客户端请求的语法错误，服务器无法理解\n401 Unauthorized    请求要求用户的身份认证\n402 Payment Required    保留，将来使用\n403 Forbidden   服务器理解请求客户端的请求，但是拒绝执行此请求\n404 Not Found   服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面\n405 Method Not Allowed  客户端请求中的方法被禁止\n406 Not Acceptable  服务器无法根据客户端请求的内容特性完成请求\n407 Proxy Authentication Required   请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权\n408 Request Time-out    服务器等待客户端发送的请求时间过长，超时\n409 Conflict    服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突\n410 Gone    客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置\n411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息\n412 Precondition Failed 客户端请求信息的先决条件错误\n413 Request Entity Too Large    由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息\n414 Request-URI Too Large   请求的URI过长（URI通常为网址），服务器无法处理\n415 Unsupported Media Type  服务器无法处理请求附带的媒体格式\n416 Requested range not satisfiable 客户端请求的范围无效\n417 Expectation Failed  服务器无法满足Expect的请求头信息\n500 Internal Server Error   服务器内部错误，无法完成请求\n501 Not Implemented 服务器不支持请求的功能，无法完成请求\n502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应\n503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中\n504 Gateway Time-out    充当网关或代理的服务器，未及时从远端服务器获取请求\n505 HTTP Version not supported  服务器不支持请求的HTTP协议的版本，无法完成处理"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598547355745},"updatedAt":{"$$date":1598547404263},"_id":"i4KwjIXq7ZRiaE5G","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"qk-ks_lib_appmerge","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 100\n        versionName \"100\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n}\n\n////这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\nAppSpec\nModuleSpec\nutil\nBinaryKeyMap\nCmCore\n\n\n\n\n\n\n/**\n ***************************************\n * 项目名称: KsLightLearn\n * @Author yangjilai\n * 邮箱：yangjilai@ksjgs.com\n * 创建时间: 2020-02-22     00:48\n * 用途: 主 Application 合并处理的注解\n ***************************************\n */\n@Retention(RetentionPolicy.CLASS)\npublic @interface AppSpec {\n}\n\n\n\n\n\n/**\n * **************************************\n * 项目名称: KsLightLearn\n *\n * @Author yangjilai\n * 邮箱：yangjilai@ksjgs.com\n * 创建时间: 2020-02-22     00:30\n * 用途: ModuleApplication 合并处理的注解\n * **************************************\n */\n@Retention(RetentionPolicy.CLASS)\npublic @interface ModuleSpec {\n    int priority() default 1000;\n}\n\n\n\n\n\n\n\n\npublic class CmCore {\n\n    private List<Application> moduleApplications = new ArrayList<>();\n\n    private BinaryKeyMap<Class, String, Class> routersMap = new BinaryKeyMap<>();\n\n    private SoftReference<BinaryKeyMap<Class, String, Object>> softRouterInstanceMap = new SoftReference<>(new BinaryKeyMap<>());\n\n    public static final String DEFAULT_NAME = \"__cm_core_default\";\n\n    private CmCore() {\n    }\n\n    public void attachBaseContext(Context context) {\n        for (Application app : moduleApplications) {\n            try {\n                // invoke each application's attachBaseContext\n                Method attachBaseContext = ContextWrapper.class.getDeclaredMethod(\"attachBaseContext\", Context.class);\n                attachBaseContext.setAccessible(true);\n                attachBaseContext.invoke(app, context);\n            } catch (NoSuchMethodException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            } catch (InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void onCreate() {\n        for (Application app : moduleApplications) {\n            app.onCreate();\n        }\n    }\n\n    public void onConfigurationChanged(Configuration configuration) {\n        for (Application app : moduleApplications) {\n            app.onConfigurationChanged(configuration);\n        }\n    }\n\n    public void onLowMemory() {\n        for (Application app : moduleApplications) {\n            app.onLowMemory();\n        }\n    }\n\n    public void onTerminate() {\n        for (Application app : moduleApplications) {\n            app.onTerminate();\n        }\n\n    }\n\n    public void onTrimMemory(int level) {\n        for (Application app : moduleApplications) {\n            app.onTrimMemory(level);\n        }\n    }\n\n    public static synchronized <T> T service(Class<T> routerType) {\n        return service(routerType, DEFAULT_NAME);\n    }\n\n    public static synchronized <T> T service(Class<T> routerType, String name) {\n        T requiredRouter = (T) get().getRouterInstanceMap().get(routerType, name);\n        if (requiredRouter == null) {\n            try {\n                requiredRouter = (T) get().routersMap.get(routerType, name).newInstance();\n                get().getRouterInstanceMap().put(routerType, name, requiredRouter);\n            } catch (Throwable throwable) {\n                throwable.printStackTrace();\n            }\n        }\n        return requiredRouter;\n    }\n\n    public List<Application> moduleApplications() {\n        return moduleApplications;\n    }\n\n    public BinaryKeyMap<Class, String, Object> getRouterInstanceMap() {\n        if (softRouterInstanceMap.get() == null) {\n            softRouterInstanceMap = new SoftReference<>(new BinaryKeyMap<>());\n        }\n        return softRouterInstanceMap.get();\n    }\n\n    public BinaryKeyMap<Class, String, Class> routersMap() {\n        return routersMap;\n    }\n\n    public static CmCore get() {\n        return SingletonHolder.INSTANCE;\n    }\n\n    static class SingletonHolder {\n        static CmCore INSTANCE = new CmCore();\n    }\n}\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598584067747},"updatedAt":{"$$date":1598584731576},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"iEFVRcARB5pUUMAa"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975688929},"updatedAt":{"$$date":1598975688929},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"iI3sICDuCJVoG4IP"}
{"name":"css-CSS 链接","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 链接\n不同的链接可以有不同的样式。\n\n链接样式\n链接的样式，可以用任何CSS属性（如颜色，字体，背景等）。\n\n特别的链接，可以有不同的样式，这取决于他们是什么状态。\n\n这四个链接状态是：\n\na:link - 正常，未访问过的链接\na:visited - 用户已访问过的链接\na:hover - 当用户鼠标放在链接上时\na:active - 链接被点击的那一刻\n实例\na:link {color:#000000;}      /* 未访问链接*/\na:visited {color:#00FF00;}  /* 已访问链接 */\na:hover {color:#FF00FF;}  /* 鼠标移动到链接上 */\na:active {color:#0000FF;}  /* 鼠标点击时 */\n\n尝试一下 »\n当设置为若干链路状态的样式，也有一些顺序规则：\n\na:hover 必须跟在 a:link 和 a:visited后面\na:active 必须跟在 a:hover后面\n常见的链接样式\n根据上述链接的颜色变化的例子，看它是在什么状态。\n\n让我们通过一些其他常见的方式转到链接样式：\n\n文本修饰\ntext-decoration 属性主要用于删除链接中的下划线：\n\n实例\na:link {text-decoration:none;}\na:visited {text-decoration:none;}\na:hover {text-decoration:underline;}\na:active {text-decoration:underline;}\n\n尝试一下 »\n背景颜色\n背景颜色属性指定链接背景色：\n\n实例\na:link {background-color:#B2FF99;}\na:visited {background-color:#FFFF85;}\na:hover {background-color:#FF704D;}\na:active {background-color:#FF704D;}\n\n尝试一下 »\n\nExamples\n更多实例\n添加不同样式的超链接\n这个例子演示了如何为超链接添加其他样式。\n\n高级 - 创建链接框\n这个例子演示了一个更高级的例子，我们结合若干CSS属性显示为方框。\n\n CSS Fonts(字体)"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888548451},"updatedAt":{"$$date":1598888857643},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"iTQXUWzkPoqcQdMV"}
{"name":"kotlin-List 相关操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/list-operations.html\nList 相关操作 - Kotlin 语言中文站\n19-23 minutes\n改进翻译\nList 是 Kotlin 标准库中最受欢迎的集合类型。对列表元素的索引访问为 List 提供了一组强大的操作。\n\nList 支持按索引取元素的所有常用操作： elementAt() 、 first() 、 last() 与取单个元素中列出的其他操作。 List 的特点是能通过索引访问特定元素，因此读取元素的最简单方法是按索引检索它。 这是通过 get() 函数或简写语法 [index] 来传递索引参数完成的。\n\n如果 List 长度小于指定的索引，则抛出异常。 另外，还有两个函数能避免此类异常：\n\ngetOrElse() 提供用于计算默认值的函数，如果集合中不存在索引，则返回默认值。\ngetOrNull() 返回 null 作为默认值。\nTarget platform: JVMRunning on kotlin v. 1.3.72\n\n除了取集合的一部分中常用的操作， List 还提供 subList() 该函数将指定元素范围的视图作为列表返回。 因此，如果原始集合的元素发生变化，则它在先前创建的子列表中也会发生变化，反之亦然。\n\nfun main() {\n//sampleStart\n    val numbers = (0..13).toList()\n    println(numbers.subList(3, 6))\n//sampleEnd\n}\n\n在任何列表中，都可以使用 indexOf() 或 lastIndexOf() 函数找到元素的位置。 它们返回与列表中给定参数相等的元素的第一个或最后一个位置。 如果没有这样的元素，则两个函数均返回 -1。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3, 4, 2, 5)\n    println(numbers.indexOf(2))\n    println(numbers.lastIndexOf(2))\n//sampleEnd\n}\n\n还有一对函数接受谓词并搜索与之匹配的元素：\n\nindexOfFirst() 返回与谓词匹配的第一个元素的索引，如果没有此类元素，则返回 -1。\nindexOfLast() 返回与谓词匹配的最后一个元素的索引，如果没有此类元素，则返回 -1。\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    println(numbers.indexOfFirst { it > 2})\n    println(numbers.indexOfLast { it % 2 == 1})\n//sampleEnd\n}\n\n还有另一种搜索列表中元素的方法——二分查找算法。 它的工作速度明显快于其他内置搜索功能，但要求该列表按照一定的顺序（自然排序或函数参数中提供的另一种排序）按升序排序过。 否则，结果是不确定的。\n\n要搜索已排序列表中的元素，请调用 binarySearch() 函数，并将该值作为参数传递。 如果存在这样的元素，则函数返回其索引；否则，将返回 (-insertionPoint - 1)，其中 insertionPoint 为应插入此元素的索引，以便列表保持排序。 如果有多个具有给定值的元素，搜索则可以返回其任何索引。\n\n还可以指定要搜索的索引区间：在这种情况下，该函数仅在两个提供的索引之间搜索。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    numbers.sort()\n    println(numbers)\n    println(numbers.binarySearch(\"two\"))  // 3\n    println(numbers.binarySearch(\"z\")) // -5\n    println(numbers.binarySearch(\"two\", 0, 2))  // -3\n//sampleEnd\n}\n\n如果列表元素不是 Comparable，则应提供一个用于二分搜索的 Comparator。 该列表必须根据此 Comparator 以升序排序。来看一个例子：\n\ndata class Product(val name: String, val price: Double)\n\nfun main() {\n//sampleStart\n    val productList = listOf(\n        Product(\"WebStorm\", 49.0),\n        Product(\"AppCode\", 99.0),\n        Product(\"DotTrace\", 129.0),\n        Product(\"ReSharper\", 149.0))\n\n    println(productList.binarySearch(Product(\"AppCode\", 99.0), compareBy<Product> { it.price }.thenBy { it.name }))\n//sampleEnd\n}\n\n这是一个不可排序的 Product 实例列表，以及一个定义排序的 Comparator：如果 p1 的价格小于 p2 的价格，则产品 p1 在产品 p2 之前。 因此，按照此顺序对列表进行升序排序后，使用 binarySearch() 查找指定的 Product的索引。\n\n当列表使用与自然排序不同的顺序时（例如，对 String 元素不区分大小写的顺序），自定义 Comparator 也很方便。\n\nfun main() {\n//sampleStart\n    val colors = listOf(\"Blue\", \"green\", \"ORANGE\", \"Red\", \"yellow\")\n    println(colors.binarySearch(\"RED\", String.CASE_INSENSITIVE_ORDER)) // 3\n//sampleEnd\n}\n\n使用 比较 函数的二分搜索无需提供明确的搜索值即可查找元素。 取而代之的是，它使用一个比较函数将元素映射到 Int 值，并搜索函数返回 0 的元素。 该列表必须根据提供的函数以升序排序；换句话说，比较的返回值必须从一个列表元素增长到下一个列表元素。\n\nimport kotlin.math.sign\n//sampleStart\ndata class Product(val name: String, val price: Double)\n\nfun priceComparison(product: Product, price: Double) = sign(product.price - price).toInt()\n\nfun main() {\n    val productList = listOf(\n        Product(\"WebStorm\", 49.0),\n        Product(\"AppCode\", 99.0),\n        Product(\"DotTrace\", 129.0),\n        Product(\"ReSharper\", 149.0))\n\n    println(productList.binarySearch { priceComparison(it, 99.0) })\n}\n//sampleEnd\nComparator 与比较函数二分搜索都可以针对列表区间执行。\n\n除了集合写操作中描述的集合修改操作之外，可变列表还支持特定的写操作。 这些操作使用索引来访问元素以扩展列表修改功能。\n\n要将元素添加到列表中的特定位置，请使用 add() 或 addAll() 并提供元素插入的位置作为附加参数。 位置之后的所有元素都将向右移动。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"five\", \"six\")\n    numbers.add(1, \"two\")\n    numbers.addAll(2, listOf(\"three\", \"four\"))\n    println(numbers)\n//sampleEnd\n}\n\n列表还提供了在指定位置替换元素的函数——set() 及其操作符形式 []。set() 不会更改其他元素的索引。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"five\", \"three\")\n    numbers[1] =  \"two\"\n    println(numbers)\n//sampleEnd\n}\n\nfill() 简单地将所有集合元素的值替换为指定值。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.fill(3)\n    println(numbers)\n//sampleEnd\n}\n\n要从列表中删除指定位置的元素，请使用 removeAt() 函数，并将位置作为参数。 在元素被删除之后出现的所有元素索引将减 1。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4, 3)    \n    numbers.removeAt(1)\n    println(numbers)\n//sampleEnd\n}\n\n在集合排序中，描述了按特定顺序检索集合元素的操作。 对于可变列表，标准库中提供了类似的扩展函数，这些扩展函数可以执行相同的排序操作。 将此类操作应用于列表实例时，它将更改指定实例中元素的顺序。\n\n就地排序函数的名称与应用于只读列表的函数的名称相似，但没有 ed/d 后缀：\n\nsort* 在所有排序函数的名称中代替 sorted*：sort()、sortDescending()、sortBy() 等等。\nshuffle() 代替 shuffled()。\nreverse() 代替 reversed()。\nasReversed() 在可变列表上调用会返回另一个可变列表，该列表是原始列表的反向视图。在该视图中的更改将反映在原始列表中。 以下示例展示了可变列表的排序函数：\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n\n    numbers.sort()\n    println(\"Sort into ascending: $numbers\")\n    numbers.sortDescending()\n    println(\"Sort into descending: $numbers\")\n\n    numbers.sortBy { it.length }\n    println(\"Sort into ascending by length: $numbers\")\n    numbers.sortByDescending { it.last() }\n    println(\"Sort into descending by the last letter: $numbers\")\n    \n    numbers.sortWith(compareBy<String> { it.length }.thenBy { it })\n    println(\"Sort by Comparator: $numbers\")\n\n    numbers.shuffle()\n    println(\"Shuffle: $numbers\")\n\n    numbers.reverse()\n    println(\"Reverse: $numbers\")\n//sampleEnd\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382137280},"updatedAt":{"$$date":1597386008841},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"igIKQKqIyydPXSfk"}
{"name":"py-循环","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n循环\n要计算1+2+3，我们可以直接写表达式：\n\n>>> 1 + 2 + 3\n6\n要计算1+2+3+...+10，勉强也能写出来。\n\n但是，要计算1+2+3+...+10000，直接写表达式就不可能了。\n\n为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。\n\nPython的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：\n\nnames = ['Michael', 'Bob', 'Tracy']\nfor name in names:\n    print(name)\n执行这段代码，会依次打印names的每一个元素：\n\nMichael\nBob\nTracy\n所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。\n\n再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：\n\nsum = 0\nfor x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:\n    sum = sum + x\nprint(sum)\n如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：\n\n>>> list(range(5))\n[0, 1, 2, 3, 4]\nrange(101)就可以生成0-100的整数序列，计算如下：\n\n# -*- coding: utf-8 -*-\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n\n Run\n请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。\n\n第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：\n\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。\n\n练习\n请利用循环依次对list中的每个名字打印出Hello, xxx!：\n\n# -*- coding: utf-8 -*-\nL = ['Bart', 'Lisa', 'Adam']\n\n Run\nbreak\n在循环中，break语句可以提前退出循环。例如，本来要循环打印1～100的数字：\n\nn = 1\nwhile n <= 100:\n    print(n)\n    n = n + 1\nprint('END')\n上面的代码可以打印出1~100。\n\n如果要提前结束循环，可以用break语句：\n\nn = 1\nwhile n <= 100:\n    if n > 10: # 当n = 11时，条件满足，执行break语句\n        break # break语句会结束当前循环\n    print(n)\n    n = n + 1\nprint('END')\n执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。\n\n可见break的作用是提前结束循环。\n\ncontinue\n在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。\n\nn = 0\nwhile n < 10:\n    n = n + 1\n    print(n)\n上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环：\n\nn = 0\nwhile n < 10:\n    n = n + 1\n    if n % 2 == 0: # 如果n是偶数，执行continue语句\n        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行\n    print(n)\n执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。\n\n可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。\n\n小结\n循环是让计算机做重复任务的有效的方法。\n\nbreak语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。\n\n要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。\n\n有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。\n\n请试写一个死循环程序。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973939120},"updatedAt":{"$$date":1594976980230},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ixtNFMchs9l62KRJ"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975872409},"updatedAt":{"$$date":1598975872409},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"j6xBe2LYUQB3rzai"}
{"name":"qk-ks_component_resource","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"values\nks_component_resource_colors.xml\nks_component_resource_strings.xml\nks_component_resource_styles.xml\n\n\n\n\n\n\n\n\n\n\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 100\n        versionName \"100\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n\n\n\n}\n\ndependencies {\n\n}\n\nrepositories {\n    mavenCentral()\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598585026479},"updatedAt":{"$$date":1598586029475},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"jKDJmmpCR3oaDZXA"}
{"name":"py- 参数小节","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\nPython的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。\n\n默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！\n\n要注意定义可变参数和关键字参数的语法：\n\n*args是可变参数，args接收的是一个tuple；\n\n**kw是关键字参数，kw接收的是一个dict。\n\n以及调用函数时如何传入可变参数和关键字参数的语法：\n\n可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；\n\n关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。\n\n使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。\n\n命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。\n\n定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977483536},"updatedAt":{"$$date":1594979596490},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"jKSFbCChvbtVp7oq"}
{"name":"kotlin-Kotlin 枚举类 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-enum-classes.html\nKotlin 枚举类 | 菜鸟教程\n2-2 minutes\n枚举类最基本的用法是实现一个类型安全的枚举。\n\n枚举常量用逗号分隔,每个枚举常量都是一个对象。\n\nenum class Color{\n    RED,BLACK,BLUE,GREEN,WHITE\n}\n枚举初始化\n每一个枚举都是枚举类的实例，它们可以被初始化：\n\nenum class Color(val rgb: Int) {\n    RED(0xFF0000),\n    GREEN(0x00FF00),\n    BLUE(0x0000FF)\n}\n默认名称为枚举字符名，值从0开始。若需要指定值，则可以使用其构造函数：\n\nenum class Shape(value:Int){\n    ovel(100),\n    rectangle(200)\n}\n枚举还支持以声明自己的匿名类及相应的方法、以及覆盖基类的方法。如：\n\nenum class ProtocolState {\n    WAITING {\n        override fun signal() = TALKING\n    },\n\n    TALKING {\n        override fun signal() = WAITING\n    };\n\n    abstract fun signal(): ProtocolState\n}\n如果枚举类定义任何成员，要使用分号将成员定义中的枚举常量定义分隔开\n\n使用枚举常量\nKotlin 中的枚举类具有合成方法，允许遍历定义的枚举常量，并通过其名称获取枚举常数。\n\nEnumClass.valueOf(value: String): EnumClass  // 转换指定 name 为枚举值，若未匹配成功，会抛出IllegalArgumentException\nEnumClass.values(): Array<EnumClass>        // 以数组的形式，返回枚举值\n获取枚举相关信息：\n\nval name: String //获取枚举名称\nval ordinal: Int //获取枚举值在所有枚举数组中定义的顺序\n实例\nenum class Color{\n    RED,BLACK,BLUE,GREEN,WHITE\n}\n\nfun main(args: Array<String>) {\n    var color:Color=Color.BLUE\n\n    println(Color.values())\n    println(Color.valueOf(\"RED\"))\n    println(color.name)\n    println(color.ordinal)\n\n}\n自 Kotlin 1.1 起，可以使用 enumValues<T>() 和 enumValueOf<T>() 函数以泛型的方式访问枚举类中的常量 ：\n\nenum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n\n\n\nfun main(args: Array<String>) {\n    printAllValues<RGB>() // 输出 RED, GREEN, BLUE\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304150593},"updatedAt":{"$$date":1597304737034},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"jv3VdBxZPFaukPg2"}
{"name":"py-条件判断","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n条件判断\n计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。\n\n比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：\n\nage = 20\nif age >= 18:\n    print('your age is', age)\n    print('adult')\n根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。\n\n也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了：\n\nage = 3\nif age >= 18:\n    print('your age is', age)\n    print('adult')\nelse:\n    print('your age is', age)\n    print('teenager')\n注意不要少写了冒号:。\n\n当然上面的判断是很粗略的，完全可以用elif做更细致的判断：\n\nage = 3\nif age >= 18:\n    print('adult')\nelif age >= 6:\n    print('teenager')\nelse:\n    print('kid')\nelif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：\n\nif <条件判断1>:\n    <执行1>\nelif <条件判断2>:\n    <执行2>\nelif <条件判断3>:\n    <执行3>\nelse:\n    <执行4>\nif语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager：\n\nage = 20\nif age >= 6:\n    print('teenager')\nelif age >= 18:\n    print('adult')\nelse:\n    print('kid')\nif判断条件还可以简写，比如写：\n\nif x:\n    print('True')\n只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。\n\n再议 input\n最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思：\n\nbirth = input('birth: ')\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n输入1982，结果报错：\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unorderable types: str() > int()\n这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：\n\ns = input('birth: ')\nbirth = int(s)\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: invalid literal for int() with base 10: 'abc'\n原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。\n\n如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973937583},"updatedAt":{"$$date":1594976922505},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"k5Ea2VJ4Exlcwtdx"}
{"name":"kotlin-聚合操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-aggregate.html\n聚合操作 - Kotlin 语言中文站\n10-13 minutes\n改进翻译\nKotlin 集合包含用于常用的 聚合操作 （基于集合内容返回单个值的操作）的函数 。 其中大多数是众所周知的，并且其工作方式与在其他语言中相同。\n\nmin() 与 max() 分别返回最小和最大的元素；\naverage() 返回数字集合中元素的平均值；\nsum() 返回数字集合中元素的总和；\ncount() 返回集合中元素的数量；\nfun main() {\n//sampleStart\n    val numbers = listOf(6, 42, 10, 4)\n\n    println(\"Count: ${numbers.count()}\")\n    println(\"Max: ${numbers.max()}\")\n    println(\"Min: ${numbers.min()}\")\n    println(\"Average: ${numbers.average()}\")\n    println(\"Sum: ${numbers.sum()}\")\n//sampleEnd\n}\n还有一些通过某些选择器函数或自定义 Comparator 来检索最小和最大元素的函数。\n\nmaxBy()/minBy() 接受一个选择器函数并返回使选择器返回最大或最小值的元素。\nmaxWith()/minWith() 接受一个 Comparator 对象并且根据此 Comparator 对象返回最大或最小元素。\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 42, 10, 4)\n    val min3Remainder = numbers.minBy { it % 3 }\n    println(min3Remainder)\n\n    val strings = listOf(\"one\", \"two\", \"three\", \"four\")\n    val longestString = strings.maxWith(compareBy { it.length })\n    println(longestString)\n//sampleEnd\n}\n此外，有一些高级的求和函数，它们接受一个函数并返回对所有元素调用此函数的返回值的总和：\n\nsumBy() 使用对集合元素调用返回 Int 值的函数。\nsumByDouble() 与返回 Double 的函数一起使用。\nfun main() {\n//sampleStart    \n    val numbers = listOf(5, 42, 10, 4)\n    println(numbers.sumBy { it * 2 })\n    println(numbers.sumByDouble { it.toDouble() / 2 })\n//sampleEnd\n}\n对于更特定的情况，有函数 reduce() 和 fold()，它们依次将所提供的操作应用于集合元素并返回累积的结果。 操作有两个参数：先前的累积值和集合元素。\n\n这两个函数的区别在于：fold() 接受一个初始值并将其用作第一步的累积值，而 reduce() 的第一步则将第一个和第二个元素作为第一步的操作参数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n\n    val sum = numbers.reduce { sum, element -> sum + element }\n    println(sum)\n    val sumDoubled = numbers.fold(0) { sum, element -> sum + element * 2 }\n    println(sumDoubled)\n\n    //val sumDoubledReduce = numbers.reduce { sum, element -> sum + element * 2 } //错误：第一个元素在结果中没有加倍\n    //println(sumDoubledReduce)\n//sampleEnd\n}\n上面的实例展示了区别：fold() 用于计算加倍的元素之和。 如果将相同的函数传给 reduce()，那么它会返回另一个结果，因为在第一步中它将列表的第一个和第二个元素作为参数，所以第一个元素不会被加倍。\n\n如需将函数以相反的顺序应用于元素，可以使用函数 reduceRight() 和 foldRight() 它们的工作方式类似于 fold() 和 reduce()，但从最后一个元素开始，然后再继续到前一个元素。 记住，在使用 foldRight 或 reduceRight 时，操作参数会更改其顺序：第一个参数变为元素，然后第二个参数变为累积值。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumDoubledRight = numbers.foldRight(0) { element, sum -> sum + element * 2 }\n    println(sumDoubledRight)\n//sampleEnd\n}\n你还可以使用将元素索引作为参数的操作。 为此，使用函数 reduceIndexed() 和 foldIndexed() 传递元素索引作为操作的第一个参数。\n\n最后，还有将这些操作从右到左应用于集合元素的函数——reduceRightIndexed() 与 foldRightIndexed()。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumEven = numbers.foldIndexed(0) { idx, sum, element -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEven)\n\n    val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEvenRight)\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382134949},"updatedAt":{"$$date":1597385236648},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"k66dLwS1vBH30YL1"}
{"name":"ad-buildSrc","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\nplugins {\n    `kotlin-dsl`\n}\nrepositories {\n    jcenter()\n}\n\n\n\n\n\n\n\n\n\n\n\n\nobject Versions {\n    val gradle_plugin = \"4.0.1\"\n    val kotlin_version = \"1.3.72\"\n    val retrofit = \"2.7.1\"\n    val okhttp3 = \"4.2.0\"\n    val multidex = \"2.0.0\"\n    val junit = \"4.12\"\n    val fresco = \"1.11.0\"\n    val kotlin_coroutines = \"1.3.7\"\n    val androidx = \"1.2.0-alpha03\"\n    val constraintlayout = \"2.0.0-beta7\"\n    val arouter_compiler = \"1.2.2\"\n    val arouter_api = \"1.5.0\"\n    val arouter_register = \"1.0.2\"\n    val support = \"28.0.0\"\n    val packer_np_plugin = \"2.0.1\"\n    val tingyun_plugin = \"2.14.2\"\n\n    val roomVersion = \"2.2.1\"\n    val archLifecycleVersion = \"2.3.0-alpha05\"\n    val coroutines = \"1.3.7\"\n    val koin_version = \"2.1.6\"\n    val cardview = \"1.0.0\"\n    val MagicIndicator = \"1.6.0\"\n    val lottie = \"3.4.0\"\n    val zip = \"0.0.1\"\n    val navigation = \"2.2.1\"\n    val photodraweeview = \"2.0.0\"\n    val gifdrawable = \"1.2.19\"\n    val AppStartFaster = \"1.0.1\"\n    val glide = \"4.11.0\"\n}\n\nval testInstrumentationRunner = \"android.support.test.runner.AndroidJUnitRunner\"\n\nobject BuildVersion {\n    const val compile_sdk = 28\n    const val min_sdk = 21\n    const val target_sdk = 28\n    const val tool_version = \"29.0.2\"\n\n    const val versionCode = 150\n    const val versionName = \"1.5.0\"\n}\n\nobject ProjectPlugin {\n    val gradle_plugin = \"com.android.tools.build:gradle:${Versions.gradle_plugin}\"\n    val kotlin_plugin = \"org.jetbrains.kotlin:kotlin-gradle-plugin:${Versions.kotlin_version}\"\n    //依赖注入\n    val hilt_plugin= \"com.google.dagger:hilt-android-gradle-plugin:2.28.3-alpha\"\n    val arouter_plugin = \"com.alibaba:arouter-register:${Versions.arouter_register}\"\n    val packer_np_plugin = \"com.mcxiaoke.packer-ng:plugin:${Versions.packer_np_plugin}\"\n}\n\nobject Deps {\n\n    //            lottie 动画\n    val lottie = \"com.airbnb.android:lottie:${Versions.lottie}\"\n    val zip = \"com.leo618:zip:${Versions.zip}\"\n\n    //多线程通讯\n    val eventbus = \"org.greenrobot:eventbus:3.1.1\"\n\n    //友盟统计\n    val analytics = \"com.umeng.umsdk:analytics:8.1.3\"\n\n    //多渠道打包\n    val packer_ng = \"com.mcxiaoke.packer-ng:helper:${Versions.packer_np_plugin}\"\n\n    // https=//github.com/CymChad/BaseRecyclerViewAdapterHelper\n    val ksladapter = \"com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.4\"\n\n    // https=//github.com/orhanobut/dialogplus\n    val dialogplus = \"com.orhanobut:dialogplus:1.11@aar\"\n\n    //阿里云oss上传和下载库\n    val oss_android_sdk = \"com.aliyun.dpa:oss-android-sdk:2.9.3\"\n\n    //图片剪裁库\n    val ucrop = \"com.yalantis:ucrop:2.2.0\"\n\n    //图片缩放库\n    val photodraweeview = \"me.relex:photodraweeview:${Versions.photodraweeview}\"\n    val andrpermission = \"com.yanzhenjie:permission:2.0.3\"\n    val gifdrawable = \"pl.droidsonroids.gif:android-gif-drawable:${Versions.gifdrawable}\"\n\n    val appStartFaster = \"com.github.NoEndToLF:AppStartFaster:${Versions.AppStartFaster}\"\n\n    val glide = \"com.github.bumptech.glide:glide:${Versions.glide}\"\n    val glide_compile = \"com.github.bumptech.glide:compiler:${Versions.glide}\"\n\n}\n\n\n//kotlin\nobject Kotlin {\n    val stdlib_jdk = \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:${Versions.kotlin_version}\"\n\n    val coroutines_core =\n            \"org.jetbrains.kotlinx:kotlinx-coroutines-core:${Versions.kotlin_coroutines}\"\n    val coroutines_android =\n            \"org.jetbrains.kotlinx:kotlinx-coroutines-android:${Versions.kotlin_coroutines}\"\n    val std_lib = \"org.jetbrains.kotlin:kotlin-stdlib:${Versions.kotlin_version}\"\n}\n\n\n/**\n * kotlin 依赖注入 库\n */\nobject Koin {\n\n    // Koin for Android\n    val android = \"org.koin:koin-android:${Versions.koin_version}\"\n\n    //// Koin Android Scope features\n    val android_scope = \"org.koin:koin-android-scope:${Versions.koin_version}\"\n\n    //// Koin Android ViewModel features\n    val android_viewmodel = \"org.koin:koin-android-viewmodel:${Versions.koin_version}\"\n}\n\n//androidx 系统库\nobject Androidx {\n    val appcompat = \"androidx.appcompat:appcompat:${Versions.androidx}\"\n    val recyclerview = \"androidx.recyclerview:recyclerview:${Versions.androidx}\"\n    val constraintlayout = \"androidx.constraintlayout:constraintlayout:${Versions.constraintlayout}\"\n    val core_ktx = \"androidx.core:core-ktx:${Versions.androidx}\"\n    val cardview = \"androidx.cardview:cardview:${Versions.cardview}\"\n    val multidex = \"androidx.multidex:multidex:${Versions.multidex}\"\n    val navigation = \"androidx.navigation:navigation-fragment:${Versions.navigation}\"\n}\n\n/**\n * lifecycle 相关库\n */\nobject ArchLifecycle {\n    val lifecycle_viewmodel = \"androidx.lifecycle:lifecycle-viewmodel:${Versions.archLifecycleVersion}\"\n\n    val lifecycle_viewmodel_ktx =\n            \"androidx.lifecycle:lifecycle-viewmodel-ktx:${Versions.archLifecycleVersion}\"\n    val lifecycle_livedata_ktx =\n            \"androidx.lifecycle:lifecycle-livedata-ktx:${Versions.archLifecycleVersion}\"\n    val lifecycle_compiler =\n            \"androidx.lifecycle:lifecycle-compiler:${Versions.archLifecycleVersion}\"\n    val lifecycle_extensions =\n            \"androidx.lifecycle:lifecycle-extensions:2.2.0\"\n\n    /**\n     * 2.3.0-alpha* 无法使用 暂时使用稳定版 2.2.0\n     */\n    val lifecycle_runtime_ktx=\"androidx.lifecycle:lifecycle-runtime-ktx:2.2.0\"\n}\n\n\n\n\n//kaishu jcenter库，暂时没用到\nobject Ks {\n    val ksui = \"com.ks.ksui:ksui:1.2.0\"\n    val ksutils = \"com.ks.ksutils:ksutils:1.2.2\"\n    val kscityselector = \"com.ks.kscityselector:kscityselector:1.1.1\"\n    val kszxing = \"com.ks.kszxing:kszxing:1.0.1\"\n    val kstoast = \"com.ks.kstoast:kstoast:1.0.0\"\n    val kprogresshud = \"com.ks.kprogresshud:kprogresshud:1.0.0\"\n    val kswebview = \"com.ks.kswebview:kswebview:0.0.4\"\n}\n\n//router相关依赖--路由跳转\nobject Router {\n    val arouter_api = \"com.alibaba:arouter-api:${Versions.arouter_api}\"\n    val arouter_compiler = \"com.alibaba:arouter-compiler:${Versions.arouter_compiler}\"\n}\n\n/**\n * 凯叔插件平台\n */\nobject Ks_plugin {\n    // 插件相关，transform开头的是transformer，task开头的是gradle task\n    val transform_relinker = \"com.ks.plugin:ks-transform-relinker:1.2.5\"\n    val task_robust_encoder = \"com.ks.plugin:ks-task-robust-encoder:1.4.2-SNAPSHOT\"\n}\n\n\n/**\n * 功能性组件版本\n */\nprivate object ks_component_version {\n    val ks_component_payment_version = \"1.0.4\"\n    val ks_component_login_version = \"1.1.0\"\n    val ks_component_net_version = \"1.2.1-SNAPSHOT\"\n    val ks_component_resource_version = \"1.0.0\"\n    val ks_component_sobot_version = \"1.0.14.1-SNAPSHOT\"\n    val ks_component_mediaplayer_version = \"1.1.8.16\"\n    val ks_component_push_version = \"1.0.14.9\"\n    val ks_component_tracker_version = \"1.0.6.9\"\n    val ks_component_share_version = \"1.0.6\"\n    val ks_component_download_version = \"1.0.3.1\"\n    val ks_component_voicerecorder_version = \"1.0.3.1\"\n    val ks_component_theforcesystem = \"0.0.13.1\"\n}\n\n/**\n * 功能性组件\n */\n\nobject Ks_component {\n    val component_net =\n            \"com.ks.kotlin:ks-component-net:${ks_component_version.ks_component_net_version}\"\n    val component_login =\n            \"com.ks.kotlin:ks-component-login:${ks_component_version.ks_component_login_version}\"\n    val component_payment =\n            \"com.ks.kotlin:ks-component-payment:${ks_component_version.ks_component_payment_version}\"\n    val component_resource =\n            \"com.ks.kotlin:ks-component-resource:${ks_component_version.ks_component_resource_version}\"\n    val component_sobot =\n            \"com.ks.kotlin:ks-component-sobot:${ks_component_version.ks_component_sobot_version}\"\n    val component_mediaplayer =\n            \"com.ks.kotlin:ks-component-mediaplayer:${ks_component_version.ks_component_mediaplayer_version}\"\n    val component_push =\n            \"com.ks.kotlin:ks-component-push:${ks_component_version.ks_component_push_version}\"\n    val component_tracker =\n            \"com.ks.kotlin:ks-component-tracker:${ks_component_version.ks_component_tracker_version}\"\n    val component_share =\n            \"com.ks.kotlin:ks-component-share:${ks_component_version.ks_component_share_version}\"\n    val component_download =\n            \"com.ks.kotlin:ks-component-download:${ks_component_version.ks_component_download_version}\"\n    val component_voicerecorder =\n            \"com.ks.kotlin:ks-component-voicerecorder:${ks_component_version.ks_component_voicerecorder_version}\"\n    val component_theforcesystem =\n            \"com.ks.kotlin:ks_component_theforcesystem:${ks_component_version.ks_component_theforcesystem}\"\n}\n\nprivate object KsLibVersions {\n\n    val ks_lib_net_version = \"1.0.7.9\"\n    val ks_lib_share_version = \"1.0.1\"\n    val ks_lib_route_version = \"1.0.5.2\"\n    val ks_lib_ktx_version = \"1.0.10\"\n    val ks_lib_persistence_version = \"1.0.4.2-SNAPSHOT\"\n    val ks_lib_autosize_version = \"1.0.0\"\n    val ks_lib_picture_version = \"1.0.3.3\"\n    val ks_lib_proguard_version = \"1.0.1\"\n    val ks_lib_wheel_picker_version = \"1.0.5\"\n    val ks_lib_magic_indicator = \"1.0.5\"\n    val ks_lib_xtablayout_version = \"1.0.1\"\n    val ks_lib_appmerge_version = \"1.0.6\"\n    val ks_lib_appmerge_plugin_version = \"1.0.7.2\"\n    val ks_lib_address_selector_version = \"1.1.1\"\n    val ks_lib_pull_refresh_version = \"1.0.5\"\n    val ks_lib_loading_version = \"1.0.2\"\n    val ks_lib_disk_version =\"0.0.6\"\n    val ks_lib_media_version =\"0.0.1.27-SNAPSHOT\"\n}\n\n/**\n * kt-base-lib 的lib 库\n */\nobject Ks_lib {\n    val lib_net = \"com.ks.kotlin:ks-lib-net:${KsLibVersions.ks_lib_net_version}\"\n    val lib_share = \"com.ks.kotlin:ks-lib-share:${KsLibVersions.ks_lib_share_version}\"\n    val lib_ktx = \"com.ks.kotlin:ks-lib-ktx:${KsLibVersions.ks_lib_ktx_version}\"\n    val lib_persistence =\n            \"com.ks.kotlin:ks-lib-persistence:${KsLibVersions.ks_lib_persistence_version}\"\n    val lib_route = \"com.ks.kotlin:ks-lib-route:${KsLibVersions.ks_lib_route_version}\"\n    val lib_autosize = \"com.ks.kotlin:ks-lib-autosize:${KsLibVersions.ks_lib_autosize_version}\"\n    val lib_picture = \"com.ks.kotlin:ks-lib-picture:${KsLibVersions.ks_lib_picture_version}\"\n    val lib_proguard = \"com.ks.kotlin:ks-lib-proguard:${KsLibVersions.ks_lib_proguard_version}\"\n    val lib_wheel_picker =\n            \"com.ks.kotlin:ks-lib-wheel-picker:${KsLibVersions.ks_lib_wheel_picker_version}\"\n    val lib_magic_indicator =\n            \"com.ks.kotlin:ks-lib-magicindicator:${KsLibVersions.ks_lib_magic_indicator}\"\n    val lib_xtablayout =\n            \"com.ks.kotlin:ks-lib-xtablayout:${KsLibVersions.ks_lib_xtablayout_version}\"\n    val lib_appmerge = \"com.ks.kotlin:ks-lib-appmerge:${KsLibVersions.ks_lib_appmerge_version}\"\n    val lib_appmerge_plugin =\n            \"com.ks.kotlin:ks-lib-appmerge-plugin:${KsLibVersions.ks_lib_appmerge_plugin_version}\"\n    val lib_address_selector =\n            \"com.ks.kotlin:ks-lib-address-selector:${KsLibVersions.ks_lib_address_selector_version}\"\n    val lib_pull_refresh =\n            \"com.ks.kotlin:ks-lib-pull-refresh:${KsLibVersions.ks_lib_pull_refresh_version}\"\n    val lib_loading = \"com.ks.kotlin:ks-lib-loadinglayout:${KsLibVersions.ks_lib_loading_version}\"\n    val lib_disk = \"com.ks.ksdiskframe:ksdiskframe:${KsLibVersions.ks_lib_disk_version}\"\n    val lib_media=\"com.ks.media:wrap:${KsLibVersions.ks_lib_media_version}\"\n\n}\n\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539554009},"updatedAt":{"$$date":1598542593567},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"k6InlOeu1ZTjxc83"}
{"name":"css-CSS 分组 和 嵌套 选择器","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"\n{\n    color:green;\n}\nh2\n{\n    color:green;\n}\np\n{\n    color:green;\n}\n为了尽量减少代码，你可以使用分组选择器。\n\n每个选择器用逗号分隔。\n\n在下面的例子中，我们对以上代码使用分组选择器：\n\n实例\nh1,h2,p\n{\n    color:green;\n}\n\n尝试一下 »\n\n嵌套选择器\n它可能适用于选择器内部的选择器的样式。\n\n在下面的例子设置了三个样式：\n\np{ }: 为所有 p 元素指定一个样式。\n.marked{ }: 为所有 class=\"marked\" 的元素指定一个样式。\n.marked p{ }: 为所有 class=\"marked\" 元素内的 p 元素指定一个样式。\np.marked{ }: 为所有 class=\"marked\" 的 p 元素指定一个样式。\n实例\np\n{\n    color:blue;\n    text-align:center;\n}\n.marked\n{\n    background-color:red;\n}\n.marked p\n{\n    color:white;\n}\np.marked{\n    text-decoration:underline;\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888558479},"updatedAt":{"$$date":1598889089289},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"k8VzOwjU4Bti0CFb"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975873591},"updatedAt":{"$$date":1598975873591},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kHeKzUw4R3omY5iA"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975862951},"updatedAt":{"$$date":1598975862951},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kMfT2t340r25Vihi"}
{"name":"kotlin-对象表达式、对象声明与伴生对象 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/object-declarations.html\n对象表达式、对象声明与伴生对象 - Kotlin 语言中文站\n11-14 minutes\n改进翻译\n有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类。 Kotlin 用对象表达式和对象声明处理这种情况。\n\n要创建一个继承自某个（或某些）类型的匿名类的对象，我们会这么写：\n\nwindow.addMouseListener(object : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { /*……*/ }\n\n    override fun mouseEntered(e: MouseEvent) { /*……*/ }\n})\n如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。 多个超类型可以由跟在冒号后面的逗号分隔的列表指定：\n\nopen class A(x: Int) {\n    public open val y: Int = x\n}\n\ninterface B { /*……*/ }\n\nval ab: A = object : A(1), B {\n    override val y = 15\n}\n任何时候，如果我们只需要“一个对象而已”，并不需要特殊超类型，那么我们可以简单地写：\n\nfun foo() {\n    val adHoc = object {\n        var x: Int = 0\n        var y: Int = 0\n    }\n    print(adHoc.x + adHoc.y)\n}\n请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象中添加的成员将无法访问。\n\nclass C {\n    // 私有函数，所以其返回类型是匿名对象类型\n    private fun foo() = object {\n        val x: String = \"x\"\n    }\n\n    // 公有函数，所以其返回类型是 Any\n    fun publicFoo() = object {\n        val x: String = \"x\"\n    }\n\n    fun bar() {\n        val x1 = foo().x        // 没问题\n        val x2 = publicFoo().x  // 错误：未能解析的引用“x”\n    }\n}\n对象表达式中的代码可以访问来自包含它的作用域的变量。\n\nfun countClicks(window: JComponent) {\n    var clickCount = 0\n    var enterCount = 0\n\n    window.addMouseListener(object : MouseAdapter() {\n        override fun mouseClicked(e: MouseEvent) {\n            clickCount++\n        }\n\n        override fun mouseEntered(e: MouseEvent) {\n            enterCount++\n        }\n    })\n    // ……\n}\n单例模式在一些场景中很有用， 而 Kotlin（继 Scala 之后）使单例声明变得很容易：\n\nobject DataProviderManager {\n    fun registerDataProvider(provider: DataProvider) {\n        // ……\n    }\n\n    val allDataProviders: Collection<DataProvider>\n        get() = // ……\n}\n这称为对象声明。并且它总是在 object 关键字后跟一个名称。 就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边。\n\n对象声明的初始化过程是线程安全的并且在首次访问时进行。\n\n如需引用该对象，我们直接使用其名称即可：\n\nDataProviderManager.registerDataProvider(……)\n这些对象可以有超类型：\n\nobject DefaultListener : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { …… }\n\n    override fun mouseEntered(e: MouseEvent) { …… }\n}\n注意：对象声明不能在局部作用域（即直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中。\n\n类内部的对象声明可以用 companion 关键字标记：\n\nclass MyClass {\n    companion object Factory {\n        fun create(): MyClass = MyClass()\n    }\n}\n该伴生对象的成员可通过只使用类名作为限定符来调用：\n\nval instance = MyClass.create()\n可以省略伴生对象的名称，在这种情况下将使用名称 Companion：\n\nclass MyClass {\n    companion object { }\n}\n\nval x = MyClass.Companion\n其自身所用的类的名称（不是另一个名称的限定符）可用作对该类的伴生对象 （无论是否具名）的引用：\n\nclass MyClass1 {\n    companion object Named { }\n}\n\nval x = MyClass1\n\nclass MyClass2 {\n    companion object { }\n}\n\nval y = MyClass2\n请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口：\n\ninterface Factory<T> {\n    fun create(): T\n}\n\nclass MyClass {\n    companion object : Factory<MyClass> {\n        override fun create(): MyClass = MyClass()\n    }\n}\n\nval f: Factory<MyClass> = MyClass\n当然，在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见Java 互操作性一节 。\n\n对象表达式和对象声明之间有一个重要的语义差别：\n\n对象表达式是在使用他们的地方立即执行（及初始化）的；\n对象声明是在第一次被访问到时延迟初始化的；\n伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307927638},"updatedAt":{"$$date":1597308130224},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kN131CDyI0iCDrnW"}
{"name":"kotlin-习惯用法 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/idioms.html\n习惯用法 - Kotlin 语言中文站\n14-17 minutes\n改进翻译\n一些在 Kotlin 中广泛使用的语法习惯，如果你有更喜欢的语法习惯或者风格，建一个 pull request 贡献给我们吧！\n\ndata class Customer(val name: String, val email: String)\n会为 Customer 类提供以下功能：\n\n所有属性的 getters （对于 var 定义的还有 setters）\nequals()\nhashCode()\ntoString()\ncopy()\n所有属性的 component1()、 component2()……等等（参见数据类）\nfun foo(a: Int = 0, b: String = \"\") { …… }\nval positives = list.filter { x -> x > 0 }\n或者可以更短:\n\nval positives = list.filter { it > 0 }\nif (\"john@example.com\" in emailsList) { …… }\n\nif (\"jane@example.com\" !in emailsList) { …… }\nwhen (x) {\n    is Foo //-> ……\n    is Bar //-> ……\n    else   //-> ……\n}\nfor ((k, v) in map) {\n    println(\"$k -> $v\")\n}\nk、v 可以改成任意名字。\n\nfor (i in 1..100) { …… }  // 闭区间：包含 100\nfor (i in 1 until 100) { …… } // 半开区间：不包含 100\nfor (x in 2..10 step 2) { …… }\nfor (x in 10 downTo 1) { …… }\nif (x in 1..10) { …… }\nval list = listOf(\"a\", \"b\", \"c\")\nval map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)\nprintln(map[\"key\"])\nmap[\"key\"] = value\nval p: String by lazy {\n    // 计算该字符串\n}\nfun String.spaceToCamelCase() { …… }\n\n\"Convert this to camelcase\".spaceToCamelCase()\nobject Resource {\n    val name = \"Name\"\n}\nval files = File(\"Test\").listFiles()\n\nprintln(files?.size)\nIf not null and else 缩写\nval files = File(\"Test\").listFiles()\n\nprintln(files?.size ?: \"empty\")\nval values = ……\nval email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\")\nval emails = …… // 可能会是空集合\nval mainEmail = emails.firstOrNull() ?: \"\"\nval value = ……\n\nvalue?.let {\n    …… // 代码会执行到此处, 假如data不为null\n}\nval value = ……\n\nval mapped = value?.let { transformValue(it) } ?: defaultValue \n// 如果该值或其转换结果为空，那么返回 defaultValue。\nfun transform(color: String): Int {\n    return when (color) {\n        \"Red\" -> 0\n        \"Green\" -> 1\n        \"Blue\" -> 2\n        else -> throw IllegalArgumentException(\"Invalid color param value\")\n    }\n}\nfun test() {\n    val result = try {\n        count()\n    } catch (e: ArithmeticException) {\n        throw IllegalStateException(e)\n    }\n\n    // 使用 result\n}\nfun foo(param: Int) {\n    val result = if (param == 1) {\n        \"one\"\n    } else if (param == 2) {\n        \"two\"\n    } else {\n        \"three\"\n    }\n}\nfun arrayOfMinusOnes(size: Int): IntArray {\n    return IntArray(size).apply { fill(-1) }\n}\n等价于\n\nfun theAnswer(): Int {\n    return 42\n}\n单表达式函数与其它惯用法一起使用能简化代码，例如和 when 表达式一起使用：\n\nfun transform(color: String): Int = when (color) {\n    \"Red\" -> 0\n    \"Green\" -> 1\n    \"Blue\" -> 2\n    else -> throw IllegalArgumentException(\"Invalid color param value\")\n}\nclass Turtle {\n    fun penDown()\n    fun penUp()\n    fun turn(degrees: Double)\n    fun forward(pixels: Double)\n}\n\nval myTurtle = Turtle()\nwith(myTurtle) { // 画一个 100 像素的正方形\n    penDown()\n    for (i in 1..4) {\n        forward(100.0)\n        turn(90.0)\n    }\n    penUp()\n}\nval myRectangle = Rectangle().apply {\n    length = 4\n    breadth = 5\n    color = 0xFAFAFA\n}\n这对于配置未出现在对象构造函数中的属性非常有用。\n\nval stream = Files.newInputStream(Paths.get(\"/some/file.txt\"))\nstream.buffered().reader().use { reader ->\n    println(reader.readText())\n}\n//  public final class Gson {\n//     ……\n//     public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n//     ……\n\ninline fun <reified T: Any> Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java)\nval b: Boolean? = ……\nif (b == true) {\n    ……\n} else {\n    // `b` 是 false 或者 null\n}\nvar a = 1\nvar b = 2\na = b.also { b = a }\nKotlin 的标准库有一个 TODO() 函数，该函数总是抛出一个 NotImplementedError。 其返回类型为 Nothing，因此无论预期类型是什么都可以使用它。 还有一个接受原因参数的重载：\n\nfun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\")\nIntelliJ IDEA 的 kotlin 插件理解 TODO() 的语言，并且会自动在 TODO 工具窗口中添加代码指示。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304158584},"updatedAt":{"$$date":1597306224262},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kWnhkNrKDW9HoWPQ"}
{"name":"py-定义函数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n\n\n如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。\n\n\n\n\n\n空函数\n如果想定义一个什么事也不做的空函数，可以用pass语句：\n\ndef nop():\n    pass\n\n\n\n    pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。\n\npass还可以用在其他语句里，比如：\n\nif age >= 18:\n    pass\n缺少了pass，代码运行就会有语法错误。\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973947094},"updatedAt":{"$$date":1594977376708},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kXPsRnxiSBdx275n"}
{"name":"css-CSS 语法","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 语法\n实例\n查看 实例 1\n查看 实例 2\nCSS 实例\nCSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:\n\n\n\n选择器通常是您需要改变样式的 HTML 元素。\n\n每条声明由一个属性和一个值组成。\n\n属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。\n\nCSS 实例\nCSS声明总是以分号(;)结束，声明总以大括号({})括起来:\n\np {color:red;text-align:center;}\n为了让CSS可读性更强，你可以每行只描述一个属性:\n\n实例\np\n{\n    color:red;\n    text-align:center;\n}\n\n尝试一下 »\n\nCSS 注释\n注释是用来解释你的代码，并且可以随意编辑它，浏览器会忽略它。\n\nCSS注释以 /* 开始, 以 */ 结束, 实例如下:\n\n实例\n/*这是个注释*/\np\n{\n    text-align:center;\n    /*这是另一个注释*/\n    color:black;\n    font-family:arial;\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888531281},"updatedAt":{"$$date":1598888587364},"_id":"kg7r2UKmvr4DqsGi","folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"CSS 分页实例","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 分页实例\n本章节我们将为大家介绍如何通过使用 CSS 来创建分页的实例。\n\n简单分页\n如果你的网站有很多个页面，你就需要使用分页来为每个页面做导航。\n\n以下实例演示了如何使用 HTML 和 CSS 来创建分页：\n\nCSS 实例\nul.pagination {\n    display: inline-block;\n    padding: 0;\n    margin: 0;\n}\n\nul.pagination li {display: inline;}\n\nul.pagination li a {\n    color: black;\n    float: left;\n    padding: 8px 16px;\n    text-decoration: none;\n}\n\n尝试一下 »\n点击及鼠标悬停分页样式\n«1234567»\n如果点击当前页，可以使用 .active 来设置当前页样式，鼠标悬停可以使用 :hover 选择器来修改样式：\n\nCSS 实例\nul.pagination li a.active {\n    background-color: #4CAF50;\n    color: white;\n}\n\nul.pagination li a:hover:not(.active) {background-color: #ddd;}\n\n尝试一下 »\nCSS 实例\nul.pagination li a.active {\n    background-color: #4CAF50;\n    color: white;\n}\n\nul.pagination li a:hover:not(.active) {background-color: #ddd;}\n\n尝试一下 »\n圆角样式\n«1234567»\n可以使用 border-radius 属性为选中的页码来添加圆角样式:\n\nCSS 实例\nul.pagination li a {\n    border-radius: 5px;\n}\n\nul.pagination li a.active {\n    border-radius: 5px;\n}\n\n尝试一下 »\n鼠标悬停过渡效果\n«1234567»\n我们可以通过添加 transition 属性来为鼠标移动到页码上时添加过渡效果:\n\nCSS 实例\nul.pagination li a {\n    transition: background-color .3s;\n}\n\n尝试一下 »\n带边框分页\n«1234567»\n我们可以使用 border 属性来添加带边框分页:\n\nCSS 实例\nul.pagination li a {\n    border: 1px solid #ddd; /* Gray */\n}\n\n尝试一下 »\n圆角边框\n提示: 在第一个分页链接和最后一个分页链接添加圆角：\n\n«1234567»\nCSS 实例\n.pagination li:first-child a {\n    border-top-left-radius: 5px;\n    border-bottom-left-radius: 5px;\n}\n\n.pagination li:last-child a {\n    border-top-right-radius: 5px;\n    border-bottom-right-radius: 5px;\n}\n\n尝试一下 »\n分页间隔\n提示: 你可以使用 margin 属性来为每个页码直接添加空格：\n\n«1234567»\nCSS 实例\nul.pagination li a {\n    margin: 0 4px; /* 0 对应的是头部与底部，可以修改它看看效果 */\n}\n\n尝试一下 »\n分页字体大小\n«1234567»\n我们可以使用 font-size 属性来设置分页的字体大小:\n\nCSS 实例\nul.pagination li a {\n    font-size: 22px;\n}\n\n尝试一下 »\n居中分页\n«1234567»\n如果要让分页居中，可以在容器元素上 (如 <div>) 添加 text-align:center 样式：\n\nCSS 实例\ndiv.center {\n    text-align: center;\n}\n\n尝试一下 »\n更多实例\nCSS 实例\n\n\n尝试一下 »\n面包屑导航\n首页 前端 HTML 教程 HTML 段落\n另外一种导航为面包屑导航，实例如下：\n\nCSS 实例\nul.breadcrumb {\n    padding: 8px 16px;\n    list-style: none;\n    background-color: #eee;\n}\n\nul.breadcrumb li {display: inline;}\n\nul.breadcrumb li+li:before {\n    padding: 8px;\n    color: black;\n    content: \"/\\00a0\";\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974627828},"updatedAt":{"$$date":1598975441293},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kk8xoLIIbK7bIihU"}
{"name":"css-CSS 媒体类型","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 媒体类型\n媒体类型允许你指定文件将如何在不同媒体呈现。该文件可以以不同的方式显示在屏幕上，在纸张上，或听觉浏览器等等。 \n\n媒体类型\n一些 CSS 属性只设计了某些媒体。例如 voice-family 属性是专为听觉用户代理。其他一些属性可用于不同的媒体类型。例如， font-size 属性可用于屏幕和印刷媒体，但有不同的值。屏幕和纸上的文件不同，通常需要一个更大的字体，sans-serif 字体比较适合在屏幕上阅读，而 serif 字体更容易在纸上阅读。\n\n@media 规则\n@media 规则允许在相同样式表为不同媒体设置不同的样式。\n\n在下面的例子告诉我们浏览器屏幕上显示一个 14 像素的 Verdana 字体样式。但是如果页面打印，将是 10 个像素的 Times 字体。请注意，font-weight 在屏幕上和纸上设置为粗体：\n\n实例\n@media screen\n{\n    p.test {font-family:verdana,sans-serif;font-size:14px;}\n}\n@media print\n{\n    p.test {font-family:times,serif;font-size:10px;}\n}\n@media screen,print\n{\n    p.test {font-weight:bold;}\n}\n\n尝试一下 »\n你可以自己尝试看看 ! 如果您使用的是 Mozilla / Firefox 或 IE5+ 打印此页，你会看到，媒体类型将使用另一种比其他文本字体大小小点的字体显示。\n\n其他媒体类型\n注意：媒体类型名称不区分大小写。\n\n媒体类型\t描述\nall\t用于所有的媒体设备。\naural\t用于语音和音频合成器。\nbraille\t用于盲人用点字法触觉回馈设备。\nembossed\t用于分页的盲人用点字法打印机。\nhandheld\t用于小的手持的设备。\nprint\t用于打印机。\nprojection\t用于方案展示，比如幻灯片。\nscreen\t用于电脑显示器。\ntty\t用于使用固定密度字母栅格的媒体，比如电传打字机和终端。\ntv\t用于电视机类型的设备。\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973623622},"updatedAt":{"$$date":1598974419556},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kkP1hfMeXUjBVPob"}
{"name":"ad-ksEmptyServiceReplace","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.app_compat\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\nreceiver\nAnalysysReceiver\nsdk\nPushReceiver\nkaishustory\ngetui\nGetuiIntentService\nGeTuiPushService\nreceiver\nMusicIntentReceiver\nNetWorkChangeReceiver\nNotificationNewReceiverOpenActivity\nNotificationPushOpenReceiver\nNotificationReceiverPlayControlReceiver\nstoryaudioservice\nMusicService\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521317688},"updatedAt":{"$$date":1598522745999},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kzViNc9QN8VNNMyC"}
{"name":"qk-ks_lib_wheel_picker","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    api deps.kotlin.stdlib_jdk\n    api deps.androidx.core_ktx\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n}\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580898978},"updatedAt":{"$$date":1598581231895},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"l1nYURfTzEGrJziD"}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244759182},"updatedAt":{"$$date":1597244759182},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"lKZZOn1nLRvLQuEF"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597404254053},"updatedAt":{"$$date":1597404254053},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"lLHSFLvCTK6VE9q0"}
{"name":"kotlin-在 Android 开发中使用常见的 Kotlin 模式  |  Android 开发者  |  Android Developers","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /kotlin/common-patterns\n在 Android 开发中使用常见的 Kotlin 模式  |  Android 开发者  |  Android Developers\n8-10 minutes\n本主题重点介绍 Kotlin 语言在 Android 开发过程中最有用的一些方面。\n\n使用 Fragment\n下文使用 Fragment 示例突出介绍 Kotlin 的一些最佳功能。\n\n继承\n您可以使用 class 关键字在 Kotlin 中声明类。在以下示例中，LoginFragment 是 Fragment 的子类。您可以通过在子类与其父类之间使用 : 运算符指示继承：\n\nclass LoginFragment : Fragment()\n在此类声明中，LoginFragment 负责调用其超类 Fragment 的构造函数。\n\n在 LoginFragment 中，您可以替换许多生命周期回调以响应 Fragment 中的状态变化。如需替换函数，请使用 override 关键字，如以下示例所示：\n\noverride fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n): View? {\n    return inflater.inflate(R.layout.login_fragment, container, false)\n}\n如需引用父类中的函数，请使用 super 关键字，如以下示例所示：\n\noverride fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n    super.onViewCreated(view, savedInstanceState)\n}\n可为 null 性和初始化\n在前面的示例中，被替换的方法中某些参数的类型以问号 ? 为后缀。这表示为这些参数传递的实际参数可以为 null。请务必安全地处理其可为 null 性。\n\n在 Kotlin 中，您必须在声明对象时初始化对象的属性。这意味着，当您获取类的实例时，可以立即引用它的任何可访问属性。不过，在调用 Fragment#onCreateView 之前，Fragment 中的 View 对象尚未准备好进行扩充，所以您需要一种方法来推迟 View 的属性初始化。\n\n您可以使用 lateinit 推迟属性初始化。使用 lateinit 时，您应尽快初始化属性。\n\n以下示例演示了如何使用 lateinit 在 onViewCreated 中分配 View 对象：\n\nclass LoginFragment : Fragment() {private lateinit var usernameEditText: EditText\n    private lateinit var passwordEditText: EditText\n    private lateinit var loginButton: Button\n    private lateinit var statusTextView: TextViewoverride fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        usernameEditText \n\n= view.findViewById(R.id.username_edit_text)\n        passwordEditText = view.findViewById(R.id.password_edit_text)\n        loginButton = view.findViewById(R.id.login_button)\n        statusTextView = view.findViewById(R.id.status_text_view)\n    }...\n}\nSAM 转换\n您可以通过实现 OnClickListener 接口来监听 Android 中的点击事件。Button 对象包含一个 setOnClickListener() 函数，该函数接受 OnClickListener 的实现。\n\nOnClickListener 具有单一抽象方法 onClick()，您必须实现该方法。因为 setOnClickListener() 始终将 OnClickListener 当作参数，又因为 OnClickListener 始终都有相同的单一抽象方法，所以此实现在 Kotlin 中可以使用匿名函数来表示。此过程称为单一抽象方法转换或 SAM 转换。\n\nSAM 转换可使代码明显变得更简洁。以下示例展示了如何使用 SAM 转换来为 Button 实现 OnClickListener：\n\nloginButton.setOnClickListener {\n    val authSuccessful: Boolean = viewModel.authenticate(\n            usernameEditText.text.toString(),\n            passwordEditText.text.toString()\n    )\n    if (authSuccessful) {\n        // Navigate to next screen\n    } else {\n        statusTextView.text = requireContext().getString(R.string.auth_failed)\n    }\n}\n当用户点击 loginButton 时，系统会执行传递给 setOnClickListener() 的匿名函数中的代码。\n\n伴生对象\n伴生对象提供了一种机制，用于定义在概念上与某个类型相关但不与某个特定对象关联的变量或函数。伴生对象类似于对变量和方法使用 Java 的 static 关键字。\n\n在以下示例中，TAG 是一个 String 常量。您不需要为每个 LoginFragment 实例定义一个唯一的 String 实例，因此您应在伴生对象中定义它：\n\nclass LoginFragment : Fragment() {...companion object {\n        private const val TAG = \"LoginFragment\"\n    }\n}\n您可以在文件的顶级定义 TAG，但文件中可能有大量的变量、函数和类也是在顶级定义的。伴生对象有助于连接变量、函数和类定义，而无需引用该类的任何特定实例。\n\n属性委托\n初始化属性时，您可能会重复 Android 的一些比较常见的模式，例如在 Fragment 中访问 ViewModel。为避免过多的重复代码，您可以使用 Kotlin 的属性委托语法。\n\nprivate val viewModel: LoginViewModel by viewModels()\n属性委托提供了一种可在您的整个应用中重复使用的通用实现。Android KTX 为您提供了一些属性委托。例如，viewModels 可检索范围限定为当前 Fragment 的 ViewModel。\n\n属性委托使用反射，这样会增加一些性能开销。这种代价换来的是简洁的语法，可让您节省开发时间。\n\n可为 null 性\nKotlin 提供了严格的可为 null 性规则，可在您的整个应用中维护类型安全。在 Kotlin 中，默认情况下，对对象的引用不能包含 null 值。如需为变量赋 null 值，必须通过将 ? 添加到基本类型的末尾以声明可为 null 变量类型。\n\n例如，以下表达式在 Kotlin 中是违反规则的。name 的类型为 String，不可为 null：\n\nval name: String = null\n如需允许 null 值，必须使用可为 null String 类型 String?，如以下示例所示：\n\nval name: String? = null\n互操作性\nKotlin 的严格规则可使代码更安全且更简洁。这些规则可降低会导致应用崩溃的 NullPointerException 出现的几率。此外，它们还可减少您需要在代码中进行的 null 检查的次数。\n\n通常，在编写 Android 应用时，您还必须调用非 Kotlin 代码，因为大多数 Android API 都是用 Java 编程语言编写的。\n\n可为 null 性是 Java 和 Kotlin 在行为上有所不同的一个主要方面。Java 对可为 null 性语法的要求不那么严格。\n\n例如，Account 类具有一些属性，包括一个名为 name 的 String 属性。Kotlin 制定了与可为 null 性有关的规则，Java 没有制定这样的规则，而是依赖于可选的可为 null 性注释明确声明您是否可以赋予 null 值。\n\n由于 Android 框架主要是用 Java 编写的，因此在调用没有可为 null 性注释的 API 时，您可能会遇到这种情况。\n\n平台类型\n如果您使用 Kotlin 引用在 Java Account 类中定义的不带注释的 name 成员，编译器将不知道 String 映射到 Kotlin 中的 String 还是 String?。这种不明确性通过平台类型 String! 表示。\n\nString! 对 Kotlin 编译器而言没有特殊的含义。String! 可以表示 String 或 String?，编译器可让您赋予任一类型的值。请注意，如果您将类型表示为 String 并赋予 null 值，则系统可能会抛出 NullPointerException。\n\n为了解决此问题，每当您用 Java 编写代码时，都应使用可为 null 性注释。这些注释对 Java 和 Kotlin 开发者都有帮助。\n\n例如，下面是在 Java 中定义的 Account 类：\n\npublic class Account implements Parcelable {\n    public final String name;\n    public final String type;\n    private final @Nullable String accessId;...\n}\n其中一个成员变量 accessId 带有 @Nullable 注释，这表示它可以持有 null 值。于是，Kotlin 会将 accessId 视为 String?。\n\n如需指明变量绝不能为 null，请使用 @NonNull 注释：\n\npublic class Account implements Parcelable {\n    public final @NonNull String name;\n    ...\n}\n在这种情况下，name 在 Kotlin 中被视为不可为 null String。\n\n可为 null 性注释包含在所有新增的 Android API 以及许多现有的 Android API 中。许多 Java 库已添加可为 null 性注释，以便为 Kotlin 和 Java 开发者提供更好的支持。\n\n处理可为 null 性\n如果您不确定 Java 类型，则应将其视为可为 null。例如，Account 类的 name 成员不带注释，因此您应假定它是一个可为 null String。\n\n如果希望修剪 name 以使其值不包含前导或尾随空格，则可以使用 Kotlin 的 trim 函数。您可以通过几种不同的方式安全地修剪 String?。其中一种方式是使用非 null 断言运算符 !!，如以下示例所示：\n\nval account = Account(\"name\", \"type\")\nval accountName = account.name!!.trim()\n!! 运算符将其左侧的所有内容视为非 null，因此，在本例中，应将 name 视为非 null String。如果它左侧表达式的结果为 null，则您的应用会抛出 NullPointerException。此运算符简单快捷，但应谨慎使用，因为它会将 NullPointerException 的实例重新引入您的代码。\n\n更安全的选择是使用安全调用运算符 ?.，如以下示例所示：\n\nval account = Account(\"name\", \"type\")\nval accountName = account.name?.trim()\n使用安全调用运算符时，如果 name 不为 null，则 name?.trim() 的结果是一个不带前导或尾随空格的名称值。如果 name 为 null，则 name?.trim() 的结果为 null。这意味着，在执行此语句时，您的应用永远不会抛出 NullPointerException。\n\n虽然安全调用运算符可使您避免潜在的 NullPointerException，但它会将 null 值传递给下一个语句。您可以使用 Elvis 运算符 (?:) 紧接着处理 null 值的情况，如以下示例所示：\n\nval account = Account(\"name\", \"type\")\nval accountName = account.name?.trim() ?: \"Default name\"\n如果 Elvis 运算符左侧表达式的结果为 null，则会将右侧的值赋予 accountName。此方法对于提供本来为 null 的默认值很有用。\n\n您还可以使用 Elvis 运算符提前从函数返回结果，如以下示例所示：\n\nfun validateAccount(account: Account?) {\n    val accountName = account?.name?.trim() ?: \"Default name\"// account cannot be null beyond this point\n    account ?: return...\n}\nAndroid API 变更\nAndroid API 对 Kotlin 的支持力度越来越高。Android 的许多最常见的 API（包括 AppCompatActivity 和 Fragment）包含可为 null 性注释，并且某些调用（如 Fragment#getContext）具有更支持 Kotlin 的替代调用。\n\n例如，访问 Fragment 的 Context 几乎总是不为 null，因为您在 Fragment 中进行的大多数调用都是在 Fragment 附加到 Activity（Context 的子类）时发生的。即便如此，Fragment#getContext 并不总是返回非 null 值，因为在某些情况下 Fragment 未附加到 Activity。因此，Fragment#getContext 的返回类型可为 null。\n\n由于从 Fragment#getContext 返回的 Context 可为 null（并且带有 @Nullable 注释），因此您必须在 Kotlin 代码中将其视为 Context?。这意味着，在访问其属性和函数之前，需要应用前面提到的某个运算符来处理可为 null 性问题。对于一些这样的情况，Android 包含可提供这种便利的替代 API。例如，Fragment#requireContext 会返回非 null Context，如果在 Context 将为 null 时调用它，则会抛出 IllegalStateException。这样，您就可以将生成的 Context 视为非 null 值，而无需使用安全调用运算符或其他解决方法。\n\n属性初始化\n默认情况下，Kotlin 中的属性并未初始化。当初始化属性的封闭类时，必须初始化属性。\n\n您可以通过几种不同的方式来初始化属性。以下示例展示了如何通过在类声明中为 index 变量赋值初始化该变量：\n\nclass LoginFragment : Fragment() {\n    val index: Int = 12\n}\n此初始化也可以在初始化式块中进行定义：\n\nclass LoginFragment : Fragment() {\n    val index: Intinit {\n        index = 12\n    }\n}\n上面的示例中，在构建 LoginFragment 时初始化 index。\n\n不过，某些属性可能无法在对象构建期间进行初始化。例如，您可能要从 Fragment 中引用 View，这意味着，必须先扩充布局。构建 Fragment 时不会发生扩充，而是在调用 Fragment#onCreateView 时进行扩充。\n\n应对这种情况的一种方法是将视图声明为可为 null 并尽快对其进行初始化，如以下示例所示：\n\nclass LoginFragment : Fragment() {\n    private var statusTextView: TextView? = nulloverride fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            statusTextView \n\n= view.findViewById(R.id.status_text_view)\n            statusTextView?.setText(R.string.auth_failed)\n    }\n}\n虽然这样可以发挥预期的作用，但现在每当引用 View 时，都必须管理其可为 null 性。更好的解决方案是对 View 初始化使用 lateinit，如以下示例所示：\n\nclass LoginFragment : Fragment() {\n    private lateinit var statusTextView: TextViewoverride fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            statusTextView \n\n= view.findViewById(R.id.status_text_view)\n            statusTextView.setText(R.string.auth_failed)\n    }\n}\n通过 lateinit 关键字，可以避免在构建对象时初始化属性。如果在属性进行初始化之前对其进行了引用，Kotlin 会抛出 UninitializedPropertyAccessException，因此请务必尽快初始化属性。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397418412},"updatedAt":{"$$date":1597398779429},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"lMXHvyWMcTpTiXrz"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980161374},"updatedAt":{"$$date":1594980161374},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"lSL0yhwJp0jsww3m"}
{"name":"css-CSS 伪元素","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 伪元素\nCSS伪元素是用来添加一些选择器的特殊效果。\n\n语法\n伪元素的语法：\n\nselector:pseudo-element {property:value;}\nCSS类也可以使用伪元素：\n\nselector.class:pseudo-element {property:value;}\n\n:first-line 伪元素\n\"first-line\" 伪元素用于向文本的首行设置特殊样式。\n\n在下面的例子中，浏览器会根据 \"first-line\" 伪元素中的样式对 p 元素的第一行文本进行格式化：\n\n实例\np:first-line \n{\n    color:#ff0000;\n    font-variant:small-caps;\n}\n\n尝试一下 »\n注意：\"first-line\" 伪元素只能用于块级元素。\n\n注意： 下面的属性可应用于 \"first-line\" 伪元素：\n\nfont properties\ncolor properties \nbackground properties\nword-spacing\nletter-spacing\ntext-decoration\nvertical-align\ntext-transform\nline-height\nclear\n:first-letter 伪元素\n\"first-letter\" 伪元素用于向文本的首字母设置特殊样式：\n\n实例\np:first-letter \n{\n    color:#ff0000;\n    font-size:xx-large;\n}\n\n尝试一下 »\n注意： \"first-letter\" 伪元素只能用于块级元素。\n\n注意： 下面的属性可应用于 \"first-letter\" 伪元素： \n\nfont properties\ncolor properties \nbackground properties\nmargin properties\npadding properties\nborder properties\ntext-decoration\nvertical-align (only if \"float\" is \"none\")\ntext-transform\nline-height\nfloat\nclear\n伪元素和CSS类\n伪元素可以结合CSS类： \n\np.article:first-letter {color:#ff0000;}\n\n<p class=\"article\">文章段落</p>\n上面的例子会使所有 class 为 article 的段落的首字母变为红色。\n\n多个伪元素\n可以结合多个伪元素来使用。\n\n在下面的例子中，段落的第一个字母将显示为红色，其字体大小为 xx-large。第一行中的其余文本将为蓝色，并以小型大写字母显示。\n\n段落中的其余文本将以默认字体大小和颜色来显示：\n\n实例\np:first-letter\n{\n    color:#ff0000;\n    font-size:xx-large;\n}\np:first-line \n{\n    color:#0000ff;\n    font-variant:small-caps;\n}\n\n尝试一下 »\n\nCSS - :before 伪元素\n\":before\" 伪元素可以在元素的内容前面插入新内容。\n\n下面的例子在每个 <h1>元素前面插入一幅图片：\n\n实例\nh1:before \n{\n    content:url(smiley.gif);\n}\n\n尝试一下 »\n\nCSS - :after 伪元素\n\":after\" 伪元素可以在元素的内容之后插入新内容。\n\n下面的例子在每个 <h1> 元素后面插入一幅图片：\n\n实例\nh1:after\n{\n    content:url(smiley.gif);\n}\n\n尝试一下 »\n\n所有CSS伪类/元素\n选择器\t示例\t示例说明\n:link\ta:link\t选择所有未访问链接\n:visited\ta:visited\t选择所有访问过的链接\n:active\ta:active\t选择正在活动链接\n:hover\ta:hover\t把鼠标放在链接上的状态\n:focus\tinput:focus\t选择元素输入后具有焦点\n:first-letter\tp:first-letter\t选择每个<p> 元素的第一个字母\n:first-line\tp:first-line\t选择每个<p> 元素的第一行\n:first-child\tp:first-child\t选择器匹配属于任意元素的第一个子元素的 <p> 元素\n:before\tp:before\t在每个<p>元素之前插入内容\n:after\tp:after\t在每个<p>元素之后插入内容\n:lang(language)\tp:lang(it)\t为<p>元素的lang属性选择一个开始值\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973613846},"updatedAt":{"$$date":1598974023228},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"lW9Kb5fwi4MPBJLv"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975691100},"updatedAt":{"$$date":1598975691100},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"lZmVOtmyga4jyM32"}
{"name":"html-1","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>菜鸟教程(runoob.com)</title>\n</head>\n<body>\n    <h1>我的第一个标题</h1>\n    <p>我的第一个段落。</p>\n</body>\n</html>\n\n\n\n\n.html\n.htm\n以上两种后缀名没有区别，都可以使用。\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885672100},"updatedAt":{"$$date":1598885743258},"_id":"lyKX7mUBAAYKO4b8","folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"css-CSS 边框","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 边框\nCSS 边框属性\nCSS边框属性允许你指定一个元素边框的样式和颜色。\n\n在四边都有边框\n\n\n红色底部边框\n\n\n圆角边框\n\n\n左侧边框带宽度，颜色为蓝色\n\n边框样式\n边框样式属性指定要显示什么样的边界。\n\nRemark border-style属性用来定义边框的样式\n\nborder-style 值:\nnone: 默认无边框\n\n\ndotted: 定义一个点线边框\n\n\ndashed: 定义一个虚线边框\n\n\nsolid: 定义实线边框\n\n\ndouble: 定义两个边框。 两个边框的宽度和 border-width 的值相同\n\n\ngroove: 定义3D沟槽边框。效果取决于边框的颜色值\n\n\nridge: 定义3D脊边框。效果取决于边框的颜色值\n\n\ninset:定义一个3D的嵌入边框。效果取决于边框的颜色值\n\n\noutset: 定义一个3D突出边框。 效果取决于边框的颜色值\n\n\n尝试一下: 设置边框样式\n\n边框宽度\n您可以通过 border-width 属性为边框指定宽度。\n\n为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。\n\n注意：CSS 没有定义 3 个关键字的具体宽度，所以一个用户可能把 thick 、medium 和 thin 分别设置为等于 5px、3px 和 2px，而另一个用户则分别设置为 3px、2px 和 1px。\n\n实例\np.one\n{\n    border-style:solid;\n    border-width:5px;\n}\np.two\n{\n    border-style:solid;\n    border-width:medium;\n}\n\n尝试一下 »\n\n边框颜色\nborder-color属性用于设置边框的颜色。可以设置的颜色：\n\nname - 指定颜色的名称，如 \"red\"\nRGB - 指定 RGB 值, 如 \"rgb(255,0,0)\"\nHex - 指定16进制值, 如 \"#ff0000\"\n您还可以设置边框的颜色为\"transparent\"。\n\n注意： border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。\n\n实例\np.one\n{\n    border-style:solid;\n    border-color:red;\n}\np.two\n{\n    border-style:solid;\n    border-color:#98bf21;\n}\n\n尝试一下 »\n\n边框-单独设置各边\n在CSS中，可以指定不同的侧面不同的边框：\n\n实例\np\n{\n    border-top-style:dotted;\n    border-right-style:solid;\n    border-bottom-style:dotted;\n    border-left-style:solid;\n}\n\n尝试一下 »\n上面的例子也可以设置一个单一属性：\n\n实例\nborder-style:dotted solid;\n\n尝试一下 »\nborder-style属性可以有1-4个值：\n\nborder-style:dotted solid double dashed;\n上边框是 dotted\n右边框是 solid\n底边框是 double\n左边框是 dashed\n\nborder-style:dotted solid double;\n上边框是 dotted\n左、右边框是 solid\n底边框是 double\n\nborder-style:dotted solid;\n上、底边框是 dotted\n右、左边框是 solid\n\nborder-style:dotted;\n四面边框是 dotted\n上面的例子用了border-style。然而，它也可以和border-width 、 border-color一起使用。\n\n边框-简写属性\n上面的例子用了很多属性来设置边框。\n\n你也可以在一个属性中设置边框。\n\n你可以在\"border\"属性中设置：\n\nborder-width\nborder-style (required)\nborder-color\n实例\nborder:5px solid red;\n\n\n\n\n\nCSS 边框属性\n属性\t描述\nborder\t简写属性，用于把针对四个边的属性设置在一个声明。\nborder-style\t用于设置元素所有边框的样式，或者单独地为各边设置边框样式。\nborder-width\t简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。\nborder-color\t简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。\nborder-bottom\t简写属性，用于把下边框的所有属性设置到一个声明中。\nborder-bottom-color\t设置元素的下边框的颜色。\nborder-bottom-style\t设置元素的下边框的样式。\nborder-bottom-width\t设置元素的下边框的宽度。\nborder-left\t简写属性，用于把左边框的所有属性设置到一个声明中。\nborder-left-color\t设置元素的左边框的颜色。\nborder-left-style\t设置元素的左边框的样式。\nborder-left-width\t设置元素的左边框的宽度。\nborder-right\t简写属性，用于把右边框的所有属性设置到一个声明中。\nborder-right-color\t设置元素的右边框的颜色。\nborder-right-style\t设置元素的右边框的样式。\nborder-right-width\t设置元素的右边框的宽度。\nborder-top\t简写属性，用于把上边框的所有属性设置到一个声明中。\nborder-top-color\t设置元素的上边框的颜色。\nborder-top-style\t设置元素的上边框的样式。\nborder-top-width\t设置元素的上边框的宽度。\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888553206},"updatedAt":{"$$date":1598889014710},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"m5e5t5ZyI02uAAyM"}
{"name":"qk-ks_component_payment","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'com.kezong.fat-aar'\nconfigurations.embed.transitive = true\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 100\n        versionName \"100\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    repositories{\n        flatDir {\n            dirs 'libs'\n        }\n    }\n\n}\n\ndependencies {\n    api fileTree(dir: 'libs', include: ['*.jar'])\n\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n//    //招商支付\n//    implementation (name: 'cmbsdk-release-1.0', ext: 'aar')\n    //支付宝支付\n    embed (name: 'alipaySdk-15.6.8-20191021122455-noUtdid', ext: 'aar')\n    //微信支付\n    api deps.wechat_sdk_android_without_mta\n\n    implementation deps.eventbus\n    implementation deps.androidx.appcompat\n\n    api deps.kotlin.coroutines_core\n    api deps.kotlin.coroutines_android\n\n}\n\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\nWorkerThread\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * Denotes that the annotated method should only be called on a worker thread.\n * If the annotated element is a class, then all methods in the class should be called\n * on a worker thread.\n * <p>\n * Example:\n * <pre><code>\n *  &#64;WorkerThread\n *  protected abstract FilterResults performFiltering(CharSequence constraint);\n * </code></pre>\n */\n@Documented\n@Retention(CLASS)\n@Target({METHOD,CONSTRUCTOR,TYPE,PARAMETER})\npublic @interface WorkerThread {\n}\n\n\n\n\n\n\n/**\n * Denotes that the annotated method or constructor should only be called on the UI thread.\n * If the annotated element is a class, then all methods in the class should be called\n * on the UI thread.\n * <p>\n * Example:\n * <pre><code>\n *  &#64;UiThread\n *\n *  public abstract void setText(@NonNull String text) { ... }\n * </code></pre>\n *\n * <p class=\"note\"><b>Note:</b> Ordinarily, an app's UI thread is also the main\n * thread. However, under special circumstances, an app's UI thread\n * might not be its main thread; for more information, see\n * <a href=\"/studio/write/annotations.html#thread-annotations\">Thread\n * annotations</a>.\n *\n * @see androidx.annotation.MainThread\n */\n@Documented\n@Retention(CLASS)\n@Target({METHOD,CONSTRUCTOR,TYPE,PARAMETER})\npublic @interface UiThread {\n}\n\n\n\n\n\n\n\n\nobject PayManager {\n\n\n    /**\n     * 支付宝 支付\n     * 需要在子线程运行\n     */\n    @WorkerThread\n    fun aliPay(context: Activity, aliPayParam: AliPayParam): PayResult {\n        val orderInfo = aliPayParam.order_info\n        val alipay = PayTask(context)\n        val result = alipay.payV2(orderInfo, true)\n        val payResult = AliPayResult(result)\n        val resultStatus = payResult.resultStatus\n        return when {\n            TextUtils.equals(resultStatus, AliPayResult.ALIPAY_OK) -> //表示支付ok\n                PayResult.SUCCEED\n            TextUtils.equals(resultStatus, AliPayResult.ALIPAY_CANCEL) -> //支付取消\n                PayResult.CANCELED\n            else -> //支付出错\n                PayResult.FAILED(errCode = resultStatus)\n        }\n    }\n\n    /***\n     * * @param activity Activity\n     * @param payParam 微信支付参数\n     * @param extData 额外的 数据参数\n     * @return  PayResult 支付结果\n     */\n    @WorkerThread\n    fun wechatPay(\n        activity: Activity, payParam: WePayParam,\n        extData: String = \"h5\"\n    ): PayResult {\n\n        val msgApi = WXAPIFactory.createWXAPI(activity, PayComponent.wxApi)\n        if (!msgApi.isWXAppInstalled) {\n            return PayResult.FAILED(errMsg = \"请安装微信客户端\")\n        }\n        val isPaySupported = msgApi.wxAppSupportAPI >= Build.PAY_SUPPORTED_SDK_INT\n        if (!isPaySupported) {\n            return PayResult.FAILED(errMsg = \"请更新微信客户端\")\n        }\n\n        msgApi.sendReq(PayReq().apply {\n            appId = payParam.appid\n            partnerId = payParam.partnerid\n            prepayId = payParam.prepayid\n            nonceStr = payParam.noncestr\n            timeStamp = payParam.timestamp\n            packageValue = payParam.packagee\n            sign = payParam.sign\n            this.extData = extData\n        })\n\n\n        return PayResult.HOLDON\n\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 支付结果\n */\nsealed class PayResult {\n    //成功\n    object SUCCEED : PayResult()\n    //失败\n    class FAILED(val errCode:String=\"\",val errMsg:String=\"\") : PayResult()\n    //取消\n    object CANCELED : PayResult()\n\n    //需要等待，可能打开了activity 没法实时返回结果\n    object HOLDON: PayResult()\n\n}\n\n\n\n\n\n\n\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.ks.component.payment\" >\n\n    <application>\n\n        <activity android:name=\"com.ks.lightlearn.wxapi.WXPayEntryActivity\"></activity>\n    </application>\n\n</manifest>\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598585028640},"updatedAt":{"$$date":1598586448201},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"m6dHDrMEMmWgcz0N"}
{"name":"mac 杀掉占用某个端口的进程/Linux 查看某个端口的进程","folderId":"6eW4X4NDu","content":[{"label":"Fragment 1","language":"text","value":"mac OS：\n\n两个小命令:\n\nlsof -i :端口\nkill -9 进程ID\n\nlinux ：\n\n查看端口：\n\nnetstat -an | grep 23"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1599053365659},"updatedAt":{"$$date":1599053368215},"_id":"mATYTqfTuO0QICW6","folder":{"id":"6eW4X4NDu","name":"jiqiao","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"css-CSS 组合选择符","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 组合选择符\nCSS 组合选择符\nNote\t组合选择符说明了两个选择器直接的关系。\nCSS组合选择符包括各种简单选择符的组合方式。\n\n在 CSS3 中包含了四种组合方式:\n\n后代选择器(以空格分隔)\n子元素选择器(以大于号分隔）\n相邻兄弟选择器（以加号分隔）\n普通兄弟选择器（以破折号分隔）\n后代选择器\n后代选择器用于选取某元素的后代元素。\n\n以下实例选取所有 <p> 元素插入到 <div> 元素中: \n\n实例\ndiv p\n{\n  background-color:yellow;\n}\n\n尝试一下 »\n\n子元素选择器\n与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素子元素的元素。\n\n以下实例选择了<div>元素中所有直接子元素 <p> ：\n\n实例\ndiv>p\n{\n  background-color:yellow;\n}\n\n尝试一下 »\n\n相邻兄弟选择器\n相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素。\n\n如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器（Adjacent sibling selector）。\n\n以下实例选取了所有位于 <div> 元素后的第一个 <p> 元素:\n\n实例\ndiv+p\n{\n  background-color:yellow;\n}\n\n尝试一下 »\n\n后续兄弟选择器\n后续兄弟选择器选取所有指定元素之后的相邻兄弟元素。\n\n以下实例选取了所有 <div> 元素之后的所有相邻兄弟元素 <p> : \n\n实例\ndiv~p\n{\n  background-color:yellow;\n}\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973611113},"updatedAt":{"$$date":1598973824784},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"mBH3nJtJnjOVkaa2"}
{"name":"ad-frame_log","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion 30\n    buildToolsVersion \"30.0.1\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 30\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n    implementation 'androidx.core:core-ktx:1.3.1'\n    implementation 'androidx.appcompat:appcompat:1.2.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n}\n\n\n\n\n\n/**\n *\n * @Author hailufeng\n * 邮箱：hilofeng@homail.com\n * 创建时间: 2020/8/20  11:55 AM\n * 用途 日志打印抽象\n * **************************************\n */\ninterface ILogger {\n\n    fun e(tag:String,m:String)\n    fun d(tag:String,m:String)\n    fun i(tag:String,m:String)\n    fun w(tag:String,m:String)\n\n}\n\n\n\nobject Loger :ILogger {\n    override fun e(tag: String, m: String) {\n\n    }\n\n    override fun d(tag: String, m: String) {\n\n    }\n\n    override fun i(tag: String, m: String) {\n\n    }\n\n    override fun w(tag: String, m: String) {\n\n    }\n\n    fun setPriority( logLevel:Int){\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539552878},"updatedAt":{"$$date":1598542515101},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"mD5PUR6WCiG3Jijt"}
{"name":"ad-ksliulishuodownload","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n//    lintOptions {\n//        // This seems to be firing due to okio referencing java.nio.File\n//        // which is harmless for us.\n//        warning 'InvalidPackage',\n//                // don't need parcel creator for the sub-class of MessageSnapshot.\n//                'ParcelCreator'\n//        // avoid warning for \"Not all execution paths return a value\"\n//        return true\n//    }\n    lintOptions {\n        abortOnError false\n    }\n\n}\n\ndependencies {\n    implementation deps.okhttp3.okhttp\n    implementation deps.androidx.junit\n    compileOnly project(':ksutils')\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\nutil\nDownloadServiceNotConnectedHelper\nFileDownloadExecutors\nFileDownloadHelper\nFileDownloadLog\nFileDownloadProperties\nFileDownloadUtils\nBaseDownloadTask\nDownloadSpeedMonitor\nDownloadTask\nDownloadTaskHunter\nFileDownloadConnectListener\nFileDownloader\nFileDownloadEventPool\nFileDownloadLargeFileListener\nFileDownloadList\nFileDownloadListener\nFileDownloadMessageStation\nFileDownloadMessenger\nFileDownloadMonitor\nFileDownloadQueueSet\nFileDownloadSampleListener\nFileDownloadServiceProxy\nFileDownloadServiceSharedTransmit\nFileDownloadServiceUIGuard\nFileDownloadTaskLauncher\nIDownloadSpeed\nIFileDownloadMessenger\nIFileDownloadServiceProxy\nILostServiceConnectedHandler\nIQueuesHandler\nITaskHunter\nIThreadPoolMonitor\nLostServiceConnectedHandler\nMessageSnapshotGate\nQueuesHandler"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521314619},"updatedAt":{"$$date":1598522423601},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"mFlzwPYdpQFgycph"}
{"name":"CSS 图片","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"本章节将为大家介绍如何使用 CSS 来布局图片。\n\n圆角图片\n实例\n圆角图片:\n\nimg {\n    border-radius: 8px;\n}\n\n尝试一下 »\n实例\n椭圆形图片:\n\nimg {\n    border-radius: 50%;\n}\n\n尝试一下 »\n缩略图\n我们使用 border 属性来创建缩略图。\n\n实例\nimg {\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    padding: 5px;\n}\n\n<img src=\"paris.jpg\" alt=\"Paris\">\n\n尝试一下 »\n实例\na {\n    display: inline-block;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    padding: 5px;\n    transition: 0.3s;\n}\n\na:hover {\n    box-shadow: 0 0 2px 1px rgba\n    (0, 140, 186, 0.5);\n}\n\n<a href=\"paris.jpg\">\n  <img src=\"paris.jpg\" alt=\"Paris\">\n</a>\n\n尝试一下 »\n响应式图片\n响应式图片会自动适配各种尺寸的屏幕。\n\n实例中，你可以通过重置浏览器大小查看效果:\n\nNorway\n\n如果你需要自由缩放图片，且图片放大的尺寸不大于其原始的最大值，则可使用以下代码：\n\n实例\nimg {\n    max-width: 100%;\n    height: auto;\n}\n\n尝试一下 »\n提示: Web 响应式设计更多内容可以参考 CSS 响应式设计教程。\n\n图片文本\n如何定位图片文本:\n\n实例\nNorway左下角左上角右上角右下角居中\n尝试一下:\n\n左上角 » 右上角 » 左下角 » 右下角 » 居中 »\n卡片式图片\n实例\ndiv.polaroid {\n    width: 80%;\n    background-color: white;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n}\n\nimg {width: 100%}\n\ndiv.container {\n    text-align: center;\n    padding: 10px 20px;\n}\n\n尝试一下 »\n图片滤镜\nCSS filter 属性用为元素添加可视效果 (例如：模糊与饱和度) 。\n\n注意: Internet Explorer 或 Safari 5.1 (及更早版本) 不支持该属性。\n\n实例\n修改所有图片的颜色为黑白 (100% 灰度):\n\nimg {\n    -webkit-filter: grayscale(100%); /* Chrome, Safari, Opera */\n    filter: grayscale(100%);\n}\n\n\n尝试一下 »\n提示: 访问 CSS 滤镜参考手册 查看更多内容。\n\n响应式图片相册\n实例\n.responsive {\n    padding: 0 6px;\n    float: left;\n    width: 24.99999%;\n}\n\n@media only screen and (max-width: 700px){\n    .responsive {\n        width: 49.99999%;\n        margin: 6px 0;\n    }\n}\n\n@media only screen and (max-width: 500px){\n    .responsive {\n        width: 100%;\n    }\n}\n\n尝试一下 »\n图片 Modal(模态)\n本实例演示了如何结合 CSS 和 JavaScript 来一起渲染图片。\n\n首先，我们使用 CSS 来创建 modal 窗口 (对话框), 默认是隐藏的。\n\n然后，我们使用 JavaScript 来显示模态窗口，当我们点击图片时，图片会在弹出的窗口中显示：\n\n实例\n// 获取模态窗口\nvar modal = document.getElementById('myModal');\n\n// 获取图片模态框，alt 属性作为图片弹出中文本描述\nvar img = document.getElementById('myImg');\nvar modalImg = document.getElementById(\"img01\");\nvar captionText = document.getElementById(\"caption\");\nimg.onclick = function(){\n    modal.style.display = \"block\";\n    modalImg.src = this.src;\n    modalImg.alt = this.alt;\n    captionText.innerHTML = this.alt;\n}\n\n// Get the <span> element that closes the modal\nvar span = document.getElementsByClassName(\"close\")[0];\n\n// When the user clicks on <span> (x), close the modal\nspan.onclick = function() {\n    modal.style.display = \"none\";\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974625215},"updatedAt":{"$$date":1598975222475},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"mGZK3C6DzSL0L4Zx"}
{"name":"qk-ks_kotlin_lib_versions.gradle","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndef versions = [\n\n        ks_lib_net_version                : '1.0.7.9',\n        ks_lib_share_version              : '1.0.1',\n        ks_lib_route_version              : '1.0.5.2',\n        ks_lib_ktx_version                : '1.0.10',\n        ks_lib_persistence_version        : '1.0.4.2-SNAPSHOT',\n        ks_lib_autosize_version           : '1.0.0',\n        ks_lib_picture_version            : '1.0.3.3',\n        ks_lib_proguard_version           : '1.0.1',\n        ks_lib_wheel_picker_version       : '1.0.5',\n        ks_lib_magic_indicator            : '1.0.5',\n        ks_lib_xtablayout_version         : '1.0.1',\n        ks_lib_appmerge_version           : '1.0.6',\n        ks_lib_appmerge_plugin_version    : '1.0.7.2',\n        ks_lib_address_selector_version   : '1.1.1',\n        ks_lib_pull_refresh_version       : '1.0.5',\n        ks_lib_loading_version            : '1.0.2',\n\n        ks_component_payment_version      : '1.0.4',\n        ks_component_login_version        : '1.1.0',\n        ks_component_net_version          : '1.2.0',\n        ks_component_resource_version     : '1.0.0',\n        ks_component_sobot_version        : '1.0.14.1-SNAPSHOT',\n        ks_component_mediaplayer_version  : '1.1.8.14',\n        ks_component_push_version         : '1.0.14.9',\n        ks_component_tracker_version      : '1.0.6.9',\n        ks_component_share_version        : '1.0.6',\n        ks_component_download_version     : '1.0.3.1',\n        ks_component_voicerecorder_version: '1.0.3.1'\n]\next {\n    ks = [\n\n            lib_net                : \"com.ks.kotlin:ks-lib-net:${versions.ks_lib_net_version}\",\n            lib_share              : \"com.ks.kotlin:ks-lib-share:${versions.ks_lib_share_version}\",\n            lib_ktx                : \"com.ks.kotlin:ks-lib-ktx:${versions.ks_lib_ktx_version}\",\n            lib_persistence        : \"com.ks.kotlin:ks-lib-persistence:${versions.ks_lib_persistence_version}\",\n            lib_route              : \"com.ks.kotlin:ks-lib-route:${versions.ks_lib_route_version}\",\n            lib_autosize           : \"com.ks.kotlin:ks-lib-autosize:${versions.ks_lib_autosize_version}\",\n            lib_picture            : \"com.ks.kotlin:ks-lib-picture:${versions.ks_lib_picture_version}\",\n            lib_proguard           : \"com.ks.kotlin:ks-lib-proguard:${versions.ks_lib_proguard_version}\",\n            lib_wheel_picker       : \"com.ks.kotlin:ks-lib-wheel-picker:${versions.ks_lib_wheel_picker_version}\",\n            lib_magic_indicator    : \"com.ks.kotlin:ks-lib-magicindicator:${versions.ks_lib_magic_indicator}\",\n            lib_xtablayout         : \"com.ks.kotlin:ks-lib-xtablayout:${versions.ks_lib_xtablayout_version}\",\n            lib_appmerge           : \"com.ks.kotlin:ks-lib-appmerge:${versions.ks_lib_appmerge_version}\",\n            lib_appmerge_plugin    : \"com.ks.kotlin:ks-lib-appmerge-plugin:${versions.ks_lib_appmerge_plugin_version}\",\n            lib_address_selector   : \"com.ks.kotlin:ks-lib-address-selector:${versions.ks_lib_address_selector_version}\",\n            lib_pull_refresh       : \"com.ks.kotlin:ks-lib-pull-refresh:${versions.ks_lib_pull_refresh_version}\",\n            lib_loading            : \"com.ks.kotlin:ks-lib-loadinglayout:${versions.ks_lib_loading_version}\",\n\n            component_net          : \"com.ks.kotlin:ks-component-net:${versions.ks_component_net_version}\",\n            component_login        : \"com.ks.kotlin:ks-component-login:${versions.ks_component_login_version}\",\n            component_payment      : \"com.ks.kotlin:ks-component-payment:${versions.ks_component_payment_version}\",\n            component_resource     : \"com.ks.kotlin:ks-component-resource:${versions.ks_component_resource_version}\",\n            component_delegate     : \"com.ks.kotlin:ks-component-delegate:${versions.ks_component_delegate_version}\",\n            component_sobot        : \"com.ks.kotlin:ks-component-sobot:${versions.ks_component_sobot_version}\",\n            component_mediaplayer  : \"com.ks.kotlin:ks-component-mediaplayer:${versions.ks_component_mediaplayer_version}\",\n            component_push         : \"com.ks.kotlin:ks-component-push:${versions.ks_component_push_version}\",\n            component_tracker      : \"com.ks.kotlin:ks-component-tracker:${versions.ks_component_tracker_version}\",\n            component_share        : \"com.ks.kotlin:ks-component-share:${versions.ks_component_share_version}\",\n            component_download     : \"com.ks.kotlin:ks-component-download:${versions.ks_component_download_version}\",\n            component_voicerecorder: \"com.ks.kotlin:ks-component-voicerecorder:${versions.ks_component_voicerecorder_version}\",\n\n\n\n            // 插件相关，transform开头的是transformer，task开头的是gradle task\n            transform_relinker     : \"com.ks.plugin:ks-transform-relinker:1.2.4-SNAPSHOT\",\n            task_robust_encoder    : \"com.ks.plugin:ks-task-robust-encoder:1.4.2-SNAPSHOT\"\n    ]\n}\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580895714},"updatedAt":{"$$date":1598581098096},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"mTmoloxqzW1LUwzD"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977492065},"updatedAt":{"$$date":1594977492065},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"mWslsYzOUdDNtGza"}
{"name":"html-HTML5 浏览器支持","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\nHTML5 浏览器支持\n你可以让一些较早的浏览器（不支持HTML5）支持 HTML5。\n\nHTML5 浏览器支持\n现代的浏览器都支持 HTML5。\n\n此外，所有浏览器，包括旧的和最新的，对无法识别的元素会作为内联元素自动处理。\n\n正因为如此，你可以 \"教会\" 浏览器处理 \"未知\" 的 HTML 元素。\n\nNote\t甚至你可以教会 IE6 (Windows XP 2001) 浏览器处理未知的 HTML 元素。\n将 HTML5 元素定义为块元素\nHTML5 定了 8 个新的 HTML 语义（semantic） 元素。所有这些元素都是 块级 元素。\n\n为了能让旧版本的浏览器正确显示这些元素，你可以设置 CSS 的 display 属性值为 block:\n\n实例\nheader, section, footer, aside, nav, main, article, figure {\n    display: block; \n}\n\n为 HTML 添加新元素\n你可以为 HTML 添加新的元素。\n\n该实例向 HTML 添加的新的元素，并为该元素定义样式，元素名为 <myHero> ：\n\n实例\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\"> \n<title>为 HTML 添加新元素</title>\n<script>\ndocument.createElement(\"myHero\")\n</script>\n<style>\nmyHero {\n    display: block;\n    background-color: #ddd;\n    padding: 50px;\n    font-size: 30px;\n}\n</style> \n</head>\n \n<body>\n \n<h1>我的第一个标题</h1>\n \n<p>我的第一个段落。</p>\n \n<myHero>我的第一个新元素</myHero>\n \n</body>\n</html>\n\n尝试一下 »\nJavaScript 语句 document.createElement(\"myHero\") 是为 IE 浏览器添加新的元素。\n\nInternet Explorer 浏览器问题\n你可以使用以上的方法来为 IE 浏览器添加 HTML5 元素，但是：\n\nNote\tInternet Explorer 8 及更早 IE 版本的浏览器不支持以上的方式。\n我们可以使用 Sjoerd Visscher 创建的 \"HTML5 Enabling JavaScript\", \" shiv\" 来解决该问题:\n\n<!--[if lt IE 9]>\n  <script src=\"http://html5shiv.googlecode.com/svn/trunk/html5.js\"></script>\n<![endif]-->\n以上代码是一个注释，作用是在 IE 浏览器的版本小于 IE9 时将读取 html5.js 文件，并解析它。\n\n注意：国内用户请使用本站静态资源库（Google 资源库在国内不稳定）：\n\n<!--[if lt IE 9]>\n  <script src=\"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\"></script>\n<![endif]-->\n针对IE浏览器html5shiv 是比较好的解决方案。html5shiv主要解决HTML5提出的新的元素不被IE6-8识别，这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。\n\n完美的 Shiv 解决方案\n实例\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>渲染 HTML5</title>\n  <!--[if lt IE 9]>\n  <script src=\"http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js\"></script>\n  <![endif]-->\n</head>\n \n<body>\n \n<h1>我的第一篇文章</h1>\n \n<article>\n菜鸟教程 —— 学的不仅是技术，更是梦想！！！\n</article>\n \n</body>\n</html>\n\n尝试一下 »\nhtml5shiv.js 引用代码必须放在 <head> 元素中，因为 IE 浏览器在解析 HTML5 新元素时需要先加载该文件。\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886145180},"updatedAt":{"$$date":1598887238637},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"mfyuKA7lEjhOZejQ"}
{"name":"ad-ksloadpic","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    api ks.ksdiskframe\n    implementation deps.androidx.annotations_experimental\n    implementation deps.androidx.core\n    implementation deps.fresco.fresco\n    implementation deps.fresco.imagepipeline_okhttp ,{\n        exclude group: \"com.squareup.okio\", module: \"okio\"\n    }\n    implementation deps.fresco.animated_gif\n\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\npublic class FrescoConfigConstants {\n    private static final int MAX_HEAP_SIZE = (int) Runtime.getRuntime().maxMemory();\n\n    public static final int MAX_DISK_CACHE_SIZE = 40 * 1048576;//磁盘缓存40m\n    public static final int MAX_MEMORY_CACHE_SIZE = MAX_HEAP_SIZE / 4;  //\n}\n\n\n\n\n\n\n\n\n\npublic class FrescoUtils {\n\n\n    private static String APP_PACKAGENAME_RES = \"res://packagename/\";\n\n    public static void mustInit(Context context, String app_packagename_res) {\n        APP_PACKAGENAME_RES = app_packagename_res;\n        Fresco.initialize(context,\n                FrescoImagePipelineConfigFactory.getOkHttpImagePipelineConfig(context));\n    }\n\n    //type = 2\n//\tprivate static GenericDraweeHierarchy  getRoundCornorParam(Context context){\n//\t\tGenericDraweeHierarchy gdh = new GenericDraweeHierarchyBuilder(context.getResources())\n//\t\t\t\t.setPlaceholderImage(Drawables.sPlaceholderDrawable)\n//\t\t\t\t.setFailureImage(Drawables.sErrorDrawable)\n//\t\t\t\t.setRoundingParams(RoundingParams.fromCornersRadius(CommonUtils.dp2px(context, 3)))\n//\t\t\t\t.setProgressBarImage(null)\n//\t\t\t\t.build();\n//\t\treturn gdh;\n//\t}\n//\t//type = 3\n//\tprivate static GenericDraweeHierarchy getNormalParam(Context context){\n//\t\tGenericDraweeHierarchy gdh = new GenericDraweeHierarchyBuilder(context.getResources())\n//\t\t\t\t.setPlaceholderImage(Drawables.sPlaceholderDrawable)\n//\t\t\t\t.setFailureImage(Drawables.sErrorDrawable)\n//\t\t\t\t.setProgressBarImage(null)\n//\t\t\t\t.build();\n//\t\treturn gdh;\n//\t}\n//\t//type = 1\n//\tprivate static GenericDraweeHierarchy  getRoundingParam(Context context){\n//\t\tGenericDraweeHierarchy gdh = new GenericDraweeHierarchyBuilder(context.getResources())\n//\t\t\t\t.setPlaceholderImage(Drawables.sPlaceholderDrawable)\n//\t\t\t\t.setFailureImage(Drawables.sErrorDrawable)\n//\t\t\t\t.setRoundingParams(RoundingParams.asCircle().setBorder(Color.parseColor(\"#99E0C5F1\"),\n//\t\t\t\t\t\tCommonUtils.dp2px(context, 3)))\n//\t\t\t\t.setProgressBarImage(null)\n//\t\t\t\t.build();\n//\t\treturn gdh;\n//\t}\n\n//    类型\tScheme\t示例\n//    远程图片\thttp://, https://\tHttpURLConnection 或者参考 使用其他网络加载方案\n//    本地文件\tfile://\tFileInputStream\n//    Content provider\tcontent://\tContentResolver\n//    asset目录下的资源\tasset://\tAssetManager\n//    res目录下的资源\tres://\tResources.openRawResource\n//    res 示例:\n//\n//    Uri uri = Uri.parse(\"res://包名(实际可以是任何字符串甚至留空)/\" + R.drawable.kaishuicon);\n\n    public static void bindFrescoFromFile(\n            SimpleDraweeView draweeView,\n            String filePath\n    ) {\n        String uri = \"file://\" + filePath;\n\n        ImageRequest imageRequest =\n                ImageRequestBuilder.newBuilderWithSource(Uri.parse(uri))\n                        .setProgressiveRenderingEnabled(true)\n                        .build();\n        DraweeController draweeController = Fresco.newDraweeControllerBuilder()\n                .setImageRequest(imageRequest)\n                .setOldController(draweeView.getController())\n                .setControllerListener(null)\n                .setAutoPlayAnimations(true)\n                .setTapToRetryEnabled(true)\n                .build();\n        draweeView.setController(draweeController);\n\n    }\n\n\n    public static void bindFrescoFromResource( SimpleDraweeView draweeView, int id) {\n        if (draweeView == null || id == -1) {\n            return;\n        }\n        String uri = APP_PACKAGENAME_RES + id;\n\n        draweeView.setImageURI(Uri.parse(uri));\n    }\n\n    public static void bindGifFromAsset(\n            SimpleDraweeView draweeView, String assetGifName) {\n        String uri = \"asset:///\" + assetGifName + \".gif\";\n        DraweeController gifController = Fresco.newDraweeControllerBuilder()\n                .setUri(Uri.parse(uri))\n                .setAutoPlayAnimations(true)\n                .build();\n        draweeView.setController(gifController);\n    }\n\n    /**\n     * gif多次设置闪动的bug\n     *\n     * @param tagId\n     * @param draweeView\n     * @param assetGifName\n     */\n    public static void bindGifFromAssetAddTag(int tagId, SimpleDraweeView draweeView, String assetGifName) {\n        if (!TextUtils.isEmpty(assetGifName)) {\n            String tag = (String) draweeView.getTag(tagId);\n            if (tag != null && !TextUtils.isEmpty(tag) && assetGifName.equals(tag)) {\n                //do nothing\n            } else {\n                draweeView.setTag(tagId, assetGifName);\n                String uri = \"asset:///\" + assetGifName + \".gif\";\n                DraweeController gifController = Fresco.newDraweeControllerBuilder()\n                        .setUri(uri)\n                        .setAutoPlayAnimations(true)\n                        .build();\n                draweeView.setController(gifController);\n            }\n        }\n    }\n\n    static DraweeController draweeController;\n\n    public static void bindGifFromResourceNewAddTag(int tagId, SimpleDraweeView draweeView, String url) {\n        if (!TextUtils.isEmpty(url)) {\n            String tag = (String) draweeView.getTag(tagId);\n            if (tag != null && !TextUtils.isEmpty(tag) && url.equals(tag)) {\n                //do nothing\n                if (draweeController != null) {\n                    Animatable animatable = draweeController.getAnimatable();\n                    if (animatable != null && !animatable.isRunning()) {\n                        animatable.start();\n                    }\n                }\n            } else {\n                draweeView.setTag(tagId, url);\n                Uri uri8Step = Uri.parse(url);\n                draweeController =\n                        Fresco.ss()\n                                .setUri(uri8Step)\n                                .setAutoPlayAnimations(true) // 设置加载图片完成后是否直接进行播放\n                                .build();\n                draweeView.setController(draweeController);\n            }\n        }\n    }\n\n    public static void bindGifFromResourceNew(SimpleDraweeView draweeView, String url) {\n        if (TextUtils.isEmpty(url)) {\n            return;\n        }\n        Uri uri8Step = Uri.parse(url);\n\n        DraweeController draweeController =\n                Fresco.newDraweeControllerBuilder()\n                        .setUri(uri8Step)\n                        .setAutoPlayAnimations(true) // 设置加载图片完成后是否直接进行播放\n                        .build();\n        draweeView.setController(draweeController);\n    }\n\n\n    public static void bindgifFromResource(\n            SimpleDraweeView draweeView,\n            String ss) {\n        DraweeController gifController = Fresco.newDraweeControllerBuilder()\n                .setAutoPlayAnimations(true)\n                .setUri(ss)\n                .build();\n        draweeView.setController(gifController);\n    }\n\n\n    public static void bindFrescoWithFail(DraweeView draweeView, String url) {\n        if (TextUtils.isEmpty(url)) {\n            return;\n        }\n        DraweeController failureImageDraweeController = Fresco.newDraweeControllerBuilder()\n                .setUri(url)\n                .setTapToRetryEnabled(false)\n                .setOldController(draweeView.getController())\n                .build();\n        draweeView.setController(failureImageDraweeController);\n    }\n\n\n    /**\n     * 处理高斯模糊\n     */\n    public static void dealWithBlur(Context context, SimpleDraweeView simpleDraweeView, String url, int radius) {\n        if (context == null || !(context instanceof Activity)) {\n            return;\n        }\n\n        if (TextUtils.isEmpty(url)) {\n            return;\n        }\n        try {\n            blur(context, simpleDraweeView, Uri.parse(url), radius);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void blur(Context context, SimpleDraweeView bandImage, Uri uri, int radius) {\n        if (context == null || !(context instanceof Activity)) {\n            return;\n        }\n        if (uri == null) {\n            return;\n        }\n\n        try {\n            ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri)\n                    .setPostprocessor(new IterativeBoxBlurPostProcessor(6, radius))\n                    .build();\n            AbstractDraweeController controller = Fresco.newDraweeControllerBuilder()\n                    .setOldController(bandImage.getController())\n                    .setImageRequest(request)\n                    .build();\n            bandImage.setController(controller);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public static void prefetchImageArray(String[] urls) {\n        for (int i = 0; i < urls.length; i++) {\n            prefetchImage(urls[i]);\n        }\n    }\n\n    public static void prefetchImage(String url) {\n        if (TextUtils.isEmpty(url)) {\n            return;\n        }\n        ImageRequest imageRequest =\n                ImageRequestBuilder.newBuilderWithSource(Uri.parse(url))\n                        .build();\n        Fresco.getImagePipeline().prefetchToDiskCache(imageRequest, null);\n    }\n\n    public interface ImageListener<T> {\n        void onSuccess(T bitmap);\n\n        void onFail(Throwable error);\n    }\n\n    //加载图片，在ImageListener回调里获取返回的Bitmap\n    public static void getBitmap(Context context, String url, final ImageListener<Bitmap> imageListener) {\n        //参考自https://github.com/hpdx/fresco-helper/blob/master/fresco-helper/src/main/java/com/facebook/fresco/helper/ImageLoader.java\n        if (TextUtils.isEmpty(url)) {\n            return;\n        }\n        Uri uri = Uri.parse(url);\n        ImagePipeline imagePipeline = Fresco.getImagePipeline();\n        ImageRequestBuilder builder = ImageRequestBuilder.newBuilderWithSource(uri);\n        ImageRequest imageRequest = builder.build();\n        DataSource<CloseableReference<CloseableImage>> dataSource = imagePipeline.fetchDecodedImage(imageRequest, context);\n        dataSource.subscribe(new BaseDataSubscriber<CloseableReference<CloseableImage>>() {\n            @Override\n            public void onNewResultImpl(DataSource<CloseableReference<CloseableImage>> dataSource) {\n                if (!dataSource.isFinished()) {\n                    return;\n                }\n\n                CloseableReference<CloseableImage> imageReference = dataSource.getResult();\n                if (imageReference != null) {\n                    final CloseableReference<CloseableImage> closeableReference = imageReference.clone();\n                    try {\n                        CloseableImage closeableImage = closeableReference.get();\n                        //动图处理\n//                        if (closeableImage instanceof CloseableAnimatedImage) {\n//                            AnimatedImageResult animatedImageResult = ((CloseableAnimatedImage) closeableImage).getImageResult();\n//                            if (animatedImageResult != null && animatedImageResult.getImage() != null) {\n//                                int imageWidth = animatedImageResult.getImage().getWidth();\n//                                int imageHeight = animatedImageResult.getImage().getHeight();\n//\n//                                Bitmap.Config bitmapConfig = Bitmap.Config.ARGB_8888;\n//                                Bitmap bitmap = Bitmap.createBitmap(imageWidth, imageHeight, bitmapConfig);\n//                                animatedImageResult.getImage().getFrame(0).renderFrame(imageWidth, imageHeight, bitmap);\n//                                if (imageListener != null) {\n//                                    imageListener.onSuccess(bitmap);\n//                                }\n//                            }\n//                        }\n                        //非动图处理\n                        if (closeableImage instanceof CloseableBitmap) {\n                            CloseableBitmap closeableBitmap = (CloseableBitmap) closeableImage;\n                            Bitmap bitmap = closeableBitmap.getUnderlyingBitmap();\n                            if (bitmap != null && !bitmap.isRecycled()) {\n                                // https://github.com/facebook/fresco/issues/648\n                                final Bitmap tempBitmap = bitmap.copy(bitmap.getConfig(), false);\n                                if (imageListener != null) {\n                                    imageListener.onSuccess(tempBitmap);\n                                }\n                            }\n                        }\n                    } finally {\n                        imageReference.close();\n                        closeableReference.close();\n                    }\n                }\n            }\n\n            @Override\n            public void onFailureImpl(DataSource dataSource) {\n                Throwable throwable = dataSource.getFailureCause();\n                if (imageListener != null) {\n                    imageListener.onFail(throwable);\n                }\n            }\n        }, UiThreadImmediateExecutorService.getInstance());\n    }\n\n\n    private static Set<String> picCacheUris = new HashSet<>();//图片加载链接\n\n    public static void tryAddToCacheUrls(String url) {\n        if (picCacheUris != null && !picCacheUris.contains(url)) {\n            picCacheUris.add(url + \"\");\n        }\n    }\n\n    public static void tryClearMemoryCache() {\n        if (picCacheUris != null && picCacheUris.size() > 0) {\n            evictFromMemoryCache(picCacheUris);\n            picCacheUris.clear();\n        }\n    }\n\n    private static void evictFromMemoryCache(Set<String> picCacheUris) {\n        if (picCacheUris != null) {\n            for (String url : picCacheUris) {\n                try {\n                    Uri uri = Uri.parse(url);\n                    Fresco.getImagePipeline().evictFromCache(uri);\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521310519},"updatedAt":{"$$date":1598962593158},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"minq9SLupojJfql4"}
{"name":"py-参数组合","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n\n比如定义一个函数，包含上述若干种参数：\n\ndef f1(a, b, c=0, *args, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)\n\ndef f2(a, b, c=0, *, d, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)\n在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。\n\n>>> f1(1, 2)\na = 1 b = 2 c = 0 args = () kw = {}\n>>> f1(1, 2, c=3)\na = 1 b = 2 c = 3 args = () kw = {}\n>>> f1(1, 2, 3, 'a', 'b')\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {}\n>>> f1(1, 2, 3, 'a', 'b', x=99)\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}\n>>> f2(1, 2, d=99, ext=None)\na = 1 b = 2 c = 0 d = 99 kw = {'ext': None}\n最神奇的是通过一个tuple和dict，你也可以调用上述函数：\n\n>>> args = (1, 2, 3, 4)\n>>> kw = {'d': 99, 'x': '#'}\n>>> f1(*args, **kw)\na = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}\n>>> args = (1, 2, 3)\n>>> kw = {'d': 88, 'x': '#'}\n>>> f2(*args, **kw)\na = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}\n所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\n\n 虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977482517},"updatedAt":{"$$date":1594979486402},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"mkzk64xLn6ACNVl5"}
{"name":"html-HTML 标题","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\n标题（Heading）是通过 <h1> - <h6> 标签进行定义的。\n\n<h1> 定义最大的标题。 <h6> 定义最小的标题。\n\n实例\n<h1>这是一个标题。</h1>\n<h2>这是一个标题。</h2>\n<h3>这是一个标题。</h3>\n\n尝试一下 »\n注释: 浏览器会自动地在标题的前后添加空行。\n\n标题很重要\n请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成粗体或大号的文本而使用标题。\n\n搜索引擎使用标题为您的网页的结构和内容编制索引。\n\n因为用户可以通过标题来快速浏览您的网页，所以用标题来呈现文档结构是很重要的。\n\n应该将 h1 用作主标题（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。\n\nHTML 水平线\n<hr> 标签在 HTML 页面中创建水平线。\n\nhr 元素可用于分隔内容。\n\n实例\n<p>这是一个段落。</p>\n<hr>\n<p>这是一个段落。</p>\n<hr>\n<p>这是一个段落。</p>\n\n尝试一下 »\n\nHTML 注释\n可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。\n\n注释写法如下:\n\n实例\n<!-- 这是一个注释 -->\n\n尝试一下 »\n注释: 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。\n\nHTML 提示 - 如何查看源代码\n你是否看过一些网页然后惊叹它是如何实现的。\n\n如果您想找到其中的奥秘，只需要单击右键，然后选择\"查看源文件\"（IE）或\"查看页面源代码\"（Firefox），其他浏览器的做法也是类似的。这么做会打开一个包含页面 HTML 代码的窗口。\n\nExamples\n本站实例\n标题\n如何在 HTML 文档中显示标题。\n\n隐藏注释\n如何在 HTML 源代码中插入注释。\n\n水平线\n如何插入水平线。\n\nHTML 标签参考手册\n菜鸟教程的标签参考手册提供了有关这些标题及其属性的更多信息。\n\n您将在本教程下面的章节中学到更多有关 HTML 标签和属性的知识。\n\n标签\t描述\n<html>\t定义 HTML 文档\n<body>\t定义文档的主体\n<h1> - <h6>\t定义 HTML 标题\n<hr>\t定义水平线\n<!--...-->\t定义注释"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885696365},"updatedAt":{"$$date":1598886010077},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"n6HLcZu9mUgUZOqh"}
{"name":"kotlin-集合概述 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collections-overview.html\n集合概述 - Kotlin 语言中文站\n20-25 minutes\n改进翻译\nKotlin 标准库提供了一整套用于管理集合的工具，集合是可变数量（可能为零）的一组条目，各种集合对于解决问题都具有重要意义，并且经常用到。\n\n集合是大多数编程语言的常见概念，因此如果熟悉像 Java 或者 Python 语言的集合，那么可以跳过这一介绍转到详细部分。\n\n集合通常包含相同类型的一些（数目也可以为零）对象。集合中的对象称为元素或条目。例如，一个系的所有学生组成一个集合，可以用于计算他们的平均年龄。 以下是 Kotlin 相关的集合类型：\n\nList 是一个有序集合，可通过索引（反映元素位置的整数）访问元素。元素可以在 list 中出现多次。列表的一个示例是一句话：有一组字、这些字的顺序很重要并且字可以重复。\nSet 是唯一元素的集合。它反映了集合（set）的数学抽象：一组无重复的对象。一般来说 set 中元素的顺序并不重要。例如，字母表是字母的集合（set）。\nMap（或者字典）是一组键值对。键是唯一的，每个键都刚好映射到一个值。值可以重复。map 对于存储对象之间的逻辑连接非常有用，例如，员工的 ID 与员工的位置。\nKotlin 让你可以独立于所存储对象的确切类型来操作集合。换句话说，将 String 添加到 String list 中的方式与添加 Int 或者用户自定义类的到相应 list 中的方式相同。 因此，Kotlin 标准库为创建、填充、管理任何类型的集合提供了泛型的（通用的，双关）接口、类与函数。\n\n这些集合接口与相关函数位于 kotlin.collections 包中。我们来大致了解下其内容。\n\nKotlin 标准库提供了基本集合类型的实现： set、list 以及 map。 一对接口代表每种集合类型：\n\n一个 只读 接口，提供访问集合元素的操作。\n一个 可变 接口，通过写操作扩展相应的只读接口：添加、删除和更新其元素。\n请注意，更改可变集合不需要它是以 var 定义的变量：写操作修改同一个可变集合对象，因此引用不会改变。 但是，如果尝试对 val 集合重新赋值，你将收到编译错误。\n\nTarget platform: JVMRunning on kotlin v. 1.3.72\n\n只读集合类型是型变的。 这意味着，如果类 Rectangle 继承自 Shape，则可以在需要 List <Shape> 的任何地方使用 List <Rectangle>。 换句话说，集合类型与元素类型具有相同的子类型关系。 map 在值（value）类型上是型变的，但在键（key）类型上不是。\n\n反之，可变集合不是型变的；否则将导致运行时故障。 如果 MutableList <Rectangle> 是 MutableList <Shape> 的子类型，你可以在其中插入其他 Shape 的继承者（例如，Circle），从而违反了它的 Rectangle 类型参数。\n\n下面是 Kotlin 集合接口的图表：\n\nCollection interfaces hierarchy\n\n让我们来看看接口及其实现。\n\nCollection<T> 是集合层次结构的根。此接口表示一个只读集合的共同行为：检索大小、检测是否为成员等等。 Collection 继承自 Iterable <T> 接口，它定义了迭代元素的操作。可以使用 Collection 作为适用于不同集合类型的函数的参数。对于更具体的情况，请使用 Collection 的继承者： List 与 Set。\n\nfun printAll(strings: Collection<String>) {\n        for(s in strings) print(\"$s \")\n        println()\n    }\n    \nfun main() {\n    val stringList = listOf(\"one\", \"two\", \"one\")\n    printAll(stringList)\n    \n    val stringSet = setOf(\"one\", \"two\", \"three\")\n    printAll(stringSet)\n}\nMutableCollection 是一个具有写操作的 Collection 接口，例如 add 以及 remove。\n\nfun List<String>.getShortWordsTo(shortWords: MutableList<String>, maxLength: Int) {\n    this.filterTo(shortWords) { it.length <= maxLength }\n    // throwing away the articles\n    val articles = setOf(\"a\", \"A\", \"an\", \"An\", \"the\", \"The\")\n    shortWords -= articles\n}\n\nfun main() {\n    val words = \"A long time ago in a galaxy far far away\".split(\" \")\n    val shortWords = mutableListOf<String>()\n    words.getShortWordsTo(shortWords, 3)\n    println(shortWords)\n}\n\nList<T> 以指定的顺序存储元素，并提供使用索引访问元素的方法。索引从 0 开始 – 第一个元素的索引 – 直到 最后一个元素的索引 即 (list.size - 1)。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Number of elements: ${numbers.size}\")\n    println(\"Third element: ${numbers.get(2)}\")\n    println(\"Fourth element: ${numbers[3]}\")\n    println(\"Index of element \\\"two\\\" ${numbers.indexOf(\"two\")}\")\n//sampleEnd\n}\nList 元素（包括空值）可以重复：List 可以包含任意数量的相同对象或单个对象的出现。 如果两个 List 在相同的位置具有相同大小和相同结构的元素，则认为它们是相等的。\n\ndata class Person(var name: String, var age: Int)\n\nfun main() {\n//sampleStart\n    val bob = Person(\"Bob\", 31)\n    val people = listOf(Person(\"Adam\", 20), bob, bob)\n    val people2 = listOf(Person(\"Adam\", 20), Person(\"Bob\", 31), bob)\n    println(people == people2)\n    bob.age = 32\n    println(people == people2)\n//sampleEnd\n}\nMutableList<T> 是可以进行写操作的 List，例如用于在特定位置添加或删除元素。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    numbers.removeAt(1)\n    numbers[0] = 0\n    numbers.shuffle()\n    println(numbers)\n//sampleEnd\n}\n如你所见，在某些方面，List 与数组（Array）非常相似。 但是，有一个重要的区别：数组的大小是在初始化时定义的，永远不会改变; 反之，List 没有预定义的大小；作为写操作的结果，可以更改 List 的大小：添加，更新或删除元素。\n\n在 Kotlin 中，List 的默认实现是 ArrayList，可以将其视为可调整大小的数组。\n\nSet<T> 存储唯一的元素；它们的顺序通常是未定义的。null 元素也是唯一的：一个 Set 只能包含一个 null。当两个 set 具有相同的大小并且对于一个 set 中的每个元素都能在另一个 set 中存在相同元素，则两个 set 相等。\n\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)\n    println(\"Number of elements: ${numbers.size}\")\n    if (numbers.contains(1)) println(\"1 is in the set\")\n\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    println(\"The sets are equal: ${numbers == numbersBackwards}\")\n//sampleEnd\n}\nMutableSet 是一个带有来自 MutableCollection 的写操作接口的 Set。\n\nSet的默认实现 - LinkedHashSet – 保留元素插入的顺序。 因此，依赖于顺序的函数，例如 first() 或 last()，会在这些 set 上返回可预测的结果。\n\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)  // LinkedHashSet is the default implementation\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    \n    println(numbers.first() == numbersBackwards.first())\n    println(numbers.first() == numbersBackwards.last())\n//sampleEnd\n}\n另一种实现方式 – HashSet – 不声明元素的顺序，所以在它上面调用这些函数会返回不可预测的结果。但是，HashSet 只需要较少的内存来存储相同数量的元素。\n\nMap<K, V> 不是 Collection 接口的继承者；但是它也是 Kotlin 的一种集合类型。 Map 存储 键-值 对（或 条目）；键是唯一的，但是不同的键可以与相同的值配对。Map 接口提供特定的函数进行通过键访问值、搜索键和值等操作。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n    \n    println(\"All keys: ${numbersMap.keys}\")\n    println(\"All values: ${numbersMap.values}\")\n    if (\"key2\" in numbersMap) println(\"Value by key \\\"key2\\\": ${numbersMap[\"key2\"]}\")    \n    if (1 in numbersMap.values) println(\"The value 1 is in the map\")\n    if (numbersMap.containsValue(1)) println(\"The value 1 is in the map\") // 同上\n//sampleEnd\n}\n无论键值对的顺序如何，包含相同键值对的两个 Map 是相等的。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)    \n    val anotherMap = mapOf(\"key2\" to 2, \"key1\" to 1, \"key4\" to 1, \"key3\" to 3)\n    \n    println(\"The maps are equal: ${numbersMap == anotherMap}\")\n//sampleEnd\n}\nMutableMap 是一个具有写操作的 Map 接口，可以使用该接口添加一个新的键值对或更新给定键的值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    numbersMap[\"one\"] = 11\n\n    println(numbersMap)\n//sampleEnd\n}\nMap 的默认实现 – LinkedHashMap – 迭代 Map 时保留元素插入的顺序。 反之，另一种实现 – HashMap – 不声明元素的顺序。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308428714},"updatedAt":{"$$date":1597313874945},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"n9MiJr2HmNm0uIVh"}
{"name":"html-HTML 图像","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\nHTML 图像\n\n实例\nNorwegian Mountain Trip\nPulpit Rock\n\n尝试一下 »\nExamples\n在线实例\n插入图像\n本例演示如何在网页中显示图像。\n\n从不同的位置插入图片\n本例演示如何将其他文件夹或服务器的图片显示到网页中。\n\n（可以在本页底端找到更多实例。）\n\nHTML 图像- 图像标签（ <img>）和源属性（Src）\n在 HTML 中，图像由<img> 标签定义。\n\n<img> 是空标签，意思是说，它只包含属性，并且没有闭合标签。\n\n要在页面上显示图像，你需要使用源属性（src）。src 指 \"source\"。源属性的值是图像的 URL 地址。\n\n定义图像的语法是：\n\n<img src=\"url\" alt=\"some_text\">\nURL 指存储图像的位置。如果名为 \"pulpit.jpg\" 的图像位于 www.runoob.com 的 images 目录中，那么其 URL 为 http://www.runoob.com/images/pulpit.jpg。\n\n浏览器将图像显示在文档中图像标签出现的地方。如果你将图像标签置于两个段落之间，那么浏览器会首先显示第一个段落，然后显示图片，最后显示第二段。\n\nHTML 图像- Alt属性\nalt 属性用来为图像定义一串预备的可替换的文本。\n\n替换文本属性的值是用户定义的。\n\n<img src=\"boat.gif\" alt=\"Big Boat\">\n在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性是个好习惯，这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。\n\nHTML 图像- 设置图像的高度与宽度\nheight（高度） 与 width（宽度）属性用于设置图像的高度与宽度。\n\n属性值默认单位为像素:\n\n<img src=\"pulpit.jpg\" alt=\"Pulpit rock\" width=\"304\" height=\"228\">\n提示: 指定图像的高度和宽度是一个很好的习惯。如果图像指定了高度宽度，页面加载时就会保留指定的尺寸。如果没有指定图片的大小，加载页面时有可能会破坏HTML页面的整体布局。\n\n基本的注意事项 - 有用的提示：\n注意: 假如某个 HTML 文件包含十个图像，那么为了正确显示这个页面，需要加载 11 个文件。加载图片是需要时间的，所以我们的建议是：慎用图片。\n\n注意: 加载页面时，要注意插入页面图像的路径，如果不能正确设置图像的位置，浏览器无法加载图片，图像标签就会显示一个破碎的图片。\n\nExamples\n更多实例\n排列图片\n本例演示如何在文字中排列图像。\n\n浮动图像\n本例演示如何使图片浮动至段落的左边或右边。\n\n设置图像链接\n本例演示如何将图像作为一个链接使用。\n\n创建图像映射\n本例显示如何创建带有可供点击区域的图像地图。其中的每个区域都是一个超级链接。\n\nHTML 图像标签\n标签\t描述\n<img>\t定义图像\n<map>\t定义图像地图\n<area>\t定义图像地图中的可点击区域\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886123859},"updatedAt":{"$$date":1598886383831},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"nB9C3V5R6o33xYge"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598974610984},"updatedAt":{"$$date":1598974610984},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"nYnjASAo5mShan4s"}
{"name":"kotlin-IntDef","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\npackage com.ks.lightlearn.base.bean.h5;\n\nimport android.text.TextUtils;\n\nimport androidx.annotation.IntDef;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n/**\n * H5调用本地支付结束后 发送事件，支付成功 与否，给h5回调，让h5 去调用后台判断是否 支付成功显示相应的网页\n */\npublic class H5PayFinishEvent {\n    @SdkPayResult\n    private int payResultCode;\n\n    private String message;\n\n    public H5PayFinishEvent(@SdkPayResult int errCode) {\n        this.payResultCode = errCode;\n    }\n\n    public H5PayFinishEvent(int payResultCode, String message) {\n        this.payResultCode = payResultCode;\n        this.message = message;\n    }\n\n    public boolean isCancel() {\n        return payResultCode == SdkPayResult.PAY_CANCEL;\n    }\n\n    public boolean isPayFailed() {\n        return payResultCode == SdkPayResult.PAY_FAIL;\n    }\n\n    public boolean isPayFinish() {\n        return payResultCode == SdkPayResult.PAY_FINISH;\n    }\n\n    public String getMessage() {\n        return TextUtils.isEmpty(message) ? defaultMessage() : message;\n    }\n\n    private String defaultMessage() {\n        if (isPayFailed()) {\n            return \"支付失败\";\n        } else if (isCancel()) {\n            return \"支付取消\";\n        }\n        return \"\";\n    }\n\n    @IntDef({\n            SdkPayResult.PAY_FINISH,\n            SdkPayResult.PAY_CANCEL,\n            SdkPayResult.PAY_FAIL\n    })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface SdkPayResult {\n        int PAY_FINISH = 0;\n        int PAY_CANCEL = -2;\n        int PAY_FAIL = -1;\n    }\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403204892},"updatedAt":{"$$date":1597403644499},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ngJDutexBb19r0xB"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973281648},"updatedAt":{"$$date":1594973281648},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"nhPtihhOx0jffTp2"}
{"name":"kqapp-lightlearn_module_course","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n\nclass InfoEditStateView(private val editText:EditText) {\n\n    init {\n        editText.filters = arrayOf<InputFilter>(WordLengthFilter(120) { onReachMaxNumWords() })\n    }\n\n    fun showDisable(showTxt:String?){\n        editText.run {\n            isEnabled = false\n            setText(showTxt)\n            setBackgroundResource(R.drawable.course_ui_round_f8f5f0)\n        }\n\n    }\n\n    fun changeEditable(showTxt:String?,action: (content:String?)->Unit){\n        editText.run {\n            isEnabled = true\n            setText(showTxt)\n\n            doAfterTextChanged {\n                if (text.isNullOrEmpty()){\n                    setBackgroundResource(R.drawable.course_ui_round_ffffff_all_r17_border_d8d8d8)\n                }else{\n                    setBackgroundResource(R.drawable.course_ui_round_ffffff_all_r17_border_ffe34a)\n                }\n                action(it?.toString())\n            }\n\n           setOnFocusChangeListener { _, hasFocus ->\n                if (hasFocus) {\n                    val selectPosition = text.toString().length\n                    if (selectPosition >= 0) {\n                        setSelection(selectPosition)\n                    }\n                }\n            }\n        }\n    }\n\n\n    private fun onReachMaxNumWords(){\n        editText.context.toast(\"最多输入120个字符哦~\")\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass WordLengthFilter(private val maxCount:Int, val reachMax:()->Unit): InputFilter.LengthFilter(maxCount){\n\n    override fun filter(source: CharSequence?, start: Int, end: Int, dest: Spanned?, dstart: Int, dend: Int): CharSequence? {\n        if (source!=null&&dest!=null){\n            val keep: Int = maxCount - (dest.length - (dend - dstart))\n            when {\n                keep <= 0 -> {\n                    reachMax()\n                }\n                keep >= end - start -> {\n                }\n                else -> {\n                    reachMax()\n                }\n            }\n        }\n        return super.filter(source, start, end, dest, dstart, dend)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593265986},"updatedAt":{"$$date":1598598302166},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"nqgA4yHM3YK6S0lG"}
{"name":"html-","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598886126100},"updatedAt":{"$$date":1598886126100},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"o4qNHMf8cuLiZCes"}
{"name":"ad-ks_recored_video","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode build_versions.versionCode\n        versionName build_versions.versionName\n    }\n\n    splits {\n        abi {\n            enable true\n            reset()\n            include 'armeabi-v7a'\n            universalApk false\n        }\n    }\n\n    //这个是解决lint报错的代码\n    lintOptions {\n        abortOnError false\n    }\n\n    dexOptions {\n        preDexLibraries = false\n        //incremental true\n        javaMaxHeapSize \"4g\"\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    api fileTree(include: ['*.jar'], dir: 'libs')\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    implementation deps.kotlin.kotlin_core\n    implementation deps.androidx.recyclerview_v7\n    implementation deps.androidx.fragment\n\n    api deps.androidx.app_compat\n    api deps.androidx.constraint_layout\n    implementation 'androidx.legacy:legacy-support-v4:1.0.0'\n\n    //testImplementation 只在单元测试代码的编译以及最终打包测试apk时有效。\n    testImplementation deps.androidx.junit\n    //androidTestImplementation 只在Android相关单元测试代码的编译以及最终打包测试apk时有效。\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    //为了解决 kotlin data class ,fastjson 解析报 defalut constructor not found错误\n    implementation deps.kotlin.kotlin_reflect\n\n    implementation ks.ksdialogplus\n    api deps.rxjava2.rxjava\n    api deps.rxjava2.rxandroid\n\n\n    def camerax_version = \"1.0.0-beta07\"\n    def camerax_ext_version = \"1.0.0-alpha14\"\n    implementation \"androidx.camera:camera-lifecycle:$camerax_version\"\n    implementation \"androidx.camera:camera-core:$camerax_version\"\n    implementation \"androidx.camera:camera-view:$camerax_ext_version\"\n    implementation \"androidx.camera:camera-camera2:$camerax_version\"\n    implementation \"androidx.camera:camera-extensions:$camerax_ext_version\"\n    if(rootProject.ext.isUseMediaModle) {\n        implementation project(':ks_media_core')\n    }else {\n        implementation ks.mediacore\n    }\n}\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class FitTextureView extends TextureView {\n\n    private final static String TAG = \"AutoFitTextureView\";\n\n    private int ratioWidth = 0;\n    private int ratioHeight = 0;\n\n    public FitTextureView(Context context) {\n        super(context);\n    }\n\n    public FitTextureView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public FitTextureView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n\n//    public FitTextureView(Context context, SurfaceTextureListener surfaceTextureListener) {\n//        super(context, null);\n//        setSurfaceTextureListener(surfaceTextureListener);\n//    }\n\n    /*\n     * Sets the aspect ratio for this view. The size of the view will be measured based on the ratio\n     * calculated fromList the parameters. Note that the actual sizes of parameters don't matter, that\n     * is, calling setAspectRatio(2, 3) and setAspectRatio(4, 6) make the same result.\n     *\n     * @param width  Relative horizontal size\n     * @param height Relative vertical size\n     */\n    public void setAspectRatio(int width, int height) {\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\"Size cannot be negative.\");\n        }\n        ratioWidth = width;\n        ratioHeight = height;\n\n        requestLayout();\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        final int width = resolveSize(getSuggestedMinimumWidth(), widthMeasureSpec);\n        final int height = resolveSize(getSuggestedMinimumHeight(), heightMeasureSpec);\n\n        if (0 == ratioWidth || 0 == ratioHeight) {\n            setMeasuredDimension(width, height);\n        } else {\n            if (width < height * (ratioWidth / (float) ratioHeight)) {\n                setMeasuredDimension(width, (int) (width * (ratioWidth / (float) ratioHeight)));\n            } else {\n                setMeasuredDimension((int) (height * (ratioWidth / (float) ratioHeight)), height);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522800701},"updatedAt":{"$$date":1598524110793},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"o7loQe9Ph5gRJ6De"}
{"name":"kotlin-【码上开学】Kotlin 里那些「不是那么写的」 - 掘金","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\njuejin.im /post/6844903920536551431\n【码上开学】Kotlin 里那些「不是那么写的」 - 掘金\n扔物线 2019年08月21日 阅读 8111 已关注\n15-19 minutes\n本期作者：\n\n视频：扔物线（朱凯）\n\n文章：Walker（张磊）\n\n大家好，我是扔物线朱凯。这是码上开学 Kotlin 基础部分的第二期：Kotlin 里那些「不是那么写的」。话不多说，视频伺候。\n\n因为我一直没有学会怎么在掘金贴视频，所以请点击 这里 去哔哩哔哩看，或者点击 这里 去 YouTube 看。\n\n以下内容来自文章作者 Walker。\n\n上一篇我们讲了 Kotlin 上手最基础的三个点：变量、函数和类型。大家都听说过，Kotlin 完全兼容 Java，这个意思是用 Java 写出来的代码和 Kotlin 可以完美交互，而不是说你用 Java 的写法去写 Kotlin 就完全没问题，这个是不行的。这期内容我们就讲一下，Kotlin 里那些「不 Java」的写法。\n\nConstructor\n上一篇中简单介绍了 Kotlin 的构造器，这一节具体看看 Kotlin 的构造器和 Java 有什么不一样的地方：\n\nJava\n\n☕️\npublic class User {\n    int id;\n    String name;\n      👇   👇\n    public User(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n复制代码\nKotlin\n\n🏝️\nclass User {\n    val id: Int\n    val name: String\n         👇\n    constructor(id: Int, name: String) {\n \n        this.id = id\n        this.name = name\n    }\n}\n复制代码\n可以发现有两点不同：\n\nJava 中构造器和类同名，Kotlin 中使用 constructor 表示。\nKotlin 中构造器没有 public 修饰，因为默认可见性就是公开的（关于可见性修饰符这里先不展开，后面会讲到）。\ninit\n除了构造器，Java 里常常配合一起使用的 init 代码块，在 Kotlin 里的写法也有了一点点改变：你需要给它加一个 init 前缀。\n\nJava\n\n☕️\npublic class User {\n   👇\n    {\n        \n    }\n    public User() {\n    }\n}\n复制代码\nKotlin\n\n🏝️\nclass User {\n    👇\n    init {\n        \n    }\n    constructor() {\n    }\n}\n复制代码\n正如上面标注的那样，Kotlin 的 init 代码块和 Java 一样，都在实例化时执行，并且执行顺序都在构造器之前。\n\n上一篇提到，Java 的类如果不加 final 关键字，默认是可以被继承的，而 Kotlin 的类默认就是 final 的。在 Java 里 final 还可以用来修饰变量，接下来让我们看看 Kotlin 是如何实现类似功能的。\n\nfinal\nKotlin 中的 val 和 Java 中的 final 类似，表示只读变量，不能修改。这里分别从成员变量、参数和局部变量来和 Java 做对比：\n\nJava\n\n☕️\n 👇\nfinal int final1 = 1;\n             👇  \nvoid method(final String final2) {\n     👇\n    final String final3 = \"The parameter is \" + final2;\n}\n复制代码\nKotlin\n\n🏝️\n👇\nval fina1 = 1\n       \nfun method(final2: String) {\n    👇\n    val final3 = \"The parameter is \" + final2\n}\n复制代码\n可以看到不同点主要有：\n\nfinal 变成了 val。\nKotlin 函数参数默认是 val 类型，所以参数前不需要写 val 关键字，Kotlin 里这样设计的原因是保证了参数不会被修改，而 Java 的参数可修改（默认没 final 修饰）会增加出错的概率。\n上一期说过，var 是 variable 的缩写， val 是 value 的缩写。\n\n其实我们写 Java 代码的时候，很少会有人用 final，但 final 用来修饰变量其实是很有用的，但大家都不用；可你如果去看看国内国外的人写的 Kotlin 代码，你会发现很多人的代码里都会有一堆的 val。为什么？因为 final 写起来比 val 麻烦一点：我需要多写一个单词。虽然只麻烦这一点点，但就导致很多人不写。\n\n这就是一件很有意思的事：从 final 到 val，只是方便了一点点，但却让它的使用频率有了巨大的改变。这种改变是会影响到代码质量的：在该加限制的地方加上限制，就可以减少代码出错的概率。\n\nval自定义 getter\n不过 val 和 final 还是有一点区别的，虽然 val 修饰的变量不能二次赋值，但可以通过自定义变量的 getter 函数，让变量每次被访问时，返回动态获取的值：\n\n🏝️\n👇\nval size: Int\n    get() { \n        return items.size\n    }\n复制代码\n不过这个属于 val 的另外一种用法，大部分情况下 val 还是对应于 Java 中的 final 使用的。\n\nstatic property / function\n刚才说到大家都不喜欢写 final 对吧？但有一种场景，大家是最喜欢用 final 的：常量。\n\n☕️\npublic static final String CONST_STRING = \"A String\";\n复制代码\n在 Java 里面写常量，我们用的是 static + final。而在 Kotlin 里面，除了 final 的写法不一样，static 的写法也不一样，而且是更不一样。确切地说：在 Kotlin 里，静态变量和静态方法这两个概念被去除了。\n\n那如果想在 Kotlin 中像 Java 一样通过类直接引用该怎么办呢？Kotlin 的答案是 companion object：\n\n🏝️\nclass Sample {\n    ...\n       👇\n    companion object {\n        val anotherString = \"Another String\"\n    }\n}\n复制代码\n为啥 Kotlin 越改越复杂了？不着急，我们先看看 object 是个什么东西。\n\nobject\nKotlin 里的 object ——首字母小写的，不是大写，Java 里的 Object 在 Kotlin 里不用了。\n\nJava 中的 Object 在 Kotlin 中变成了 Any，和 Object 作用一样：作为所有类的基类。\n\n而 object 不是类，像 class 一样在 Kotlin 中属于关键字：\n\n🏝️\nobject Sample {\n    val name = \"A name\"\n}\n复制代码\n它的意思很直接：创建一个类，并且创建一个这个类的对象。这个就是 object 的意思：对象。\n\n在代码中如果要使用这个对象，直接通过它的类名就可以访问：\n\n🏝️\nSample.name\n复制代码\n这不就是单例么，所以在 Kotlin 中创建单例不用像 Java 中那么复杂，只需要把 class 换成 object 就可以了。\n\n单例类\n\n我们看一个单例的例子，分别用 Java 和 Kotlin 实现：\n\nJava 中实现单例类（非线程安全）：\n\n☕️\npublic class A {\n    private static A sInstance;\n    \n    public static A getInstance() {\n        if (sInstance == null) {\n            sInstance = new A();\n        }\n        return sInstance;\n    }\n\n    \n    ...\n}\n复制代码\n可以看到 Java 中为了实现单例类写了大量的模版代码，稍显繁琐。\n\nKotlin 中实现单例类：\n\n 🏝️\n\nobject A {\n    val number: Int = 1\n    fun method() {\n        println(\"A.method()\")\n    }\n}    \n复制代码\n和 Java 相比的不同点有：\n\n和类的定义类似，但是把 class 换成了 object 。\n不需要额外维护一个实例变量 sInstance。\n不需要「保证实例只创建一次」的 getInstance() 方法。\n相比 Java 的实现简单多了。\n\n这种通过 object 实现的单例是一个饿汉式的单例，并且实现了线程安全。\n\n继承类和实现接口\n\nKotlin 中不仅类可以继承别的类，可以实现接口，object 也可以：\n\n🏝️\nopen class A {\n    open fun method() {\n        ...\n    }\n}\n\ninterface B {\n    fun interfaceMethod()\n}\n  👇      👇   👇\nobject C : A(), B {\n\n    override fun method() {\n        ...\n    }\n\n    override fun interfaceMethod() {\n        ...\n    }\n}\n复制代码\n为什么 object 可以实现接口呢？简单来讲 object 其实是把两步合并成了一步，既有 class 关键字的功能，又实现了单例，这样就容易理解了。\n\n匿名类\n\n另外，Kotlin 还可以创建 Java 中的匿名类，只是写法上有点不同：\n\nJava：\n\n☕️                                              👇 \nViewPager.SimpleOnPageChangeListener listener = new ViewPager.SimpleOnPageChangeListener() {\n    @Override \n    public void onPageSelected(int position) {\n        \n    }\n};\n复制代码\nKotlin：\n\n🏝️          \nval listener = object: ViewPager.SimpleOnPageChangeListener() {\n    override fun onPageSelected(position: Int) {\n        \n    }\n}        \n复制代码\n和 Java 创建匿名类的方式很相似，只不过把 new 换成了 object:：\n\nJava 中 new 用来创建一个匿名类的对象\nKotlin 中 object: 也可以用来创建匿名类的对象\n这里的 new 和 object: 修饰的都是接口或者抽象类。\n\ncompanion object\n用 object 修饰的对象中的变量和函数都是静态的，但有时候，我们只想让类中的一部分函数和变量是静态的该怎么做呢：\n\n🏝️\nclass A {\n          👇\n    object B {\n        var c: Int = 0\n    }\n}\n复制代码\n如上，可以在类中创建一个对象，把需要静态的变量或函数放在内部对象 B 中，外部可以通过如下的方式调用该静态变量：\n\n🏝️\nA.B.c\n  👆\n复制代码\n类中嵌套的对象可以用 companion 修饰：\n\n🏝️\nclass A {\n       👇\n    companion object B {\n        var c: Int = 0\n    }\n}\n复制代码\ncompanion 可以理解为伴随、伴生，表示修饰的对象和外部类绑定。\n\n但这里有一个小限制：一个类中最多只可以有一个伴生对象，但可以有多个嵌套对象。就像皇帝后宫佳丽三千，但皇后只有一个。\n\n这样的好处是调用的时候可以省掉对象名：\n\n🏝️\nA.c \n复制代码\n所以，当有 companion 修饰时，对象的名字也可以省略掉：\n\n🏝️\nclass A {\n                \n    companion object {\n        var c: Int = 0\n    }\n}\n复制代码\n这就是这节最开始讲到的，Java 静态变量和方法的等价写法：companion object 变量和函数。\n\n静态初始化\n\nJava 中的静态变量和方法，在 Kotlin 中都放在了 companion object 中。因此 Java 中的静态初始化在 Kotlin 中自然也是放在 companion object 中的，像类的初始化代码一样，由 init 和一对大括号表示：\n\n🏝️\nclass Sample {\n       👇\n    companion object {\n         👇\n        init {\n            ...\n        }\n    }\n}\n复制代码\ntop-level property / function 声明\n除了静态函数这种简便的调用方式，Kotlin 还有更方便的东西：「top-level declaration 顶层声明」。其实就是把属性和函数的声明不写在 class 里面，这个在 Kotlin 里是允许的：\n\n🏝️\npackage com.hencoder.plus\n\n\nfun topLevelFuncion() {\n}\n复制代码\n这样写的属性和函数，不属于任何 class，而是直接属于 package，它和静态变量、静态函数一样是全局的，但用起来更方便：你在其它地方用的时候，就连类名都不用写：\n\n🏝️\nimport com.hencoder.plus.topLevelFunction \n\ntopLevelFunction()\n复制代码\n写在顶级的函数或者变量有个好处：在 Android Studio 中写代码时，IDE 很容易根据你写的函数前几个字母自动联想出相应的函数。这样提高了写代码的效率，而且可以减少项目中的重复代码。\n\n命名相同的顶级函数\n\n顶级函数不写在类中可能有一个问题：如果在不同文件中声明命名相同的函数，使用的时候会不会混淆？来看一个例子：\n\n在 org.kotlinmaster.library 包下有一个函数 method：\n\n🏝️\npackage org.kotlinmaster.library1\n                           👆\nfun method() {\n    println(\"library1 method()\")\n}\n复制代码\n在 org.kotlinmaster.library2 包下有一个同名函数：\n\n🏝️\npackage org.kotlinmaster.library2\n                           👆\nfun method() {\n    println(\"library2 method()\")\n}\n复制代码\n在使用的时候如果同时调用这两个同名函数会怎么样：\n\n🏝️\nimport org.kotlinmaster.library1.method\n                           👆\nfun test() {\n    method()\n                       👇\n    org.kotlinmaster.library2.method()\n}\n复制代码\n可以看到当出现两个同名顶级函数时，IDE 会自动加上包前缀来区分，这也印证了「顶级函数属于包」的特性。\n\n对比\n那在实际使用中，在 object、companion object 和 top-level 中该选择哪一个呢？简单来说按照下面这两个原则判断：\n\n如果想写工具类的功能，直接创建文件，写 top-level「顶层」函数。\n如果需要继承别的类或者实现接口，就用 object 或 companion object。\n常量\nJava 中，除了上面讲到的的静态变量和方法会用到 static，声明常量时也会用到，那 Kotlin 中声明常量会有什么变化呢？\n\nJava 中声明常量：\n\n☕️\npublic class Sample {\n            👇     👇\n    public static final int CONST_NUMBER = 1;\n}\n复制代码\nKotlin 中声明常量：\n\n🏝️\nclass Sample {\n    companion object {\n         👇                  \n        const val CONST_NUMBER = 1\n    }\n}\n\nconst val CONST_SECOND_NUMBER = 2\n复制代码\n发现不同点有：\n\nKotlin 的常量必须声明在对象（包括伴生对象）或者「top-level 顶层」中，因为常量是静态的。\nKotlin 新增了修饰常量的 const 关键字。\n除此之外还有一个区别：\n\nKotlin 中只有基本类型和 String 类型可以声明成常量。\n原因是 Kotlin 中的常量指的是 「compile-time constant 编译时常量」，它的意思是「编译器在编译的时候就知道这个东西在每个调用处的实际值」，因此可以在编译时直接把这个值硬编码到代码里使用的地方。\n\n而非基本和 String 类型的变量，可以通过调用对象的方法或变量改变对象内部的值，这样这个变量就不是常量了，来看一个 Java 的例子，比如一个 User 类：\n\n☕️\npublic class User {\n    int id; \n    String name; \n    public User(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n复制代码\n在使用的地方声明一个 static final 的 User 实例 user，它是不能二次赋值的：\n\n☕️\nstatic final User user = new User(123, \"Zhangsan\");\n  👆    👆\n复制代码\n但是可以通过访问这个 user 实例的成员变量改变它的值：\n\n☕️\nuser.name = \"Lisi\";\n      👆\n复制代码\n所以 Java 中的常量可以认为是「伪常量」，因为可以通过上面这种方式改变它内部的值。而 Kotlin 的常量因为限制类型必须是基本类型，所以不存在这种问题，更符合常量的定义。\n\n前面讲的 val 「只读变量」和静态变量都是针对单个变量来说的，接下来我们看看编程中另外一个常见的主题：数组和集合。\n\n数组和集合\n数组\n声明一个 String 数组：\n\nJava 中的写法：\n\n☕️\nString[] strs = {\"a\", \"b\", \"c\"};\n      👆        👆\n复制代码\nKotlin 中的写法：\n\n🏝️\nval strs: Array<String> = arrayOf(\"a\", \"b\", \"c\")\n            👆              👆\n复制代码\n可以看到 Kotlin 中的数组是一个拥有泛型的类，创建函数也是泛型函数，和集合数据类型一样。\n\n针对泛型的知识点，我们在后面的文章会讲，这里就先按照 Java 泛型来理解。\n\n将数组泛型化有什么好处呢？对数组的操作可以像集合一样功能更强大，由于泛型化，Kotlin 可以给数组增加很多有用的工具函数：\n\nget() / set()\ncontains()\nfirst()\nfind()\n这样数组的实用性就大大增加了。\n\n取值和修改\n\nKotlin 中获取或者设置数组元素和 Java 一样，可以使用方括号加下标的方式索引：\n\n🏝️\nprintln(strs[0])\n   👇      👆\nstrs[1] = \"B\"\n复制代码\n不支持协变\n\nKotlin 的数组编译成字节码时使用的仍然是 Java 的数组，但在语言层面是泛型实现，这样会失去协变 (covariance) 特性，就是子类数组对象不能赋值给父类的数组变量：\n\nKotlin\n\n🏝️\nval strs: Array<String> = arrayOf(\"a\", \"b\", \"c\")\n                  👆\nval anys: Array<Any> = strs \n                👆\n复制代码\n而这在 Java 中是可以的：\n\n☕️\nString[] strs = {\"a\", \"b\", \"c\"};\n  👆\nObject[] objs = strs; \n  👆\n复制代码\n关于协变的问题，这里就先不展开了，后面讲泛型的时候会提到。\n\n集合\nKotlin 和 Java 一样有三种集合类型：List、Set 和 Map，它们的含义分别如下：\n\nList 以固定顺序存储一组元素，元素可以重复。\nSet 存储一组互不相等的元素，通常没有固定顺序。\nMap 存储 键-值 对的数据集合，键互不相等，但不同的键可以对应相同的值。\n从 Java 到 Kotlin，这三种集合类型的使用有哪些变化呢？我们依次看看。\n\nList\n\nJava 中创建一个列表：\n\n☕️\nList<String> strList = new ArrayList<>();\nstrList.add(\"a\");\nstrList.add(\"b\");\nstrList.add(\"c\"); \n复制代码\nKotlin 中创建一个列表：\n\n🏝️            \nval strList = listOf(\"a\", \"b\", \"c\")\n复制代码\n首先能看到的是 Kotlin 中创建一个 List 特别的简单，有点像创建数组的代码。而且 Kotlin 中的 List 多了一个特性：支持 covariant（协变）。也就是说，可以把子类的 List 赋值给父类的 List 变量：\n\nKotlin：\n\n🏝️\nval strs: List<String> = listOf(\"a\", \"b\", \"c\")\n                👆\nval anys: List<Any> = strs \n               👆\n复制代码\n而这在 Java 中是会报错的：\n\n☕️\nList<String> strList = new ArrayList<>();\n       👆\nList<Object> objList = strList; \n      👆  \n复制代码\n对于协变的支持与否，List 和数组刚好反过来了。关于协变，这里只需结合例子简单了解下，后面的文章会对它展开讨论。\n\n和数组的区别\n\nKotlin 中数组和 MutableList 的 API 是非常像的，主要的区别是数组的元素个数不能变。那在什么时候用数组呢？\n\n这个问题在 Java 中就存在了，数组和 List 的功能类似，List 的功能更多一些，直觉上应该用 List 。但数组也不是没有优势，基本类型 (int[]、float[]) 的数组不用自动装箱，性能好一点。\n\n在 Kotlin 中也是同样的道理，在一些性能需求比较苛刻的场景，并且元素类型是基本类型时，用数组好一点。不过这里要注意一点，Kotlin 中要用专门的基本类型数组类 (IntArray FloatArray LongArray) 才可以免于装箱。也就是说元素不是基本类型时，相比 Array，用 List 更方便些。\n\nSet\n\nJava 中创建一个 Set：\n\n☕️\nSet<String> strSet = new HashSet<>();\nstrSet.add(\"a\");\nstrSet.add(\"b\");\nstrSet.add(\"c\");\n复制代码\nKotlin 中创建相同的 Set：\n\n🏝️           \nval strSet = setOf(\"a\", \"b\", \"c\")\n复制代码\n和 List 类似，Set 同样具有 covariant（协变）特性。\n\nMap\n\nJava 中创建一个 Map：\n\n☕️\nMap<String, Integer> map = new HashMap<>();\nmap.put(\"key1\", 1);\nmap.put(\"key2\", 2);\nmap.put(\"key3\", 3);\nmap.put(\"key4\", 3);\n复制代码\nKotlin 中创建一个 Map：\n\n🏝️         \nval map = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 3)\n复制代码\n和上面两种集合类型相似创建代码很简洁。mapOf 的每个参数表示一个键值对，to 表示将「键」和「值」关联，这个叫做「中缀表达式」，这里先不展开，后面的文章会做介绍。\n\n取值和修改\n\nKotlin 中的 Map 除了和 Java 一样可以使用 get() 根据键获取对应的值，还可以使用方括号的方式获取：\n\n🏝️\n                 👇\nval value1 = map.get(\"key1\")\n               👇\nval value2 = map[\"key2\"]\n复制代码\n类似的，Kotlin 中也可以用方括号的方式改变 Map 中键对应的值：\n\n🏝️       \n              👇\nval map = mutableMapOf(\"key1\" to 1, \"key2\" to 2)\n    👇\nmap.put(\"key1\", 2)\n   👇\nmap[\"key1\"] = 2    \n复制代码\n这里用到了「操作符重载」的知识，实现了和数组一样的「Positional Access Operations」，关于这个概念这里先不展开，后面会讲到。\n\n可变集合/不可变集合\n\n上面修改 Map 值的例子中，创建函数用的是 mutableMapOf() 而不是 mapOf()，因为只有 mutableMapOf() 创建的 Map 才可以修改。Kotlin 中集合分为两种类型：只读的和可变的。这里的只读有两层意思：\n\n集合的 size 不可变\n集合中的元素值不可变\n以下是三种集合类型创建不可变和可变实例的例子：\n\nlistOf() 创建不可变的 List，mutableListOf() 创建可变的 List。\nsetOf() 创建不可变的 Set，mutableSetOf() 创建可变的 Set。\nmapOf() 创建不可变的 Map，mutableMapOf() 创建可变的 Map。\n可以看到，有 mutable 前缀的函数创建的是可变的集合，没有 mutbale 前缀的创建的是不可变的集合，不过不可变的可以通过 toMutable*() 系函数转换成可变的集合：\n\n🏝️\nval strList = listOf(\"a\", \"b\", \"c\")\n            👇\nstrList.toMutableList()\nval strSet = setOf(\"a\", \"b\", \"c\")\n            👇\nstrSet.toMutableSet()\nval map = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 3)\n         👇\nmap.toMutableMap()\n复制代码\n然后就可以对集合进行修改了，这里有一点需要注意下：\n\ntoMutable*() 返回的是一个新建的集合，原有的集合还是不可变的，所以只能对函数返回的集合修改。\nSequence\n除了集合 Kotlin 还引入了一个新的容器类型 Sequence，它和 Iterable 一样用来遍历一组数据并可以对每个元素进行特定的处理，先来看看如何创建一个 Sequence。\n\n创建\n类似 listOf() ，使用一组元素创建：\n\n🏝️\nsequenceOf(\"a\", \"b\", \"c\")\n复制代码\n使用 Iterable 创建：\n\n🏝️\nval list = listOf(\"a\", \"b\", \"c\")\nlist.asSequence()\n复制代码\n这里的 List 实现了 Iterable 接口。\n\n使用 lambda 表达式创建：\n\n🏝️                          \nval sequence = generateSequence(0) { it + 1 }\n                                  \n复制代码\n这看起来和 Iterable 一样呀，为啥要多此一举使用 Sequence 呢？在下一篇文章中会结合例子展开讨论。\n\n可见性修饰符\n讲完了数据集合，再看看 Kotlin 中的可见性修饰符，Kotlin 中有四种可见性修饰符：\n\npublic：公开，可见性最大，哪里都可以引用。\nprivate：私有，可见性最小，根据声明位置不同可分为类中可见和文件中可见。\nprotected：保护，相当于 private + 子类可见。\ninternal：内部，仅对 module 内可见。\n相比 Java 少了一个 default 「包内可见」修饰符，多了一个 internal「module 内可见」修饰符。这一节结合例子讲讲 Kotlin 这四种可见性修饰符，以及在 Kotlin 和 Java 中的不同。先来看看 public：\n\npublic\nJava 中没写可见性修饰符时，表示包内可见，只有在同一个 package 内可以引用：\n\n☕️                         👇\npackage org.kotlinmaster.library; \n\nclass User {\n}\n复制代码\n☕️                      \npackage org.kotlinmaster.library;\n\npublic class Example {\n    void method() {\n        new User(); \n    }\n}\n复制代码\n☕️\npackage org.kotlinmaster;\n                    \nimport org.kotlinmaster.library.User;\n                          👆\npublic class OtherPackageExample {\n    void method() {\n        new User(); \n    }\n}\n复制代码\npackage 外如果要引用，需要在 class 前加上可见性修饰符 public 表示公开。\n\nKotlin 中如果不写可见性修饰符，就表示公开，和 Java 中 public 修饰符具有相同效果。在 Kotlin 中 public 修饰符「可以加，但没必要」。\n\n@hide\n在 Android 的官方 sdk 中，有一些方法只想对 sdk 内可见，不想开放给用户使用（因为这些方法不太稳定，在后续版本中很有可能会修改或删掉）。为了实现这个特性，会在方法的注释中添加一个 Javadoc 方法 @hide，用来限制客户端访问：\n\n☕️\n\npublic void hideMethod() {\n    ...\n}\n复制代码\n但这种限制不太严格，可以通过反射访问到限制的方法。针对这个情况，Kotlin 引进了一个更为严格的可见性修饰符：internal。\n\ninternal\ninternal 表示修饰的类、函数仅对 module 内可见，这里的 module 具体指的是一组共同编译的 kotlin 文件，常见的形式有：\n\nAndroid Studio 里的 module\nMaven project\n我们常见的是 Android Studio 中的 module 这种情况，Maven project 仅作了解就好，不用细究。\n\ninternal 在写一个 library module 时非常有用，当需要创建一个函数仅开放给 module 内部使用，不想对 library 的使用者可见，这时就应该用 internal 可见性修饰符。\n\nJava 的「包内可见」怎么没了？\nJava 的 default「包内可见」在 Kotlin 中被弃用掉了，Kotlin 中与它最接近的可见性修饰符是 internal「module 内可见」。为什么会弃用掉包内可见呢？我觉得有这几个原因：\n\nKotlin 鼓励创建 top-level 函数和属性，一个源码文件可以包含多个类，使得 Kotlin 的源码结构更加扁平化，包结构不再像 Java 中那么重要。\n为了代码的解耦和可维护性，module 越来越多、越来越小，使得 internal 「module 内可见」已经可以满足对于代码封装的需求。\nprotected\nJava 中 protected 表示包内可见 + 子类可见。\nKotlin 中 protected 表示 private + 子类可见。\nKotlin 相比 Java protected 的可见范围收窄了，原因是 Kotlin 中不再有「包内可见」的概念了，相比 Java 的可见性着眼于 package，Kotlin 更关心的是 module。\n\nprivate\nJava 中的 private 表示类中可见，作为内部类时对外部类「可见」。\nKotlin 中的 private 表示类中或所在文件内可见，作为内部类时对外部类「不可见」。\nprivate 修饰的变量「类中可见」和 「文件中可见」:\n\n🏝️\nclass Sample {\n    private val propertyInClass = 1 \n}\n\nprivate val propertyInFile = \"A string.\" \n复制代码\nprivate 修饰内部类的变量时，在 Java 和 Kotlin 中的区别：\n\n在 Java 中，外部类可以访问内部类的 private 变量：\n\n☕️\npublic class Outter {\n    public void method() {\n        Inner inner = new Inner();\n                            👇\n        int result = inner.number * 2; \n    }\n    \n    private class Inner {\n        private int number = 0;\n    }\n}\n复制代码\n在 Kotlin 中，外部类不可以访问内部类的 private 变量：\n\n🏝️\nclass Outter {\n    fun method() {\n        val inner = Inner()\n                            👇\n        val result = inner.number * 2 \n    }\n    \n    class Inner {\n        private val number = 1\n    }\n}\n复制代码\n可以修饰类和接口\n\nJava 中一个文件只允许一个外部类，所以 class 和 interface 不允许设置为 private，因为声明 private 后无法被外部使用，这样就没有意义了。\n\nKotlin 允许同一个文件声明多个 class 和 top-level 的函数和属性，所以 Kotlin 中允许类和接口声明为 private，因为同个文件中的其它成员可以访问：\n\n🏝️                   \nprivate class Sample {\n    val number = 1\n    fun method() {\n        println(\"Sample method()\")\n    }\n}\n            \nval sample = Sample()\n复制代码\n练习题\n创建一个 Kotlin 类，这个类需要禁止外部通过构造器创建实例，并提供至少一种实例化方式。\n分别用 Array、IntArray、List 实现 「保存 1-100_000 的数字，并求出这些数字的平均值」，打印出这三种数据结构的执行时间。\n作者介绍\n视频作者\n扔物线（朱凯）\n码上开学创始人、项目管理人、内容模块规划者和视频内容作者。\nAndroid GDE（ Google 认证 Android 开发专家），前 Flipboard Android 工程师。\nGitHub 全球 Java 排名第 92 位，在 GitHub 上有 6.6k followers 和 9.9k stars。\n个人的 Android 开源库 MaterialEditText 被全球多个项目引用，其中包括在全球拥有 5 亿用户的新闻阅读软件 Flipboard 。\n曾多次在 Google Developer Group Beijing 线下分享会中担任 Android 部分的讲师。\n个人技术文章《给 Android 开发者的 RxJava 详解》发布后，在国内多个公司和团队内部被转发分享和作为团队技术会议的主要资料来源，以及逆向传播到了美国一些如 Google 、 Uber 等公司的部分华人团队。\n创办的 Android 高级进阶教学网站 HenCoder 在全球华人 Android 开发社区享有相当的影响力。\n之后创办 Android 高级开发教学课程 HenCoder Plus ，学员遍布全球，有来自阿里、头条、华为、腾讯等知名一线互联网公司，也有来自中国台湾、日本、美国等地区的资深软件工程师。\n文章作者\nWalker（张磊）\nWalker（张磊） ，即刻 Android 高级工程师。2015 年加入即刻，参与了即刻 2.0 到 6.0 版本的架构设计和产品迭代。多年 Android 开发经验，曾就职于 OPPO，专注于客户端用户体验、音视频开发和性能优化。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597400500002},"updatedAt":{"$$date":1597400981192},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"o87EeT5jiy6ciSAl"}
{"name":"qk-ks_component_theforcesystem","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"apply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    libraryVariants.all {\n        it.getGenerateBuildConfigProvider()\n    }\n\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    android {\n        lintOptions {\n            abortOnError false\n        }\n    }\n}\n\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation deps.kotlin.coroutines_core\n    implementation deps.kotlin.coroutines_android\n    implementation kaishu.ksbsdiffpatcher\n    implementation deps.google_gson\n    implementation ks.component_download\n    implementation ks.component_net\n    implementation deps.tecentX5\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.ks.theforcesystem\">\n\n    <application>\n\n        <service\n            android:name=\".service.DownloadWebViewPatchService\"\n            android:exported=\"false\" />\n    </application>\n</manifest>\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 管理原力系统的二级、三集目录\n */\npublic class ConstantUtil {\n    //原力系统二级根页面\n    public static final String WEB_PAGE = \"webPage\";\n    //原力系统三级页面（解压之后的）\n    public static final String KS_UNZIP = \"/ksUnZip\";\n    //原力系统三级页面\n    public static final String WEBPAGE_UNZIP = \"webPage/ksUnZip\";\n\n    //基准包名称\n    public static final String BASE_ZIP = \"app.zip\";\n    //patch名称\n    public static final String PATCH = \"patch\";\n    //合成包名称\n    public static final String NEW_ZIP = \"newapp.zip\";\n\n    //内存缓存\n    public static TheForceSystemBean THE_FORCE_SYSTEM_DATA;\n\n\n    public static boolean isAppInForground(Context context) {\n        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        List<ActivityManager.RunningAppProcessInfo> processes = am.getRunningAppProcesses();\n        if (processes == null) {\n            return false;\n        }\n        for (ActivityManager.RunningAppProcessInfo tmp : processes) {\n            if (tmp.processName.equals(context.getPackageName())) {\n                if (tmp.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninterface TheForceSystemService {\n\n    /**\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @POST(\"https://dapi.kaishustory.com/web-force/v1/package/record/download${GlobalUrlManager.IDENTIFICATION_IGNORE}\")\n    suspend fun duploadDownloadOrPatchResult(@Body requestBody: RequestBody): KsResponse<Any>\n\n\n    /**\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @POST(\"https://tapi.kaishustory.com/web-force/v1/package/record/download${GlobalUrlManager.IDENTIFICATION_IGNORE}\")\n    suspend fun tuploadDownloadOrPatchResult(@Body requestBody: RequestBody): KsResponse<Any>\n\n    /**\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @POST(\"https://gapi.kaishustory.com/web-force/v1/package/record/download${GlobalUrlManager.IDENTIFICATION_IGNORE}\")\n    suspend fun guploadDownloadOrPatchResult(@Body requestBody: RequestBody): KsResponse<Any>\n\n\n    /**\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @POST(\"https://api.kaishustory.com/web-force/v1/package/record/download${GlobalUrlManager.IDENTIFICATION_IGNORE}\")\n    suspend fun uploadDownloadOrPatchResult(@Body requestBody: RequestBody): KsResponse<Any>\n\n\n    /**\n     * 查询线上的最新patch包\n     *\n     * @param md5 本地package包的md5\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @GET(\"https://dapi.kaishustory.com/web-force/v1/package/check${GlobalUrlManager.IDENTIFICATION_IGNORE}\")\n    suspend fun dWebviewPatchCheck(\n        @Query(\"md5\") md5: String?,\n        @Query(\"appName\") appName: String\n    ): KsResponse<TheForceSystemBean>\n\n    /**\n     * 查询线上的最新patch包\n     *\n     * @param md5 本地package包的md5\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @GET(\"https://tapi.kaishustory.com/web-force/v1/package/check${GlobalUrlManager.IDENTIFICATION_IGNORE}\")\n    suspend fun tWebviewPatchCheck(\n        @Query(\"md5\") md5: String?,\n        @Query(\"appName\") appName: String\n    ): KsResponse<TheForceSystemBean>\n\n    /**\n     * 查询线上的最新patch包\n     *\n     * @param md5 本地package包的md5\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @GET(\"https://gapi.kaishustory.com/web-force/v1/package/check${GlobalUrlManager.IDENTIFICATION_IGNORE}\")\n    suspend fun gWebviewPatchCheck(\n        @Query(\"md5\") md5: String?,\n        @Query(\"appName\") appName: String\n    ): KsResponse<TheForceSystemBean>\n\n    /**\n     * 查询线上的最新patch包\n     *\n     * @param md5 本地package包的md5\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong)\n    @GET(\"https://api.kaishustory.com/web-force/v1/package/check${GlobalUrlManager.IDENTIFICATION_IGNORE}\")\n    suspend fun webviewPatchCheck(\n        @Query(\"md5\") md5: String?,\n        @Query(\"appName\") appName: String\n    ): KsResponse<TheForceSystemBean>\n\n}\n\n\n\n\n\n\n\n\nclass TheForceSystemRepository : KsBaseRepository() {\n\n    suspend fun webviewPatchCheck(baseZipMd5: String?): KsResult<TheForceSystemBean> {\n        var appName = TheForceSystemDelegate.getAppName()\n\n        return safeApiCall(call = { webSouceCheck(baseZipMd5, appName) })\n    }\n\n    private suspend fun webSouceCheck(\n        baseZipMd5: String?,\n        appName: String\n    ): KsResult<TheForceSystemBean> =\n        when (TheForceSystemDelegate.getEnv()) {\n            TheForceSystemDelegate.ENV_DEBUG ->\n                executeResponse(getService().tWebviewPatchCheck(baseZipMd5, appName))\n            TheForceSystemDelegate.ENV_DAPI ->\n                executeResponse(getService().dWebviewPatchCheck(baseZipMd5, appName))\n            TheForceSystemDelegate.ENV_GAMA ->\n                executeResponse(getService().gWebviewPatchCheck(baseZipMd5, appName))\n            TheForceSystemDelegate.ENV_RELEASE ->\n                executeResponse(getService().webviewPatchCheck(baseZipMd5, appName))\n            else ->\n                executeResponse(getService().webviewPatchCheck(baseZipMd5, appName))\n\n        }\n\n    suspend fun uploadDownloadOrPatchResult(\n        appVersion: String,\n        platForm: String,\n        packageMD5: String?,\n        patchMD5: String?,\n        result: Int\n    ): KsResult<Any> {\n\n        val jsonObject = JSONObject()\n        jsonObject.put(\"appVersion\", appVersion)\n        jsonObject.put(\"platform\", platForm)\n        jsonObject.put(\"packageMD5\", packageMD5)\n        jsonObject.put(\"patchMD5\", patchMD5)\n        jsonObject.put(\"result\", result)\n\n        val requestBody = TheForceSystemDelegate.createRequestBody(jsonObject)\n\n        return safeApiCall(call = { uploadDownloadOrPatchResult(requestBody) })\n    }\n\n    private suspend fun uploadDownloadOrPatchResult(\n        requestBody: RequestBody\n    ): KsResult<Any> =\n        when (TheForceSystemDelegate.getEnv()) {\n            TheForceSystemDelegate.ENV_DEBUG ->\n                executeResponse(getService().tuploadDownloadOrPatchResult(requestBody))\n            TheForceSystemDelegate.ENV_DAPI ->\n                executeResponse(getService().duploadDownloadOrPatchResult(requestBody))\n            TheForceSystemDelegate.ENV_GAMA ->\n                executeResponse(getService().guploadDownloadOrPatchResult(requestBody))\n            TheForceSystemDelegate.ENV_RELEASE ->\n                executeResponse(getService().uploadDownloadOrPatchResult(requestBody))\n            else ->\n                executeResponse(getService().uploadDownloadOrPatchResult(requestBody))\n\n        }\n\n\n    private fun getService(): TheForceSystemService =\n        KsRetrofitClient.getService(TheForceSystemService::class.java)\n}\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598585022788},"updatedAt":{"$$date":1598585660939},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"oKIG4dzYjMIJJUEG"}
{"name":"kotlin-协程上下文与调度器 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/coroutines/coroutine-context-and-dispatchers.html\n协程上下文与调度器 - Kotlin 语言中文站\n47-59 minutes\n改进翻译\n目录\n\n协程上下文与调度器\n调度器与线程\n非受限调度器 vs 受限调度器\n调试协程与线程\n在不同线程间跳转\n上下文中的作业\n子协程\n父协程的职责\n命名协程以用于调试\n组合上下文中的元素\n协程作用域\n线程局部数据\n协程总是运行在一些以 CoroutineContext 类型为代表的上下文中，它们被定义在了 Kotlin 的标准库里。\n\n协程上下文是各种不同元素的集合。其中主元素是协程中的 Job， 我们在前面的文档中见过它以及它的调度器，而本文将对它进行介绍。\n\n协程上下文包含一个 协程调度器 （参见 CoroutineDispatcher）它确定了哪些线程或与线程相对应的协程执行。协程调度器可以将协程限制在一个特定的线程执行，或将它分派到一个线程池，亦或是让它不受限地运行。\n\n所有的协程构建器诸如 launch 和 async 接收一个可选的 CoroutineContext 参数，它可以被用来显式的为一个新协程或其它上下文元素指定一个调度器。\n\n尝试下面的示例：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch { // 运行在父协程的上下文中，即 runBlocking 主协程\n        println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Unconfined) { // 不受限的——将工作在主线程中\n        println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Default) { // 将会获取默认调度器\n        println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // 将使它获得一个新的线程\n        println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n可以在这里获取完整代码。\n\n它执行后得到了如下输出（也许顺序会有所不同）：\n\nUnconfined            : I'm working in thread main\nDefault               : I'm working in thread DefaultDispatcher-worker-1\nnewSingleThreadContext: I'm working in thread MyOwnThread\nmain runBlocking      : I'm working in thread main\n当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。\n\nDispatchers.Unconfined 是一个特殊的调度器且似乎也运行在 main 线程中，但实际上， 它是一种不同的机制，这会在后文中讲到。\n\n当协程在 GlobalScope 中启动时，使用的是由 Dispatchers.Default 代表的默认调度器。 默认调度器使用共享的后台线程池。 所以 launch(Dispatchers.Default) { …… } 与 GlobalScope.launch { …… } 使用相同的调度器。\n\nnewSingleThreadContext 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。\n\nDispatchers.Unconfined 协程调度器在调用它的线程启动了一个协程，但它仅仅只是运行到第一个挂起点。挂起后，它恢复线程中的协程，而这完全由被调用的挂起函数来决定。非受限的调度器非常适用于执行不消耗 CPU 时间的任务，以及不更新局限于特定线程的任何共享数据（如UI）的协程。\n\n另一方面，该调度器默认继承了外部的 CoroutineScope。 runBlocking 协程的默认调度器，特别是， 当它被限制在了调用者线程时，继承自它将会有效地限制协程在该线程运行并且具有可预测的 FIFO 调度。\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch(Dispatchers.Unconfined) { // 非受限的——将和主线程一起工作\n        println(\"Unconfined      : I'm working in thread ${Thread.currentThread().name}\")\n        delay(500)\n        println(\"Unconfined      : After delay in thread ${Thread.currentThread().name}\")\n    }\n    launch { // 父协程的上下文，主 runBlocking 协程\n        println(\"main runBlocking: I'm working in thread ${Thread.currentThread().name}\")\n        delay(1000)\n        println(\"main runBlocking: After delay in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n可以在这里获取完整代码。\n\n执行后的输出：\n\nUnconfined      : I'm working in thread main\nmain runBlocking: I'm working in thread main\nUnconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor\nmain runBlocking: After delay in thread main\n所以，该协程的上下文继承自 runBlocking {...} 协程并在 main 线程中运行，当 delay 函数调用的时候，非受限的那个协程在默认的执行者线程中恢复执行。\n\n非受限的调度器是一种高级机制，可以在某些极端情况下提供帮助而不需要调度协程以便稍后执行或产生不希望的副作用， 因为某些操作必须立即在协程中执行。 非受限调度器不应该在通常的代码中使用。\n\n协程可以在一个线程上挂起并在其它线程上恢复。 甚至一个单线程的调度器也是难以弄清楚协程在何时何地正在做什么事情。使用通常调试应用程序的方法是让线程在每一个日志文件的日志声明中打印线程的名字。这种特性在日志框架中是普遍受支持的。但是在使用协程时，单独的线程名称不会给出很多协程上下文信息，所以 kotlinx.coroutines 包含了调试工具来让它更简单。\n\n使用 -Dkotlinx.coroutines.debug JVM 参数运行下面的代码：\n\nimport kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val a = async {\n        log(\"I'm computing a piece of the answer\")\n        6\n    }\n    val b = async {\n        log(\"I'm computing another piece of the answer\")\n        7\n    }\n    log(\"The answer is ${a.await() * b.await()}\")\n//sampleEnd    \n}\n可以在这里获取完整代码。\n\n这里有三个协程，包括 runBlocking 内的主协程 (#1) ， 以及计算延期的值的另外两个协程 a (#2) 和 b (#3)。 它们都在 runBlocking 上下文中执行并且被限制在了主线程内。 这段代码的输出如下：\n\n[main @coroutine#2] I'm computing a piece of the answer\n[main @coroutine#3] I'm computing another piece of the answer\n[main @coroutine#1] The answer is 42\n这个 log 函数在方括号种打印了线程的名字，并且你可以看到它是 main 线程，并且附带了当前正在其上执行的协程的标识符。这个标识符在调试模式开启时，将连续分配给所有创建的协程。\n\n当 JVM 以 -ea 参数配置运行时，调试模式也会开启。 你可以在 DEBUG_PROPERTY_NAME 属性的文档中阅读有关调试工具的更多信息。\n\n使用 -Dkotlinx.coroutines.debug JVM 参数运行下面的代码（参见调试）：\n\nimport kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() {\n//sampleStart\n    newSingleThreadContext(\"Ctx1\").use { ctx1 ->\n        newSingleThreadContext(\"Ctx2\").use { ctx2 ->\n            runBlocking(ctx1) {\n                log(\"Started in ctx1\")\n                withContext(ctx2) {\n                    log(\"Working in ctx2\")\n                }\n                log(\"Back to ctx1\")\n            }\n        }\n    }\n//sampleEnd    \n}\n可以在这里获取完整代码。\n\n它演示了一些新技术。其中一个使用 runBlocking 来显式指定了一个上下文，并且另一个使用 withContext 函数来改变协程的上下文，而仍然驻留在相同的协程中，正如可以在下面的输出中所见到的：\n\n[Ctx1 @coroutine#1] Started in ctx1\n[Ctx2 @coroutine#1] Working in ctx2\n[Ctx1 @coroutine#1] Back to ctx1\n注意，在这个例子中，当我们不再需要某个在 newSingleThreadContext 中创建的线程的时候， 它使用了 Kotlin 标准库中的 use 函数来释放该线程。\n\n协程的 Job 是上下文的一部分，并且可以使用 coroutineContext [Job] 表达式在上下文中检索它：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    println(\"My job is ${coroutineContext[Job]}\")\n//sampleEnd    \n}\n可以在这里获取完整代码。\n\n在调试模式下，它将输出如下这些信息：\n\nMy job is \"coroutine#1\":BlockingCoroutine{Active}@6d311334\n请注意，CoroutineScope 中的 isActive 只是 coroutineContext[Job]?.isActive == true 的一种方便的快捷方式。\n\n当一个协程被其它协程在 CoroutineScope 中启动的时候， 它将通过 CoroutineScope.coroutineContext 来承袭上下文，并且这个新协程的 Job 将会成为父协程作业的 子 作业。当一个父协程被取消的时候，所有它的子协程也会被递归的取消。\n\n然而，当使用 GlobalScope 来启动一个协程时，则新协程的作业没有父作业。 因此它与这个启动的作用域无关且独立运作。\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // 启动一个协程来处理某种传入请求（request）\n    val request = launch {\n        // 孵化了两个子作业, 其中一个通过 GlobalScope 启动\n        GlobalScope.launch {\n            println(\"job1: I run in GlobalScope and execute independently!\")\n            delay(1000)\n            println(\"job1: I am not affected by cancellation of the request\")\n        }\n        // 另一个则承袭了父协程的上下文\n        launch {\n            delay(100)\n            println(\"job2: I am a child of the request coroutine\")\n            delay(1000)\n            println(\"job2: I will not execute this line if my parent request is cancelled\")\n        }\n    }\n    delay(500)\n    request.cancel() // 取消请求（request）的执行\n    delay(1000) // 延迟一秒钟来看看发生了什么\n    println(\"main: Who has survived request cancellation?\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n这段代码的输出如下：\n\njob1: I run in GlobalScope and execute independently!\njob2: I am a child of the request coroutine\njob1: I am not affected by cancellation of the request\nmain: Who has survived request cancellation?\n一个父协程总是等待所有的子协程执行结束。父协程并不显式的跟踪所有子协程的启动，并且不必使用 Job.join 在最后的时候等待它们：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // 启动一个协程来处理某种传入请求（request）\n    val request = launch {\n        repeat(3) { i -> // 启动少量的子作业\n            launch  {\n                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒的时间\n                println(\"Coroutine $i is done\")\n            }\n        }\n        println(\"request: I'm done and I don't explicitly join my children that are still active\")\n    }\n    request.join() // 等待请求的完成，包括其所有子协程\n    println(\"Now processing of the request is complete\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n结果如下所示：\n\nrequest: I'm done and I don't explicitly join my children that are still active\nCoroutine 0 is done\nCoroutine 1 is done\nCoroutine 2 is done\nNow processing of the request is complete\n当协程经常打印日志并且你只需要关联来自同一个协程的日志记录时， 则自动分配的 id 是非常好的。然而，当一个协程与特定请求的处理相关联时或做一些特定的后台任务，最好将其明确命名以用于调试目的。 CoroutineName 上下文元素与线程名具有相同的目的。当调试模式开启时，它被包含在正在执行此协程的线程名中。\n\n下面的例子演示了这一概念：\n\nimport kotlinx.coroutines.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n\nfun main() = runBlocking(CoroutineName(\"main\")) {\n//sampleStart\n    log(\"Started main coroutine\")\n    // 运行两个后台值计算\n    val v1 = async(CoroutineName(\"v1coroutine\")) {\n        delay(500)\n        log(\"Computing v1\")\n        252\n    }\n    val v2 = async(CoroutineName(\"v2coroutine\")) {\n        delay(1000)\n        log(\"Computing v2\")\n        6\n    }\n    log(\"The answer for v1 / v2 = ${v1.await() / v2.await()}\")\n//sampleEnd    \n}\n可以在这里获取完整代码。\n\n程序执行使用了 -Dkotlinx.coroutines.debug JVM 参数，输出如下所示：\n\n[main @main#1] Started main coroutine\n[main @v1coroutine#2] Computing v1\n[main @v2coroutine#3] Computing v2\n[main @main#1] The answer for v1 / v2 = 42\n有时我们需要在协程上下文中定义多个元素。我们可以使用 + 操作符来实现。 比如说，我们可以显式指定一个调度器来启动协程并且同时显式指定一个命名：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    launch(Dispatchers.Default + CoroutineName(\"test\")) {\n        println(\"I'm working in thread ${Thread.currentThread().name}\")\n    }\n//sampleEnd    \n}\n可以在这里获取完整代码。\n\n这段代码使用了 -Dkotlinx.coroutines.debug JVM 参数，输出如下所示：\n\nI'm working in thread DefaultDispatcher-worker-1 @test#2\n让我们将关于上下文，子协程以及作业的知识综合在一起。假设我们的应用程序拥有一个具有生命周期的对象，但这个对象并不是一个协程。举例来说，我们编写了一个 Android 应用程序并在 Android 的 activity 上下文中启动了一组协程来使用异步操作拉取并更新数据以及执行动画等等。所有这些协程必须在这个 activity 销毁的时候取消以避免内存泄漏。当然，我们也可以手动操作上下文与作业，以结合 activity 的生命周期与它的协程，但是 kotlinx.coroutines 提供了一个封装：CoroutineScope 的抽象。 你应该已经熟悉了协程作用域，因为所有的协程构建器都声明为在它之上的扩展。\n\n我们通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 Dispatchers.Main 作为默认调度器的 UI 应用程序 创建作用域：\n\nclass Activity {\n    private val mainScope = MainScope()\n\n    fun destroy() {\n        mainScope.cancel()\n    }\n    // 继续运行……\nNow, we can launch coroutines in the scope of this Activity using the defined scope. For the demo, we launch ten coroutines that delay for a different time:\n\n    // 在 Activity 类中\n    fun doSomething() {\n        // 在示例中启动了 10 个协程，且每个都工作了不同的时长\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // Activity 类结束\n在 main 函数中我们创建 activity，调用测试函数 doSomething，并且在 500 毫秒后销毁这个 activity。 这取消了从 doSomething 启动的所有协程。我们可以观察到这些是由于在销毁之后， 即使我们再等一会儿，activity 也不再打印消息。\n\nimport kotlinx.coroutines.*\n\nclass Activity {\n    private val mainScope = CoroutineScope(Dispatchers.Default) // use Default for test purposes\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n\n    fun doSomething() {\n        // 在示例中启动了 10 个协程，且每个都工作了不同的时长\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // Activity 类结束\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    val activity = Activity()\n    activity.doSomething() // 运行测试函数\n    println(\"Launched coroutines\")\n    delay(500L) // 延迟半秒钟\n    println(\"Destroying activity!\")\n    activity.destroy() // 取消所有的协程\n    delay(1000) // 为了在视觉上确认它们没有工作\n//sampleEnd    \n}\n可以在这里获取完整代码。\n\n这个示例的输出如下所示：\n\nLaunched coroutines\nCoroutine 0 is done\nCoroutine 1 is done\nDestroying activity!\n你可以看到，只有前两个协程打印了消息，而另一个协程在 Activity.destroy() 中单次调用了 job.cancel()。\n\n注意，Android 在所有具有生命周期的实体中都对协程作用域提供了一等的支持。 请查看相关文档。\n\n有时，能够将一些线程局部数据传递到协程与协程之间是很方便的。 然而，由于它们不受任何特定线程的约束，如果手动完成，可能会导致出现样板代码。\n\nThreadLocal， asContextElement 扩展函数在这里会充当救兵。它创建了额外的上下文元素， 且保留给定 ThreadLocal 的值，并在每次协程切换其上下文时恢复它。\n\n它很容易在下面的代码中演示：\n\nimport kotlinx.coroutines.*\n\nval threadLocal = ThreadLocal<String?>() // 声明线程局部变量\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    threadLocal.set(\"main\")\n    println(\"Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = \"launch\")) {\n        println(\"Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n        yield()\n        println(\"After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    }\n    job.join()\n    println(\"Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n//sampleEnd    \n}\n可以在这里获取完整代码。\n\n在这个例子中我们使用 Dispatchers.Default 在后台线程池中启动了一个新的协程，所以它工作在线程池中的不同线程中，但它仍然具有线程局部变量的值， 我们指定使用 threadLocal.asContextElement(value = \"launch\")， 无论协程执行在哪个线程中都是没有问题的。 因此，其输出如（调试）所示：\n\nPre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'\nLaunch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: 'launch'\nAfter yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: 'launch'\nPost-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'\n这很容易忘记去设置相应的上下文元素。如果运行协程的线程不同， 在协程中访问的线程局部变量则可能会产生意外的值。 为了避免这种情况，建议使用 ensurePresent 方法并且在不正确的使用时快速失败。\n\nThreadLocal 具有一流的支持，可以与任何 kotlinx.coroutines 提供的原语一起使用。 但它有一个关键限制，即：当一个线程局部变量变化时，则这个新值不会传播给协程调用者（因为上下文元素无法追踪所有 ThreadLocal 对象访问），并且下次挂起时更新的值将丢失。 使用 withContext 在协程中更新线程局部变量，详见 asContextElement。\n\n另外，一个值可以存储在一个可变的域中，例如 class Counter(var i: Int)，是的，反过来， 可以存储在线程局部的变量中。然而，在这个案例中你完全有责任来进行同步可能的对这个可变的域进行的并发的修改。\n\n对于高级的使用，例如，那些在内部使用线程局部传递数据的用于与日志记录 MDC 集成，以及事务上下文或任何其它库，请参见需要实现的 ThreadContextElement 接口的文档。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386561179},"updatedAt":{"$$date":1597388428316},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"odJnFbbCvjFJc8DS"}
{"name":"kotlin-接口 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/interfaces.html\n接口 - Kotlin 语言中文站\n6-8 minutes\n改进翻译\nKotlin 的接口可以既包含抽象方法的声明也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。\n\n使用关键字 interface 来定义接口\n\n一个类或者对象可以实现一个或多个接口。\n\nclass Child : MyInterface {\n    override fun bar() {\n        // 方法体\n    }\n}\n你可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。\n\ninterface MyInterface {\n    val prop: Int // 抽象的\n\n    val propertyWithImplementation: String\n        get() = \"foo\"\n\n    fun foo() {\n        print(prop)\n    }\n}\n\nclass Child : MyInterface {\n    override val prop: Int = 29\n}\n一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现：\n\ninterface Named {\n    val name: String\n}\n\ninterface Person : Named {\n    val firstName: String\n    val lastName: String\n    \n    override val name: String get() = \"$firstName $lastName\"\n}\n\ndata class Employee(\n    // 不必实现“name”\n    override val firstName: String,\n    override val lastName: String,\n    val position: Position\n) : Person\n实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如\n\ninterface A {\n    fun foo() { print(\"A\") }\n    fun bar()\n}\n\ninterface B {\n    fun foo() { print(\"B\") }\n    fun bar() { print(\"bar\") }\n}\n\nclass C : A {\n    override fun bar() { print(\"bar\") }\n}\n\nclass D : A, B {\n    override fun foo() {\n        super<A>.foo()\n        super<B>.foo()\n    }\n\n    override fun bar() {\n        super<B>.bar()\n    }\n}\n上例中，接口 A 和 B 都定义了方法 foo() 和 bar()。 两者都实现了 foo(), 但是只有 B 实现了 bar() (bar() 在 A 中没有标记为抽象， 因为没有方法体时默认为抽象）。因为 C 是一个实现了 A 的具体类，所以必须要重写 bar() 并实现这个抽象方法。\n\n然而，如果我们从 A 和 B 派生 D，我们需要实现我们从多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306187990},"updatedAt":{"$$date":1597307907724},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"okyR70l78sf8VqLi"}
{"name":"CSS3 字体","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 字体\nWith CSS3, web designers are no longer forced to use only web-safe fonts\nCSS3 @font-face 规则\n使用以前 CSS 的版本，网页设计师不得不使用用户计算机上已经安装的字体。\n\n使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。\n\n当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。\n\n您所选择的字体在新的 CSS3 版本有关于 @font-face 规则描述。\n\n您\"自己的\"的字体是在 CSS3 @font-face 规则中定义的。\n\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器版本号。\n\n属性\t\t\t\t\t\n@font-face\t4.0\t9.0\t3.5\t3.2\t10.0\nInternet Explorer 9+, Firefox, Chrome, Safari, 和 Opera 支持 WOFF (Web Open Font Format) 字体.\n\nFirefox, Chrome, Safari, 和 Opera 支持 .ttf(True Type字体)和.otf(OpenType)字体字体类型）。\n\nChrome, Safari 和 Opera 也支持 SVG 字体/折叠.\n\nInternet Explorer 同样支持 EOT (Embedded OpenType) 字体.\n\n注意： Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。\n\n使用您需要的字体\n在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。\n\nlamp\t提示：URL请使用小写字母的字体，大写字母在IE中会产生意外的结果\n如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n<style> \n@font-face\n{\n    font-family: myFirstFont;\n    src: url(sansation_light.woff);\n}\n \ndiv\n{\n    font-family:myFirstFont;\n}\n</style>\n\n尝试一下 »\n\n使用粗体文本\n您必须添加另一个包含粗体文字的@font-face规则：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n@font-face\n{\n    font-family: myFirstFont;\n    src: url(sansation_bold.woff);\n    font-weight:bold;\n}\n\n尝试一下 »\n该文件\"Sansation_Bold.ttf\"是另一种字体文件，包含Sansation字体的粗体字。\n\n浏览器使用这一文本的字体系列\"myFirstFont\"时应该呈现为粗体。\n\n这样你就可以有许多相同的字体@font-face的规则。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974615041},"updatedAt":{"$$date":1598974858348},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"olGfWwlAaX0OrAyw"}
{"name":"qk-ks_lib_share","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\nlibs\numeng-common-2.1.0.jar\numeng-share-core-6.9.6.jar\numeng-share-QQ-simplify-6.9.6.jar\numeng-share-sina-simplify-6.9.6.jar\numeng-share-wechat-simplify-6.9.6.jar\numeng-shareboard-widget-6.9.6.jar\numeng-sharetool-6.9.6.jar\n\n\n\n\n\n\n\n\nobject UmengConfig {\n\n    lateinit var wxAppId: String\n\n    /**\n     * 初始化友盟分享以及第三方登录\n     * @param debug 是否测试环境\n     * @param context Application context\n     * @param umengAppKey 友盟 app key\n     * @param marketChannel 友盟渠道id\n     * @param wxAppID AppID 微信开放平台 AppId\n     * @param wxAppSecret AppSecret 微信开放平台 AppSecret\n     * @param qqZoneAppId qq appid\n     * @param qqZoneAppSecret qq appSecret\n     * @param sinaAppId 新浪 appid\n     * @param sinaAppSecret 新浪 app secret\n     * @param sinaCallbackUrl 新浪 回调url\n     */\n    fun initUmengConfig(\n        debug: Boolean = false,\n        context: Context,\n        umengAppKey: String,\n        marketChannel: String,\n        wxAppID: String,\n        wxAppSecret: String,\n        qqZoneAppId: String? = \"\",\n        qqZoneAppSecret: String? = \"\",\n        sinaAppId: String? = \"\",\n        sinaAppSecret: String? = \"\",\n        sinaCallbackUrl: String? = \"\") {\n        \n        /**\n         * 设置组件化的Log开关\n         * 参数: boolean 默认为false，如需查看LOG设置为true\n         */\n//        UMConfigure.setLogEnabled(true)\n\n        UMConfigure.init(\n            context,\n            umengAppKey,\n            marketChannel,\n            UMConfigure.DEVICE_TYPE_PHONE,\n            null\n        )\n        this.wxAppId = wxAppID\n        PlatformConfig.setWeixin(wxAppID, wxAppSecret)\n\n        if (!qqZoneAppId.isNullOrEmpty() and !qqZoneAppSecret.isNullOrEmpty()) {\n            PlatformConfig.setQQZone(qqZoneAppId, qqZoneAppSecret)\n        }\n\n        if (!sinaAppId.isNullOrEmpty() and !sinaAppSecret.isNullOrEmpty()) {\n            PlatformConfig.setSinaWeibo(sinaAppId, sinaAppSecret, sinaCallbackUrl)\n        }\n\n        UMConfigure.setLogEnabled(debug)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 101\n        versionName \"101\"\n\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    sourceSets {\n        main {\n            manifest.srcFile 'AndroidManifest.xml'\n            java.srcDirs = ['src', 'src/main/java', 'src/main/java/']\n            resources.srcDirs = ['src']\n            aidl.srcDirs = ['src']\n            renderscript.srcDirs = ['src']\n            res.srcDirs = ['res']\n            assets.srcDirs = ['assets']\n            jniLibs.srcDirs = ['libs']\n        }\n\n\n        // Move the build types to build-types/<type>\n        // For instance, build-types/debug/java, build-types/debug/AndroidManifest.xml, ...\n        // This moves them out of them default location under src/<type>/... which would\n        // conflict with src/ being used by the main source set.\n        // Adding new build types or product flavors should be accompanied\n        // by a similar customization.\n        debug.setRoot('build-types/debug')\n        release.setRoot('build-types/release')\n    }\n}\n\ndependencies {\n    api fileTree(include: ['*.jar'], dir: 'libs')\n    api deps.wechat_sdk_android_without_mta\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n          package=\"com.ks.lib.share\"\n    >\n\n    <!-- 必须的权限 -->\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <!-- 推荐的权限 -->\n    <!-- 添加如下权限，以便使用更多的第三方SDK和更精准的统计数据 -->\n    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" />\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n\n\n    <application>\n\n        <!--        umeng-->\n\n        <!--        新浪：start-->\n        <activity\n            android:name=\"com.umeng.socialize.media.WBShareCallBackActivity\"\n            android:configChanges=\"keyboardHidden|orientation\"\n            android:theme=\"@android:style/Theme.Translucent.NoTitleBar\"\n            android:exported=\"false\"\n            >\n        </activity>\n        <activity android:name=\"com.sina.weibo.sdk.web.WeiboSdkWebActivity\"\n            android:configChanges=\"keyboardHidden|orientation\"\n            android:exported=\"false\"\n            android:windowSoftInputMode=\"adjustResize\"\n            >\n\n        </activity>\n        <activity\n            android:theme=\"@android:style/Theme.Translucent.NoTitleBar.Fullscreen\"\n            android:launchMode=\"singleTask\"\n            android:name=\"com.sina.weibo.sdk.share.WbShareTransActivity\">\n            <intent-filter>\n                <action android:name=\"com.sina.weibo.sdk.action.ACTION_SDK_REQ_ACTIVITY\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n            </intent-filter>\n\n        </activity>\n        <!--        新浪：end-->\n\n        <!--        qq start-->\n        <activity\n            android:name=\"com.tencent.tauth.AuthActivity\"\n            android:launchMode=\"singleTask\"\n            android:noHistory=\"true\" >\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n\n                <data android:scheme=\"tencent100424468\" />\n            </intent-filter>\n        </activity>\n        <activity\n            android:name=\"com.tencent.connect.common.AssistActivity\"\n            android:theme=\"@android:style/Theme.Translucent.NoTitleBar\"\n            android:configChanges=\"orientation|keyboardHidden|screenSize\"/>\n\n        <meta-data\n            android:name=\"UMENG_APPKEY\"\n            android:value=\"${UMENG_APPKEY}\" />\n        <meta-data\n            android:name=\"UMENG_MESSAGE_SECRET\"\n            android:value=\"fdfff0807f987b491de3e4c36c5d1090\" />\n\n    </application>\n\n</manifest>\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580899998},"updatedAt":{"$$date":1598592768187},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"p4L1gpEFbc735R1F"}
{"name":"新手村通关指南","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"新手村通关指南\n😉很高兴你能加入我们的团队！\n接下来，你将配合办理入职相关手续，我们将为你提供团队相关信息。\n📦Level 1\n🔲 熟悉开发组和项目组成员\n🔲 申请各种账号权限\n🔲下载vpn软件，使用企业邮箱里面的账号密码登录。\n🔲使用公司邮箱，注册gitlab账号，并找负责人（iOS：@董晓东(dadong-dybxx) Android：@杨庆(shibuyanqi)邀请进组，开通代码权限。\n🔲找 @封宇(fengyu-4inok)开通RN仓库权限。\n🔲下载主项目代码，并熟悉对应模块的代码~\n🔲iOS端需要添加测试设备的，将UDID发给 @董晓东(dadong-dybxx)\n🔲 熟悉各个业务系统的使用\n🔲 搭建开发环境\n🔲iOS：CocoaPods/Xcode等\n🔲Android：\n📦Level 2\n🔲熟悉开发流程\n🔲记录问题\n🔲明确流程，角色认知，责任担当\n🔲熟悉Demo代码\n🔲记录问题\n🔲根据业务线熟悉业务系统\n🔲输出页面流转图\n📦Level 3-4\n🔲答疑\n🔲开发流程答疑\n🔲Demo代码答疑\n🔲熟悉代码规范\n🔲学习代码规范\n🔲熟悉代码\n🔲明确模块内部的代码组织方式，各个类承担的职责\n📦Level 5\n🔲check\n🔲GitFlow\n🔲开发流程\n🔲分享\n🔲当前项目代码中存在的问题\n🔲对当前项目的建议\n附录：\n内部系统账号密码\n常用软件下载\n各业务线对接人\n常见问题汇总"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598545170398},"updatedAt":{"$$date":1598545235923},"_id":"p70inCrMdDY6N72c","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"qk-ks_component_download","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    libraryVariants.all {\n        it.getGenerateBuildConfigProvider()\n    }\n\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    android {\n        lintOptions {\n            abortOnError false\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n\n    implementation deps.okhttp3.okhttp\n    implementation deps.kotlin.coroutines_core\n    implementation deps.kotlin.coroutines_android\n    implementation deps.archLifecycle.lifecycle_viewmodel_ktx\n    implementation deps.archLifecycle.lifecycle_livedata_ktx\n}\n\n////这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class TrustAllSSLSocketClient {\n    //获取这个SSLSocketFactory\n    public static SSLSocketFactory getSSLSocketFactory() {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n            sslContext.init(null, getTrustManager(), new SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    //获取TrustManager\n    private static TrustManager[] getTrustManager() {\n        TrustManager[] trustAllCerts = new TrustManager[]{getX509TrustManager()};\n        return trustAllCerts;\n    }\n\n    //获取TrustManager\n    public static X509TrustManager getX509TrustManager() {\n        return new X509TrustManager() {\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType) {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType) {\n            }\n\n            @Override\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[]{};\n            }\n        };\n    }\n\n\n    //获取HostnameVerifier\n    public static HostnameVerifier getHostnameVerifier() {\n        HostnameVerifier hostnameVerifier = new HostnameVerifier() {\n            @Override\n            public boolean verify(String s, SSLSession sslSession) {\n                return true;\n            }\n        };\n        return hostnameVerifier;\n    }\n}\n\n\n\n\n\n\n\nclass DownloadViewModel : CoroutineViewModel() {\n\n    private var newCall: Call? = null\n    private lateinit var mOkHttpClient: OkHttpClient\n    private var lastProgress: Int = 0\n\n    fun downloadFile(fileUrl: String, path: String, fileName: String): LiveData<FileDownloadEvent> {\n        val result = MutableLiveData<FileDownloadEvent>()\n        if (fileUrl.isBlank()) {\n            result.value = FileDownloadEvent.Failure(\"下载失败\")\n        } else {\n            proceedFileDownload(fileUrl, path, fileName, result)\n        }\n        return result\n    }\n\n    private fun proceedFileDownload(\n        fileUrl: String,\n        path: String,\n        fileName: String,\n        result: MutableLiveData<FileDownloadEvent>\n    ) {\n\n        mOkHttpClient = OkHttpClient.Builder()\n            .retryOnConnectionFailure(true)\n            .connectTimeout(100, TimeUnit.SECONDS)\n            .readTimeout(100, TimeUnit.SECONDS)\n            .sslSocketFactory(\n                TrustAllSSLSocketClient.getSSLSocketFactory(),\n                TrustAllSSLSocketClient.getX509TrustManager()\n            )\n            .hostnameVerifier(TrustAllSSLSocketClient.getHostnameVerifier())\n            .build()\n\n        launch(Dispatchers.IO) {\n            try {\n                performFileDownload(fileUrl, path, fileName, result)\n            } catch (exception: IOException) {\n                withContext(Dispatchers.Main) {\n                    result.postValue(FileDownloadEvent.Failure(\"下载失败\"))\n                }\n            }\n        }\n    }\n\n    private fun performFileDownload(\n        fileUrl: String,\n        path: String,\n        fileName: String,\n        result: MutableLiveData<FileDownloadEvent>\n    ) {\n        val downloadTarget = targetFile(path, fileName)\n\n        val request: Request = Request.Builder().url(fileUrl).build()\n        newCall = mOkHttpClient.newCall(request)\n        newCall?.enqueue(object : Callback {\n\n            override fun onFailure(call: Call, e: IOException) {\n                launch(Dispatchers.Main) {\n                    result.value = FileDownloadEvent.Failure(\"下载失败\")\n                }\n            }\n\n            override fun onResponse(call: Call, response: Response) {\n                var `is`: InputStream? = null\n                val buf = ByteArray(4096)\n                var len = 0\n                var fos: FileOutputStream? = null\n                try {\n                    `is` = response.body!!.byteStream()\n                    val total = response.body!!.contentLength()\n                    fos = FileOutputStream(downloadTarget)\n                    var sum: Long = 0\n                    while (`is`.read(buf).also { len = it } != -1) {\n                        fos.write(buf, 0, len)\n                        sum += len.toLong()\n                        val progress = (sum * 1.0f / total * 100).toInt()\n                        if (progress > lastProgress) {\n                            launch(Dispatchers.Main) {\n                                result.postValue(FileDownloadEvent.Progress(progress))\n                            }\n                        }\n                        lastProgress = progress\n                    }\n                    fos.flush()\n                    launch(Dispatchers.Main) {\n                        result.postValue(FileDownloadEvent.Success(downloadTarget.path))\n                    }\n                } catch (e: Exception) {\n                    launch(Dispatchers.Main) {\n                        result.postValue(FileDownloadEvent.Failure(\"下载失败\"))\n                    }\n                } finally {\n                    `is`?.close()\n                    fos?.close()\n                }\n            }\n        })\n    }\n\n    private fun targetFile(path: String, fileName: String): File {\n        var downloadTarget = File(path, fileName)\n        if (downloadTarget.exists()) {\n            downloadTarget.delete()\n        }\n\n        if (!downloadTarget.exists() && downloadTarget.isFile) {\n            downloadTarget.createNewFile()\n        }\n        return downloadTarget\n    }\n\n    /**\n     * 下载取消\n     */\n    fun downloadCancel() {\n        newCall?.let {\n            if (it.isExecuted()) {\n                it.cancel()\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\nclass DownloadUtils {\n\n    private lateinit var mOkHttpClient: OkHttpClient\n    private var lastProgress: Int = 0\n\n    fun downloadFile(fileUrl: String, path: String, fileName: String, listener: DownloadListener) {\n        if (!fileUrl.isBlank()) {\n            proceedFileDownload(fileUrl, path, fileName, listener)\n        }\n    }\n\n    private fun proceedFileDownload(\n        fileUrl: String,\n        path: String,\n        fileName: String,\n        listener: DownloadListener\n    ) {\n\n        mOkHttpClient = OkHttpClient.Builder()\n            .connectTimeout(100, TimeUnit.SECONDS)\n            .readTimeout(100, TimeUnit.SECONDS)\n            .retryOnConnectionFailure(true)\n            .sslSocketFactory(\n                TrustAllSSLSocketClient.getSSLSocketFactory(),\n                TrustAllSSLSocketClient.getX509TrustManager()\n            )\n            .hostnameVerifier(TrustAllSSLSocketClient.getHostnameVerifier())\n            .build()\n        performFileDownload(fileUrl, path, fileName, listener)\n\n    }\n\n    private fun performFileDownload(\n        fileUrl: String,\n        path: String,\n        fileName: String,\n        listener: DownloadListener\n\n    ) {\n        val downloadTarget = targetFile(path, fileName)\n\n        val request: Request = Request.Builder().url(fileUrl).build()\n\n        mOkHttpClient.newCall(request).enqueue(object : Callback {\n\n            override fun onFailure(call: Call, e: IOException) {\n                listener.onFail(\"下载失败\")\n            }\n\n            override fun onResponse(call: Call, response: Response) {\n                var `is`: InputStream? = null\n                val buf = ByteArray(4096)\n                var len = 0\n                var fos: FileOutputStream? = null\n                try {\n                    `is` = response.body!!.byteStream()\n                    val total = response.body!!.contentLength()\n                    fos = FileOutputStream(downloadTarget)\n                    var sum: Long = 0\n                    while (`is`.read(buf).also { len = it } != -1) {\n                        fos.write(buf, 0, len)\n                        sum += len.toLong()\n                        val progress = (sum * 1.0f / total * 100).toInt()\n                        if (progress > lastProgress) {\n                            listener.onProgress(progress)\n                        }\n                        lastProgress = progress\n                    }\n                    fos.flush()\n                    listener.onSuccess(downloadTarget.path)\n                } catch (e: Exception) {\n                    listener.onFail(\"下载失败\")\n                } finally {\n                    `is`?.close()\n                    fos?.close()\n                }\n            }\n        })\n    }\n\n    private fun targetFile(path: String, fileName: String): File {\n        var downloadTarget = File(path, fileName)\n        if (downloadTarget.exists()) {\n            downloadTarget.delete()\n        }\n\n        if (!downloadTarget.exists() && downloadTarget.isFile) {\n            downloadTarget.createNewFile()\n        }\n        return downloadTarget\n    }\n}\n\n\n\n\n\n\n\n\n\n\nabstract class CoroutineViewModel : ViewModel(), CoroutineScope {\n\n    private val job = Job()\n\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.Main + job\n\n    override fun onCleared() {\n        job.cancel()\n        super.onCleared()\n    }\n}\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598586255521},"updatedAt":{"$$date":1598592821559},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"pOnE5lNFy7BAYNN4"}
{"name":"ad-polyv_player","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\n/**保利威视播放器包装实现\n *\n */\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 5\n\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    lintOptions {\n        abortOnError false\n    }\n\n}\nrepositories {\n    maven {\n        url 'http://maven.aliyun.com/nexus/content/repositories/releases/'\n    }\n    maven { url 'https://dl.bintray.com/polyv/android' }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    testImplementation deps.androidx.junit\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n    //保利威库 内部集成 IM Player ，\n    implementation(deps.polyv) {\n        exclude group: 'com.easefun.polyv', module: 'polyvPlayerABI'\n        exclude group: 'tv.danmaku.ijk.media'\n        exclude group: 'com.aliyun.ams'\n        exclude group: 'pl.droidsonroids.gif'\n        exclude group: 'com.tencent.bugly'\n    }\n    //, module: 'ijkplayer-armv7a','ijkplayer-java'\n    implementation ks.ksliveframe\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\npublic class PolyvConfig {\n    /**appId */\n    public static String appId = \"\";\n    /**保利威 userId  名字怪异 有位置是account id*/\n    public static String polyAccountID = \"\";\n    /**保利威 加密key*/\n    public static String secretKey = \"\";\n}\n\n\n\n\n\n\npublic class PolyvPlayer extends BaseInternalPlayer {\n    private PolyvCloudClassVideoView mPlayerView;\n    private DataSource mDataSource;\n    PolyvBaseVideoParams videoParams;\n    String TAG = \"PolyvPlayer\";\n\n    public PolyvPlayer(Context ctx) {\n\n        mPlayerView = new PolyvCloudClassVideoView(ctx){\n            //重写方法 注入IjkPlayer 追帧方法 注意：仅直播使用追帧\n            @Override\n            protected ArrayList<PolyvPlayerOptionParamVO> initOptionParameters() {\n                ArrayList<PolyvPlayerOptionParamVO> list =  super.initOptionParameters();\n            //    自编译播放器 (IjkMediaPlayer.OPT_CATEGORY_PLAYER,\"kaishu_live_flag\",1);\n                list.add(new PolyvPlayerOptionParamVO(4,\"kaishu_live_flag\",1));\n                return list;\n            }\n        };\n    }\n\n\n    public View getPlayerView() {\n        return mPlayerView;\n    }\n\n    @Override\n    public void setDataSource(DataSource dataSource) {\n        if (dataSource == null) {\n            return;\n        }\n        this.mDataSource = dataSource;\n        mPlayerView.setMediaController(new PLVECEmptyMediaController());\n        initPlayerListener();\n\n    }\n\n    private void initPlayerListener() {\n        mPlayerView.setOnErrorListener(new IPolyvVideoViewListenerEvent.OnErrorListener() {\n            @Override\n            public void onError(int what, int extra) {/**/}\n\n            @Override\n            public void onError(PolyvPlayError error) {\n                String tips = error.playStage == PolyvPlayError.PLAY_STAGE_HEADAD ? \"片头广告\"\n                        : error.playStage == PolyvPlayError.PLAY_STAGE_TAILAD ? \"片尾广告\"\n                        : error.playStage == PolyvPlayError.PLAY_STAGE_TEASER ? \"暖场视频\"\n                        : error.isMainStage() ? \"主视频\" : \"\";\n                tips = tips+\"  错误详情\"+error.errorDescribe;\n                Log.e(TAG, tips);\n            }\n        });\n        //直播状态监听\n        //  mPlayerView.setAspectRatio(PolyvPlayerScreenRatio.AR_MATCH_PARENT);\n        mPlayerView.setOnNoLiveAtPresentListener(new IPolyvCloudClassListenerEvent.OnNoLiveAtPresentListener() {\n            @Override\n            public void onNoLiveAtPresent() {\n                Log.e(TAG, \"NO live\");\n                if(mOnPlayerEventListener!=null){\n                    mOnPlayerEventListener.onPlayerEvent(PLAYER_EVENT_NO_LIVE,null);\n                }\n            }\n\n            @Override\n            public void onLiveEnd() {\n                Log.e(TAG, \"直播结束\");\n                if(mOnPlayerEventListener!=null){\n                    mOnPlayerEventListener.onPlayerEvent(PLAYER_EVENT_LIVE_END,null);\n                }\n            }\n        });\n        mPlayerView.setOnPreparedListener(new IPolyvVideoViewListenerEvent.OnPreparedListener() {\n            @Override\n            public void onPrepared() {\n                if(isStop){\n                    mPlayerView.pause();\n                    return;\n                }\n\n                Log.i(TAG, \"直播开始\");\n                if(mOnPlayerEventListener!=null){\n                    mOnPlayerEventListener.onPlayerEvent(PLAYER_EVENT_ON_PREPARED,null);\n                }\n            }\n            @Override\n            public void onPreparing() {/**/\n                Log.i(TAG, \"直播prepareIng\");\n            }\n        });\n        mPlayerView.setOnBufferingUpdateListener(new IPolyvVideoViewListenerEvent.OnBufferingUpdateListener() {\n            @Override\n            public void onBufferingUpdate(int percent) {\n                Log.i(TAG, \"Buffer\");\n            }\n        });\n        mPlayerView.setOnVideoSizeChangedListener(new IPolyvVideoViewListenerEvent.OnVideoSizeChangedListener() {\n            @Override\n            public void onVideoSizeChanged(int width, int height, int sar_num, int sar_den) {\n                Log.i(TAG, \"onVideoSizeChanged\");\n            }\n        });\n        //裁剪\n        mPlayerView.setAspectRatio(PolyvPlayerScreenRatio.AR_ASPECT_FILL_PARENT);\n        //设置直播主播追帧\n        mPlayerView.enableFrameSkip(true);\n        //解决保利威 getStatusbar 崩溃\n        mPlayerView.setNeedGestureDetector(false);\n    }\n\n    @Override\n    public void setDisplay(SurfaceHolder surfaceHolder) {\n\n    }\n\n    @Override\n    public void setSurface(Surface surface) {\n    }\n\n    @Override\n    public void setVolume(float left, float right) {\n        if (mPlayerView != null)\n            mPlayerView.setVolume((int) left);\n    }\n\n    @Override\n    public void setSpeed(float speed) {\n        if (mPlayerView != null)\n            mPlayerView.setSpeed(speed);\n    }\n\n    @Override\n    public boolean isPlaying() {\n        return mPlayerView != null && mPlayerView.isPlaying();\n    }\n\n    @Override\n    public int getCurrentPosition() {\n        return mPlayerView == null ? 0 : mPlayerView.getCurrentPosition();\n\n    }\n\n    @Override\n    public int getDuration() {\n        return mPlayerView == null ? 0 : mPlayerView.getDuration();\n    }\n\n    @Override\n    public int getAudioSessionId() {\n        return 0;\n    }\n\n    @Override\n    public int getVideoWidth() {\n        return 0;\n    }\n\n    @Override\n    public int getVideoHeight() {\n        return 0;\n    }\n\n    @Override\n    public void start() {\n//        channelId,\n//                userId,\n//                viewerId\n        if(mDataSource==null){\n            return;\n        }\n        isStop = false;\n        HashMap<String, String> extra = mDataSource.getExtra();\n        if (extra != null) {\n            PolyvConfig.polyAccountID = extra.get(\"polyAccountID\");\n            PolyvConfig.secretKey = extra.get(\"secret\");\n            String channelId = extra.get(\"channelId\");\n            PolyvConfig.appId = extra.get(\"appid\");\n            String userId = extra.get(\"userId\");\n            String name = extra.get(\"name\");\n            videoParams = new PolyvBaseVideoParams(channelId, PolyvConfig.polyAccountID, userId);\n            videoParams.buildOptions(PolyvBaseVideoParams.WAIT_AD, true)\n                    .buildOptions(PolyvBaseVideoParams.MARQUEE, true)\n                    .buildOptions(PolyvBaseVideoParams.PARAMS2, name);\n            mPlayerView.playByMode(videoParams, PolyvPlayOption.PLAYMODE_LIVE);\n\n        }\n\n    }\n\n    @Override\n    public void start(int msc) {\n\n\n    }\n\n    @Override\n    public void pause() {\n        if (mPlayerView != null) {\n            mPlayerView.pause();\n        }\n    }\n\n    @Override\n    public void resume() {\n        if (mPlayerView != null) {\n            //播放器 内核播放出问题 刷新url\n            if(!mPlayerView.isInPlaybackState()) {\n                start();\n            }\n            //继续播放\n            else if(!mPlayerView.isPlaying()){\n                mPlayerView.start();\n            }\n            Log.i(TAG,\"player resume to refresh url\");\n        }\n    }\n\n    @Override\n    public void seekTo(int msc) {\n        if (mPlayerView != null)\n            mPlayerView.seekTo(msc);\n    }\n    boolean isStop;\n    @Override\n    public void stop() {\n        isStop = true;\n        if (mPlayerView != null) {\n            mPlayerView.stopPlay();\n        }\n        Log.i(TAG,\"stop\");\n    }\n\n    @Override\n    public void reset() {\n        if(mPlayerView!=null&&!mPlayerView.isPlaying()){\n            mPlayerView.start();\n        }\n    }\n\n    @Override\n    public void destroy() {\n\n        if (mPlayerView != null) {\n            mPlayerView.stopPlay();\n            mPlayerView.release(true);\n            mPlayerView.destroy();\n            mPlayerView = null;\n        }\n    }\n}\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598517301859},"updatedAt":{"$$date":1598518480568},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"pTKmc6b0sPdbYcA7"}
{"name":"HTML 速查列表","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\nHTML 速查列表\nHTML 速查列表. 你可以打印它，以备日常使用。\n\nHTML 基本文档\n<!DOCTYPE html>\n<html>\n<head>\n<title>文档标题</title>\n</head>\n<body>\n可见文本...\n</body>\n</html>\n基本标签（Basic Tags）\n<h1>最大的标题</h1>\n<h2> . . . </h2>\n<h3> . . . </h3>\n<h4> . . . </h4>\n<h5> . . . </h5>\n<h6>最小的标题</h6>\n \n<p>这是一个段落。</p>\n<br> （换行）\n<hr> （水平线）\n<!-- 这是注释 -->\n文本格式化（Formatting）\n<b>粗体文本</b>\n<code>计算机代码</code>\n<em>强调文本</em>\n<i>斜体文本</i>\n<kbd>键盘输入</kbd> \n<pre>预格式化文本</pre>\n<small>更小的文本</small>\n<strong>重要的文本</strong>\n \n<abbr> （缩写）\n<address> （联系信息）\n<bdo> （文字方向）\n<blockquote> （从另一个源引用的部分）\n<cite> （工作的名称）\n<del> （删除的文本）\n<ins> （插入的文本）\n<sub> （下标文本）\n<sup> （上标文本）\n链接（Links）\n普通的链接：<a href=\"http://www.example.com/\">链接文本</a>\n图像链接： <a href=\"http://www.example.com/\"><img src=\"URL\" alt=\"替换文本\"></a>\n邮件链接： <a href=\"mailto:webmaster@example.com\">发送e-mail</a>\n书签：\n<a id=\"tips\">提示部分</a>\n<a href=\"#tips\">跳到提示部分</a>\n图片（Images）\n<img src=\"URL\" alt=\"替换文本\" height=\"42\" width=\"42\">\n样式/区块（Styles/Sections）\n<style type=\"text/css\">\nh1 {color:red;}\np {color:blue;}\n</style>\n<div>文档中的块级元素</div>\n<span>文档中的内联元素</span>\n无序列表\n<ul>\n    <li>项目</li>\n    <li>项目</li>\n</ul>\n有序列表\n<ol>\n    <li>第一项</li>\n    <li>第二项</li>\n</ol>\n定义列表\n<dl>\n  <dt>项目 1</dt>\n    <dd>描述项目 1</dd>\n  <dt>项目 2</dt>\n    <dd>描述项目 2</dd>\n</dl>\n表格（Tables）\n<table border=\"1\">\n  <tr>\n    <th>表格标题</th>\n    <th>表格标题</th>\n  </tr>\n  <tr>\n    <td>表格数据</td>\n    <td>表格数据</td>\n  </tr>\n</table>\n框架（Iframe）\n<iframe src=\"demo_iframe.htm\"></iframe>\n表单（Forms）\n<form action=\"demo_form.php\" method=\"post/get\">\n<input type=\"text\" name=\"email\" size=\"40\" maxlength=\"50\">\n<input type=\"password\">\n<input type=\"checkbox\" checked=\"checked\">\n<input type=\"radio\" checked=\"checked\">\n<input type=\"submit\" value=\"Send\">\n<input type=\"reset\">\n<input type=\"hidden\">\n\n<select>\n  <option>苹果</option>\n  <option selected=\"selected\">香蕉</option>\n  <option>樱桃</option>\n</select>\n\n<textarea name=\"comment\" rows=\"60\" cols=\"20\">\n</textarea>\n \n</form>\n实体（Entities）\n&lt; 等同于 <\n&gt; 等同于 >\n&#169; 等同于 ©\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886142826},"updatedAt":{"$$date":1598887106601},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"pnazfSh2dRJBAlVf"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975870931},"updatedAt":{"$$date":1598975870931},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"pnii7Gc8hFJOtxKi"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973273709},"updatedAt":{"$$date":1594973273709},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"pt4ptmd2BgnvAGP3"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977495490},"updatedAt":{"$$date":1594977495490},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"pzcJji0MzjtSRx7P"}
{"name":"css-CSS 轮廓（outline）","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 轮廓（outline）\n轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。\n\n轮廓（outline）属性指定元素轮廓的样式、颜色和宽度。\n\n轮廓（outline）实例\n在元素周围画线\n本例演示使用outline属性在元素周围画一条线。\n\n设置轮廓的样式\n本例演示如何设置轮廓的样式。\n\n设置轮廓的颜色\n本例演示如何设置轮廓的颜色。\n\n设置轮廓的宽度\n本例演示如何设置轮廓的宽度。\n\nCSS 轮廓（outline）\n轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。\n\nCSS outline 属性规定元素轮廓的样式、颜色和宽度。\n\nOutline\n所有CSS 轮廓（outline）属性\n\"CSS\" 列中的数字表示哪个CSS版本定义了该属性(CSS1 或者CSS2)。\n\n属性\t说明\t值\tCSS\noutline\t在一个声明中设置所有的轮廓属性\toutline-color\noutline-style\noutline-width\ninherit\t2\noutline-color\t设置轮廓的颜色\tcolor-name\nhex-number\nrgb-number\ninvert\ninherit\t2\noutline-style\t设置轮廓的样式\tnone\ndotted\ndashed\nsolid\ndouble\ngroove\nridge\ninset\noutset\ninherit\t2\noutline-width\t设置轮廓的宽度\tthin\nmedium\nthick\nlength\ninherit\t"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888554309},"updatedAt":{"$$date":1598889024306},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"pzebLxsvd7GkABT3"}
{"name":"py-set","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\nset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n\n要创建一个set，需要提供一个list作为输入集合：\n\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。\n\n重复元素在set中自动被过滤：\n\n>>> s = set([1, 1, 2, 2, 3, 3])\n>>> s\n{1, 2, 3}\n通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：\n\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n通过remove(key)方法可以删除元素：\n\n>>> s.remove(4)\n>>> s\n{1, 2, 3}\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n\n>>> s1 = set([1, 2, 3])\n>>> s2 = set([2, 3, 4])\n>>> s1 & s2\n{2, 3}\n>>> s1 | s2\n{1, 2, 3, 4}\nset和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973941643},"updatedAt":{"$$date":1594977107218},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"q3ZnuWnRxMvVwA7U"}
{"name":"qk-ks_component_mediaplayer","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    resourcePrefix(\"mediaplayer_\")\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 102\n        versionName \"102\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n\n        externalNativeBuild {\n            cmake {\n                cppFlags \"-std=c++11 -frtti -fexceptions\"\n                cFlags \"-O3\"\n                arguments \"-DANDROID_ARM_NEON=TRUE\"\n            }\n        }\n\n\n        ndk {\n            abiFilters 'armeabi-v7a'\n        }\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            consumerProguardFiles 'consumer-rules.pro'\n        }\n        debug {\n            debuggable true\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"0\"\n            externalNativeBuild {\n                ndkBuild {\n                    arguments 'NDK_DEBUG=1'\n                }\n            }\n\n        }\n    }\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n            java {\n                srcDirs += []\n            }\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility = 1.8\n        targetCompatibility = 1.8\n    }\n\n    splits {\n        abi {\n            enable true\n            reset()\n            include 'armeabi-v7a'\n            universalApk false\n        }\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n\n}\n\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n    implementation deps.androidx.appcompat\n    implementation deps.androidx.constraintlayout\n\n    //implementation 'com.github.czy1121:loadinglayout:1.0.1'\n\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    api \"androidx.media:media:1.1.0\"\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\narmeabi-v7a\nlibijkffmpeg.so\nlibijkplayer.so\nlibijksdl.so\n\nplayer\nannotations\nexceptions\nffmpeg\nmisc\npragma\nIjkLibLoader\nIjkMediaCodecInfo\nIjkMediaMeta\nIjkMediaPlayer\nIjkTimedText\nISurfaceTextureHolder\nISurfaceTextureHost\nMediaInfo\nMediaPlayerProxy\nTextureMediaPlayer\nStorageUtils\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598586253136},"updatedAt":{"$$date":1598592389855},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"q79GAlTFU9rShdBD"}
{"name":"ad-ksdialogplus","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 4\n        versionName version\n    }\n\n}\n\ndependencies {\n    implementation deps.androidx.design, {\n        exclude group: \"com.android.support\", module: \"multidex\"\n    }\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDialogPlus\nDialogPlusBuilder\nExpandTouchListener\nGridHolder\nHeightAnimation\nHolder\nHolderAdapter\nListHolder\nOnBackPressListener\nOnCancelListener\nOnClickListener\nOnDismissListener\nOnHolderListener\nOnItemClickListener\nSimpleAnimationListener\nUtils\nViewHolder\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598521321165},"updatedAt":{"$$date":1598523092540},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qCmjoJQewBv98Crh"}
{"name":"java-使用线程池","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                    60L, TimeUnit.SECONDS,\n                                    new SynchronousQueue<Runnable>());\n}\n因此，想创建指定动态范围的线程池，可以这么写：\n\nint min = 4;\nint max = 10;\nExecutorService es = new ThreadPoolExecutor(min, max,\n        60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());\nScheduledThreadPool\n还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用ScheduledThreadPool。放入ScheduledThreadPool的任务可以定期反复执行。\n\n创建一个ScheduledThreadPool仍然是通过Executors类：\n\nScheduledExecutorService ses = Executors.newScheduledThreadPool(4);\n我们可以提交一次性任务，它会在指定延迟后只执行一次：\n\n// 1秒后执行一次性任务:\nses.schedule(new Task(\"one-time\"), 1, TimeUnit.SECONDS);\n如果任务以固定的每3秒执行，我们可以这样写：\n\n// 2秒后开始执行定时任务，每3秒执行:\nses.scheduleAtFixedRate(new Task(\"fixed-rate\"), 2, 3, TimeUnit.SECONDS);\n如果任务以固定的3秒为间隔执行，我们可以这样写：\n\n// 2秒后开始执行定时任务，以3秒为间隔执行:\nses.scheduleWithFixedDelay(new Task(\"fixed-delay\"), 2, 3, TimeUnit.SECONDS);\n注意FixedRate和FixedDelay的区别。FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间：\n\n│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  \n├───────┼───────┼───────┼───────┼────>\n│<─────>│<─────>│<─────>│<─────>│\n而FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：\n\n│░░░│       │░░░░░│       │░░│       │░\n└───┼───────┼─────┼───────┼──┼───────┼──>\n    │<─────>│     │<─────>│  │<─────>│\n因此，使用ScheduledThreadPool时，我们要根据需要选择执行一次、FixedRate执行还是FixedDelay执行。\n\n细心的童鞋还可以思考下面的问题：\n\n在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？\n\n如果任务抛出了异常，后续任务是否继续执行？\n\nJava标准库还提供了一个java.util.Timer类，这个类也可以定期执行任务，但是，一个Timer会对应一个Thread，所以，一个Timer只能定期执行一个任务，多个定时任务必须启动多个Timer，而一个ScheduledThreadPool就可以调度多个定时任务，所以，我们完全可以用ScheduledThreadPool取代旧的Timer。\n\n练习\n从下载练习：使用线程池 （推荐使用IDE练习插件快速下载）\n\n小结\nJDK提供了ExecutorService实现了线程池功能：\n\n线程池内部维护一组线程，可以高效执行大量小任务；\n\nExecutors提供了静态方法创建不同类型的ExecutorService；\n\n必须调用shutdown()关闭ExecutorService；\n\nScheduledThreadPool可以定期调度多个任务。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826929589},"updatedAt":{"$$date":1594968084143},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qQDYRGHkEQkPQz7h"}
{"name":"py-要计算str包含多少个字符，可以用len()函数：","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n>> len('ABC')\n3\n>>> len('中文')\n2\nlen()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：\n\n>>> len(b'ABC')\n3\n>>> len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')\n6\n>>> len('中文'.encode('utf-8'))\n6"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973932390},"updatedAt":{"$$date":1594974680304},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qR1Zq5H4BvK9tAui"}
{"name":"kqapp-","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593280831},"updatedAt":{"$$date":1598593280831},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qbmH5tFSbmXUgxIt"}
{"name":"CSS3 教程","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"\nCSS 用于控制网页的样式和布局。\nCSS3 是最新的 CSS 标准。\n\n本教程向您讲解 CSS3 中的新特性。\n\n开始学习 CSS3!\n\n\nCSS3 Transforms\n\nOperaSafariChromeFirefoxInternet Explorer\nCSS3 实例\ndiv\n{\n    transform:rotate(30deg);\n}\n\n尝试一下 »\n点击 \"尝试一下\" 按钮查看在线实例。\n\nCSS3 参考手册\n在\b菜鸟教程中，我们提供完整的 CSS3 参考手册，包括所有属性和选择器的语法、实例、浏览器支持信息。\n\nCSS 属性参考手册\n\nCSS3 浏览器支持情况\n\nCSS 选择器参考手册\n\nCSS 颜色参考手册"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974375293},"updatedAt":{"$$date":1598974657278},"_id":"qeF50KMpaWfbVhxv","folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-MockWebServerTest","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage okhttp3.mockwebserver;\n\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.ConnectException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.SocketTimeoutException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.HttpsURLConnection;\nimport okhttp3.Handshake;\nimport okhttp3.Headers;\nimport okhttp3.HttpUrl;\nimport okhttp3.Protocol;\nimport okhttp3.RecordingHostnameVerifier;\nimport okhttp3.TestUtil;\nimport okhttp3.testing.PlatformRule;\nimport okhttp3.tls.HandshakeCertificates;\nimport okhttp3.tls.HeldCertificate;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.Timeout;\nimport org.junit.runner.Description;\nimport org.junit.runners.model.Statement;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static okhttp3.tls.internal.TlsUtil.localhost;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.data.Offset.offset;\nimport static org.junit.Assert.fail;\nimport static org.junit.Assume.assumeFalse;\n\n@SuppressWarnings({\"ArraysAsListWithZeroOrOneArgument\", \"deprecation\"})\npublic final class MockWebServerTest {\n  @Rule public PlatformRule platform = new PlatformRule();\n\n  @Rule public final MockWebServer server = new MockWebServer();\n\n  @Rule public Timeout globalTimeout = Timeout.seconds(30);\n\n  @Before public void checkPlatforms() {\n    platform.assumeNotBouncyCastle();\n  }\n\n  @Test public void defaultMockResponse() {\n    MockResponse response = new MockResponse();\n    assertThat(headersToList(response)).containsExactly(\"Content-Length: 0\");\n    assertThat(response.getStatus()).isEqualTo(\"HTTP/1.1 200 OK\");\n  }\n\n  @Test public void setResponseMockReason() {\n    String[] reasons = {\n        \"Mock Response\",\n        \"Informational\",\n        \"OK\",\n        \"Redirection\",\n        \"Client Error\",\n        \"Server Error\",\n        \"Mock Response\"\n    };\n    for (int i = 0; i < 600; i++) {\n      MockResponse response = new MockResponse().setResponseCode(i);\n      String expectedReason = reasons[i / 100];\n      assertThat(response.getStatus()).isEqualTo((\"HTTP/1.1 \" + i + \" \" + expectedReason));\n      assertThat(headersToList(response)).containsExactly(\"Content-Length: 0\");\n    }\n  }\n\n  @Test public void setStatusControlsWholeStatusLine() {\n    MockResponse response = new MockResponse().setStatus(\"HTTP/1.1 202 That'll do pig\");\n    assertThat(headersToList(response)).containsExactly(\"Content-Length: 0\");\n    assertThat(response.getStatus()).isEqualTo(\"HTTP/1.1 202 That'll do pig\");\n  }\n\n  @Test public void setBodyAdjustsHeaders() throws IOException {\n    MockResponse response = new MockResponse().setBody(\"ABC\");\n    assertThat(headersToList(response)).containsExactly(\"Content-Length: 3\");\n    assertThat(response.getBody().readUtf8()).isEqualTo(\"ABC\");\n  }\n\n  @Test public void mockResponseAddHeader() {\n    MockResponse response = new MockResponse()\n        .clearHeaders()\n        .addHeader(\"Cookie: s=square\")\n        .addHeader(\"Cookie\", \"a=android\");\n    assertThat(headersToList(response)).containsExactly(\"Cookie: s=square\", \"Cookie: a=android\");\n  }\n\n  @Test public void mockResponseSetHeader() {\n    MockResponse response = new MockResponse()\n        .clearHeaders()\n        .addHeader(\"Cookie: s=square\")\n        .addHeader(\"Cookie: a=android\")\n        .addHeader(\"Cookies: delicious\");\n    response.setHeader(\"cookie\", \"r=robot\");\n    assertThat(headersToList(response)).containsExactly(\"Cookies: delicious\", \"cookie: r=robot\");\n  }\n\n  @Test public void mockResponseSetHeaders() {\n    MockResponse response = new MockResponse()\n        .clearHeaders()\n        .addHeader(\"Cookie: s=square\")\n        .addHeader(\"Cookies: delicious\");\n\n    response.setHeaders(new Headers.Builder().add(\"Cookie\", \"a=android\").build());\n\n    assertThat(headersToList(response)).containsExactly(\"Cookie: a=android\");\n  }\n\n  @Test public void regularResponse() throws Exception {\n    server.enqueue(new MockResponse().setBody(\"hello world\"));\n\n    URL url = server.url(\"/\").url();\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    connection.setRequestProperty(\"Accept-Language\", \"en-US\");\n    InputStream in = connection.getInputStream();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));\n    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);\n    assertThat(reader.readLine()).isEqualTo(\"hello world\");\n\n    RecordedRequest request = server.takeRequest();\n    assertThat(request.getRequestLine()).isEqualTo(\"GET / HTTP/1.1\");\n    assertThat(request.getHeader(\"Accept-Language\")).isEqualTo(\"en-US\");\n\n    // Server has no more requests.\n    assertThat(server.takeRequest(100, MILLISECONDS)).isNull();\n  }\n\n  @Test public void redirect() throws Exception {\n    server.enqueue(new MockResponse()\n        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)\n        .addHeader(\"Location: \" + server.url(\"/new-path\"))\n        .setBody(\"This page has moved!\"));\n    server.enqueue(new MockResponse().setBody(\"This is the new location!\"));\n\n    URLConnection connection = server.url(\"/\").url().openConnection();\n    InputStream in = connection.getInputStream();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));\n    assertThat(reader.readLine()).isEqualTo(\"This is the new location!\");\n\n    RecordedRequest first = server.takeRequest();\n    assertThat(first.getRequestLine()).isEqualTo(\"GET / HTTP/1.1\");\n    RecordedRequest redirect = server.takeRequest();\n    assertThat(redirect.getRequestLine()).isEqualTo(\"GET /new-path HTTP/1.1\");\n  }\n\n  /**\n   * Test that MockWebServer blocks for a call to enqueue() if a request is made before a mock\n   * response is ready.\n   */\n  @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {\n    new Thread(() -> {\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException ignored) {\n      }\n      server.enqueue(new MockResponse().setBody(\"enqueued in the background\"));\n    }).start();\n\n    URLConnection connection = server.url(\"/\").url().openConnection();\n    InputStream in = connection.getInputStream();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));\n    assertThat(reader.readLine()).isEqualTo(\"enqueued in the background\");\n  }\n\n  @Test public void nonHexadecimalChunkSize() throws Exception {\n    server.enqueue(new MockResponse()\n        .setBody(\"G\\r\\nxxxxxxxxxxxxxxxx\\r\\n0\\r\\n\\r\\n\")\n        .clearHeaders()\n        .addHeader(\"Transfer-encoding: chunked\"));\n\n    URLConnection connection = server.url(\"/\").url().openConnection();\n    InputStream in = connection.getInputStream();\n    try {\n      in.read();\n      fail();\n    } catch (IOException expected) {\n    }\n  }\n\n  @Test public void responseTimeout() throws Exception {\n    server.enqueue(new MockResponse()\n        .setBody(\"ABC\")\n        .clearHeaders()\n        .addHeader(\"Content-Length: 4\"));\n    server.enqueue(new MockResponse().setBody(\"DEF\"));\n\n    URLConnection urlConnection = server.url(\"/\").url().openConnection();\n    urlConnection.setReadTimeout(1000);\n    InputStream in = urlConnection.getInputStream();\n    assertThat(in.read()).isEqualTo('A');\n    assertThat(in.read()).isEqualTo('B');\n    assertThat(in.read()).isEqualTo('C');\n    try {\n      in.read(); // if Content-Length was accurate, this would return -1 immediately\n      fail();\n    } catch (SocketTimeoutException expected) {\n    }\n\n    URLConnection urlConnection2 = server.url(\"/\").url().openConnection();\n    InputStream in2 = urlConnection2.getInputStream();\n    assertThat(in2.read()).isEqualTo('D');\n    assertThat(in2.read()).isEqualTo('E');\n    assertThat(in2.read()).isEqualTo('F');\n    assertThat(in2.read()).isEqualTo(-1);\n\n    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);\n    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);\n  }\n\n  @Ignore(\"Not actually failing where expected\")\n  @Test public void disconnectAtStart() throws Exception {\n    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));\n    server.enqueue(new MockResponse()); // The jdk's HttpUrlConnection is a bastard.\n    server.enqueue(new MockResponse());\n    try {\n      server.url(\"/a\").url().openConnection().getInputStream();\n      fail();\n    } catch (IOException expected) {\n    }\n    server.url(\"/b\").url().openConnection().getInputStream(); // Should succeed.\n  }\n\n  /**\n   * Throttle the request body by sleeping 500ms after every 3 bytes. With a 6-byte request, this\n   * should yield one sleep for a total delay of 500ms.\n   */\n  @Test public void throttleRequest() throws Exception {\n    TestUtil.assumeNotWindows();\n\n    server.enqueue(new MockResponse()\n        .throttleBody(3, 500, TimeUnit.MILLISECONDS));\n\n    long startNanos = System.nanoTime();\n    URLConnection connection = server.url(\"/\").url().openConnection();\n    connection.setDoOutput(true);\n    connection.getOutputStream().write(\"ABCDEF\".getBytes(UTF_8));\n    InputStream in = connection.getInputStream();\n    assertThat(in.read()).isEqualTo(-1);\n    long elapsedNanos = System.nanoTime() - startNanos;\n    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);\n    assertThat(elapsedMillis).isBetween(500L, 1000L);\n  }\n\n  /**\n   * Throttle the response body by sleeping 500ms after every 3 bytes. With a 6-byte response, this\n   * should yield one sleep for a total delay of 500ms.\n   */\n  @Test public void throttleResponse() throws Exception {\n    TestUtil.assumeNotWindows();\n\n    server.enqueue(new MockResponse()\n        .setBody(\"ABCDEF\")\n        .throttleBody(3, 500, TimeUnit.MILLISECONDS));\n\n    long startNanos = System.nanoTime();\n    URLConnection connection = server.url(\"/\").url().openConnection();\n    InputStream in = connection.getInputStream();\n    assertThat(in.read()).isEqualTo('A');\n    assertThat(in.read()).isEqualTo('B');\n    assertThat(in.read()).isEqualTo('C');\n    assertThat(in.read()).isEqualTo('D');\n    assertThat(in.read()).isEqualTo('E');\n    assertThat(in.read()).isEqualTo('F');\n    assertThat(in.read()).isEqualTo(-1);\n    long elapsedNanos = System.nanoTime() - startNanos;\n    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);\n    assertThat(elapsedMillis).isBetween(500L, 1000L);\n  }\n\n  /** Delay the response body by sleeping 1s. */\n  @Test public void delayResponse() throws IOException {\n    TestUtil.assumeNotWindows();\n\n    server.enqueue(new MockResponse()\n        .setBody(\"ABCDEF\")\n        .setBodyDelay(1, SECONDS));\n\n    long startNanos = System.nanoTime();\n    URLConnection connection = server.url(\"/\").url().openConnection();\n    InputStream in = connection.getInputStream();\n    assertThat(in.read()).isEqualTo('A');\n    long elapsedNanos = System.nanoTime() - startNanos;\n    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);\n    assertThat(elapsedMillis).isGreaterThanOrEqualTo(1000L);\n\n    in.close();\n  }\n\n  @Test public void disconnectRequestHalfway() throws Exception {\n    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));\n    // Limit the size of the request body that the server holds in memory to an arbitrary\n    // 3.5 MBytes so this test can pass on devices with little memory.\n    server.setBodyLimit(7 * 512 * 1024);\n\n    HttpURLConnection connection = (HttpURLConnection) server.url(\"/\").url().openConnection();\n    connection.setRequestMethod(\"POST\");\n    connection.setDoOutput(true);\n    connection.setFixedLengthStreamingMode(1024 * 1024 * 1024); // 1 GB\n    connection.connect();\n    OutputStream out = connection.getOutputStream();\n\n    byte[] data = new byte[1024 * 1024];\n    int i;\n    for (i = 0; i < 1024; i++) {\n      try {\n        out.write(data);\n        out.flush();\n        if (i == 513) {\n          // pause slightly after half way to make result more predictable\n          Thread.sleep(100);\n        }\n      } catch (IOException e) {\n        break;\n      }\n    }\n    // Halfway +/- 0.5%\n    assertThat((float) i).isCloseTo(512f, offset(5f));\n  }\n\n  @Test public void disconnectResponseHalfway() throws IOException {\n    server.enqueue(new MockResponse()\n        .setBody(\"ab\")\n        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));\n\n    URLConnection connection = server.url(\"/\").url().openConnection();\n    assertThat(connection.getContentLength()).isEqualTo(2);\n    InputStream in = connection.getInputStream();\n    assertThat(in.read()).isEqualTo('a');\n    try {\n      int byteRead = in.read();\n      // OpenJDK behavior: end of stream.\n      assertThat(byteRead).isEqualTo(-1);\n    } catch (ProtocolException e) {\n      // On Android, HttpURLConnection is implemented by OkHttp v2. OkHttp\n      // treats an incomplete response body as a ProtocolException.\n    }\n  }\n\n  private List<String> headersToList(MockResponse response) {\n    Headers headers = response.getHeaders();\n    int size = headers.size();\n    List<String> headerList = new ArrayList<>(size);\n    for (int i = 0; i < size; i++) {\n      headerList.add(headers.name(i) + \": \" + headers.value(i));\n    }\n    return headerList;\n  }\n\n  @Test public void shutdownWithoutStart() throws IOException {\n    MockWebServer server = new MockWebServer();\n    server.shutdown();\n  }\n\n  @Test public void closeViaClosable() throws IOException {\n    Closeable server = new MockWebServer();\n    server.close();\n  }\n\n  @Test public void shutdownWithoutEnqueue() throws IOException {\n    MockWebServer server = new MockWebServer();\n    server.start();\n    server.shutdown();\n  }\n\n  @Test public void portImplicitlyStarts() {\n    assertThat(server.getPort()).isGreaterThan(0);\n  }\n\n  @Test public void hostnameImplicitlyStarts() {\n    assertThat(server.getHostName()).isNotNull();\n  }\n\n  @Test public void toProxyAddressImplicitlyStarts() {\n    assertThat(server.toProxyAddress()).isNotNull();\n  }\n\n  @Test public void differentInstancesGetDifferentPorts() throws IOException {\n    MockWebServer other = new MockWebServer();\n    assertThat(other.getPort()).isNotEqualTo(server.getPort());\n    other.shutdown();\n  }\n\n  @Test public void statementStartsAndStops() throws Throwable {\n    final AtomicBoolean called = new AtomicBoolean();\n    Statement statement = server.apply(new Statement() {\n      @Override public void evaluate() throws Throwable {\n        called.set(true);\n        server.url(\"/\").url().openConnection().connect();\n      }\n    }, Description.EMPTY);\n\n    statement.evaluate();\n\n    assertThat(called.get()).isTrue();\n    try {\n      server.url(\"/\").url().openConnection().connect();\n      fail();\n    } catch (ConnectException expected) {\n    }\n  }\n\n  @Test public void shutdownWhileBlockedDispatching() throws Exception {\n    // Enqueue a request that'll cause MockWebServer to hang on QueueDispatcher.dispatch().\n    HttpURLConnection connection = (HttpURLConnection) server.url(\"/\").url().openConnection();\n    connection.setReadTimeout(500);\n    try {\n      connection.getResponseCode();\n      fail();\n    } catch (SocketTimeoutException expected) {\n    }\n\n    // Shutting down the server should unblock the dispatcher.\n    server.shutdown();\n  }\n\n  @Test public void requestUrlReconstructed() throws Exception {\n    server.enqueue(new MockResponse().setBody(\"hello world\"));\n\n    URL url = server.url(\"/a/deep/path?key=foo%20bar\").url();\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    InputStream in = connection.getInputStream();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));\n    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);\n    assertThat(reader.readLine()).isEqualTo(\"hello world\");\n\n    RecordedRequest request = server.takeRequest();\n    assertThat(request.getRequestLine()).isEqualTo(\n        \"GET /a/deep/path?key=foo%20bar HTTP/1.1\");\n\n    HttpUrl requestUrl = request.getRequestUrl();\n    assertThat(requestUrl.scheme()).isEqualTo(\"http\");\n    assertThat(requestUrl.host()).isEqualTo(server.getHostName());\n    assertThat(requestUrl.port()).isEqualTo(server.getPort());\n    assertThat(requestUrl.encodedPath()).isEqualTo(\"/a/deep/path\");\n    assertThat(requestUrl.queryParameter(\"key\")).isEqualTo(\"foo bar\");\n  }\n\n  @Test public void shutdownServerAfterRequest() throws Exception {\n    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE));\n\n    URL url = server.url(\"/\").url();\n\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);\n\n    HttpURLConnection refusedConnection = (HttpURLConnection) url.openConnection();\n\n    try {\n      refusedConnection.getResponseCode();\n      fail(\"Second connection should be refused\");\n    } catch (ConnectException e) {\n      assertThat(e.getMessage()).contains(\"refused\");\n    }\n  }\n\n  @Test public void http100Continue() throws Exception {\n    server.enqueue(new MockResponse().setBody(\"response\"));\n\n    URL url = server.url(\"/\").url();\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    connection.setDoOutput(true);\n    connection.setRequestProperty(\"Expect\", \"100-Continue\");\n    connection.getOutputStream().write(\"request\".getBytes(UTF_8));\n\n    InputStream in = connection.getInputStream();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));\n    assertThat(reader.readLine()).isEqualTo(\"response\");\n\n    RecordedRequest request = server.takeRequest();\n    assertThat(request.getBody().readUtf8()).isEqualTo(\"request\");\n  }\n\n  @Test public void testH2PriorKnowledgeServerFallback() {\n    try {\n      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));\n      fail();\n    } catch (IllegalArgumentException expected) {\n      assertThat(expected.getMessage()).isEqualTo(\n          (\"protocols containing h2_prior_knowledge cannot use other protocols: \"\n              + \"[h2_prior_knowledge, http/1.1]\"));\n    }\n  }\n\n  @Test public void testH2PriorKnowledgeServerDuplicates() {\n    try {\n      // Treating this use case as user error\n      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));\n      fail();\n    } catch (IllegalArgumentException expected) {\n      assertThat(expected.getMessage()).isEqualTo(\n          (\"protocols containing h2_prior_knowledge cannot use other protocols: \"\n              + \"[h2_prior_knowledge, h2_prior_knowledge]\"));\n    }\n  }\n\n  @Test public void testMockWebServerH2PriorKnowledgeProtocol() {\n    server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE));\n\n    assertThat(server.protocols().size()).isEqualTo(1);\n    assertThat(server.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);\n  }\n\n  @Test public void https() throws Exception {\n    HandshakeCertificates handshakeCertificates = localhost();\n    server.useHttps(handshakeCertificates.sslSocketFactory(), false);\n    server.enqueue(new MockResponse().setBody(\"abc\"));\n\n    HttpUrl url = server.url(\"/\");\n    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();\n    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());\n    connection.setHostnameVerifier(new RecordingHostnameVerifier());\n\n    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);\n    BufferedReader reader =\n        new BufferedReader(new InputStreamReader(connection.getInputStream(), UTF_8));\n    assertThat(reader.readLine()).isEqualTo(\"abc\");\n\n    RecordedRequest request = server.takeRequest();\n    assertThat(request.getRequestUrl().scheme()).isEqualTo(\"https\");\n    Handshake handshake = request.getHandshake();\n    assertThat(handshake.tlsVersion()).isNotNull();\n    assertThat(handshake.cipherSuite()).isNotNull();\n    assertThat(handshake.localPrincipal()).isNotNull();\n    assertThat(handshake.localCertificates().size()).isEqualTo(1);\n    assertThat(handshake.peerPrincipal()).isNull();\n    assertThat(handshake.peerCertificates().size()).isEqualTo(0);\n  }\n\n  @Test public void httpsWithClientAuth() throws Exception {\n    assumeFalse(getPlatform().equals(\"conscrypt\"));\n\n    HeldCertificate clientCa = new HeldCertificate.Builder()\n        .certificateAuthority(0)\n        .build();\n    HeldCertificate serverCa = new HeldCertificate.Builder()\n        .certificateAuthority(0)\n        .build();\n    HeldCertificate serverCertificate = new HeldCertificate.Builder()\n        .signedBy(serverCa)\n        .addSubjectAlternativeName(server.getHostName())\n        .build();\n    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()\n        .addTrustedCertificate(clientCa.certificate())\n        .heldCertificate(serverCertificate)\n        .build();\n\n    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);\n    server.enqueue(new MockResponse().setBody(\"abc\"));\n    server.requestClientAuth();\n\n    HeldCertificate clientCertificate = new HeldCertificate.Builder()\n        .signedBy(clientCa)\n        .build();\n    HandshakeCertificates clientHandshakeCertificates = new HandshakeCertificates.Builder()\n        .addTrustedCertificate(serverCa.certificate())\n        .heldCertificate(clientCertificate)\n        .build();\n\n    HttpUrl url = server.url(\"/\");\n    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();\n    connection.setSSLSocketFactory(clientHandshakeCertificates.sslSocketFactory());\n    connection.setHostnameVerifier(new RecordingHostnameVerifier());\n\n    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);\n    BufferedReader reader =\n        new BufferedReader(new InputStreamReader(connection.getInputStream(), UTF_8));\n    assertThat(reader.readLine()).isEqualTo(\"abc\");\n\n    RecordedRequest request = server.takeRequest();\n    assertThat(request.getRequestUrl().scheme()).isEqualTo(\"https\");\n    Handshake handshake = request.getHandshake();\n    assertThat(handshake.tlsVersion()).isNotNull();\n    assertThat(handshake.cipherSuite()).isNotNull();\n    assertThat(handshake.localPrincipal()).isNotNull();\n    assertThat(handshake.localCertificates().size()).isEqualTo(1);\n    assertThat(handshake.peerPrincipal()).isNotNull();\n    assertThat(handshake.peerCertificates().size()).isEqualTo(1);\n  }\n\n  @Test\n  public void shutdownTwice() throws IOException {\n    MockWebServer server2 = new MockWebServer();\n\n    server2.start();\n    server2.shutdown();\n    try {\n      server2.start();\n      fail();\n    } catch (IllegalArgumentException iae) {\n      // expected\n    }\n    server2.shutdown();\n  }\n\n  public static String getPlatform() {\n    return System.getProperty(\"okhttp.platform\", \"jdk8\");\n  }\n}"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241221886},"updatedAt":{"$$date":1598512686091},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qg46RdjfmyfoxJEM"}
{"name":"qk-","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598586260063},"updatedAt":{"$$date":1598586260063},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qidupg0PXTuJ2k2B"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598974376474},"updatedAt":{"$$date":1598974376474},"_id":"qoYgxoOugXOVaNhw"}
{"name":"CSS3 3D 转换","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"3D 转换\nCSS3 允许您使用 3D 转换来对元素进行格式化。\n\n在本章中，您将学到其中的一些 3D 转换方法：\n\nrotateX()\nrotateY()\n点击下面的元素，来查看 2D 转换与 3D 转换之间的不同之处：\n\n2D rotate3D rotate\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器版本号。\n\n紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号。\n\n属性\t\t\t\t\t\ntransform\t36.0\n12.0 -webkit-\t10.0\t16.0\n10.0 -moz-\t4.0 -webkit-\t23.0\n15.0 -webkit-\ntransform-origin\n(three-value syntax)\t36.0\n12.0 -webkit-\t10.0\t16.0\n10.0 -moz-\t4.0 -webkit-\t23.0\n15.0 -webkit-\ntransform-style\t36.0\n12.0 -webkit-\t11.0\t16.0\n10.0 -moz-\t4.0 -webkit-\t23.0\n15.0 -webkit-\nperspective\t36.0\n12.0 -webkit-\t10.0\t16.0\n10.0 -moz-\t4.0 -webkit-\t23.0\n15.0 -webkit-\nperspective-origin\t36.0\n12.0 -webkit-\t10.0\t16.0\n10.0 -moz-\t4.0 -webkit-\t23.0\n15.0 -webkit-\nbackface-visibility\t36.0\n12.0 -webkit-\t10.0\t16.0\n10.0 -moz-\t4.0 -webkit-\t23.0\n15.0 -webkit-\nrotateX() 方法\nRotate X\nrotateX()方法，围绕其在一个给定度数X轴旋转的元素。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\ndiv\n{\n    transform: rotateX(120deg);\n    -webkit-transform: rotateX(120deg); /* Safari 与 Chrome */\n}\n\n尝试一下 »\n\nrotateY() 方法\nRotate Y\nrotateY()方法，围绕其在一个给定度数Y轴旋转的元素。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\ndiv\n{\n    transform: rotateY(130deg);\n    -webkit-transform: rotateY(130deg); /* Safari 与 Chrome */\n}\n\n尝试一下 »\n\n转换属性\n下表列出了所有的转换属性：\n\n属性\t描述\tCSS\ntransform\t向元素应用 2D 或 3D 转换。\t3\ntransform-origin\t允许你改变被转换元素的位置。\t3\ntransform-style\t规定被嵌套元素如何在 3D 空间中显示。\t3\nperspective\t规定 3D 元素的透视效果。\t3\nperspective-origin\t规定 3D 元素的底部位置。\t3\nbackface-visibility\t定义元素在不面对屏幕时是否可见。\t3\n3D 转换方法\n函数\t描述\nmatrix3d(n,n,n,n,n,n,\nn,n,n,n,n,n,n,n,n,n)\t定义 3D 转换，使用 16 个值的 4x4 矩阵。\ntranslate3d(x,y,z)\t定义 3D 转化。\ntranslateX(x)\t定义 3D 转化，仅使用用于 X 轴的值。\ntranslateY(y)\t定义 3D 转化，仅使用用于 Y 轴的值。\ntranslateZ(z)\t定义 3D 转化，仅使用用于 Z 轴的值。\nscale3d(x,y,z)\t定义 3D 缩放转换。\nscaleX(x)\t定义 3D 缩放转换，通过给定一个 X 轴的值。\nscaleY(y)\t定义 3D 缩放转换，通过给定一个 Y 轴的值。\nscaleZ(z)\t定义 3D 缩放转换，通过给定一个 Z 轴的值。\nrotate3d(x,y,z,angle)\t定义 3D 旋转。\nrotateX(angle)\t定义沿 X 轴的 3D 旋转。\nrotateY(angle)\t定义沿 Y 轴的 3D 旋转。\nrotateZ(angle)\t定义沿 Z 轴的 3D 旋转。\nperspective(n)\t定义 3D 转换元素的透视视图。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974617292},"updatedAt":{"$$date":1598974920825},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qvosOfQWCePnnL4Q"}
{"name":"ad-kasbase的build.gradle","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'android-aspectjx'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n    useLibrary useLibrary\n    packagingOptions {\n        doNotStrip \"*/armeabi/libdu.so\"\n        doNotStrip \"*/armeabi-v7a/libdu.so\"\n        doNotStrip \"*/arm64-v8a/libdu.so\"\n        exclude 'LICENSE.txt'\n    }\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n        //bugly\n        ndk {\n            //设置支持的SO库架构\n            abiFilters 'armeabi', 'armeabi-v7a'//, 'arm64-v8a'//, 'x86_64',\n        }\n    }\n\n    buildTypes {\n        release {\n            debuggable false\n            shrinkResources false\n            minifyEnabled false\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"3\"\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"\n            buildConfigField \"boolean\", \"SWITCH\", \"true\"\n            externalNativeBuild {\n                ndkBuild {\n                    arguments 'NDK_DEBUG=0'\n                }\n            }\n        }\n\n        debug {\n            debuggable true\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"0\"\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"\n            buildConfigField \"boolean\", \"SWITCH\", \"false\"\n            externalNativeBuild {\n                ndkBuild {\n                    arguments 'NDK_DEBUG=1'\n                }\n            }\n        }\n\n        gama.initWith(debug)\n        gama {\n            debuggable true\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"2\"\n            matchingFallbacks = ['debug', 'release']\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"\n            buildConfigField \"boolean\", \"SWITCH\", \"false\"\n        }\n\n        CDRelease.initWith(debug)\n        CDRelease {\n            debuggable true\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"3\"\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"\n            buildConfigField \"boolean\", \"SWITCH\", \"true\"\n            matchingFallbacks = ['release', 'debug']\n        }\n\n        CDGama.initWith(debug)\n        CDGama {\n            debuggable true\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"2\"\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"\n            buildConfigField \"boolean\", \"SWITCH\", \"true\"\n            matchingFallbacks = ['release', 'debug']\n        }\n\n        CDDebug.initWith(debug)\n        CDDebug {\n            debuggable true\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"0\"\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"\n            buildConfigField \"boolean\", \"SWITCH\", \"true\"\n            matchingFallbacks = ['release', 'debug']\n        }\n\n        dapi.initWith(debug)\n        dapi {\n            buildConfigField \"int\", \"NET_REQUEST_TARGET\", \"1\"\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"\n            buildConfigField \"boolean\", \"SWITCH\", \"false\"\n            matchingFallbacks = ['debug', 'release']\n        }\n    }\n\n    lintOptions {\n        abortOnError false\n    }\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n        }\n    }\n\n    repositories {\n        flatDir {\n            dirs LIB_MEDIA_DIR_PATH\n        }\n    }\n\n    publishNonDefault true\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\n\ndependencies {\n    api fileTree(dir: 'libs', include: ['*.jar'])\n    api ks.ksautosizebybd\n    api deps.androidx.recyclerview_v7\n    api deps.androidx.support_v4\n    api deps.androidx.design, {\n        exclude group: \"com.android.support\", module: \"multidex\"\n    }\n    api(deps.androidx.constraint_layout) {\n        force = true\n    }\n    api(project(':ks_provide_center')) {\n        exclude group: \"com.android.support\"\n    }\n//    api project(':permission2')\n    api ks.ksloadpic\n    api(ks.ksdialogplus) {\n        changing = true\n    }\n    api ks.ksutils\n    api ks.ksui\n    api ks.kstoast\n    api ks.kprogresshud\n\n    api(ks.ksliulishuodownload) {\n        exclude group: \"com.squareup.okhttp3\"\n    }\n\n    //api deps.recyclerViewAdapterHelper\n\n    //临时测试\n    api(getRnVersion()) { changing = true }\n    //极光\n    api deps.jiguang.jpush\n    api deps.jiguang.jcore\n    api deps.jpush.jpush_xiaomi\n    api deps.jpush.jpush_meizu\n    api deps.jpush.jpush_vivo\n    api deps.jpush.jpush_oppo\n    api deps.jpush.jpush_huawei\n//    api deps.jpush.jpush_verification\n    //智启客服\n    api project(':sobotsdk')\n    // 个推 + 一键登录\n//    api deps.getui.sdk\n    api deps.getui.gtc\n    //zxing\n    api(ks.kszxing) {\n        exclude group: \"com.android.support.constraint\", module: \"constraint-layout-solver\"\n    }\n\n    api deps.fresco.fresco\n    implementation deps.fresco.imagepipeline_okhttp, {\n        exclude group: \"com.squareup.okhttp\", module: \"okhttp\"\n    }\n    api deps.fresco.animated_gif\n    api deps.photodraweeview\n\n    api ks.ksconvenientbanner, {\n        exclude group: 'com.android.support'\n    }\n    api deps.tkrefreshlayout, {\n        exclude group: 'com.android.support'\n    }\n    api deps.circleprogress\n    api ks.easyrecyclerview\n    api deps.oss_android_sdk, {\n        exclude group: \"com.squareup.okhttp\", module: \"okhttp\"\n    }\n\n    //听云\n    api deps.tingyun.newlens_agent\n    api deps.tingyun.newlens_nativecrash\n\n    implementation deps.androidx.multidex\n    //谷歌服务\n    implementation deps.play_services_appindexing\n    implementation deps.wechat_sdk_android_without_mta\n    implementation deps.crashreport\n    implementation deps.packer_ng\n    implementation ks.ksmp3recorder\n    api deps.ucrop\n    implementation ks.ksswipeback, {\n        exclude group: \"com.android.support\", module: \"appcompat-v7\"\n    }\n\n    implementation deps.toolsfinal, {\n        exclude group: \"com.android.support\"\n    }\n\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    //为了解决 kotlin data class ,fastjson 解析报 defalut constructor not found错误\n    implementation deps.kotlin.kotlin_reflect\n\n// 由于小米镜像源不稳定，所以指定版本走缓存，如果需要配置，可以放开版本注释\n    api deps.xiaoaccount\n    implementation deps.rxpermissions\n    api deps.volley\n    api ks.ksurirouter\n    api deps.growingio\n    //task启动库\n    api ks.ksinit\n    //gif drawable 库 \n    api deps.gif_drawable\n    api project(':common_res')\n    api ks.recyclerViewAdaperHelper\n    //api project(':baseRecyclerViewAdapterHelper')\n    //svga 多模块使用\n    api deps.svga\n\n    api(name: 'mio_sdk_app_2.1.0', ext: 'aar')\n    api(name: 'gamesdk-20200312', ext: 'aar')\n    api(name: 'umeng-asms-v1.1.1', ext: 'aar') // 友盟重要组件，如不集成会在初始化时输出e级别的LOG提示和Toast提示\n//    api(name: 'umeng-crash-v0.0.4', ext: 'aar') // 友盟重要组件，如不集成会在初始化时输出e级别的LOG提示和Toast提示\n\n    api ks.kswebview\n\n    api project(':ks_base_res')\n    api project(':ks_permissionrx')\n    api project(':ks_image_select')\n    api project(':ks_point_upload')\n//\n    api ks.kstheforcesystem, {\n        exclude group: \"com.ks.kotlin\", module: \"ks-lib-ktx\"\n        exclude group: \"com.ks.kotlin\", module: \"ks-lib-persistence\"\n        exclude group: \"com.ks.kotlin\", module: \"ks-component-download\"\n        exclude group: \"com.squareup.okhttp3\", module: \"okhttp\"\n        exclude group: \"com.squareup.okhttp3\", module: \"logging-interceptor\"\n        exclude group: \"com.squareup.retrofit2\", module: \"retrofit\"\n//        exclude group: \"com.squareup.retrofit2\", module: \"adapter-rxjava2\"\n//        exclude group: \"com.squareup.retrofit2\", module: \"converter-gson\"\n    }\n}\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515781981},"updatedAt":{"$$date":1598517283004},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qx5Mj443eufadRYW"}
{"name":"andr-Kotlin-Java 互操作指南","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /kotlin/interop\nKotlin-Java 互操作指南  |  Android 开发者  |  Android Developers\n7-9 minutes\n本文档提供了关于用 Java 和 Kotlin 编写公共 API 的一系列规则，目的是让您从另一种语言使用代码时感觉其符合语言习惯。\n\n上次更新日期：2018 年 5 月 18 日\n\nJava（供 Kotlin 使用）\n不得使用硬关键字\n请勿将 Kotlin 的任何硬关键字用作方法或字段的名称。从 Kotlin 调用时，这些硬关键字需要使用反引号进行转义。允许使用软关键字、修饰符关键字和特殊标识符。\n\n例如，从 Kotlin 使用时，Mockito 的 when 函数需要使用反引号：\n\nval callable = Mockito.mock(Callable::class.java)\nMockito.`when`(callable.call()).thenReturn(/* … */)\n避免使用 Any 的扩展函数或属性的名称\n除非绝对必要，否则应避免对方法使用 Any 的扩展函数的名称或对字段使用 Any 的扩展属性的名称。虽然成员方法和字段始终优先于 Any 的扩展函数或属性，但读取代码时可能很难知道调用的是哪个。\n\n可为 null 性注释\n公共 API 中的每个非基元参数类型、返回类型和字段类型都应具有可为 null 性注释。不带注释的类型会被解释为“平台”类型，而后者的可为 null 性不明确。\n\nJSR 305 软件包注释可用于设置合理的默认值，但目前不建议这样做。这类注释要求编译器遵循一个选择启用标志，而这与 Java 9 的模块系统存在冲突。\n\nLambda 参数位于最后\n符合 SAM 转换条件的参数类型应位于最后。\n\n例如，RxJava 2’s Flowable.create() 方法签名定义为：\n\npublic static  Flowable create(\n    FlowableOnSubscribe source,\n    BackpressureStrategy mode) { /* … */ }\n由于 FlowableOnSubscribe 符合 SAM 转换条件，因此从 Kotlin 对此方法进行的函数调用如下所示：\n\nFlowable.create({ /* … */ }, BackpressureStrategy.LATEST)\n不过，如果该方法签名中的参数颠倒顺序，则函数调用可以使用尾随 lambda 语法：\n\nFlowable.create(BackpressureStrategy.LATEST) { /* … */ }\n属性前缀\n要使方法在 Kotlin 中表示为属性，必须使用严格的“bean”样式的前缀。\n\n访问器方法需要“get”前缀，而对于布尔值返回方法，可以使用“is”前缀。\n\npublic final class User {\n  public String getName() { /* … */ }\n  public boolean isActive() { /* … */ }\n}\nval name = user.name // Invokes user.getName()\nval active = user.active // Invokes user.isActive()\n关联的更改器方法需要“set”前缀。\n\npublic final class User {\n  public String getName() { /* … */ }\n  public void setName(String name) { /* … */ }\n}\nuser.name = \"Bob\" // Invokes user.setName(String)\n如果要将方法作为属性提供，请勿使用“has”/“set”之类的非标准前缀或不带“get”前缀的访问器。带有非标准前缀的方法仍可作为函数进行调用，这种情况或许可以接受，具体取决于方法的行为。\n\n运算符过载\n请注意在 Kotlin 中允许使用特殊调用点语法（即运算符过载）的方法名称。确保这样的方法名称可以有效地与缩短的语法一起使用。\n\npublic final class IntBox {\n  private final int value;\n  public IntBox(int value) {\n    this.value = value;\n  }\n  public IntBox plus(IntBox other) {\n    return new IntBox(value + other.value);\n  }\n}\nval one = IntBox(1)\nval two = IntBox(2)\nval three = one + two // Invokes one.plus(two)\nKotlin（供 Java 使用）\n文件名\n当文件包含顶级函数或属性时，应始终使用 @file:JvmName(\"Foo\") 对其进行注释，以提供一个合适的名称。\n\n默认情况下，MyClass.kt 文件中的顶级成员最终会进入一个名为 MyClassKt 的类中，此名称没有吸引力，并且会泄露作为实现细节的语言。\n\n不妨考虑添加 @file:JvmMultifileClass，以将多个文件中的顶级成员组合到一个类中。\n\nLambda 参数\n需要从 Java 中使用的函数类型应避免返回类型 Unit。这样做要求指定明确的 return Unit.INSTANCE; 语句，但该语句不符合语言习惯。\n\nfun sayHi(callback: (String) -> Unit) = /* … */\n// Kotlin caller:\ngreeter.sayHi { Log.d(\"Greeting\", \"Hello, $it!\") }\n// Java caller:\ngreeter.sayHi(name -> {\n    Log.d(\"Greeting\", \"Hello, \" + name + \"!\");\n    return Unit.INSTANCE;\n});\n此语法也不允许提供从语义上命名的类型以便在其他类型上实现。\n\n在 Kotlin 中为 lambda 类型定义命名的单一抽象方法 (SAM) 接口可以为 Java 更正此问题，但这样就无法在 Kotlin 中使用 lambda 语法。\n\ninterface GreeterCallback {\n    fun greetName(name: String): Unit\n}fun sayHi(callback: GreeterCallback) = /* … */\n// Kotlin caller:\ngreeter.sayHi(object : GreeterCallback {\n    override fun greetName(name: String) {\n        Log.d(\"Greeting\", \"Hello, $name!\")\n    }\n})\n// Java caller:\ngreeter.sayHi(name -> Log.d(\"Greeting\", \"Hello, \" + name + \"!\"))\n在 Java 中定义命名的 SAM 接口就可以使用稍低版本的 Kotlin lambda 语法，其中必须明确指定接口类型。\n\n// Defined in Java:\ninterface GreeterCallback {\n    void greetName(String name);\n}\nfun sayHi(greeter: GreeterCallback) = /* … */\n// Kotlin caller:\ngreeter.sayHi(GreeterCallback { Log.d(\"Greeting\", \"Hello, $it!\") })\n// Java caller:\ngreeter.sayHi(name -> Log.d(\"Greeter\", \"Hello, \" + name + \"!\"));\n要定义一个在 Java 和 Kotlin 中用作 lambda 的参数类型，又要求在这两种语言中使用时都感觉其符合语言习惯，这在目前还无法做到。当前的建议是优先选用函数类型，虽然当返回类型为 Unit 时在 Java 中的体验会受到影响。\n\n避免使用 Nothing 类属\n类属参数为 Nothing 的类型会作为原始类型提供给 Java。原始类型在 Java 中很少使用，应避免使用。\n\n记录异常\n会抛出受检异常的函数应使用 @Throws 记录这些异常。运行时异常应记录在 KDoc 中。\n\n请注意函数委托给的 API，因为它们可能会抛出 Kotlin 本来会以静默方式允许传播的受检异常。\n\n防御性复制\n从公共 API 返回共享或无主的只读集合时，应将其封装在不可修改的容器中或执行防御性复制。虽然 Kotlin 强制要求它们具备只读属性，但在 Java 端没有这样的强制性要求。如果没有封装容器或不执行防御性复制，可能会因返回长期存在的集合引用而违反不变量。\n\n伴生函数\n伴生对象中的公共函数必须带有 @JvmStatic 注释才能作为静态方法公开。\n\n如果没有该注释，则这些函数只能作为静态 Companion 字段中的实例方法使用。\n\n不正确：没有注释\n\nclass KotlinClass {\n    companion object {\n        fun doWork() {\n            /* … */\n        }\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        KotlinClass.Companion.doWork();\n    }\n}\n正确：@JvmStatic 注释\n\nclass KotlinClass {\n    companion object {\n        @JvmStatic fun doWork() {\n            /* … */\n        }\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        KotlinClass.doWork();\n    }\n}\n伴生常量\n在 companion object 中作为有效常量的公共非 const 属性必须带有 @JvmField 注释才能作为静态字段公开。\n\n如果没有该注释，则这些属性只能作为静态 Companion 字段中命名奇怪的“getter”实例使用。使用 @JvmStatic 而不是 @JvmField 可将命名奇怪的“getter”移至类的静态方法，但这样仍然不正确。\n\n不正确：没有注释\n\nclass KotlinClass {\n    companion object {\n        const val INTEGER_ONE = 1\n        val BIG_INTEGER_ONE = BigInteger.ONE\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        System.out.println(KotlinClass.INTEGER_ONE);\n        System.out.println(KotlinClass.Companion.getBIG_INTEGER_ONE());\n    }\n}\n不正确：@JvmStatic 注释\n\nclass KotlinClass {\n    companion object {\n        const val INTEGER_ONE = 1\n        @JvmStatic val BIG_INTEGER_ONE = BigInteger.ONE\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        System.out.println(KotlinClass.INTEGER_ONE);\n        System.out.println(KotlinClass.getBIG_INTEGER_ONE());\n    }\n}\n正确：@JvmField 注释\n\nclass KotlinClass {\n    companion object {\n        const val INTEGER_ONE = 1\n        @JvmField val BIG_INTEGER_ONE = BigInteger.ONE\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        System.out.println(KotlinClass.INTEGER_ONE);\n        System.out.println(KotlinClass.BIG_INTEGER_ONE);\n    }\n}\n符合语言习惯的命名\nKotlin 的调用规范与 Java 不同，这可能会改变您为函数命名的方式。请使用 @JvmName 设计名称，使其符合这两种语言的规范或与各自的标准库命名保持一致。\n\n扩展函数和扩展属性最常出现这种情况，因为接收器类型的位置不同。\n\nsealed class Optional\ndata class Some(val value: T): Optional()\nobject None : Optional()@JvmName(\"ofNullable\")\nfun  T?.asOptional() = if (this == null) None else Some(this)\n// FROM KOTLIN:\nfun main(vararg args: String) {\n    val nullableString: String? = \"foo\"\n    val optionalString = nullableString.asOptional()\n}\n// FROM JAVA:\npublic static void main(String... args) {\n    String nullableString = \"Foo\";\n    Optional optionalString =\n          Optionals.ofNullable(nullableString);\n}\n默认值的函数过载\n参数具有默认值的函数必须使用 @JvmOverloads。如果没有此注释，则无法使用任何默认值来调用函数。\n\n使用 @JvmOverloads 时，应检查生成的方法，以确保它们每个都有意义。如果它们没有意义，请执行以下一种或两种重构，直到满意为止：\n\n更改参数顺序，使具有默认值的参数尽量接近末尾。\n将默认值移至手动函数过载。\n不正确：没有 @JvmOverloads\n\nclass Greeting {\n    fun sayHello(prefix: String = \"Mr.\", name: String) {\n        println(\"Hello, $prefix $name\")\n    }\n}\npublic class JavaClass {\n    public static void main(String... args) {\n        Greeting greeting = new Greeting();\n        greeting.sayHello(\"Mr.\", \"Bob\");\n    }\n}\n正确：@JvmOverloads 注释\n\nclass Greeting {\n    @JvmOverloads\n    fun sayHello(prefix: String = \"Mr.\", name: String) {\n        println(\"Hello, $prefix $name\")\n    }\n}\npublic class JavaClass {\n    public static void main(String... args) {\n        Greeting greeting = new Greeting();\n        greeting.sayHello(\"Bob\");\n    }\n}\nLint 检查\n要求\nAndroid Studio 版本：3.2 Canary 10 或更高版本\nAndroid Gradle 插件版本：3.2 或更高版本\n支持的检查\n现在有一些 Android Lint 检查可帮助您检测并标记上述某些互操作性问题。目前只检测到了 Java（供 Kotlin 使用）中的问题。具体来说，支持的检查包括：\n\n未知 Null 性\n属性访问\n不得使用 Kotlin 硬关键字\nLambda 参数位于最后\nAndroid Studio\n要启用这些检查，请依次转到 File > Preferences > Editor > Inspections，然后在“Kotlin Interoperability”下勾选要启用的规则：\n\n\n\n图 1.Android Studio 中的 Kotlin 互操作性设置。\n\n勾选要启用的规则后，当您运行代码检查（依次转到 Analyze > Inspect Code…）时，将运行新的检查。\n\n命令行 build\n要通过命令行 build 启用这些检查，请在 build.gradle 文件中添加以下代码行：\n\nandroid {...\n    lintOptions \n\n{\n        enable 'Interoperability'\n    }\n}\n如需了解 lintOptions 内支持的全部配置，请参阅 Android Gradle DSL 参考。\n\n然后，从命令行运行 ./gradlew lint。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244740351},"updatedAt":{"$$date":1597245341438},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"r2G2IlUjtfTnbqX7"}
{"name":"Android 关于点9图在气泡评论里使用的调研","folderId":"4YrYQlvQK","content":[{"label":"Fragment 1","language":"text","value":"1. 点9图简单介绍\nAndroid为了使用同一张图作为大小区域背景，设计了一种可以指定区域拉伸的图片格式“.9.png”，这种图片格式就是点九图。Android 特有的一种格式，在ios开发中，可以在代码中指定某个点进行拉伸。\n如上图，点九图的本质实际上是在图片的四周各增加了1px的像素，并使用纯黑(#FF000000)的线进行标记，其它的与原图没有任何区别\n标记位置\t含义\n左--> 纵向拉伸区域\n上--> 横向拉伸区域\n右--> 纵向显示区域\n下--> 横向显示区域\n点9图可以通过ps等p图工具手动画黑线、Draw9patch工具、AndroidStudio、或者\n在线工具点击进入\n2. 点9图的使用\nAndroid中使用点九图，主要有三种形式\n1. 使用res文件夹中的点九图\n2. 使用assets或者文件中的点九图\n3. 使用网上拉取的点九图。\n注意\nAndroid并不是直接使用点九图，而是在编译时将其转换为另外一种格式，这种格式是将其四周的黑色像素保存至Bitmap类中的一个名为mNinePatchChunk的byte[]中，并抹除掉四周的这一个像素的宽度；接着在使用时，如果Bitmap的这个mNinePatchChunk不为空，且为9patch chunk，则将其构造为NinePatchDrawable，否则将会被构造为BitmapDrawable，最终设置给view，NinePatchDrawable的拉伸主要是通过其draw方法实现的。\n总而言之，最后打出的包中的点九图，已经不是原来的带黑线的点九图了。而是通过appt工具，把点9图的黑线信息编码到png的图片字节中。\n3. 把点9图应用到气泡中\n点9图放到res文件夹， 在编译期已经已经把点9信息合成到png中， 我们使用的时候，系统自动解析信息，所以使用起来基本无感知，但是放到文件和网络中的点9图片不能直接使用。如果直接加载就会出现如下效果\n黑线仍然存在，且没有固定区域拉伸的效果\n4. 解决思路\n既然无法直接使用点9图，就要寻求系统是如何使用点9图的，包括他的编译过程，也就是点9信息存储和使用方式。\n关于点9图的源码分析，参考腾讯音乐团队的blog,详见文末的参考文献\n根据之前的讨论我们知道，画黑线的点九图与普通图片的区别主要在于四周多了1px的黑线，而转换后的点九图则没有这1px的黑线，但是它却包含了用于拉伸的信息。所以我们要从这个信息里面入手。\n第一种方案：直接上传点9图片，下载之后再做处理。UI生成端比较方便，但是处理过程比较繁琐， 而且资源图片要和iOS进行区分，后台配置比较繁琐。\n第二种方案：设计生成点9图之后，通过appt命令，把点9信息编码到在图片资源中，Android 端获取图片后直接解析点9信息。优点是可以和iOS端共用一个资源图，解析也比较方便，缺点是上传前需要提前进行appt命令合成，而且有合成错误的风险，。\n第三种方案：直接和iOS使用同一套资源，Android手动添加patch点，便于适配不使用padding。优点是配置端比较方便，缺点是解析和生成比较繁琐。\n第一种方案就不说了，三端都繁琐的事情，就没必要做了。\n第二种方案处理流程\na> UI端生成点9图片\nb> 通过命令 aapt s -i xx.9.png -o xx.png 生成包含点9信息的图片，上传服务器\nc> Android下载之后，解析点9信息\nvar bmp = Bitmap.createBitmap(bmpTemp)\nvar chunk = bmp?.ninePatchChunk\nd> 判断点9信息正确之后，生成NinePatchDrawable，设置对应view backgroud\nif (NinePatch.isNinePatchChunk(chunk)) {\n       var ninePatchDrawable =  NinePatchDrawable(context?.resources, bmp, chunk,  NinePatchChunk.getPaddingRect(chunk), null)\n       view.post {\n            view.background = ninePatchDrawable\n        }\n} else {\n    var bitmapDrawable = BitmapDrawable(context?.resources, bmp)\n     view.post {\n         view.background = bitmapDrawable\n     }\n}\n中间遇到的一个坑，就是这种方式加载的点9图无法使用padding效果，就是点9图的右下内容区域控制，查资料找到实现方案NinePatchDrawable的第三个参数padding内容, 如下类中的getPaddingRect方法。\nimport android.graphics.Rect;\nimport com.richard.base.BaseApplication;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n/**\n * **************************************\n * 项目名称:Giggle\n *\n * @Author wuzhiguo\n * 创建时间: 2020/8/14     11:25 AM\n * 用途:\n * **************************************\n */\npublic class NinePatchChunk {\n    private static final String TAG = \"NinePatchChunk\";\n    public final Rect mPaddings = new Rect();\n    public int mDivX[];\n    public int mDivY[];\n    public int mColor[];\n    private static float density = BaseApplication.Companion.getInstance().getResources().getDisplayMetrics().density;\n    private static void readIntArray(final int[] data, final ByteBuffer buffer) {\n        for (int i = 0, n = data.length; i < n; ++i)\n            data[i] = buffer.getInt();\n    }\n    private static void checkDivCount(final int length) {\n        if (length == 0 || (length & 0x01) != 0)\n            throw new IllegalStateException(\"invalid nine-patch: \" + length);\n    }\n    public static Rect getPaddingRect(final byte[] data) {\n        NinePatchChunk deserialize = deserialize(data);\n        if (deserialize == null) {\n            return new Rect();\n        }\n        return deserialize.mPaddings;\n    }\n    public static NinePatchChunk deserialize(final byte[] data) {\n        final ByteBuffer byteBuffer =\n                ByteBuffer.wrap(data).order(ByteOrder.nativeOrder());\n        if (byteBuffer.get() == 0) {\n            return null; // is not serialized\n        }\n        final NinePatchChunk chunk = new NinePatchChunk();\n        chunk.mDivX = new int[byteBuffer.get()];\n        chunk.mDivY = new int[byteBuffer.get()];\n        chunk.mColor = new int[byteBuffer.get()];\n        try {\n            checkDivCount(chunk.mDivX.length);\n            checkDivCount(chunk.mDivY.length);\n        } catch (Exception e) {\n            return null;\n        }\n        // skip 8 bytes\n        byteBuffer.getInt();\n        byteBuffer.getInt();\n        chunk.mPaddings.left = byteBuffer.getInt();\n        chunk.mPaddings.right = byteBuffer.getInt();\n        chunk.mPaddings.top = byteBuffer.getInt();\n        chunk.mPaddings.bottom = byteBuffer.getInt();\n        // skip 4 bytes\n        byteBuffer.getInt();\n        readIntArray(chunk.mDivX, byteBuffer);\n        readIntArray(chunk.mDivY, byteBuffer);\n        readIntArray(chunk.mColor, byteBuffer);\n        return chunk;\n    }\n}\n另一个坑就是fresco图片加载框架通过ImagePipeline、BaseBitmapDataSubscriber获取的bitmap对象中，NinePatchChunk信息是空的，只能通过DataSource方式获取字节流转换成bitmap才可以。\n第三种方案，手动添加拉伸信息到bitmap\n要实现这种方案，首先要对Bitmap和NinePatch以及png的tunk信息有一定的了解，详情可参阅QQ音乐的blog讲解\n实现方案如下\npackage com.ks.playerpage.util\nimport android.content.res.Resources\nimport android.graphics.Bitmap\nimport android.graphics.NinePatch\nimport android.graphics.Rect\nimport android.graphics.drawable.NinePatchDrawable\nimport java.nio.ByteBuffer\nimport java.nio.ByteOrder\n/**\n * **************************************\n * 项目名称:Giggle\n *\n * @Author wuzhiguo\n * 邮箱：wuzhiguo@ksjgs.com\n * 创建时间: 2020/8/14     11:25 AM\n * 用途: 手动构建NinePatch\n * **************************************\n */\nclass NinePatchBuilder {\n    var width: Int\n    var height: Int\n    var bitmap: Bitmap? = null\n    var resources: Resources? = null\n    private val xRegions = mutableListOf<Int>()\n    private val yRegions = mutableListOf<Int>()\n    constructor(resources: Resources?, bitmap: Bitmap) {\n        width = bitmap.width\n        height = bitmap.height\n        this.bitmap = bitmap\n        this.resources = resources\n    }\n    constructor(width: Int, height: Int) {\n        this.width = width\n        this.height = height\n    }\n    fun addXRegion(x: Int, width: Int): NinePatchBuilder {\n        xRegions.add(x)\n        xRegions.add(x + width)\n        return this\n    }\n    fun addXRegionPoints(x1: Int, x2: Int): NinePatchBuilder {\n        xRegions.add(x1)\n        xRegions.add(x2)\n        return this\n    }\n    fun addXRegion(xPercent: Float, widthPercent: Float): NinePatchBuilder {\n        val xtmp = (xPercent * width).toInt()\n        xRegions.add(xtmp)\n        xRegions.add(xtmp + (widthPercent * width).toInt())\n        return this\n    }\n    fun addXRegionPoints(x1Percent: Float, x2Percent: Float): NinePatchBuilder {\n        xRegions.add((x1Percent * width).toInt())\n        xRegions.add((x2Percent * width).toInt())\n        return this\n    }\n    fun addXCenteredRegion(width: Int): NinePatchBuilder {\n        val x = ((this.width - width) / 2)\n        xRegions.add(x)\n        xRegions.add(x + width)\n        return this\n    }\n    fun addXCenteredRegion(widthPercent: Float): NinePatchBuilder {\n        val width = (widthPercent * width).toInt()\n        val x = ((this.width - width) / 2)\n        xRegions.add(x)\n        xRegions.add(x + width)\n        return this\n    }\n    fun addYRegion(y: Int, height: Int): NinePatchBuilder {\n        yRegions.add(y)\n        yRegions.add(y + height)\n        return this\n    }\n    fun addYRegionPoints(y1: Int, y2: Int): NinePatchBuilder {\n        yRegions.add(y1)\n        yRegions.add(y2)\n        return this\n    }\n    fun addYRegion(yPercent: Float, heightPercent: Float): NinePatchBuilder {\n        val ytmp = (yPercent * height).toInt()\n        yRegions.add(ytmp)\n        yRegions.add(ytmp + (heightPercent * height).toInt())\n        return this\n    }\n    fun addYRegionPoints(y1Percent: Float, y2Percent: Float): NinePatchBuilder {\n        yRegions.add((y1Percent * height).toInt())\n        yRegions.add((y2Percent * height).toInt())\n        return this\n    }\n    fun addYCenteredRegion(height: Int): NinePatchBuilder {\n        val y = ((this.height - height) / 2)\n        yRegions.add(y)\n        yRegions.add(y + height)\n        return this\n    }\n    fun addYCenteredRegion(heightPercent: Float): NinePatchBuilder {\n        val height = (heightPercent * height).toInt()\n        val y = ((this.height - height) / 2)\n        yRegions.add(y)\n        yRegions.add(y + height)\n        return this\n    }\n    fun buildChunk(): ByteArray {\n        if (xRegions.size == 0) {\n            xRegions.add(0)\n            xRegions.add(width)\n        }\n        if (yRegions.size == 0) {\n            yRegions.add(0)\n            yRegions.add(height)\n        }\n        /* example code from a anwser above\n        // The 9 patch segment is not a solid color.\n        private static final int NO_COLOR = 0x00000001;\n        ByteBuffer buffer = ByteBuffer.allocate(56).order(ByteOrder.nativeOrder());\n        //was translated\n        buffer.put((byte)0x01);\n        //divx size\n        buffer.put((byte)0x02);\n        //divy size\n        buffer.put((byte)0x02);\n        //color size\n        buffer.put(( byte)0x02);\n        //skip\n        buffer.putInt(0);\n        buffer.putInt(0);\n        //padding\n        buffer.putInt(0);\n        buffer.putInt(0);\n        buffer.putInt(0);\n        buffer.putInt(0);\n        //skip 4 bytes\n        buffer.putInt(0);\n        buffer.putInt(left);\n        buffer.putInt(right);\n        buffer.putInt(top);\n        buffer.putInt(bottom);\n        buffer.putInt(NO_COLOR);\n        buffer.putInt(NO_COLOR);\n        return buffer;*/\n        val NO_COLOR = 1 //0x00000001;\n        val COLOR_SIZE = 9 //could change, may be 2 or 6 or 15 - but has no effect on output\n        val arraySize: Int = 1 + 2 + 4 + 1 + xRegions.size + yRegions.size + COLOR_SIZE\n        val byteBuffer: ByteBuffer =\n            ByteBuffer.allocate(arraySize * 4).order(ByteOrder.nativeOrder())\n        byteBuffer.put(1.toByte()) //was translated\n        byteBuffer.put(xRegions.size.toByte()) //divisions x\n        byteBuffer.put(yRegions.size.toByte()) //divisions y\n        byteBuffer.put(COLOR_SIZE.toByte()) //color size\n        //skip\n        byteBuffer.putInt(0)\n        byteBuffer.putInt(0)\n        //padding -- always 0 -- left right top bottom\n        byteBuffer.putInt(0)\n        byteBuffer.putInt(0)\n        byteBuffer.putInt(0)\n        byteBuffer.putInt(0)\n        //skip\n        byteBuffer.putInt(0)\n        for (rx in xRegions) byteBuffer.putInt(rx) // regions left right left right ...\n        for (ry in yRegions) byteBuffer.putInt(ry) // regions top bottom top bottom ...\n        for (i in 0 until COLOR_SIZE) byteBuffer.putInt(NO_COLOR)\n        return byteBuffer.array()\n    }\n    fun buildNinePatch(): NinePatch? {\n        val chunk = buildChunk()\n        return if (bitmap != null) NinePatch(bitmap, chunk, null) else null\n    }\n    fun build(): NinePatchDrawable? {\n        val ninePatch = buildNinePatch()\n        return ninePatch?.let { NinePatchDrawable(resources, it) }\n    }\n    fun buildWithPadding(rect: Rect): NinePatchDrawable?  {\n        return NinePatchDrawable(resources, bitmap, buildChunk(),  rect, null)\n    }\n}\n简单使用方式如下\nval builder = NinePatchBuilder(resources, bmpTemp)\nbuilder.addXCenteredRegion(10)\nbuilder.addYCenteredRegion(10) \nval drawable = builder.build()\nview.background = drawable\n这种方式会保存原来的点9图padding信息，如果原图没有的话， 可以手动在view上做padding控制。\n5. 注意事项\n一定要使用缓存，不然异步加载的过程中，在list中显示会有问题，跳变很严重，尤其是在快速滑动的时候， 最好能复用图片缓存框架，内存+磁盘两种缓存都要做。\n代码操作bitmap一定要及时释放回收，最好能有一定的保障机制，避免bitmap大量占用内存。比如发现图片过大，可以走default处理方式。\n具体方案二和方案三哪种方案更合适，预研阶段进行了测试，看不出来有什么性能的差异，后续实际开发会持续进行测试验证。\n参考文章\nQQ音乐- Android点九图总结以及在聊天气泡中的使用\nstackoverflow 社区\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598544663477},"updatedAt":{"$$date":1598545166863},"_id":"r3zmPLIMpYJ8YNcR","folder":{"id":"4YrYQlvQK","name":"yuque","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-Kotlin 基础语法 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-basic-syntax.html\nKotlin 基础语法 | 菜鸟教程\n4-5 minutes\nKotlin 文件以 .kt 为后缀。\n\n包声明\n代码文件的开头一般为包的声明：\n\npackage com.runoob.main\n\nimport java.util.*\n\nfun test() {}\nclass Runoob {}\nkotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。\n\n以上例中 test() 的全名是 com.runoob.main.test、Runoob 的全名是 com.runoob.main.Runoob。\n\n如果没有指定包，默认为 default 包。\n\n默认导入\n有多个包会默认导入到每个 Kotlin 文件中：\n\nkotlin.*\nkotlin.annotation.*\nkotlin.collections.*\nkotlin.comparisons.*\nkotlin.io.*\nkotlin.ranges.*\nkotlin.sequences.*\nkotlin.text.*\n函数定义\n函数定义使用关键字 fun，参数格式为：参数 : 类型\n\nfun sum(a: Int, b: Int): Int {   // Int 参数，返回值 Int\n    return a + b\n}\n表达式作为函数体，返回类型自动推断：\n\nfun sum(a: Int, b: Int) = a + b\n\npublic fun sum(a: Int, b: Int): Int = a + b   // public 方法则必须明确写出返回类型\n无返回值的函数(类似Java中的void)：\n\nfun printSum(a: Int, b: Int): Unit { \n    print(a + b)\n}\n\n\n// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：\npublic fun printSum(a: Int, b: Int) { \n    print(a + b)\n}\n可变长参数函数\n函数的变长参数可以用 vararg 关键字进行标识：\n\nfun vars(vararg v:Int){\n    for(vt in v){\n        print(vt)\n    }\n}\n\n// 测试\nfun main(args: Array<String>) {\n    vars(1,2,3,4,5)  // 输出12345\n}\nlambda(匿名函数)\nlambda表达式使用实例：\n\n// 测试\nfun main(args: Array<String>) {\n    val sumLambda: (Int, Int) -> Int = {x,y -> x+y}\n    println(sumLambda(1,2))  // 输出 3\n}\n定义常量与变量\n可变变量定义：var 关键字\n\nvar <标识符> : <类型> = <初始化值>\n不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)\n\nval <标识符> : <类型> = <初始化值>\n常量与变量都可以没有初始化值,但是在引用前必须初始化\n\n编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。\n\nval a: Int = 1\nval b = 1       // 系统自动推断变量类型为Int\nval c: Int      // 如果不在声明时初始化则必须提供变量类型\nc = 1           // 明确赋值\n\n\nvar x = 5        // 系统自动推断变量类型为Int\nx += 1           // 变量可修改\n注释\nKotlin 支持单行和多行注释，实例如下：\n\n// 这是一个单行注释\n\n/* 这是一个多行的\n   块注释。 */\n与 Java 不同, Kotlin 中的块注释允许嵌套。\n\n字符串模板\n$ 表示一个变量名或者变量值\n\n$varName 表示变量值\n\n${varName.fun()} 表示变量的方法返回值:\n\nvar a = 1\n// 模板中的简单名称：\nval s1 = \"a is $a\" \n\na = 2\n// 模板中的任意表达式：\nval s2 = \"${s1.replace(\"is\", \"was\")}, but now is $a\"\nNULL检查机制\nKotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理\n\n//类型后面加?表示可为空\nvar age: String? = \"23\" \n//抛出空指针异常\nval ages = age!!.toInt()\n//不做处理返回 null\nval ages1 = age?.toInt()\n//age为空返回-1\nval ages2 = age?.toInt() ?: -1\n当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。\n\n当 str 中的字符串内容不是一个整数时, 返回 null:\n\nfun parseInt(str: String): Int? {\n  // ...\n}\n以下实例演示如何使用一个返回值可为 null 的函数:\n\nfun main(args: Array<String>) {\n  if (args.size < 2) {\n    print(\"Two integers expected\")\n    return\n  }\n  val x = parseInt(args[0])\n  val y = parseInt(args[1])\n  // 直接使用 `x * y` 会导致错误, 因为它们可能为 null.\n  if (x != null && y != null) {\n    // 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量\n    print(x * y)\n  }\n}\n类型检测及自动类型转换\n我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。\n\nfun getStringLength(obj: Any): Int? {\n  if (obj is String) {\n    // 做过类型判断以后，obj会被系统自动转换为String类型\n    return obj.length \n  }\n\n  //在这里还有一种方法，与Java中instanceof不同，使用!is\n  // if (obj !is String){\n  //   // XXX\n  // }\n\n  // 这里的obj仍然是Any类型的引用\n  return null\n}\n或者\n\nfun getStringLength(obj: Any): Int? {\n  if (obj !is String)\n    return null\n  // 在这个分支中, `obj` 的类型会被自动转换为 `String`\n  return obj.length\n}\n甚至还可以\n\nfun getStringLength(obj: Any): Int? {\n  // 在 `&&` 运算符的右侧, `obj` 的类型会被自动转换为 `String`\n  if (obj is String && obj.length > 0)\n    return obj.length\n  return null\n}\n区间\n区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。\n\n区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例:\n\nfor (i in 1..4) print(i) // 输出“1234”\n\nfor (i in 4..1) print(i) // 什么都不输出\n\nif (i in 1..10) { // 等同于 1 <= i && i <= 10\n    println(i)\n}\n\n// 使用 step 指定步长\nfor (i in 1..4 step 2) print(i) // 输出“13”\n\nfor (i in 4 downTo 1 step 2) print(i) // 输出“42”\n\n\n// 使用 until 函数排除结束元素\nfor (i in 1 until 10) {   // i in [1, 10) 排除了 10\n     println(i)\n}\n实例测试\nfun main(args: Array<String>) {\n    print(\"循环输出：\")\n    for (i in 1..4) print(i) // 输出“1234”\n    println(\"\\n----------------\")\n    print(\"设置步长：\")\n    for (i in 1..4 step 2) print(i) // 输出“13”\n    println(\"\\n----------------\")\n    print(\"使用 downTo：\")\n    for (i in 4 downTo 1 step 2) print(i) // 输出“42”\n    println(\"\\n----------------\")\n    print(\"使用 until：\")\n    // 使用 until 函数排除结束元素\n    for (i in 1 until 4) {   // i in [1, 4) 排除了 4\n        print(i)\n    }\n    println(\"\\n----------------\")\n}\n输出结果：\n\n循环输出：1234\n----------------\n设置步长：13\n----------------\n使用 downTo：42\n----------------\n使用 until：123\n----------------"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303687029},"updatedAt":{"$$date":1597303781660},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"r58qMvy8EO8g46MN"}
{"name":"kotlin-MaskProgressViewAttributeSet","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\npackage com.ks.component.ui.view\n\nimport android.content.Context\nimport android.graphics.Color\nimport android.util.AttributeSet\nimport android.view.ViewGroup\nimport android.widget.RelativeLayout\nimport com.ks.lib.ktx.ext.dp2px\n\n/**\n ***************************************\n * 项目名称:jrhApplication\n * @Author jiaruihua\n * 邮箱：jiaruihua@ksjgs.com\n * 创建时间: 2020/6/16     6:39 PM\n * 用途:\n ***************************************\n */\nclass MaskProgressView : RelativeLayout {\n\n    private var attrs: AttributeSet? = null\n    private var mTotalProgress = 100\n    private var needSecondProgress = false\n\n    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) {\n\n        this.attrs = attrs\n    }\n\n    fun initViews(progress: Int = 0, secondProgress: Int = 0, totalProgress: Int = 100, needProgress: Boolean = true, needSecondProgress: Boolean = true, bgColor: String = \"#ffffff\", progressColor: String? = null) {\n        removeAllViews()\n        this.needSecondProgress = needSecondProgress\n        mTotalProgress = if (totalProgress > 0) totalProgress else 100\n        drawBg(bgColor)\n        if (needSecondProgress) {\n            drawSecondProgress(secondProgress)\n        }\n        if (needProgress) {\n            drawProgress(progress, progressColor)\n        }\n    }\n\n\n    private fun drawProgress(progress: Int, progressColor: String?) {\n        progressColor?.let {\n            addView(RoundProgressBarView(context, Color.parseColor(progressColor), progress / mTotalProgress.toFloat()))\n        }\n    }\n\n    private fun drawSecondProgress(secondProgress: Int) {\n        val roundView = MoveProgressLayout(context, attrs)\n        var per = secondProgress / mTotalProgress.toFloat()\n        per = if (per > 1.0f) 1.0f else per\n        val params = ViewGroup.LayoutParams((measuredWidth * per).toInt(), ViewGroup.LayoutParams.MATCH_PARENT)\n        addView(roundView, params)\n    }\n\n\n    private fun drawBg(bgColor: String) {\n        if (bgColor.isNotEmpty()) {\n            addView(RoundProgressBarView(context, Color.parseColor(bgColor), 1.0f))\n        } else {\n            addView(RoundProgressBarView(context, Color.parseColor(\"#ffffff\"), 1.0f))\n        }\n\n    }\n\n    fun startAni(color1: String, color2: String) {\n        if (!needSecondProgress || childCount < 2) return\n        val maskView = getChildAt(1) as MoveProgressLayout\n        maskView.post {\n            maskView.initViews(dp2px(15).toFloat(), Color.parseColor(color1), Color.parseColor(color2))\n            maskView.startAni(1000 * 10)\n        }\n\n    }\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597403210955},"updatedAt":{"$$date":1597404063527},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"rRTHCyw8TcxpJPXr"}
{"name":"java-使用ThreadLocal","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"多线程是Java实现多任务的基础，Thread对象代表一个线程，我们可以在代码中调用Thread.currentThread()获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字：\n\n// Thread\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        log(\"start main...\");\n        new Thread(() -> {\n            log(\"run task...\");\n        }).start();\n        new Thread(() -> {\n            log(\"print...\");\n        }).start();\n        log(\"end main.\");\n    }\n\n    static void log(String s) {\n        System.out.println(Thread.currentThread().getName() + \": \" + s);\n    }\n}\n\n Run\n对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：\n\npublic void process(User user) {\n    checkPermission();\n    doWork();\n    saveStatus();\n    sendResponse();\n}\n然后，通过线程池去执行这些任务。\n\n观察process()方法，它内部需要调用若干其他方法，同时，我们遇到一个问题：如何在一个线程内传递状态？\n\nprocess()方法需要传递的状态就是User实例。有的童鞋会想，简单地传入User就可以了：\n\npublic void process(User user) {\n    checkPermission(user);\n    doWork(user);\n    saveStatus(user);\n    sendResponse(user);\n}\n但是往往一个方法又会调用其他很多方法，这样会导致User传递到所有地方：\n\nvoid doWork(User user) {\n    queryStatus(user);\n    checkStatus();\n    setNewStatus(user);\n    log();\n}\n这种在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。\n\n给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，User对象就传不进去了。\n\nJava标准库提供了一个特殊的ThreadLocal，它可以在一个线程中传递同一个对象。\n\nThreadLocal实例通常总是以静态字段初始化如下：\n\nstatic ThreadLocal<User> threadLocalUser = new ThreadLocal<>();\n它的典型使用方式如下：\n\nvoid processUser(user) {\n    try {\n        threadLocalUser.set(user);\n        step1();\n        step2();\n    } finally {\n        threadLocalUser.remove();\n    }\n}\n通过设置一个User实例关联到ThreadLocal中，在移除之前，所有方法都可以随时获取到该User实例：\n\nvoid step1() {\n    User u = threadLocalUser.get();\n    log();\n    printUser();\n}\n\nvoid log() {\n    User u = threadLocalUser.get();\n    println(u.name);\n}\n\nvoid step2() {\n    User u = threadLocalUser.get();\n    checkUser(u.id);\n}\n注意到普通的方法调用一定是同一个线程执行的，所以，step1()、step2()以及log()方法内，threadLocalUser.get()获取的User对象是同一个实例。\n\n实际上，可以把ThreadLocal看成一个全局Map<Thread, Object>：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key：\n\nObject threadLocalValue = threadLocalMap.get(Thread.currentThread());\n因此，ThreadLocal相当于给每个线程都开辟了一个独立的存储空间，各个线程的ThreadLocal关联的实例互不干扰。\n\n最后，特别注意ThreadLocal一定要在finally中清除：\n\ntry {\n    threadLocalUser.set(user);\n    ...\n} finally {\n    threadLocalUser.remove();\n}\n这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。\n\n为了保证能释放ThreadLocal关联的实例，我们可以通过AutoCloseable接口配合try (resource) {...}结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的ThreadLocal可以封装为一个UserContext对象：\n\npublic class UserContext implements AutoCloseable {\n\n    static final ThreadLocal<String> ctx = new ThreadLocal<>();\n\n    public UserContext(String user) {\n        ctx.set(user);\n    }\n\n    public static String currentUser() {\n        return ctx.get();\n    }\n\n    @Override\n    public void close() {\n        ctx.remove();\n    }\n}\n使用的时候，我们借助try (resource) {...}结构，可以这么写：\n\ntry (var ctx = new UserContext(\"Bob\")) {\n    // 可任意调用UserContext.currentUser():\n    String currentUser = UserContext.currentUser();\n} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象\n这样就在UserContext中完全封装了ThreadLocal，外部代码在try (resource) {...}内部可以随时调用UserContext.currentUser()获取当前线程绑定的用户名。\n\n练习\n从下载练习：ThreadLocal练习 （推荐使用IDE练习插件快速下载）\n\n小结\nThreadLocal表示线程的“局部变量”，它确保每个线程的ThreadLocal变量都是各自独立的；\n\nThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；\n\n使用ThreadLocal要用try ... finally结构，并在finally中清除。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826932040},"updatedAt":{"$$date":1594973551028},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"rUCGLq25zuOwlDvT"}
{"name":"andr-字符串","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/string-resource\n字符串资源  |  Android 开发者  |  Android Developers\n18-23 minutes\n字符串资源为您的应用提供具有可选文本样式和格式设置的文本字符串。共有三种类型的资源可为您的应用提供字符串：\n\nString\n提供单个字符串的 XML 资源。\nString Array\n提供字符串数组的 XML 资源。\nQuantity Strings (Plurals)\n带有用于多元化的不同字符串的 XML 资源。\n所有字符串都能应用某些样式设置标记和格式设置参数。如需了解有关样式和格式设置字符串的信息，请参阅格式和样式设置部分。\n\nString\n可从应用或其他资源文件（如 XML 布局）引用的单个字符串。\n\n请注意：字符串是一种简单资源，您可以使用 name 属性（并非 XML 文件的名称）中提供的值对其进行引用。因此，您可以在一个 <resources> 元素下，将字符串资源与其他简单资源合并到一个 XML 文件中。\n\n文件位置：\nres/values/filename.xml\nfilename 是任意值。<string> 元素的 name 用作资源 ID。\n编译资源的数据类型：\n指向 String 的资源指针。\n资源引用：\n在 Java 中：R.string.string_name\n在 XML 中：@string/string_name\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string\n        name=\"string_name\"\n        >text_string</string>\n</resources>\n元素：\n<resources>\n必备。此元素必须是根节点。\n无属性。\n\n<string>\n字符串，可包含样式设置标记。请注意，您必须对撇号和引号进行转义。如需了解有关如何正确设置字符串样式和格式的详细信息，请参阅下文的格式和样式设置。\n属性：\n\nname\nString。字符串的名称。此名称用作资源 ID。\n示例：\n保存在 res/values/strings.xml 的 XML 文件：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string name=\"hello\">Hello!</string>\n</resources>\n该布局 XML 会对视图应用一个字符串：\n\n<TextView\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"@string/hello\" />\n以下应用代码用于检索字符串：\n\n您可以使用 getString(int) 或 getText(int) 检索字符串。getText(int) 会保留所有应用于字符串的富文本样式。\n\nString Array\n可从应用引用的字符串数组。\n\n请注意：字符串数组是一种简单资源，您可以使用 name 属性（并非 XML 文件的名称）中提供的值对其进行引用。因此，您可以在一个 <resources> 元素下，将字符串数组资源与其他简单资源合并到一个 XML 文件中。\n\n文件位置：\nres/values/filename.xml\nfilename 是任意值。<string-array> 元素的 name 用作资源 ID。\n编译资源的数据类型：\n指向 String 数组的资源指针。\n资源引用：\n在 Java 中：R.array.string_array_name\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string-array\n        name=\"string_array_name\">\n        <item\n            >text_string</item>\n    </string-array>\n</resources>\n元素：\n<resources>\n必备。此元素必须是根节点。\n无属性。\n\n<string-array>\n定义一个字符串数组。包含一个或多个 <item> 元素。\n属性：\n\nname\nString。数组的名称。此名称用作引用数组的资源 ID。\n<item>\n字符串，可包含样式设置标记。其值可以是对另一字符串资源的引用。必须为 <string-array> 元素的子项。请注意，您必须对撇号和引号进行转义。如需了解有关如何正确设置字符串样式和格式的信息，请参阅下文的格式和样式设置。\n无属性。\n\n示例：\n保存在 res/values/strings.xml 的 XML 文件：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string-array name=\"planets_array\">\n        <item>Mercury</item>\n        <item>Venus</item>\n        <item>Earth</item>\n        <item>Mars</item>\n    </string-array>\n</resources>\n以下应用代码用于检索字符串数组：\n\nQuantity Strings (Plurals)\n针对语法数量的一致性，不同语言有不同规则。例如，在英语中，数量 1 是一种特殊情况。我们会写成“1 book”，但如果是任何其他数量，则会写成“n books”。这种对单复数的区分很常见，但其他语言拥有更细致的区分。Android 支持以下完整集合：zero、one、two、few、many 和 other。\n\n决定为给定语言和数量使用哪种情况的规则可能非常复杂，因此 Android 为您提供 getQuantityString() 等方法来选择合适资源。\n\n虽然 Quantity Strings 过去称作“Quantity Strings”（并且 API 中仍采用此名称），但其只应用于表示复数。例如，类似使用 Quantity Strings 实现 Gmail 的“Inbox”这类情况便属于错误行为，正确的做法是用其实现“Inbox (12)”这种存在未读邮件的情况。使用 Quantity Strings 来替代 if 语句似乎很方便，但必须注意的是，某些语言（如中文）根本不做这些语法区分，因此您获取的始终是 other 字符串。\n\n选择使用哪一个字符串完全取决于语法上的必要性。在英语中，即使数量为 0，表示 zero 的字符串也会被忽略，因为在语法上，0 与 2 或除 1 以外的任何其他数字并无区别（“zero books”、“one book”、“two books”等）。相反，韩语中仅使用过 other 字符串。\n\n请勿被某些事实误导，例如 two 听起来仅适用于数量 2：某种语言可能规定，对 2、12、102（依此类推）等数量进行相同处理，但对其他数量进行特殊处理。您可以依靠翻译人员来了解其语言的实际区分要求。\n\n通常，您可以利用“Books: 1”等无需考虑数量的表示，从而避免使用 Quantity Strings。如果您的应用可接受此样式，则您和翻译人员的工作都会更轻松。\n\n请注意：Plurals 集合是一种简单资源，您可以使用 name 属性（并非 XML 文件的名称）中提供的值对其进行引用。因此，您可以在一个 <resources> 元素下，将 plurals 资源与其他简单资源合并到一个 XML 文件中。\n\n文件位置：\nres/values/filename.xml\nfilename 是任意值。<plurals> 元素的 name 用作资源 ID。\n资源引用：\n在 Java 中：R.plurals.plural_name\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <plurals\n        name=\"plural_name\">\n        <item\n            quantity=[\"zero\" | \"one\" | \"two\" | \"few\" | \"many\" | \"other\"]\n            >text_string</item>\n    </plurals>\n</resources>\n元素：\n<resources>\n必备。此元素必须是根节点。\n无属性。\n\n<plurals>\n字符串集合，根据事物数量提供其中的一个字符串。包含一个或多个 <item> 元素。\n属性：\n\nname\nString。字符串对的名称。此名称用作资源 ID。\n<item>\n一个复数或单数字符串。其值可以是对另一字符串资源的引用。必须为 <plurals> 元素的子项。请注意，您必须对撇号和引号进行转义。如需了解有关如何正确设置字符串样式和格式的信息，请参阅下文的格式和样式设置。\n属性：\n\nquantity\n关键字。表示应在何时使用该字符串的值。以下是该关键字的有效值（括号内仅为部分示例）：\nValue\t描述\nzero\t当某种语言要求对数字 0（如阿拉伯语中的 0）进行特殊处理时。\none\t当某种语言要求对 1 这类数字（如英语和大多数其他语言中的数字 1；在俄语中，任何末尾为 1 但非 11 的数字均属此类）进行特殊处理时。\ntwo\t当某种语言要求对 2 这类数字（如威尔士语中的 2，或斯洛文尼亚语中的 102）进行特殊处理时。\nfew\t当某种语言要求对“小”数字（如捷克语中的 2、3 和 4；或波兰语中末尾为 2、3 或 4，但非 12、13 或 14 的数字）进行特殊处理时。\nmany\t当某种语言要求对“大”数字（如马耳他语中末尾为 11 至 99 的数字）进行特殊处理时。\nother\t当某种语言未要求对给定数量（如中文中的所有数字，或英语中的 42）进行特殊处理时。\n示例：\n保存在 res/values/strings.xml 的 XML 文件：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <plurals name=\"numberOfSongsAvailable\">\n        <!--\n             As a developer, you should always supply \"one\" and \"other\"\n             strings. Your translators will know which strings are actually\n             needed for their language. Always include %d in \"one\" because\n             translators will need to use %d for languages where \"one\"\n             doesn't mean 1 (as explained above).\n          -->\n        <item quantity=\"one\">%d song found.</item>\n        <item quantity=\"other\">%d songs found.</item>\n    </plurals>\n</resources>\n保存在 res/values-pl/strings.xml 中的 XML 文件：\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <plurals name=\"numberOfSongsAvailable\">\n        <item quantity=\"one\">Znaleziono %d piosenkę.</item>\n        <item quantity=\"few\">Znaleziono %d piosenki.</item>\n        <item quantity=\"other\">Znaleziono %d piosenek.</item>\n    </plurals>\n</resources>\n用法：\n\nval count = getNumberOfSongsAvailable()\nval songsFound = resources.\ngetQuantityString\n(R.plurals.numberOfSongsAvailable, count, count)\nint count = getNumberOfSongsAvailable();\nResources res = \ngetResources()\n;\nString songsFound = res.\ngetQuantityString\n(R.plurals.numberOfSongsAvailable, count, count);\n使用 getQuantityString() 方法时，如果您的字符串包含带有数字的字符串格式设置，则您需要传递两次 count。例如，对于字符串 %d songs found，第一个 count 参数会选择相应的复数字符串，第二个 count 参数会被插入 %d 占位符内。如果您的复数字符串没有字符串格式设置，则无需向 getQuantityString 传递第三个参数。\n\n格式和样式\n关于如何正确设置字符串资源的格式和样式，您应了解以下几个要点。\n\n处理特殊字符\n如果 XML 或 Android 中的字符串包含有特殊用法的字符，则必须转义这些字符。您可以使用前导反斜杠转义某些字符，但其他字符需使用 XML 转义。您也可以通过在双引号中包括整个字符串，处理撇号和单引号。以下为部分示例：\n\n字符\t转义形式\n@\t\\@\n?\t\\?\n<\t&lt;\n&\t&amp;\n单引号 (')\t\n以下任意字符：\n\n&apos;\n\\'\n在双引号中包括整个字符串（例如，\"This'll work\"）\n双引号 (\")\t\n以下任意字符：\n\n&quot;\n\\\"\n请注意，您必须转义双引号。在单引号中包括字符串没有任何作用。\n\n设置字符串格式\n如需设置字符串的格式，您可以在字符串资源中放入格式参数（如以下示例资源所示）。\n\n<string name=\"welcome_messages\">Hello, %1$s! You have %2$d new messages.</string>\n在本例中，格式字符串有两个参数：%1$s 为字符串，而 %2$d 为十进制数字。然后，您可通过调用 getString(int, Object...) 来设置字符串格式。例如：\n\nvar text = getString(R.string.welcome_messages, username, mailCount)\nString text = getString(R.string.welcome_messages, username, mailCount);\n使用 HTML 标记设置样式\n您可以使用 HTML 标记为字符串添加样式设置。例如：\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string name=\"welcome\">Welcome to <b>Android</b>!</string>\n</resources>\n支持以下 HTML 元素：\n\n粗体：<b>、<em>\n斜体：<i>、<cite>、<dfn>\n文本放大 25%：<big>\n文本缩小 20%：<small>\n设置字体属性：<font face=”font_family“ color=”hex_color”>。可能的字体系列示例包括 monospace、serif 和 sans_serif。\n设置等宽字体系列：<tt>\n删除线：<s>、<strike>、<del>\n下划线：<u>\n上标：<sup>\n下标：<sub>\n列表标记：<ul>、<li>\n换行符：<br>\n区隔标记：<div>\nCSS 样式：<span style=”color|background_color|text-decoration”>\n段落：<p dir=”rtl | ltr” style=”…”>\n如果您没有应用格式设置，则可通过调用 setText(java.lang.CharSequence) 直接设置 TextView 文本。但在某些情况下，您可能想创建带样式的文本资源，并将其用作格式字符串。您通常无法实现此目标，因为 format(String, Object...) 和 getString(int, Object...) 方法会删除字符串中的所有样式信息。解决方法是编写带转义实体的 HTML 标记，并在完成格式设置后通过 fromHtml(String) 恢复这些实体。例如：\n\n将您带样式的文本资源存储为 HTML 转义字符串：\n<resources>\n  <string name=\"welcome_messages\">Hello, %1$s! You have &lt;b>%2$d new messages&lt;/b>.</string>\n</resources>\n如上所示，带格式的字符串中添加了 <b> 元素。请注意，开括号使用 &lt; 符号实现了 HTML 转义。\n\n然后照常设置字符串格式，但还需调用 fromHtml(String)，以将 HTML 文本转换成带样式的文本：\nval text: String = getString(R.string.welcome_messages, username, mailCount)\nval styledText: Spanned = Html.fromHtml(text, FROM_HTML_MODE_LEGACY)\nString text = getString(R.string.welcome_messages, username, mailCount);\nSpanned styledText = Html.fromHtml(text, FROM_HTML_MODE_LEGACY);\n由于 fromHtml(String) 方法会设置所有 HTML 实体的格式，因此请务必使用 htmlEncode(String) 转义带格式文本的字符串中任何可能存在的 HTML 字符。例如，如果您打算对包含“<”或“&”等字符的字符串进行格式设置，则在设置格式前必须先转义这类字符。如此一来，当通过 fromHtml(String) 传递带格式的字符串时，字符才会以最初的编写形式显示。例如：\n\nval escapedUsername: String = TextUtils.\nhtmlEncode\n(username)val text: String = getString(R.string.welcome_messages, escapedUsername, mailCount)\nval styledText: Spanned = Html.fromHtml(text, FROM_HTML_MODE_LEGACY)\nString escapedUsername = TextUtils.\nhtmlEncode\n(username);String text = getString(R.string.welcome_messages, escapedUsername, mailCount);\nSpanned styledText = Html.fromHtml(text);\n使用 Spannable 设置样式\nSpannable 是一种文本对象，您可使用颜色和字体粗细等字体属性对其进行样式设置。您可以使用 SpannableStringBuilder 生成文本，然后对文本应用 android.text.style 软件包中定义的样式。\n\n您可以使用以下辅助方法设置创建 spannable 文本的大量工作：\n\n/**\n * Returns a CharSequence that concatenates the specified array of CharSequence\n * objects and then applies a list of zero or more tags to the entire range.\n *\n * @param content an array of character sequences to apply a style to\n * @param tags the styled span objects to apply to the content\n *        such as android.text.style.StyleSpan\n */\nprivate fun apply(content: Array<out CharSequence>, vararg tags: Any): CharSequence {\n    return SpannableStringBuilder().apply {\n        openTags(tags)\n        content.forEach { charSequence ->\n            append(charSequence)\n        }\n        closeTags(tags)\n    }\n}/**\n * Iterates over an array of tags and applies them to the beginning of the specified\n * Spannable object so that future text appended to the text will have the styling\n * applied to it. Do not call this method directly.\n */\nprivate fun Spannable.openTags(tags: Array<out Any>) {\n    tags.forEach { tag ->\n        setSpan(tag, 0, 0, Spannable.SPAN_MARK_MARK)\n    }\n}/**\n * \"Closes\" the specified tags on a Spannable by updating the spans to be\n * endpoint-exclusive so that future text appended to the end will not take\n * on the same styling. Do not call this method directly.\n */\nprivate fun Spannable.closeTags(tags: Array<out Any>) {\n    tags.forEach { tag ->\n    if (length > 0) {\n            setSpan(tag, 0, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)\n        } else {\n            removeSpan(tag)\n        }\n    }\n}\n/**\n * Returns a CharSequence that concatenates the specified array of CharSequence\n * objects and then applies a list of zero or more tags to the entire range.\n *\n * @param content an array of character sequences to apply a style to\n * @param tags the styled span objects to apply to the content\n *        such as android.text.style.StyleSpan\n *\n */\nprivate static CharSequence applyStyles(CharSequence[] content, Object[] tags) {\n    SpannableStringBuilder text = new SpannableStringBuilder();\n    openTags(text, tags);\n    for (CharSequence item : content) {\n        text.append(item);\n    }\n    closeTags(text, tags);\n    return text;\n}/**\n * Iterates over an array of tags and applies them to the beginning of the specified\n * Spannable object so that future text appended to the text will have the styling\n * applied to it. Do not call this method directly.\n */\nprivate static void openTags(Spannable text, Object[] tags) {\n    for (Object tag : tags) {\n        text.setSpan(tag, 0, 0, Spannable.SPAN_MARK_MARK);\n    }\n}/**\n * \"Closes\" the specified tags on a Spannable by updating the spans to be\n * endpoint-exclusive so that future text appended to the end will not take\n * on the same styling. Do not call this method directly.\n */\nprivate static void closeTags(Spannable text, Object[] tags) {\n    int len = text.length();\n    for (Object tag : tags) {\n        if (len > 0) {\n            text.setSpan(tag, 0, len, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n        } else {\n            text.removeSpan(tag);\n        }\n    }\n}\n以下 bold、italic 和 color 方法包含上述辅助方法，并展示应用 android.text.style 软件包中所定义样式的具体示例。通过创建类似的方法，您也可对其他类型的文本进行样式设置。\n\n/**\n * Returns a CharSequence that applies boldface to the concatenation\n * of the specified CharSequence objects.\n */\nfun bold(vararg content: CharSequence): CharSequence = apply(content, StyleSpan(Typeface.BOLD))/**\n * Returns a CharSequence that applies italics to the concatenation\n * of the specified CharSequence objects.\n */\nfun italic(vararg content: CharSequence): CharSequence = apply(content, StyleSpan(Typeface.ITALIC))/**\n * Returns a CharSequence that applies a foreground color to the\n * concatenation of the specified CharSequence objects.\n */\nfun color(color: Int, vararg content: CharSequence): CharSequence =\n        apply(content, ForegroundColorSpan(color))\n/**\n * Returns a CharSequence that applies boldface to the concatenation\n * of the specified CharSequence objects.\n */\npublic static CharSequence bold(CharSequence... content) {\n    return apply(content, new StyleSpan(Typeface.BOLD));\n}/**\n * Returns a CharSequence that applies italics to the concatenation\n * of the specified CharSequence objects.\n */\npublic static CharSequence italic(CharSequence... content) {\n    return apply(content, new StyleSpan(Typeface.ITALIC));\n}/**\n * Returns a CharSequence that applies a foreground color to the\n * concatenation of the specified CharSequence objects.\n */\npublic static CharSequence color(int color, CharSequence... content) {\n    return apply(content, new ForegroundColorSpan(color));\n}\n以下示例展示如何通过结合这些方法，向短语中的单个字词应用各种样式：\n\n// Create an italic \"hello, \" a red \"world\",\n// and bold the entire sequence.\nval text: CharSequence = bold(italic(getString(R.string.hello)),\n        color(Color.RED, getString(R.string.world)))\n// Create an italic \"hello, \" a red \"world\",\n// and bold the entire sequence.\nvar text = bold(italic(getString(R.string.hello)),\n  color(Color.RED, getString(R.string.world)))\n</pre>\n</section><section><h3 id=\"java\">Java</h3>\n<pre class=\"prettyprint lang-java\">\n// Create an italic \"hello, \" a red \"world\",\n// and bold the entire sequence.\nCharSequence text = bold(italic(getString(R.string.hello)),\n    color(Color.RED, getString(R.string.world)));\ncore-ktx Kotlin 模块还包含扩展函数，便于您更轻松地使用 span。您可以前往 GitHub 查看 android.text 软件包文档，了解详情。\n\n如需了解有关使用 span 的更多信息，请访问以下链接：\n\n使用 Span 设置样式的文本\n了解 span\n使用注解设置样式\n您可以通过使用 strings.xml 资源文件中的 Annotation 类和 <annotation> 标记，应用复杂样式或自定义样式。借助注解标记，您可以通过在 XML 文件中定义自定义键值对来标记自定义样式的部分字符串，框架随后会将该 XML 文件转换成 Annotation span。然后，您便可检索这些注解，并使用键和值来应用样式。\n\n创建注解时，请务必为 strings.xml 文件中的所有字符串翻译添加 <annotation> 标记。\n\n\n在所有语言中向“text”一词应用自定义字体\n\n示例 - 添加自定义字体\n添加 <annotation> 标记并定义键值对。在此情况下，键为 font，而值是我们要使用的字体类型：title_emphasis\n\n// values/strings.xml\n<string name=\"title\">Best practices for <annotation font=\"title_emphasis\">text</annotation> on Android</string>\n// values-es/strings.xml\n\n<string name=\"title\"><annotation font=\"title_emphasis\">Texto</annotation> en Android: mejores prácticas</string>\n加载字符串资源并找到包含 font 键的注解。然后，创建一个自定义 span，并用其替换现有 span。\n\n// get the text as SpannedString so we can get the spans attached to the text\nval titleText = getText(R.string.title) as SpannedString// get all the annotation spans from the text\nval annotations = titleText.getSpans(0, titleText.length, Annotation::class.java)// create a copy of the title text as a SpannableString.\n// the constructor copies both the text and the spans. so we can add and remove spans\nval spannableString = SpannableString(titleText)// iterate through all the annotation spans\nfor (annotation in annotations) {\n   // look for the span with the key font\n   if (annotation.key == \"font\") {\n      val fontName = annotation.value\n      // check the value associated to the annotation key\n      if (fontName == \"title_emphasis\") {\n         // create the typeface\n         val typeface = getFontCompat(R.font.permanent_marker)\n         // set the span at the same indices as the annotation\n         spannableString.setSpan(CustomTypefaceSpan(typeface),\n            titleText.getSpanStart(annotation),\n            titleText.getSpanEnd(annotation),\n            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)\n      }\n   }\n}// now, the spannableString contains both the annotation spans and the CustomTypefaceSpan\nstyledText.text = spannableString\n// get the text as SpannedString so we can get the spans attached to the text\nSpannedString titleText = (SpannedString) getText(R.string.title_about);// get all the annotation spans from the text\nAnnotation[] annotations = titleText.getSpans(0, titleText.length(), Annotation.class);// create a copy of the title text as a SpannableString.\n// the constructor copies both the text and the spans. so we can add and remove spans\nSpannableString spannableString = new SpannableString(titleText);// iterate through all the annotation spans\nfor (Annotation annotation: annotations) {\n  // look for the span with the key font\n  if (annotation.getKey().equals(\"font\")) {\n    String fontName = annotation.getValue();\n    // check the value associated to the annotation key\n    if (fontName.equals(\"title_emphasis\")) {\n    // create the typeface\n    Typeface typeface = ResourcesCompat.getFont(this, R.font.roboto_mono);\n    // set the span at the same indices as the annotation\n    spannableString.setSpan(new CustomTypefaceSpan(typeface),\n      titleText.getSpanStart(annotation),\n      titleText.getSpanEnd(annotation),\n      Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n    }\n  }\n}// now, the spannableString contains both the annotation spans and the CustomTypefaceSpan\nstyledText.text = spannableString;\n如果您多次使用相同文本，则应构建一次 SpannableString 对象并根据需要重复使用该对象，以避免出现潜在的性能和内存问题。\n\n如需了解注解用法的更多示例，请参阅在 Android 中设置国际化文本的样式\n\n注解 span 和文本打包\nAnnotation span 也是 ParcelableSpans，因此需对键值对进行打包和拆包。只要包的接收方了解如何解释注解，您便可使用 Annotation span 向打包文本应用自定义样式。\n\n如要在向 Intent Bundle 传递文本时保留自定义样式，您首先需在文本中添加 Annotation span。您可以使用 <annotation> 标记在 XML 资源中执行此操作（如上例所示），或通过创建新的 Annotation 并将其设置为 span，在代码中执行此操作（如下所示）：\n\nval spannableString = SpannableString(\"My spantastic text\")\nval annotation = Annotation(\"font\", \"title_emphasis\")\nspannableString.setSpan(annotation, 3, 7, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)// start Activity with text with spans\nval intent = Intent(this, MainActivity::class.java)\nintent.putExtra(TEXT_EXTRA, spannableString)\nstartActivity(intent)\nSpannableString spannableString = new SpannableString(\"My spantastic text\");\nAnnotation annotation = new Annotation(\"font\", \"title_emphasis\");\nspannableString.setSpan(annotation, 3, 7, 33);// start Activity with text with spans\nIntent intent = new Intent(this, MainActivity.class);\nintent.putExtra(TEXT_EXTRA, spannableString);\nthis.startActivity(intent);\n以 SpannableString 的形式从 Bundle 中检索文本，然后解析附加的注解（如上例所示）。\n\n// read text with Spans\nval intentCharSequence = intent.getCharSequenceExtra(TEXT_EXTRA) as SpannableString\n// read text with Spans\nSpannableString intentCharSequence = (SpannableString)intent.getCharSequenceExtra(TEXT_EXTRA);\n如需了解有关文本样式设置的更多信息，请访问以下链接：\n\nGoogle I/O 2018 大会 - Android 文本最佳实践\n了解 span"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242642948},"updatedAt":{"$$date":1597242792820},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ra9Ro72uTD8vrIwa"}
{"name":"CSS3 2D 转换","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 2D 转换\nCSS3 转换\nCSS3 转换可以对元素进行移动、缩放、转动、拉长或拉伸。\n\nCSS3 Transforms\n它是如何工作？\n转换的效果是让某个元素改变形状，大小和位置。\n\n您可以使用 2D 或 3D 转换来转换您的元素。\n\n鼠标移动到以下元素上，查看 2D 和 3D 的转换效果：\n\n2D 转换3D 转换\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器版本号。\n\n紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号。\n\n属性\t\t\t\t\t\ntransform\t36.0\n4.0 -webkit-\t10.0\n9.0 -ms-\t16.0\n3.5 -moz-\t3.2 -webkit-\t23.0\n15.0 -webkit-\n12.1\n10.5 -o-\ntransform-origin\n(two-value syntax)\t36.0\n4.0 -webkit-\t10.0\n9.0 -ms-\t16.0\n3.5 -moz-\t3.2 -webkit-\t23.0\n15.0 -webkit-\n12.1\n10.5 -o-\nInternet Explorer 10, Firefox, 和 Opera支持transform 属性.\n\nChrome 和 Safari 要求前缀 -webkit- 版本.\n\n注意： Internet Explorer 9 要求前缀 -ms- 版本.\n\n2D 转换\n在本章您将了解2D变换方法：\n\ntranslate()\nrotate()\nscale()\nskew()\nmatrix()\n在下一章中您将了解3D转换。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\ndiv\n{\ntransform: rotate(30deg);\n-ms-transform: rotate(30deg); /* IE 9 */\n-webkit-transform: rotate(30deg); /* Safari and Chrome */\n}\n\n尝试一下 »\n\ntranslate() 方法\nTranslate\ntranslate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\ndiv\n{\ntransform: translate(50px,100px);\n-ms-transform: translate(50px,100px); /* IE 9 */\n-webkit-transform: translate(50px,100px); /* Safari and Chrome */\n}\n\n尝试一下 »\ntranslate值（50px，100px）是从左边元素移动50个像素，并从顶部移动100像素。\n\nrotate() 方法\nRotate\nrotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\ndiv\n{\ntransform: rotate(30deg);\n-ms-transform: rotate(30deg); /* IE 9 */\n-webkit-transform: rotate(30deg); /* Safari and Chrome */\n}\n\n尝试一下 »\nrotate值（30deg）元素顺时针旋转30度。\n\nscale() 方法\nScale\nscale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n-ms-transform:scale(2,3); /* IE 9 */\n-webkit-transform: scale(2,3); /* Safari */\ntransform: scale(2,3); /* 标准语法 */\n\n尝试一下 »\nscale（2,3）转变宽度为原来的大小的2倍，和其原始大小3倍的高度。\n\nskew() 方法\n语法\ntransform:skew(<angle> [,<angle>]);\n包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。\n\nskewX(<angle>);表示只在X轴(水平方向)倾斜。\nskewY(<angle>);表示只在Y轴(垂直方向)倾斜。\nOperaSafariChromeFirefoxInternet Explorer\n实例\ndiv\n{\ntransform: skew(30deg,20deg);\n-ms-transform: skew(30deg,20deg); /* IE 9 */\n-webkit-transform: skew(30deg,20deg); /* Safari and Chrome */\n}\n\n尝试一下 »\nskew(30deg,20deg) 元素在X轴和Y轴上倾斜20度30度。\n\nmatrix() 方法\nRotate\nmatrix()方法和2D变换方法合并成一个。\n\nmatrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n利用matrix()方法旋转div元素30°\n\ndiv\n{\ntransform:matrix(0.866,0.5,-0.5,0.866,0,0);\n-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */\n-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */\n}\n\n尝试一下 »\n\n新转换属性\n以下列出了所有的转换属性:\n\nProperty\t描述\tCSS\ntransform\t适用于2D或3D转换的元素\t3\ntransform-origin\t允许您更改转化元素位置\t3\n2D 转换方法\n函数\t描述\nmatrix(n,n,n,n,n,n)\t定义 2D 转换，使用六个值的矩阵。\ntranslate(x,y)\t定义 2D 转换，沿着 X 和 Y 轴移动元素。\ntranslateX(n)\t定义 2D 转换，沿着 X 轴移动元素。\ntranslateY(n)\t定义 2D 转换，沿着 Y 轴移动元素。\nscale(x,y)\t定义 2D 缩放转换，改变元素的宽度和高度。\nscaleX(n)\t定义 2D 缩放转换，改变元素的宽度。\nscaleY(n)\t定义 2D 缩放转换，改变元素的高度。\nrotate(angle)\t定义 2D 旋转，在参数中规定角度。\nskew(x-angle,y-angle)\t定义 2D 倾斜转换，沿着 X 和 Y 轴。\nskewX(angle)\t定义 2D 倾斜转换，沿着 X 轴。\nskewY(angle)\t定义 2D 倾斜转换，沿着 Y 轴。\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974616192},"updatedAt":{"$$date":1598974883159},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ro4bdfCc5T0rfLRc"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980160299},"updatedAt":{"$$date":1594980160299},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"roiJaWxOJH0EH19y"}
{"name":"kotlin-Set 相关操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/set-operations.html\nSet 相关操作 - Kotlin 语言中文站\n3-4 minutes\n改进翻译\nKotlin 集合包中包含 set 常用操作的扩展函数：查找交集、并集或差集。\n\n要将两个集合合并为一个（并集），可使用 union() 函数。也能以中缀形式使用 a union b。 注意，对于有序集合，操作数的顺序很重要：在结果集合中，左侧操作数在前。\n\n要查找两个集合中都存在的元素（交集），请使用 intersect() 。 要查找另一个集合中不存在的集合元素（差集），请使用 subtract() 。 这两个函数也能以中缀形式调用，例如， a intersect b 。\n\nfun main() {\n//sampleStart\n    val numbers = setOf(\"one\", \"two\", \"three\")\n\n    println(numbers union setOf(\"four\", \"five\"))\n    println(setOf(\"four\", \"five\") union numbers)\n\n    println(numbers intersect setOf(\"two\", \"one\"))\n    println(numbers subtract setOf(\"three\", \"four\"))\n    println(numbers subtract setOf(\"four\", \"three\")) // 相同的输出\n//sampleEnd\n}\n注意， List 也支持 Set 操作。 但是，对 List 进行 Set 操作的结果仍然是 Set ，因此将删除所有重复的元素。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382138364},"updatedAt":{"$$date":1597386028019},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"rpPIdpzRu5HAzx0g"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975869195},"updatedAt":{"$$date":1598975869195},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ru1ATC4EQrAbYOaz"}
{"name":"html-","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598885694122},"updatedAt":{"$$date":1598885694122},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"rxVUpTaKn7S9FXH5"}
{"name":"ad-gradle.properties2","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n# Project-wide Gradle settings.\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\norg.gradle.jvmargs=-Xmx2048m\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n# org.gradle.parallel=true\n# AndroidX package structure to make it clearer which packages are bundled with the\n# Android operating system, and which are packaged with your app\"s APK\n# https://developer.android.com/topic/libraries/support-library/androidx-rn\nandroid.useAndroidX=true\n# Automatically convert third-party libraries to use AndroidX\nandroid.enableJetifier=true\n\nRELEASE_REPOSITORY_URL=http://10.0.20.167:8081/repository/ksandroidx/\nSNAPSHOT_REPOSITORY_URL=http://10.0.20.167:8081/repository/ksandroidx-snapshot/\nNEXUS_USERNAME=admin\nNEXUS_PASSWORD=kaishu2099\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539537106},"updatedAt":{"$$date":1598539683111},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"sAuWKZJCxDnZjyxf"}
{"name":"java-使用Condition","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"使用ReentrantLock比直接使用synchronized更安全，可以替代synchronized进行线程同步。\n\n但是，synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock我们怎么编写wait和notify的功能呢？\n\n答案是使用Condition对象来实现wait和notify的功能。\n\n我们仍然以TaskQueue为例，把前面用synchronized实现的功能通过ReentrantLock和Condition来实现：\n\nclass TaskQueue {\n    private final Lock lock = new ReentrantLock();\n    private final Condition condition = lock.newCondition();\n    private Queue<String> queue = new LinkedList<>();\n\n    public void addTask(String s) {\n        lock.lock();\n        try {\n            queue.add(s);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public String getTask() {\n        lock.lock();\n        try {\n            while (queue.isEmpty()) {\n                condition.await();\n            }\n            return queue.remove();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n可见，使用Condition时，引用的Condition对象必须从Lock实例的newCondition()返回，这样才能获得一个绑定了Lock实例的Condition实例。\n\nCondition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：\n\nawait()会释放当前锁，进入等待状态；\n\nsignal()会唤醒某个等待线程；\n\nsignalAll()会唤醒所有等待线程；\n\n唤醒线程从await()返回后需要重新获得锁。\n\n此外，和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：\n\nif (condition.await(1, TimeUnit.SECOND)) {\n    // 被其他线程唤醒\n} else {\n    // 指定时间内没有被其他线程唤醒\n}\n可见，使用Condition配合Lock，我们可以实现更灵活的线程同步。\n\n小结\nCondition可以替代wait和notify；\n\nCondition对象必须从Lock对象获取。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826925022},"updatedAt":{"$$date":1594967598256},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"sBKoG8Rbd1J6AsPX"}
{"name":"css-CSS 字体","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS字体属性定义字体，加粗，大小，文字样式。\n\nserif和sans-serif字体之间的区别\nSerif vs. Sans-serif\nRemark 在计算机屏幕上，sans-serif字体被认为是比serif字体容易阅读\n\nCSS字型\n在CSS中，有两种类型的字体系列名称：\n\n通用字体系列 - 拥有相似外观的字体系统组合（如 \"Serif\" 或 \"Monospace\"）\n特定字体系列 - 一个特定的字体系列（如 \"Times\" 或 \"Courier\"）\nGeneric family\t字体系列\t说明\nSerif\tTimes New Roman\nGeorgia\tSerif字体中字符在行的末端拥有额外的装饰\nSans-serif\tArial\nVerdana\t\"Sans\"是指无 - 这些字体在末端没有额外的装饰\nMonospace\tCourier New\nLucida Console\t所有的等宽字符具有相同的宽度\n\n字体系列\nfont-family 属性设置文本的字体系列。\n\nfont-family 属性应该设置几个字体名称作为一种\"后备\"机制，如果浏览器不支持第一种字体，他将尝试下一种字体。\n\n注意: 如果字体系列的名称超过一个字，它必须用引号，如Font Family：\"宋体\"。\n\n多个字体系列是用一个逗号分隔指明：\n\n实例\np{font-family:\"Times New Roman\", Times, serif;}\n\n尝试一下 »\n对于较常用的字体组合，看看我们的 Web安全字体组合。\n\n字体样式\n主要是用于指定斜体文字的字体样式属性。\n\n这个属性有三个值：\n\n正常 - 正常显示文本\n斜体 - 以斜体字显示的文字\n倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持）\n实例\np.normal {font-style:normal;}\np.italic {font-style:italic;}\np.oblique {font-style:oblique;}\n\n尝试一下 »\n\n字体大小\nfont-size 属性设置文本的大小。\n\n能否管理文字的大小，在网页设计中是非常重要的。但是，你不能通过调整字体大小使段落看上去像标题，或者使标题看上去像段落。\n\n请务必使用正确的HTML标签，就<h1> - <h6>表示标题和<p>表示段落：\n\n字体大小的值可以是绝对或相对的大小。\n\n绝对大小：\n\n设置一个指定大小的文本\n不允许用户在所有浏览器中改变文本大小\n确定了输出的物理尺寸时绝对大小很有用\n相对大小：\n\n相对于周围的元素来设置大小\n允许用户在浏览器中改变文字大小\nRemark 如果你不指定一个字体的大小，默认大小和普通文本段落一样，是16像素（16px=1em）。\n\n设置字体大小像素\n设置文字的大小与像素，让您完全控制文字大小：\n\n实例\nh1 {font-size:40px;}\nh2 {font-size:30px;}\np {font-size:14px;}\n\n尝试一下 »\n上面的例子可以在 Internet Explorer 9, Firefox, Chrome, Opera, 和 Safari 中通过缩放浏览器调整文本大小。\n\n虽然可以通过浏览器的缩放工具调整文本大小，但是，这种调整是整个页面，而不仅仅是文本\n\n用em来设置字体大小\n为了避免Internet Explorer 中无法调整文本的问题，许多开发者使用 em 单位代替像素。\n\nem的尺寸单位由W3C建议。\n\n1em和当前字体大小相等。在浏览器中默认的文字大小是16px。\n\n因此，1em的默认大小是16px。可以通过下面这个公式将像素转换为em：px/16=em\n\n实例\nh1 {font-size:2.5em;} /* 40px/16=2.5em */\nh2 {font-size:1.875em;} /* 30px/16=1.875em */\np {font-size:0.875em;} /* 14px/16=0.875em */\n\n尝试一下 »\n在上面的例子，em的文字大小是与前面的例子中像素一样。不过，如果使用 em 单位，则可以在所有浏览器中调整文本大小。\n\n不幸的是，仍然是IE浏览器的问题。调整文本的大小时，会比正常的尺寸更大或更小。\n\n使用百分比和EM组合\n在所有浏览器的解决方案中，设置 <body>元素的默认字体大小的是百分比：\n\n实例\nbody {font-size:100%;}\nh1 {font-size:2.5em;}\nh2 {font-size:1.875em;}\np {font-size:0.875em;}\n\n尝试一下 »\n我们的代码非常有效。在所有浏览器中，可以显示相同的文本大小，并允许所有浏览器缩放文本的大小。\n\nExamples\n更多实例\n设置字体加粗\n这个例子演示了如何设置字体的加粗。\n\n可以设置字体的转变\n这个例子演示了如何设置字体的转变。\n\n在一个声明中的所有字体属性\n本例演示如何使用简写属性将字体属性设置在一个声明之内。\n\n所有CSS字体属性\nProperty\t描述\nfont\t在一个声明中设置所有的字体属性\nfont-family\t指定文本的字体系列\nfont-size\t指定文本的字体大小\nfont-style\t指定文本的字体样式\nfont-variant\t以小型大写字体或者正常字体显示文本。\nfont-weight\t指定字体的粗细。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598888547219},"updatedAt":{"$$date":1598888794817},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"sBNXEi2bOCz7geZk"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597404257427},"updatedAt":{"$$date":1597404257427},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"sP2plSDS6ZL3ianM"}
{"name":"kqapp-gradle.properties","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n# Project-wide Gradle settings.\n\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\norg.gradle.jvmargs=-Xmx2048m\n\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n# org.gradle.parallel=true\n\n# AndroidX package structure to make it clearer which packages are bundled with the\n# Android operating system, and which are packaged with your app\"s APK\n# https://developer.android.com/topic/libraries/support-library/androidx-rn\nandroid.useAndroidX=true\n# Automatically convert third-party libraries to use AndroidX\nandroid.enableJetifier=true\n# 开启R8 压缩\n#android.enableR8=true\n\n#android.useDeprecatedNdk=true\n\napkName=lightlearn\n\n#打点上报开关 （解决当开发时，上报日志刷屏的痛点  只在非release 环境有效）\nisOpenTrack = true\n\n#debug 是否开启混淆\nisDebugMinifyEnabled = false\n\n# 每次更改“isModule”的值后，需要点击 \"Sync Project\" 按钮\n# 用户模块\nisLoginModule=false\n# 我的模块\nisMineModule=false\n# 支付模块\nisPayModule=false\n# 课程模块\nisCourseModule=false\n# 商品模块\nisProductModule=false\n#首页模块\nisHomeModule=false\n#相册选择模块\nisPictureSelectModule=false\n\n# 本地maven ，加快编译速度\nlightlearn_module_login_aar_enable=true\nlightlearn_module_mine_aar_enable=true\nlightlearn_module_payment_aar_enable=true\nlightlearn_module_course_aar_enable=false\nlightlearn_module_product_aar_enable=true\nlightlearn_module_home_aar_enable=false\nlightlearn_module_pictureselect_aar_enable=true\n#使用 子module 源码，改为true 使用源码，false使用aar，本地不改代码 建议改为false 使用aar 加快编译速度\nuseModuleSource=true\n\n\nGROUP=com.ks.lightlearn\n\nTINGYUN_SCAN=false\nenableDokit=false\n#dokit全局配置\n#dokit 慢函数开关\nDOKIT_METHOD_SWITCH=true\n#dokit 函数调用栈层级\nDOKIT_METHOD_STACK_LEVEL=4\n#0:默认模式 打印函数调用栈 需添加指定入口  默认为application onCreate 和attachBaseContext\n#1:普通模式 运行时打印某个函数的耗时 全局业务代码函数插入\nDOKIT_METHOD_STRATEGY=1\n\n# maven 库 配置\nNEXUS_USERNAME=admin\nNEXUS_PASSWORD=kaishu2099\nREPOSITORY_URL=http\\://10.0.20.167\\:8081/repository/KsLightLearn/\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593218743},"updatedAt":{"$$date":1598593330547},"_id":"saOgU67auwvBQYBT","folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"css-CSS Float(浮动)","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS Float(浮动)\n什么是 CSS Float（浮动）？\n\n\nCSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。\n\nFloat（浮动），往往是用于图像，但它在布局时一样非常有用。\n\n元素怎样浮动\n元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。\n\n一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。\n\n浮动元素之后的元素将围绕它。\n\n浮动元素之前的元素将不会受到影响。\n\n如果图像是右浮动，下面的文本流将环绕在它左边：\n\n实例\nimg\n{\n    float:right;\n}\n\n尝试一下 »\n\n彼此相邻的浮动元素\n如果你把几个浮动的元素放到一起，如果有空间的话，它们将彼此相邻。\n\n在这里，我们对图片廊使用 float 属性：\n\n实例\n.thumbnail \n{\n    float:left;\n    width:110px;\n    height:90px;\n    margin:5px;\n}\n\n尝试一下 »\n\n清除浮动 - 使用 clear\n元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。\n\nclear 属性指定元素两侧不能出现浮动元素。\n\n使用 clear 属性往文本中添加图片廊：\n\n实例\n.text_line\n{\n    clear:both;\n}\n\n尝试一下 »\n\nExamples\n更多实例\n为图像添加边框和边距并浮动到段落的右侧\n\n让我们为图像添加边框和边距并浮动到段落的右侧\n\n标题和图片向右侧浮动\n\n让标题和图片向右侧浮动。\n\n让段落的第一个字母浮动到左侧\n\n改变样式，让段落的第一个字母浮动到左侧。\n\n创建一个没有表格的网页\n\n使用 float 创建一个网页页眉、页脚、左边的内容和主要内容。\n\nCSS 中所有的浮动属性\n\"CSS\" 列中的数字表示不同的 CSS 版本（CSS1 或 CSS2）定义了该属性。\n\n属性\t描述\t值\tCSS\nclear\t指定不允许元素周围有浮动元素。\tleft\nright\nboth\nnone\ninherit\t1\nfloat\t指定一个盒子（元素）是否可以浮动。\tleft\nright\nnone\ninherit\t"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973607551},"updatedAt":{"$$date":1598973719189},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"scf2sWIvA0t54rZ4"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594973931290},"updatedAt":{"$$date":1594973931290},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"sfHyqeU6rNij316P"}
{"name":"kotlin-函数：infix、vararg、tailrec - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/functions.html\n函数：infix、vararg、tailrec - Kotlin 语言中文站\n20-25 minutes\n改进翻译\nKotlin 中的函数使用 fun 关键字声明：\n\n调用函数使用传统的方法：\n\n调用成员函数使用点表示法：\n\nStream().read() // 创建类 Stream 实例并调用 read()\n函数参数使用 Pascal 表示法定义，即 name: type。参数用逗号隔开。每个参数必须有显式类型：\n\nfun powerOf(number: Int, exponent: Int) { /*……*/ }\n函数参数可以有默认值，当省略相应的参数时使用默认值。与其他语言相比，这可以减少重载数量：\n\nfun read(b: Array<Byte>, off: Int = 0, len: Int = b.size) { /*……*/ }\n默认值通过类型后面的 = 及给出的值来定义。\n\n覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：\n\nopen class A {\n    open fun foo(i: Int = 10) { /*……*/ }\n}\n\nclass B : A() {\n    override fun foo(i: Int) { /*……*/ }  // 不能有默认值\n}\n如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用具名参数调用该函数来使用：\n\nfun foo(bar: Int = 0, baz: Int) { /*……*/ }\n\nfoo(baz = 1) // 使用默认值 bar = 0\n如果在默认参数之后的最后一个参数是 lambda 表达式，那么它既可以作为具名参数在括号内传入，也可以在括号外传入：\n\nfun foo(bar: Int = 0, baz: Int = 1, qux: () -> Unit) { /*……*/ }\n\nfoo(1) { println(\"hello\") }     // 使用默认值 baz = 1\nfoo(qux = { println(\"hello\") }) // 使用两个默认值 bar = 0 与 baz = 1\nfoo { println(\"hello\") }        // 使用两个默认值 bar = 0 与 baz = 1\n可以在调用函数时使用具名的函数参数。当一个函数有大量的参数或默认参数时这会非常方便。\n\n给定以下函数：\n\nfun reformat(str: String,\n             normalizeCase: Boolean = true,\n             upperCaseFirstLetter: Boolean = true,\n             divideByCamelHumps: Boolean = false,\n             wordSeparator: Char = ' ') {\n/*……*/\n}\n我们可以使用默认参数来调用它：\n\n然而，当使用非默认参数调用它时，该调用看起来就像：\n\nreformat(str, true, true, false, '_')\n使用具名参数我们可以使代码更具有可读性：\n\nreformat(str,\n    normalizeCase = true,\n    upperCaseFirstLetter = true,\n    divideByCamelHumps = false,\n    wordSeparator = '_'\n)\n并且如果我们不需要所有的参数：\n\nreformat(str, wordSeparator = '_')\n当一个函数调用混用位置参数与具名参数时，所有位置参数都要放在第一个具名参数之前。例如，允许调用 f(1, y = 2) 但不允许 f(x = 1, 2)。\n\n可以通过使用星号操作符将可变数量参数（vararg） 以具名形式传入：\n\nfun foo(vararg strings: String) { /*……*/ }\n\nfoo(strings = *arrayOf(\"a\", \"b\", \"c\"))\n对于 JVM 平台：在调用 Java 函数时不能使用具名参数语法，因为 Java 字节码并不总是保留函数参数的名称。\n\n如果一个函数不返回任何有用的值，它的返回类型是 Unit。Unit 是一种只有一个值——Unit 的类型。这个值不需要显式返回：\n\nfun printHello(name: String?): Unit {\n    if (name != null)\n        println(\"Hello $name\")\n    else\n        println(\"Hi there!\")\n    // `return Unit` 或者 `return` 是可选的\n}\nUnit 返回类型声明也是可选的。上面的代码等同于：\n\nfun printHello(name: String?) { …… }\n当函数返回单个表达式时，可以省略花括号并且在 = 符号之后指定代码体即可：\n\nfun double(x: Int): Int = x * 2\n当返回值类型可由编译器推断时，显式声明返回类型是可选的：\n\nfun double(x: Int) = x * 2\n具有块代码体的函数必须始终显式指定返回类型，除非他们旨在返回 Unit，在这种情况下它是可选的。 Kotlin 不推断具有块代码体的函数的返回类型，因为这样的函数在代码体中可能有复杂的控制流，并且返回类型对于读者（有时甚至对于编译器）是不明显的。\n\n函数的参数（通常是最后一个）可以用 vararg 修饰符标记：\n\nfun <T> asList(vararg ts: T): List<T> {\n    val result = ArrayList<T>()\n    for (t in ts) // ts is an Array\n        result.add(t)\n    return result\n}\n允许将可变数量的参数传递给函数：\n\nval list = asList(1, 2, 3)\n在函数内部，类型 T 的 vararg 参数的可见方式是作为 T 数组，即上例中的 ts 变量具有类型 Array <out T>。\n\n只有一个参数可以标注为 vararg。如果 vararg 参数不是列表中的最后一个参数， 可以使用具名参数语法传递其后的参数的值，或者，如果参数具有函数类型，则通过在括号外部传一个 lambda。\n\n当我们调用 vararg-函数时，我们可以一个接一个地传参，例如 asList(1, 2, 3)，或者，如果我们已经有一个数组并希望将其内容传给该函数，我们使用伸展（spread）操作符（在数组前面加 *）：\n\nval a = arrayOf(1, 2, 3)\nval list = asList(-1, 0, *a, 4)\n标有 infix 关键字的函数也可以使用中缀表示法（忽略该调用的点与圆括号）调用。中缀函数必须满足以下要求：\n\n它们必须是成员函数或扩展函数；\n它们必须只有一个参数；\n其参数不得接受可变数量的参数且不能有默认值。\ninfix fun Int.shl(x: Int): Int { …… }\n\n// 用中缀表示法调用该函数\n1 shl 2\n\n// 等同于这样\n1.shl(2)\n中缀函数调用的优先级低于算术操作符、类型转换以及 rangeTo 操作符。 以下表达式是等价的：\n\n1 shl 2 + 3 等价于 1 shl (2 + 3)\n0 until n * 2 等价于 0 until (n * 2)\nxs union ys as Set<*> 等价于 xs union (ys as Set<*>)\n另一方面，中缀函数调用的优先级高于布尔操作符 && 与 ||、is- 与 in- 检测以及其他一些操作符。这些表达式也是等价的：\n\na && b xor c 等价于 a && (b xor c)\na xor b in c 等价于 (a xor b) in c\n完整的优先级层次结构请参见其语法参考。\n\n请注意，中缀函数总是要求指定接收者与参数。当使用中缀表示法在当前接收者上调用方法时，需要显式使用 this；不能像常规方法调用那样省略。这是确保非模糊解析所必需的。\n\nclass MyStringCollection {\n    infix fun add(s: String) { /*……*/ }\n    \n    fun build() {\n        this add \"abc\"   // 正确\n        add(\"abc\")       // 正确\n        //add \"abc\"        // 错误：必须指定接收者\n    }\n}\n在 Kotlin 中函数可以在文件顶层声明，这意味着你不需要像一些语言如 Java、C# 或 Scala 那样需要创建一个类来保存一个函数。此外除了顶层函数，Kotlin 中函数也可以声明在局部作用域、作为成员函数以及扩展函数。\n\nKotlin 支持局部函数，即一个函数在另一个函数内部：\n\nfun dfs(graph: Graph) {\n    fun dfs(current: Vertex, visited: MutableSet<Vertex>) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v, visited)\n    }\n\n    dfs(graph.vertices[0], HashSet())\n}\n局部函数可以访问外部函数（即闭包）的局部变量，所以在上例中，visited 可以是局部变量：\n\nfun dfs(graph: Graph) {\n    val visited = HashSet<Vertex>()\n    fun dfs(current: Vertex) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v)\n    }\n\n    dfs(graph.vertices[0])\n}\n成员函数是在类或对象内部定义的函数：\n\nclass Sample {\n    fun foo() { print(\"Foo\") }\n}\n成员函数以点表示法调用：\n\nSample().foo() // 创建类 Sample 实例并调用 foo\n关于类和覆盖成员的更多信息参见类和继承。\n\n函数可以有泛型参数，通过在函数名前使用尖括号指定：\n\nfun <T> singletonList(item: T): List<T> { /*……*/ }\n关于泛型函数的更多信息参见泛型。\n\n内联函数在这里讲述。\n\n扩展函数在其自有章节讲述。\n\n高阶函数和 Lambda 表达式在其自有章节讲述。\n\nKotlin 支持一种称为尾递归的函数式编程风格。 这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 tailrec 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本：\n\nval eps = 1E-10 // \"good enough\", could be 10^-15\n\ntailrec fun findFixPoint(x: Double = 1.0): Double\n        = if (Math.abs(x - Math.cos(x)) < eps) x else findFixPoint(Math.cos(x))\n这段代码计算余弦的不动点（fixpoint of cosine），这是一个数学常数。 它只是重复地从 1.0 开始调用 Math.cos，直到结果不再改变，对于这里指定的 eps 精度会产生 0.7390851332151611 的结果。最终代码相当于这种更传统风格的代码：\n\nval eps = 1E-10 // \"good enough\", could be 10^-15\n\nprivate fun findFixPoint(): Double {\n    var x = 1.0\n    while (true) {\n        val y = Math.cos(x)\n        if (Math.abs(x - y) < eps) return x\n        x = Math.cos(x)\n    }\n}\n要符合 tailrec 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前在 Kotlin for JVM 与 Kotlin/Native 中支持尾递归。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308426153},"updatedAt":{"$$date":1597308634040},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"shI082KPsB0QkH9b"}
{"name":"ad-ks_frame_ijkplayer","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"VERSION_NAME=0.0.0.1-SNAPSHOT\nPOM_ARTIFACT_ID=ijkplayer\nPROJECT_DESC=kaishustory ijkplayer  library\n\n\n\n\n\n\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n\n    testImplementation deps.test.junit\n    testImplementation deps.test.ext_junit\n    androidTestImplementation deps.test.spresso_core\n\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    implementation deps.androidx.core\n    implementation deps.androidx.app_compat\n}\n\napply from: rootProject.file(\"./script/upload_local_maven.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic static void loadLibrariesOnce(IjkLibLoader libLoader) {\n        synchronized (IjkMediaPlayer.class) {\n            if (!mIsLibLoaded) {\n                if (libLoader == null)\n                    libLoader = sLocalLibLoader;\n                libLoader.loadLibrary(\"ijkffmpeg\");\n                libLoader.loadLibrary(\"ijksdl\");\n                libLoader.loadLibrary(\"ijkplayer\");\n                mIsLibLoaded = true;\n            }\n        }\n    }\n\n\n\n\n\n\n\n    public IjkMediaPlayer(IjkLibLoader libLoader) {\n        initPlayer(libLoader);\n        this.setOption(IjkMediaPlayer.OPT_CATEGORY_CODEC, \"skip_loop_filter\", 48);\n        this.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, \"reconnect\", 1);\n        //花哥要求注掉，默认有软解\n//        this.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, \"mediacodec\", 1);\n        this.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, \"framedrop\", 5);\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539550461},"updatedAt":{"$$date":1598542283082},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"skIcUB6qI4unvtN6"}
{"name":"qk-ks_lib_appmerge_plugin","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\napply plugin: 'groovy'\n\ndependencies {\n    compile gradleApi()\n    compile localGroovy()\n    compile 'com.android.tools.build:gradle-api:3.0.0'\n    compile 'org.ow2.asm:asm:5.1'\n    compile 'commons-io:commons-io:2.6'\n}\n\n////这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\nutil\nCompressor\nDecompression\nCmPlugin\nCmTransform\n\n\n\n\n\n\n\n\nclass CmPlugin implements Plugin<Project> {\n\n    @Override\n    void apply(Project project) {\n        project.android.registerTransform(new CmTransform(project))\n    }\n}\n\n\n\n\n\n\n\n\n\n\nclass CmTransform extends Transform {\n\n    Project mProject\n\n    static Logger logger\n\n    /**\n     * Classes annotated with @ModuleSpec\n     */\n    def moduleApplications = new ArrayList<AnnotationModuleSpec>()\n    /**\n     * Classes annotated with @AppSpec\n     */\n    def appApplications = [:]\n\n    /**\n     * The AppJoint class File\n     */\n    def appJointClassFile\n\n    /*\n     * The modified AppJoint class File\n     */\n    File appJointOutputFile\n\n    public static final String SERVICE_PROVIDER_DEFAULT_NAME = \"__cm_core_default\"\n\n    public static final int MODULE_SPEC_DEFAULT_PRIORITY = 1000\n\n    CmTransform(Project project) {\n        mProject = project\n        logger = mProject.logger\n    }\n\n    @Override\n    String getName() {\n        return \"appMerge\"\n    }\n\n    @Override\n    Set<QualifiedContent.ContentType> getInputTypes() {\n        return Collections.singleton(QualifiedContent.DefaultContentType.CLASSES)\n    }\n\n    @Override\n    Set<? super QualifiedContent.Scope> getScopes() {\n        return Sets.immutableEnumSet(\n                QualifiedContent.Scope.PROJECT,\n                QualifiedContent.Scope.SUB_PROJECTS,\n                QualifiedContent.Scope.EXTERNAL_LIBRARIES\n        )\n    }\n\n    @Override\n    boolean isIncremental() {\n        return true\n    }\n\n    @Override\n    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {\n\n        logger.quiet '================================ appmerge   start  ================================'\n        def startTime = System.currentTimeMillis()\n\n        // Maybe contains the AppJoint class to write code into\n        def maybeStubs = []\n        // Maybe contains @ModuleSpec, @AppSpec or @ServiceProvider\n        def maybeModules = []\n\n        transformInvocation.inputs.each { input ->\n            // Find annotated classes in jar\n            input.jarInputs.each { jarInput ->\n                if (!jarInput.file.exists()) return\n                logger.info(\"jar input:\" + jarInput.file.getAbsolutePath())\n                logger.info(\"jar name:\" + jarInput.name)\n\n                def jarName = jarInput.name\n\n                if (jarName == \":core\") {\n                    // maybe stub in dev and handle them later\n                    if (maybeStubs.size() == 0) {\n                        maybeStubs.add(jarInput)\n                    }\n                    // maybe submodule, ':core' could be user's business module\n                    maybeModules.add(jarInput)\n                } else if (jarName.startsWith(\":\")) {\n                    // maybe submodule\n                    maybeModules.add(jarInput)\n                } else if (jarName.startsWith(\"com.ks.kotlin:ks-lib-appmerge\")) {\n                    // find the stub\n                    maybeStubs.clear()\n                    maybeStubs.add(jarInput)\n                } else {\n                    // normal jars, just copy it to destination\n                    def dest = transformInvocation.outputProvider.getContentLocation(jarName, jarInput.contentTypes, jarInput.scopes, Format.JAR)\n                    logger.info(\"jar output path:\" + dest.getAbsolutePath())\n                    FileUtils.copyFile(jarInput.file, dest)\n                }\n            }\n\n            // Find annotated classes in dir\n            input.directoryInputs.each { dirInput ->\n                logger.info(\"dirInput.file :\" + dirInput.file)\n\n                def outDir = transformInvocation.outputProvider.getContentLocation(dirInput.name, dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY)\n                // dirInput.file is like \"build/intermediates/classes/debug\"\n                int pathBitLen = dirInput.file.toString().length()\n\n                def callback = { File it ->\n                    if (it.exists()) {\n                        def path = \"${it.toString().substring(pathBitLen)}\"\n                        if (it.isDirectory()) {\n                            new File(outDir, path).mkdirs()\n                        } else {\n                            def output = new File(outDir, path)\n                            findAnnotatedClasses(it, output)\n                            if (!output.parentFile.exists()) output.parentFile.mkdirs()\n                            output.bytes = it.bytes\n                        }\n                    }\n                }\n\n                if (dirInput.changedFiles != null && !dirInput.changedFiles.isEmpty()) {\n                    dirInput.changedFiles.keySet().each(callback)\n                }\n                if (dirInput.file != null && dirInput.file.exists()) {\n                    dirInput.file.traverse(callback)\n                }\n            }\n        }\n\n        def repackageActions = []\n\n        // Inside submodules, find class annotated with\n        // @ModuleSpec, @AppSpec or @ServiceProvider\n        maybeModules.each { JarInput jarInput ->\n            def repackageAction = traversalJar(\n                    transformInvocation,\n                    jarInput,\n                    { File outputFile, File input -> return findAnnotatedClasses(input, outputFile) }\n            )\n            if (repackageAction) repackageActions.add(repackageAction)\n        }\n\n        // Inside local ':core' Module or remote app-joint dependency,\n        // find the AppJoint class in jars\n        maybeStubs.each { JarInput jarInput ->\n            def repackageAction = traversalJar(\n                    transformInvocation,\n                    jarInput,\n                    { File outputFile, File input -> return findAppJointClass(input, outputFile) }\n            )\n            if (repackageAction) repackageActions.add(repackageAction)\n        }\n\n        logger.info(\"moduleApplications: $moduleApplications\")\n        logger.info(\"appApplications: $appApplications\")\n        logger.info(\"appJointClassFile: $appJointClassFile\")\n        logger.info(\"appJointOutputFile: $appJointOutputFile\")\n        logger.info(\"repackageActions: ${repackageActions.size()}\")\n\n        if (appJointClassFile == null) {\n            throw new RuntimeException(\"CmCore class file not found, please check \\\"com.ks.kotlin:ks-lib-appmerge:{latest_version}\\\" is in your dependency graph.\")\n        }\n\n        // Insert code to AppJoint class\n        def inputStream = new FileInputStream(appJointClassFile)\n        ClassReader cr = new ClassReader(inputStream)\n        ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS)\n        ClassVisitor classVisitor = new AppJointClassVisitor(cw)\n        cr.accept(classVisitor, 0)\n        appJointOutputFile.bytes = cw.toByteArray()\n        inputStream.close()\n\n        // Insert code to Application of App\n        appApplications.each { File classFile, File output ->\n            inputStream = new FileInputStream(classFile)\n            ClassReader reader = new ClassReader(inputStream)\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS)\n            ClassVisitor visitor = new ApplicationClassVisitor(writer)\n\n            reader.accept(visitor, 0)\n            output.bytes = writer.toByteArray()\n            inputStream.close()\n        }\n\n        // After all class modifications are done, repackage all deferred jar repackage\n        repackageActions.each { Closure action -> action.call() }\n\n        def cost = System.currentTimeMillis() - startTime\n\n        logger.quiet \"appmerge-plugin cost $cost ms\"\n\n        logger.quiet '================================ appmerge   end  ================================'\n    }\n\n    // Visit and change the AppJoint Class\n    class AppJointClassVisitor extends ClassVisitor {\n\n        AppJointClassVisitor(ClassVisitor cv) {\n            super(Opcodes.ASM5, cv)\n        }\n\n        @Override\n        MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n            MethodVisitor methodVisitor = super.visitMethod(access, name, desc, signature, exceptions)\n            logger.info(\"visiting method: $access, $name, $desc, $signature, $exceptions\")\n            if (access == 2 && name == \"<init>\" && desc == \"()V\") {\n                return new AddCodeToConstructorVisitor(methodVisitor)\n            }\n            return methodVisitor;\n        }\n    }\n\n    class AddCodeToConstructorVisitor extends MethodVisitor {\n\n        AddCodeToConstructorVisitor(MethodVisitor mv) {\n            super(Opcodes.ASM5, mv)\n        }\n\n        @Override\n        void visitInsn(int opcode) {\n            switch (opcode) {\n                case Opcodes.IRETURN:\n                case Opcodes.FRETURN:\n                case Opcodes.ARETURN:\n                case Opcodes.LRETURN:\n                case Opcodes.DRETURN:\n                case Opcodes.RETURN:\n                    moduleApplications.sort { a, b -> a.order <=> b.order }\n                    for (int i = 0; i < moduleApplications.size(); i++) {\n                        logger.info(\"insertApplicationAdd order:${moduleApplications[i].order} className:${moduleApplications[i].className}\")\n                        insertApplicationAdd(moduleApplications[i].className)\n                    }\n                    break\n            }\n            super.visitInsn(opcode)\n        }\n\n        /**\n         * add \"moduleApplications.add(new Application())\" statement\n         * @param applicationName internal name like \"android/app/Application\"\n         */\n        void insertApplicationAdd(String applicationName) {\n            mv.visitVarInsn(Opcodes.ALOAD, 0)\n            mv.visitFieldInsn(Opcodes.GETFIELD, \"me/cangming/CmCore\", \"moduleApplications\", \"Ljava/util/List;\")\n            mv.visitTypeInsn(Opcodes.NEW, applicationName)\n            mv.visitInsn(Opcodes.DUP)\n            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, applicationName, \"<init>\", \"()V\", false)\n            mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java/util/List\", \"add\", \"(Ljava/lang/Object;)Z\", true)\n            mv.visitInsn(Opcodes.POP)\n        }\n\n        void insertRoutersPut(Tuple2<String, String> router, String impl) {\n            mv.visitVarInsn(Opcodes.ALOAD, 0)\n            mv.visitFieldInsn(Opcodes.GETFIELD, \"me/cangming/CmCore\", \"routersMap\",\n                    \"Lme/cangming/util/BinaryKeyMap;\")\n            mv.visitLdcInsn(Type.getObjectType(router.first))\n            mv.visitLdcInsn(router.second)\n            mv.visitLdcInsn(Type.getObjectType(impl))\n            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"me/cangming/util/BinaryKeyMap\",\n                    \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V\", true)\n        }\n    }\n\n    // Visit and change the classes annotated with @Modules annotation\n    class ApplicationClassVisitor extends ClassVisitor {\n\n        boolean onCreateDefined\n        boolean attachBaseContextDefined\n        boolean onConfigurationChangedDefined\n        boolean onLowMemoryDefined\n        boolean onTerminateDefined\n        boolean onTrimMemoryDefined\n\n\n        ApplicationClassVisitor(ClassVisitor cv) {\n            super(Opcodes.ASM5, cv)\n        }\n\n        @Override\n        MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n            MethodVisitor methodVisitor = super.visitMethod(access, name, desc, signature, exceptions)\n            logger.info(\"visiting method: $access, $name, $desc, $signature, $exceptions\")\n            switch (name + desc) {\n                case \"onCreate()V\":\n                    onCreateDefined = true\n                    return new AddCallAppJointMethodVisitor(methodVisitor, \"onCreate\", \"()V\", false, false)\n                case \"attachBaseContext(Landroid/content/Context;)V\":\n                    attachBaseContextDefined = true\n                    return new AddCallAppJointMethodVisitor(methodVisitor, \"attachBaseContext\", \"(Landroid/content/Context;)V\", true, false)\n                case \"onConfigurationChanged(Landroid/content/res/Configuration;)V\":\n                    onConfigurationChangedDefined = true\n                    return new AddCallAppJointMethodVisitor(methodVisitor, \"onConfigurationChanged\", \"(Landroid/content/res/Configuration;)V\", true, false)\n                case \"onLowMemory()V\":\n                    onLowMemoryDefined = true\n                    return new AddCallAppJointMethodVisitor(methodVisitor, \"onLowMemory\", \"()V\", false, false)\n                case \"onTerminate()V\":\n                    onTerminateDefined = true\n                    return new AddCallAppJointMethodVisitor(methodVisitor, \"onTerminate\", \"()V\", false, false)\n                case \"onTrimMemory(I)V\":\n                    onTrimMemoryDefined = true\n                    return new AddCallAppJointMethodVisitor(methodVisitor, \"onTrimMemory\", \"(I)V\", false, true)\n\n            }\n            return methodVisitor\n        }\n\n        @Override\n        void visitEnd() {\n            if (!attachBaseContextDefined) {\n                defineMethod(4, \"attachBaseContext\", \"(Landroid/content/Context;)V\", true, false)\n            }\n            if (!onCreateDefined) {\n                defineMethod(1, \"onCreate\", \"()V\", false, false)\n            }\n            if (!onConfigurationChangedDefined) {\n                defineMethod(1, \"onConfigurationChanged\", \"(Landroid/content/res/Configuration;)V\", true, false)\n            }\n            if (!onLowMemoryDefined) {\n                defineMethod(1, \"onLowMemory\", \"()V\", false, false)\n            }\n            if (!onTerminateDefined) {\n                defineMethod(1, \"onTerminate\", \"()V\", false, false)\n            }\n            if (!onTrimMemoryDefined) {\n                defineMethod(1, \"onTrimMemory\", \"(I)V\", false, true)\n            }\n            super.visitEnd()\n        }\n\n        void defineMethod(int access, String name, String desc, boolean aLoad1, boolean iLoad1) {\n            MethodVisitor methodVisitor = this.visitMethod(access, name, desc, null, null)\n            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0)\n            if (aLoad1) {\n                methodVisitor.visitVarInsn(Opcodes.ALOAD, 1)\n            }\n            if (iLoad1) {\n                methodVisitor.visitVarInsn(Opcodes.ILOAD, 1)\n            }\n            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, \"android/app/Application\", name, desc, false)\n            methodVisitor.visitInsn(Opcodes.RETURN)\n            methodVisitor.visitEnd()\n        }\n    }\n\n    class AddCallAppJointMethodVisitor extends MethodVisitor {\n\n        String name\n        String desc\n        boolean aLoad1\n        boolean iLoad1\n\n        AddCallAppJointMethodVisitor(MethodVisitor mv, String name, String desc, boolean aLoad1, boolean iLoad1) {\n            super(Opcodes.ASM5, mv)\n            this.name = name\n            this.desc = desc\n            this.aLoad1 = aLoad1\n            this.iLoad1 = iLoad1\n        }\n\n        void visitInsn(int opcode) {\n            switch (opcode) {\n                case Opcodes.IRETURN:\n                case Opcodes.FRETURN:\n                case Opcodes.ARETURN:\n                case Opcodes.LRETURN:\n                case Opcodes.DRETURN:\n                case Opcodes.RETURN:\n                    mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"me/cangming/CmCore\", \"get\", \"()Lme/cangming/CmCore;\", false)\n                    if (aLoad1) {\n                        mv.visitVarInsn(Opcodes.ALOAD, 1)\n                    }\n                    if (iLoad1) {\n                        mv.visitVarInsn(Opcodes.ILOAD, 1)\n                    }\n                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"me/cangming/CmCore\", name, desc, false)\n                    break\n            }\n            super.visitInsn(opcode)\n        }\n    }\n\n    /**\n     * Find the AppJoint class, this method doesn't change the class file\n     * @param file : the class file to be checked\n     * @param outputFile : where the modified class should be output to\n     * @return whether the file is AppJoint class file\n     */\n    boolean findAppJointClass(File file, File outputFile) {\n        if (!file.exists() || !file.name.endsWith(\".class\")) {\n            return\n        }\n        boolean found = false;\n        def inputStream = new FileInputStream(file)\n        ClassReader cr = new ClassReader(inputStream)\n        cr.accept(new ClassVisitor(Opcodes.ASM5) {\n            @Override\n            void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n                super.visit(version, access, name, signature, superName, interfaces)\n                if (name == \"me/cangming/CmCore\") {\n                    appJointClassFile = file\n                    appJointOutputFile = outputFile\n                    found = true\n                }\n            }\n        }, 0)\n        inputStream.close()\n        return found\n    }\n\n    /**\n     * Check @ModuleSpec, @AppSpec, @ServiceProvider existence\n     * doesn't change any class file\n     *\n     * @param file : the file to be checked\n     * @param output : the class modification output path, if it needs\n     * @return whether this class needs to be modify\n     */\n    boolean findAnnotatedClasses(File file, File output) {\n        if (!file.exists() || !file.name.endsWith(\".class\")) {\n            return\n        }\n        def needsModification = false\n        def inputStream = new FileInputStream(file)\n        ClassReader cr = new ClassReader(inputStream)\n        cr.accept(new ClassVisitor(Opcodes.ASM5) {\n            static class AnnotationMethodsVisitor extends AnnotationVisitor {\n\n                AnnotationMethodsVisitor() {\n                    super(Opcodes.ASM5)\n                }\n\n                @Override\n                void visit(String name, Object value) {\n                    logger.info(\"Annotation value: name=$name value=$value\")\n                    super.visit(name, value)\n                }\n            }\n\n            @Override\n            AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n                logger.info(\"visiting $desc\")\n                switch (desc) {\n                    case \"Lme/cangming/core/ModuleSpec;\":\n                        addModuleApplication(new AnnotationModuleSpec(cr.className))\n                        return new AnnotationMethodsVisitor() {\n                            @Override\n                            void visit(String name, Object value) {\n                                def moduleApplication = moduleApplications.find({\n                                    it.className == cr.className\n                                })\n                                if (moduleApplication) {\n                                    moduleApplication.order = Integer.valueOf(value)\n                                }\n                                super.visit(name, value)\n                            }\n                        }\n                    case \"Lme/cangming/core/AppSpec;\":\n                        appApplications[file] = output\n                        needsModification = true\n                        break\n                }\n                return super.visitAnnotation(desc, visible)\n            }\n        }, 0)\n        inputStream.close()\n        return needsModification\n    }\n\n    private void addModuleApplication(AnnotationModuleSpec annotationOrder) {\n        for (int i = 0; i < moduleApplications.size(); i++) {\n            if (annotationOrder.className == moduleApplications.get(i).className) {\n                // the module application class ready to be added is already marked\n                return\n            }\n        }\n        moduleApplications.add(annotationOrder)\n    }\n\n    class AnnotationModuleSpec {\n        private int order = MODULE_SPEC_DEFAULT_PRIORITY\n        private String className\n\n        AnnotationModuleSpec(String className) {\n            this.className = className\n        }\n\n        @Override\n        String toString() {\n            return String.format(\"{className=%s, order=%s}\", className, String.valueOf(order))\n        }\n    }\n    /**\n     * Unzip jarInput, traversal all files, do something, and repackage it back to jar(Optional)\n     * @param transformInvocation From Transform Api\n     * @param jarInput From Transform Api\n     * @param closure something you wish to do while traversal, return true if you want to repackage later\n     * @return repackage action if you return true in closure, null if you return false in every traversal\n     */\n    static Closure traversalJar(TransformInvocation transformInvocation, JarInput jarInput, Closure closure) {\n        def jarName = jarInput.name\n\n        File unzipDir = new File(\n                jarInput.file.getParent(),\n                jarName.replace(\":\", \"\") + \"_unzip\")\n        if (unzipDir.exists()) {\n            unzipDir.delete()\n        }\n        unzipDir.mkdirs()\n        Decompression.uncompress(jarInput.file, unzipDir)\n\n        File repackageFolder = new File(\n                jarInput.file.getParent(),\n                jarName.replace(\":\", \"\") + \"_repackage\"\n        )\n\n        FileUtils.copyDirectory(unzipDir, repackageFolder)\n\n        boolean repackageLater = false\n        unzipDir.eachFileRecurse(FileType.FILES, { File it ->\n            File outputFile = new File(repackageFolder, it.absolutePath.split(\"_unzip\")[1])\n            boolean result = closure.call(outputFile, it)\n            if (result) repackageLater = true\n        })\n\n        def repackageAction = {\n            def dest = transformInvocation.outputProvider.getContentLocation(\n                    jarName, jarInput.contentTypes, jarInput.scopes, Format.JAR)\n            Compressor zc = new Compressor(dest.getAbsolutePath())\n            zc.compress(repackageFolder.getAbsolutePath())\n        }\n\n        if (!repackageLater) {\n            repackageAction.call()\n        } else {\n            return repackageAction\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598584066704},"updatedAt":{"$$date":1598584590595},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"sp7APAU3YiESe3yb"}
{"name":"html-","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887698257},"updatedAt":{"$$date":1598887698257},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ssFZ5u1eR71Yim76"}
{"name":"qklib- 项目","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    ext.kotlin_version = '1.3.61'\n\n    apply from: 'dependencies.gradle'\n    apply from: 'ks_kotlin_lib_versions.gradle'\n    ext {\n        // 是否上传 Jcenter\n        upLoadJcenterFlag = false\n        //这个不要改，本地 想调试就改false，但是不要提交这个。\n        // true 的时候 其他有的工程依赖是本地依赖，这样上传到maven 会报找不到版本的bug\n        develop = false\n    }\n    repositories {\n\n        google()\n        jcenter()\n\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.5.3'\n        classpath project_plugin.kotlin_plugin\n        classpath 'com.github.dcendents:android-maven-gradle-plugin:2.1'\n        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.4'\n        classpath 'com.kezong:fat-aar:1.2.8'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n//        classpath \"me.cangming.gitplugin:git-plugin:1.0.0-SNAPSHOT\"\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n        maven { url \"https://www.jitpack.io\" }\n        maven {\n            url(\"http://10.0.20.167:8081/repository/ks_kt_lib_public/\")\n        }\n\n        maven{url \"http://10.0.20.167:8081/repository/kaishustory/\"}\n\n        flatDir {\n            dirs 'libs'\n        }\n\n        maven { url 'https://dl.bintray.com/kaishustory/maven' }\n\n        maven { url 'https://dl.bintray.com/umsdk/release' }\n\n    }\n}\n\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\n\nconfigurations.all {\n    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'\n}\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580884305},"updatedAt":{"$$date":1598581009716},"_id":"su25PXmyj8Zbu2uV","folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"html-HTML 基础- 4个实例","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n不要担心本章中您还没有学过的例子。\n\n您将在下面的章节中学到它们。\n\nHTML 标题\nHTML 标题（Heading）是通过<h1> - <h6> 标签来定义的。\n\n实例\n<h1>这是一个标题</h1>\n<h2>这是一个标题</h2>\n<h3>这是一个标题</h3>\n\n尝试一下 »\n\nHTML 段落\nHTML 段落是通过标签 <p> 来定义的。\n\n实例\n<p>这是一个段落。</p>\n<p>这是另外一个段落。</p>\n\n尝试一下 »\n\nHTML 链接\nHTML 链接是通过标签 <a> 来定义的。\n\n实例\n<a href=\"https://www.runoob.com\">这是一个链接</a>\n\n尝试一下 »\n提示:在 href 属性中指定链接的地址。\n\n(您将在本教程稍后的章节中学习更多有关属性的知识)。\n\nHTML 图像\nHTML 图像是通过标签 <img> 来定义的.\n\n实例\n<img src=\"/images/logo.png\" width=\"258\" height=\"39\" />\n\n尝试一下 »\n注意： 图像的名称和尺寸是以属性的形式提供的。\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885692069},"updatedAt":{"$$date":1598885885435},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"sw7rJH7KHinHydPR"}
{"name":"ad-demovideo","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion 21\n        targetSdkVersion build_versions.target_sdk\n        versionCode build_versions.versionCode\n        versionName build_versions.versionName\n\n        multiDexEnabled true\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n    splits {\n        abi {\n            enable true\n            reset()\n            include 'armeabi-v7a'\n            universalApk false\n        }\n    }\n\n\n    //这个是解决lint报错的代码\n    lintOptions {\n        abortOnError false\n    }\n\n\n    dexOptions {\n        preDexLibraries = false\n        //incremental true\n        javaMaxHeapSize \"4g\"\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\n\n\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n    implementation 'androidx.core:core-ktx:1.3.1'\n    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n\n    api 'com.facebook.fresco:fresco:2.2.0'\n    //implementation 'om.facebook.fresco:webpsupport:1.3.0'\n    // http\n    api 'com.facebook.fresco:imagepipeline-okhttp3:2.2.0'\n    api 'com.facebook.fresco:animated-webp:2.2.0'\n    api 'com.facebook.fresco:animated-gif:2.2.0'\n\n    compileOnly deps.androidx.app_compat\n    compileOnly deps.androidx.recyclerview_v7\n\n\n\n//    api project(':ks_recored_video')\n//    api project(':ks_recored_video')\n//    api project(':ks_media_preview')\n\n    if(rootProject.ext.isUseMediaModle) {\n        api project(':ks_media_wrap')\n    }else {\n        api ks.mediawrap\n    }\n   // api project(':ks_media_wrap')\n    implementation deps.androidx.multidex\n\n    api 'com.github.bumptech.glide:glide:4.11.0'\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'\n    api \"com.github.bumptech.glide:okhttp3-integration:4.11.0\"\n\n\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598525724810},"updatedAt":{"$$date":1598537912899},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"t0LRbf0tzQqeJd0L"}
{"name":"andr-LiveData 概览  ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/architecture/livedata\nLiveData 概览  |  Android 开发者  |  Android Developers\n15-18 minutes\nLiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。\n\n如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。LiveData 只会将更新通知给活跃的观察者。为观察 LiveData 对象而注册的非活跃观察者不会收到更改通知。\n\n您可以注册与实现 LifecycleOwner 接口的对象配对的观察者。有了这种关系，当相应的 Lifecycle 对象的状态变为 DESTROYED 时，便可移除此观察者。 这对于 Activity 和 Fragment 特别有用，因为它们可以放心地观察 LiveData 对象而不必担心泄露（当 Activity 和 Fragment 的生命周期被销毁时，系统会立即退订它们）。\n\n要详细了解如何使用 LiveData，请参阅使用 LiveData 对象。\n\n使用 LiveData 的优势\n使用 LiveData 具有以下优势：\n\n确保界面符合数据状态\nLiveData 遵循观察者模式。当生命周期状态发生变化时，LiveData 会通知 Observer 对象。您可以整合代码以在这些 Observer 对象中更新界面。观察者可以在每次发生更改时更新界面，而不是在每次应用数据发生更改时更新界面。\n不会发生内存泄漏\n观察者会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。\n不会因 Activity 停止而导致崩溃\n如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。\n不再需要手动处理生命周期\n界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。\n数据始终保持最新状态\n如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。\n适当的配置更改\n如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。\n共享资源\n您可以使用单一实例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。如需了解详情，请参阅扩展 LiveData。\n使用 LiveData 对象\n请按照以下步骤使用 LiveData 对象：\n\n创建 LiveData 实例以存储某种类型的数据。这通常在 ViewModel 类中完成。\n创建可定义 onChanged() 方法的 Observer 对象，该方法可以控制当 LiveData 对象存储的数据更改时会发生什么。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中创建 Observer 对象。\n使用 observe() 方法将 Observer 对象附加到 LiveData 对象。observe() 方法会采用 LifecycleOwner 对象。这样会使 Observer 对象订阅 LiveData 对象，以使其收到有关更改的通知。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中附加 Observer 对象。\n\n当您更新存储在 LiveData 对象中的值时，它会触发所有已注册的观察者（只要附加的 LifecycleOwner 处于活跃状态）。\n\nLiveData 允许界面控制器观察者订阅更新。当 LiveData 对象存储的数据发生更改时，界面会自动更新以做出响应。\n\n创建 LiveData 对象\nLiveData 是一种可用于任何数据的封装容器，其中包括可实现 Collections 的对象，如 List。LiveData 对象通常存储在 ViewModel 对象中，并可通过 getter 方法进行访问，如以下示例中所示：\n\n    class NameViewModel : ViewModel() {// Create a LiveData with a String\n        val currentName: MutableLiveData<String> by lazy {\n            MutableLiveData<String>()\n        }// Rest of the ViewModel...\n    }\n    \n    public class NameViewModel extends ViewModel {// Create a LiveData with a String\n    private MutableLiveData<String> currentName;\n    public MutableLiveData<String> getCurrentName() {\n            if (currentName == null) {\n                currentName = new MutableLiveData<String>();\n            }\n            return currentName;\n        }// Rest of the ViewModel...\n    }\n    \n最初，LiveData 对象中的数据并未经过设置。\n\n您可以在 ViewModel 指南中详细了解 ViewModel 类的好处和用法。\n\n观察 LiveData 对象\n在大多数情况下，应用组件的 onCreate() 方法是开始观察 LiveData 对象的正确着手点，原因如下：\n\n确保系统不会从 Activity 或 Fragment 的 onResume() 方法进行冗余调用。\n确保 Activity 或 Fragment 变为活跃状态后具有可以立即显示的数据。一旦应用组件处于 STARTED 状态，就会从它正在观察的 LiveData 对象接收最新值。只有在设置了要观察的 LiveData 对象时，才会发生这种情况。\n通常，LiveData 仅在数据发生更改时才发送更新，并且仅发送给活跃观察者。此行为的一种例外情况是，观察者从非活跃状态更改为活跃状态时也会收到更新。此外，如果观察者第二次从非活跃状态更改为活跃状态，则只有在自上次变为活跃状态以来值发生了更改时，它才会收到更新。\n\n以下示例代码说明了如何开始观察 LiveData 对象：\n\n    class NameActivity : AppCompatActivity() {// Use the 'by viewModels()' Kotlin property delegate\n        // from the activity-ktx artifact\n        private val model: NameViewModel by viewModels()override fun onCreate(savedInstanceState: Bundle?) {\n            super.onCreate(savedInstanceState)// Other code to setup the activity...// Create the observer which updates the UI.\n            val nameObserver = Observer<String> { newName ->\n                // Update the UI, in this case, a TextView.\n                nameTextView.text = newName\n            }// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.\n            model.currentName.observe(this, nameObserver)\n        }\n    }\n    \n    public class NameActivity extends AppCompatActivity {private NameViewModel model;@Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);// Other code to setup the activity...// Get the ViewModel.\n            model = new ViewModelProvider(this).get(NameViewModel.class);// Create the observer which updates the UI.\n            final Observer<String> nameObserver = new Observer<String>() {\n                @Override\n                public void onChanged(@Nullable final String newName) {\n                    // Update the UI, in this case, a TextView.\n                    nameTextView.setText(newName);\n                }\n            };// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.\n            model.getCurrentName().observe(this, nameObserver);\n        }\n    }\n    \n在传递 nameObserver 参数的情况下调用 observe() 后，系统会立即调用 onChanged()，从而提供 mCurrentName 中存储的最新值。如果 LiveData 对象尚未在 mCurrentName 中设置值，则不会调用 onChanged()。\n\n更新 LiveData 对象\nLiveData 没有公开可用的方法来更新存储的数据。MutableLiveData 类将公开 setValue(T) 和 postValue(T) 方法，如果您需要修改存储在 LiveData 对象中的值，则必须使用这些方法。通常情况下会在 ViewModel 中使用 MutableLiveData，然后 ViewModel 只会向观察者公开不可变的 LiveData 对象。\n\n设置观察者关系后，您可以更新 LiveData 对象的值（如以下示例中所示），这样当用户点按某个按钮时会触发所有观察者：\n\n    button.setOnClickListener {\n        val anotherName = \"John Doe\"\n        model.currentName.setValue(anotherName)\n    }\n    \n    button.setOnClickListener(new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            String anotherName = \"John Doe\";\n            model.getCurrentName().setValue(anotherName);\n        }\n    });\n    \n在本例中调用 setValue(T) 导致观察者使用值 John Doe 调用其 onChanged() 方法。本例中演示的是按下按钮的方法，但也可以出于各种各样的原因调用 setValue() 或 postValue() 来更新 mName，这些原因包括响应网络请求或数据库加载完成。在所有情况下，调用 setValue() 或 postValue() 都会触发观察者并更新界面。\n\n将 LiveData 与 Room 一起使用\nRoom 持久性库支持返回 LiveData 对象的可观察查询。可观察查询属于数据库访问对象 (DAO) 的一部分。\n\n当数据库更新时，Room 会生成更新 LiveData 对象所需的所有代码。在需要时，生成的代码会在后台线程上异步运行查询。此模式有助于使界面中显示的数据与存储在数据库中的数据保持同步。您可以在 Room 持久性库指南中详细了解 Room 和 DAO。\n\n将协程与 LiveData 一起使用\nLiveData 支持 Kotlin 协程。如需了解详情，请参阅将 Kotlin 协程与 Android 架构组件一起使用。\n\n扩展 LiveData\n如果观察者的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。以下示例代码说明了如何扩展 LiveData 类：\n\n    class StockLiveData(symbol: String) : LiveData<BigDecimal>() {\n        private val stockManager = StockManager(symbol)private val listener = { price: BigDecimal ->\n            value = price\n        }override fun onActive() {\n            stockManager.requestPriceUpdates(listener)\n        }override fun onInactive() {\n            stockManager.removeUpdates(listener)\n        }\n    }\n    \n    public class StockLiveData extends LiveData<BigDecimal> {\n        private StockManager stockManager;private SimplePriceListener listener = new SimplePriceListener() {\n            @Override\n            public void onPriceChanged(BigDecimal price) {\n                setValue(price);\n            }\n        };public StockLiveData(String symbol) {\n            stockManager = new StockManager(symbol);\n        }@Override\n        protected void onActive() {\n            stockManager.requestPriceUpdates(listener);\n        }@Override\n        protected void onInactive() {\n            stockManager.removeUpdates(listener);\n        }\n    }\n    \n本例中的价格监听器实现包括以下重要方法：\n\n当 LiveData 对象具有活跃观察者时，会调用 onActive() 方法。这意味着，您需要从此方法开始观察股价更新。\n当 LiveData 对象没有任何活跃观察者时，会调用 onInactive() 方法。由于没有观察者在监听，因此没有理由与 StockManager 服务保持连接。\nsetValue(T) 方法将更新 LiveData 实例的值，并将更改通知给任何活跃观察者。\n您可以使用 StockLiveData 类，如下所示：\n\n    public class MyFragment : Fragment() {\n        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            val myPriceListener: LiveData<BigDecimal> = ...\n            myPriceListener.observe(viewLifecycleOwner, Observer<BigDecimal> { price: BigDecimal? ->\n                // Update the UI.\n            })\n        }\n    }\n    \n    public class MyFragment extends Fragment {\n        @Override\n        public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n            super.onViewCreated(view, savedInstanceState);\n            LiveData<BigDecimal> myPriceListener = ...;\n            myPriceListener.observe(getViewLifeycleOwner(), price -> {\n                // Update the UI.\n            });\n        }\n    }\n    \nobserve() 方法将与 Fragment 视图关联的 LifecycleOwner 作为第一个参数传递。这样做表示此观察者已绑定到与所有者关联的 Lifecycle 对象，这意味着：\n\n如果 Lifecycle 对象未处于活跃状态，那么即使值发生更改，也不会调用观察者。\n销毁 Lifecycle 对象后，会自动移除观察者。\nLiveData 对象具有生命周期感知能力，这一事实意味着您可以在多个 Activity、Fragment 和 Service 之间共享这些对象。为使示例保持简单，您可以将 LiveData 类实现为单一实例，如下所示：\n\n    class StockLiveData(symbol: String) : LiveData<BigDecimal>() {\n        private val stockManager: StockManager = StockManager(symbol)private val listener = { price: BigDecimal ->\n            value = price\n        }override fun onActive() {\n            stockManager.requestPriceUpdates(listener)\n        }override fun onInactive() {\n            stockManager.removeUpdates(listener)\n        }companion object {\n            private lateinit var sInstance: StockLiveData@MainThread\n            fun get(symbol: String): StockLiveData {\n                sInstance = if (::sInstance.isInitialized) sInstance else StockLiveData(symbol)\n                return sInstance\n            }\n        }\n    }\n    \n    public class StockLiveData extends LiveData<BigDecimal> {\n        private static StockLiveData sInstance;\n        private StockManager stockManager;private SimplePriceListener listener = new SimplePriceListener() {\n            @Override\n            public void onPriceChanged(BigDecimal price) {\n                setValue(price);\n            }\n        };\n        @MainThread\n        public static StockLiveData get(String symbol) {\n            if (sInstance == null) {\n                sInstance = new StockLiveData(symbol);\n            }\n            return sInstance;\n        }\n        \n        private StockLiveData(String symbol) {\n            stockManager = new StockManager(symbol);\n        }\n        \n        @Override\n        protected void onActive() {\n            stockManager.requestPriceUpdates(listener);\n        }\n        \n        @Override\n        protected void onInactive() {\n            stockManager.removeUpdates(listener);\n        }\n    }\n    \n并且您可以在 Fragment 中使用它，如下所示：\n\n    class MyFragment : Fragment() {override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            StockLiveData.get(symbol).observe(viewLifecycleOwner, Observer<BigDecimal> { price: BigDecimal? ->\n                // Update the UI.\n            })}\n    \n    public class MyFragment extends Fragment {\n        @Override\n        public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n            super.onViewCreated(view, savedInstanceState);\n            StockLiveData.get(symbol).observe(getViewLifecycleOwner(), price -> {\n                // Update the UI.\n            });\n        }\n    }\n    \n多个 Fragment 和 Activity 可以观察 MyPriceListener 实例。仅当一个或多个系统服务可见且处于活跃状态时，LiveData 才会连接到该服务。\n\n转换 LiveData\n您可能希望在将 LiveData 对象分派给观察者之前对存储在其中的值进行更改，或者您可能需要根据另一个实例的值返回不同的 LiveData 实例。Lifecycle 软件包会提供 Transformations 类，该类包括可应对这些情况的辅助程序方法。\n\nTransformations.map()\n对存储在 LiveData 对象中的值应用函数，并将结果传播到下游。\n    val userLiveData: LiveData<User> = UserLiveData()\n    val userName: LiveData<String> = Transformations.map(userLiveData) {\n        user -> \"${user.name} ${user.lastName}\"\n    }\n    \n    LiveData<User> userLiveData = ...;\n    LiveData<String> userName = Transformations.map(userLiveData, user -> {\n        user.name + \" \" + user.lastName\n    });\n    \nTransformations.switchMap()\n与 map() 类似，对存储在 LiveData 对象中的值应用函数，并将结果解封和分派到下游。传递给 switchMap() 的函数必须返回 LiveData 对象，如以下示例中所示：\n    private fun getUser(id: String): LiveData<User> {\n      ...\n    }\n    val userId: LiveData<String> = ...\n    val user = Transformations.switchMap(userId) { id -> getUser(id) }\n    \n    private LiveData<User> getUser(String id) {\n      ...;\n    }LiveData<String> userId = ...;\n    LiveData<User> user = Transformations.switchMap(userId, id -> getUser(id) );\n    \n您可以使用转换方法在观察者的生命周期内传送信息。除非观察者正在观察返回的 LiveData 对象，否则不会计算转换。因为转换是以延迟的方式计算，所以与生命周期相关的行为会隐式传递下去，而不需要额外的显式调用或依赖项。\n\n如果您认为 ViewModel 对象中需要有 Lifecycle 对象，那么进行转换或许是更好的解决方案。例如，假设您有一个界面组件，该组件接受地址并返回该地址的邮政编码。您可以为此组件实现简单的 ViewModel，如以下示例代码所示：\n\n    class MyViewModel(private val repository: PostalCodeRepository) : ViewModel() {private fun getPostalCode(address: String): LiveData<String> {\n            // DON'T DO THIS\n            return repository.getPostCode(address)\n        }\n    }\n    \n    class MyViewModel extends ViewModel {\n        private final PostalCodeRepository repository;\n        public MyViewModel(PostalCodeRepository repository) {\n           this.repository = repository;\n        }private LiveData<String> getPostalCode(String address) {\n           // DON'T DO THIS\n           return repository.getPostCode(address);\n        }\n    }\n    \n然后，该界面组件需要取消注册先前的 LiveData 对象，并在每次调用 getPostalCode() 时注册到新的实例。此外，如果重新创建了该界面组件，它会再触发一次对 repository.getPostCode() 方法的调用，而不是使用先前调用所得的结果。\n\n您也可以将邮政编码查询实现为地址输入的转换，如以下示例中所示：\n\n    class MyViewModel(private val repository: PostalCodeRepository) : ViewModel() {\n        private val addressInput = MutableLiveData<String>()\n        val postalCode: LiveData<String> = Transformations.switchMap(addressInput) {\n                address -> repository.getPostCode(address) }private fun setInput(address: String) {\n            addressInput.value = address\n        }\n    }\n    \n    class MyViewModel extends ViewModel {\n        private final PostalCodeRepository repository;\n        private final MutableLiveData<String> addressInput = new MutableLiveData();\n        public final LiveData<String> postalCode =\n                Transformations.switchMap(addressInput, (address) -> {\n                    return repository.getPostCode(address);\n                 });public MyViewModel(PostalCodeRepository repository) {\n          this.repository = repository\n      }private void setInput(String address) {\n          addressInput.setValue(address);\n      }\n    }\n    \n在这种情况下，postalCode 字段定义为 addressInput 的转换。只要您的应用具有与 postalCode 字段关联的活跃观察者，就会在 addressInput 发生更改时重新计算并检索该字段的值。\n\n此机制允许较低级别的应用创建以延迟的方式按需计算的 LiveData 对象。ViewModel 对象可以轻松获取对 LiveData 对象的引用，然后在其基础之上定义转换规则。\n\n创建新的转换\n有十几种不同的特定转换在您的应用中可能很有用，但默认情况下不提供它们。要实现您自己的转换，您可以使用 MediatorLiveData 类，该类可以监听其他 LiveData 对象并处理它们发出的事件。MediatorLiveData 正确地将其状态传播到源 LiveData 对象。要详细了解此模式，请参阅 Transformations 类的参考文档。\n\n合并多个 LiveData 源\nMediatorLiveData 是 LiveData 的子类，允许您合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。\n\n例如，如果界面中有可以从本地数据库或网络更新的 LiveData 对象，则可以向 MediatorLiveData 对象添加以下源：\n\n与存储在数据库中的数据关联的 LiveData 对象。\n与从网络访问的数据关联的 LiveData 对象。\n您的 Activity 只需观察 MediatorLiveData 对象即可从这两个源接收更新。有关详细示例，请参阅应用架构指南的附录：公开网络状态部分。\n\n其他资源\n如需详细了解 LiveData 类，请参阅以下资源。\n\n示例\nSunflower，这是一个演示应用，演示架构组件的最佳做法\nAndroid 架构组件基本示例\nCodelab\n带 View 的 Android Room (Java) (Kotlin)\n博客\nViewModel 和 LiveData：模式 + 反模式\nViewModel  之外的 LiveData - 使用 Transformations 和 MediatorLiveData 的响应模式\nLiveData 与信息提示控件、导航和其他事件（SingleLiveEvent 情景）\n视频\nJetpack LiveData\nLiveData 其乐无穷（2018 年 Android 开发者峰会）"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243906536},"updatedAt":{"$$date":1597402306236},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"t3GuTCZmPgo2yB1l"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597404260496},"updatedAt":{"$$date":1597404260496},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"t7QvHD8E0HlXX12U"}
{"name":"ad-gradle.properties","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n# Project-wide Gradle settings.\n\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\n# Default value: -Xmx10248m -XX:MaxPermSize=256m\n# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8\n\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n# org.gradle.parallel=true\n#android.useDeprecatedNdk=true\n\n\n\n\napp.apkName=kaishustory\nandroid.injected.testOnly=false\norg.gradle.jvmargs=-Xmx8016m -XX:MaxPermSize=8016m -XX:+HeapDumpOnOutOfMemoryError\n\nandroid.useAndroidX=true\n# Automatically convert third-party libraries to use AndroidX\nandroid.enableJetifier=true\n\n\norg.gradle.daemon=false\norg.gradle.parallel=true\norg.gradle.configureondemand=true\n\nandroid.enableR8=false\n\nPROP_TARGET_SDK_VERSION=14\nPROP_APP_ABI=armeabi-v7a\n\n#上线之前要检查\nBUILD_COCOS=false\nTINGYUN_SCAN=false\n# 【0 测试库】 【1 开发库】 【2gama】 【3 上线库】\nBUILD_TYPE=0\n#RN_DAPI_VERSION=0.0.12\n#RN_DEBUG_VERSION=0.0.14\n#RN_GAMA_VERSION=0.0.12\n#RN_RELEASE_VERSION=0.0.12\n\nRN_DAPI_VERSION=+\nRN_DEBUG_VERSION=+\nRN_GAMA_VERSION=+\nRN_RELEASE_VERSION=+\nRN_FULL_PATH=NULL\n\n# 直播模块\nisLiveModule=false\n# 性能分析\nisAnalysis=false\n#方法耗时\nTraceMethod=false\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515778066},"updatedAt":{"$$date":1598516817053},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"tBcodW70GcbiO6Dk"}
{"name":"kotlin-类与继承 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/classes.html\n类与继承 - Kotlin 语言中文站\n25-31 minutes\n改进翻译\nKotlin 中使用关键字 class 声明类\n\n类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。\n\n在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。\n\nclass Person constructor(firstName: String) { /*……*/ }\n如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。\n\nclass Person(firstName: String) { /*……*/ }\n主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。\n\n在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：\n\n//sampleStart\nclass InitOrderDemo(name: String) {\n    val firstProperty = \"First property: $name\".also(::println)\n    \n    init {\n        println(\"First initializer block that prints ${name}\")\n    }\n    \n    val secondProperty = \"Second property: ${name.length}\".also(::println)\n    \n    init {\n        println(\"Second initializer block that prints ${name.length}\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    InitOrderDemo(\"hello\")\n}\n请注意，主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用：\n\nclass Customer(name: String) {\n    val customerKey = name.toUpperCase()\n}\n事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：\n\nclass Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }\n与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。\n\n如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：\n\nclass Customer public @Inject constructor(name: String) { /*……*/ }\n更多详情，参见可见性修饰符\n\n类也可以声明前缀有 constructor的次构造函数：\n\nclass Person {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(parent: Person) {\n        parent.children.add(this)\n    }\n}\n如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：\n\nclass Person(val name: String) {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(name: String, parent: Person) : this(name) {\n        parent.children.add(this)\n    }\n}\n请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：\n\n//sampleStart\nclass Constructors {\n    init {\n        println(\"Init block\")\n    }\n\n    constructor(i: Int) {\n        println(\"Constructor\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    Constructors(1)\n}\n如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：\n\nclass DontCreateMe private constructor () { /*……*/ }\n注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。\n\nclass Customer(val customerName: String = \"\")\n要创建一个类的实例，我们就像普通函数一样调用构造函数：\n\nval invoice = Invoice()\n\nval customer = Customer(\"Joe Smith\")\n注意 Kotlin 并没有 new 关键字。\n\n创建嵌套类、内部类与匿名内部类的类实例在嵌套类中有述。\n\n类可以包含：\n\n构造函数与初始化块\n函数\n属性\n嵌套类与内部类\n对象声明\n在 Kotlin 中所有类都有一个共同的超类 Any，这对于没有超类型声明的类是默认超类：\n\nclass Example // 从 Any 隐式继承\nAny 有三个方法：equals()、 hashCode() 与 toString()。因此，为所有 Kotlin 类都定义了这些方法。\n\n默认情况下，Kotlin 类是最终（final）的：它们不能被继承。 要使一个类可继承，请用 open 关键字标记它。\n\nopen class Base // 该类开放继承\n\n如需声明一个显式的超类型，请在类头中把超类型放到冒号之后：\n\nopen class Base(p: Int)\n\nclass Derived(p: Int) : Base(p)\n如果派生类有一个主构造函数，其基类可以（并且必须） 用派生类主构造函数的参数就地初始化。\n\n如果派生类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：\n\nclass MyView : View {\n    constructor(ctx: Context) : super(ctx)\n\n    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)\n}\n我们之前提到过，Kotlin 力求清晰显式。因此，Kotlin 对于可覆盖的成员（我们称之为开放）以及覆盖后的成员需要显式修饰符：\n\nopen class Shape {\n    open fun draw() { /*……*/ }\n    fun fill() { /*……*/ }\n}\n\nclass Circle() : Shape() {\n    override fun draw() { /*……*/ }\n}\nCircle.draw() 函数上必须加上 override 修饰符。如果没写，编译器将会报错。 如果函数没有标注 open 如 Shape.fill()，那么子类中不允许定义相同签名的函数， 不论加不加 override。将 open 修饰符添加到 final 类（即没有 open 的类）的成员上不起作用。\n\n标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：\n\nopen class Rectangle() : Shape() {\n    final override fun draw() { /*……*/ }\n}\n属性覆盖与方法覆盖类似；在超类中声明然后在派生类中重新声明的属性必须以 override 开头，并且它们必须具有兼容的类型。 每个声明的属性可以由具有初始化器的属性或者具有 get 方法的属性覆盖。\n\nopen class Shape {\n    open val vertexCount: Int = 0\n}\n\nclass Rectangle : Shape() {\n    override val vertexCount = 4\n}\n你也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。 这是允许的，因为一个 val 属性本质上声明了一个 get 方法， 而将其覆盖为 var 只是在子类中额外声明一个 set 方法。\n\n请注意，你可以在主构造函数中使用 override 关键字作为属性声明的一部分。\n\ninterface Shape {\n    val vertexCount: Int\n}\n\nclass Rectangle(override val vertexCount: Int = 4) : Shape // 总是有 4 个顶点\n\nclass Polygon : Shape {\n    override var vertexCount: Int = 0  // 以后可以设置为任何数\n}\n在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。\n\n//sampleStart\nopen class Base(val name: String) {\n\n    init { println(\"Initializing Base\") }\n\n    open val size: Int = \n        name.length.also { println(\"Initializing size in Base: $it\") }\n}\n\nclass Derived(\n    name: String,\n    val lastName: String\n) : Base(name.capitalize().also { println(\"Argument for Base: $it\") }) {\n\n    init { println(\"Initializing Derived\") }\n\n    override val size: Int =\n        (super.size + lastName.length).also { println(\"Initializing size in Derived: $it\") }\n}\n//sampleEnd\n\nfun main() {\n    println(\"Constructing Derived(\\\"hello\\\", \\\"world\\\")\")\n    val d = Derived(\"hello\", \"world\")\n}\n这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化。如果在基类初始化逻辑中（直接或通过另一个覆盖的 open 成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或运行时故障。设计一个基类时，应该避免在构造函数、属性初始化器以及 init 块中使用 open 成员。\n\n派生类中的代码可以使用 super 关键字调用其超类的函数与属性访问器的实现：\n\nopen class Rectangle {\n    open fun draw() { println(\"Drawing a rectangle\") }\n    val borderColor: String get() = \"black\"\n}\n\nclass FilledRectangle : Rectangle() {\n    override fun draw() {\n        super.draw()\n        println(\"Filling the rectangle\")\n    }\n\n    val fillColor: String get() = super.borderColor\n}\n在一个内部类中访问外部类的超类，可以通过由外部类名限定的 super 关键字来实现：super@Outer：\n\nclass FilledRectangle: Rectangle() {\n    fun draw() { /* …… */ }\n    val borderColor: String get() = \"black\"\n    \n    inner class Filler {\n        fun fill() { /* …… */ }\n        fun drawAndFill() {\n            super@FilledRectangle.draw() // 调用 Rectangle 的 draw() 实现\n            fill()\n            println(\"Drawn a filled rectangle with color ${super@FilledRectangle.borderColor}\") // 使用 Rectangle 所实现的 borderColor 的 get()\n        }\n    }\n}\n在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super<Base>：\n\nopen class Rectangle {\n    open fun draw() { /* …… */ }\n}\n\ninterface Polygon {\n    fun draw() { /* …… */ } // 接口成员默认就是“open”的\n}\n\nclass Square() : Rectangle(), Polygon {\n    // 编译器要求覆盖 draw()：\n    override fun draw() {\n        super<Rectangle>.draw() // 调用 Rectangle.draw()\n        super<Polygon>.draw() // 调用 Polygon.draw()\n    }\n}\n可以同时继承 Rectangle 与 Polygon， 但是二者都有各自的 draw() 实现，所以我们必须在 Square 中覆盖 draw()， 并提供其自身的实现以消除歧义。\n\n类以及其中的某些成员可以声明为 abstract。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。\n\n我们可以用一个抽象成员覆盖一个非抽象的开放成员\n\nopen class Polygon {\n    open fun draw() {}\n}\n\nabstract class Rectangle : Polygon() {\n    abstract override fun draw()\n}\n如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂方法），你可以把它写成该类内对象声明中的一员。\n\n更具体地讲，如果在你的类内声明了一个伴生对象， 你就可以访问其成员，只是以类名作为限定符。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306185686},"updatedAt":{"$$date":1597307786437},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"tCgut1eqc9TFudaE"}
{"name":"kotlin-KTX 扩展程序列表  |  Android 开发者  |  Android Developers","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /kotlin/ktx/extensions-list\nKTX 扩展程序列表  |  Android 开发者  |  Android Developers\ntriggeredContentAuthorities\n20-25 minutes\n目录\nandroidx.activity\nandroidx.benchmark\nandroidx.benchmark.junit4\nandroidx.collection\nandroidx.core.animation\nandroidx.core.content\nandroidx.core.content.res\nandroidx.core.database\nandroidx.core.database.sqlite\nandroidx.core.graphics\nandroidx.core.graphics.drawable\nandroidx.core.location\nandroidx.core.net\nandroidx.core.os\nandroidx.core.text\nandroidx.core.transition\nandroidx.core.util\nandroidx.core.view\nandroidx.core.widget\nandroidx.dynamicanimation.animation\nandroidx.fragment.app\nandroidx.fragment.app.testing\nandroidx.lifecycle\nandroidx.navigation\nandroidx.navigation.fragment\nandroidx.navigation.ui\nandroidx.paging\nandroidx.palette.graphics\nandroidx.preference\nandroidx.room\nandroidx.slice.builders\nandroidx.sqlite.db\nandroidx.work\nandroidx.work.testing\ncom.google.android.play.core.ktx\n目录\nandroidx.activity\nandroidx.benchmark\nandroidx.benchmark.junit4\nandroidx.collection\nandroidx.core.animation\nandroidx.core.content\nandroidx.core.content.res\nandroidx.core.database\nandroidx.core.database.sqlite\nandroidx.core.graphics\nandroidx.core.graphics.drawable\nandroidx.core.location\nandroidx.core.net\nandroidx.core.os\nandroidx.core.text\nandroidx.core.transition\nandroidx.core.util\nandroidx.core.view\nandroidx.core.widget\nandroidx.dynamicanimation.animation\nandroidx.fragment.app\nandroidx.fragment.app.testing\nandroidx.lifecycle\nandroidx.navigation\nandroidx.navigation.fragment\nandroidx.navigation.ui\nandroidx.paging\nandroidx.palette.graphics\nandroidx.preference\nandroidx.room\nandroidx.slice.builders\nandroidx.sqlite.db\nandroidx.work\nandroidx.work.testing\ncom.google.android.play.core.ktx\nandroidx.activity\n依赖项\n    dependencies {\n        implementation \"androidx.activity:activity-ktx:1.1.0\"\n    }\n    \n扩展函数\n对于 OnBackPressedDispatcher\n对于 ComponentActivity\nandroidx.benchmark\n依赖项\n    dependencies {\n        implementation \"androidx.benchmark:benchmark-junit4:1.0.0\"\n    }\n    \n顶级函数\nandroidx.benchmark.junit4\n依赖项\n    dependencies {\n        implementation \"androidx.benchmark:benchmark-junit4:1.0.0\"\n    }\n    \n扩展函数\n对于 BenchmarkRule\nandroidx.collection\n依赖项\n    dependencies {\n        implementation \"androidx.collection:collection-ktx:1.1.0\"\n    }\n    \n扩展函数\n对于 LongSparseArray\n对于 SparseArrayCompat\n扩展属性\n对于 LongSparseArray\n对于 SparseArrayCompat\n顶级函数\nArrayMap<K, V>\tarrayMapOf()\n返回新的空 ArrayMap。\n\nArrayMap<K, V>\tarrayMapOf(vararg pairs: Pair<K, V>)\n返回以键值对列表形式提供的具有指定内容的新 ArrayMap，键值对中第一个组件是键，第二个组件是值。\n\nArraySet<T>\tarraySetOf()\n返回新的空 ArraySet。\n\nArraySet<T>\tarraySetOf(vararg values: T)\n返回具有指定内容的新 ArraySet。\n\nLruCache<K, V>\tlruCache(maxSize: Int, crossinline sizeOf: (key: K, value: V) -> Int = { _, _ -> 1 }, crossinline create: (key: K) -> V? = { null as V? }, crossinline onEntryRemoved: (evicted: Boolean, key: K, oldValue: V, newValue: V?) -> Unit = { _, _, _, _ -> })\n创建具有指定参数的 LruCache。\n\nandroidx.core.animation\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.animation.Animator\nandroidx.core.content\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.content.Context\n对于 android.content.SharedPreferences\n顶级函数\nandroidx.core.content.res\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.content.res.TypedArray\nandroidx.core.database\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.database.Cursor\nandroidx.core.database.sqlite\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.database.sqlite.SQLiteDatabase\nandroidx.core.graphics\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.graphics.Bitmap\n对于 android.graphics.Canvas\nUnit\tCanvas.withClip(clipRect: Rect, block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.clipRect 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withClip(clipRect: RectF, block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.clipRect 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withClip(left: Int, top: Int, right: Int, bottom: Int, block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.clipRect 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withClip(left: Float, top: Float, right: Float, bottom: Float, block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.clipRect 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withClip(clipPath: Path, block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.clipPath 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withMatrix(matrix: Matrix = Matrix(), block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.concat 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withRotation(degrees: Float = 0.0f, pivotX: Float = 0.0f, pivotY: Float = 0.0f, block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.rotate 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withSave(block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withScale(x: Float = 1.0f, y: Float = 1.0f, pivotX: Float = 0.0f, pivotY: Float = 0.0f, block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.scale 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withSkew(x: Float = 0.0f, y: Float = 0.0f, block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.skew 和 Canvas.restoreToCount 的调用中。\n\nUnit\tCanvas.withTranslation(x: Float = 0.0f, y: Float = 0.0f, block: Canvas.() -> Unit)\n将指定的 block 封装在对 Canvas.save/Canvas.translate 和 Canvas.restoreToCount 的调用中。\n\n对于 android.graphics.Color\n对于 android.graphics.ImageDecoder.Source\n对于 android.graphics.Matrix\n对于 android.graphics.Paint\n对于 android.graphics.Path\n对于 android.graphics.Picture\n对于 android.graphics.Point\n对于 android.graphics.PointF\n对于 android.graphics.PorterDuff.Mode\n对于 android.graphics.Rect\n对于 android.graphics.RectF\n对于 android.graphics.Region\n对于 android.graphics.Shader\n对于 kotlin.Int\n对于 kotlin.Long\n对于 kotlin.String\n扩展属性\n对于 kotlin.Int\n对于 kotlin.Long\n顶级函数\nBitmap\tcreateBitmap(width: Int, height: Int, config: Config = Bitmap.Config.ARGB_8888)\n返回具有指定的宽度和高度的可变位图。\n\nBitmap\tcreateBitmap(width: Int, height: Int, config: Config = Bitmap.Config.ARGB_8888, hasAlpha: Boolean = true, colorSpace: ColorSpace = ColorSpace.get(ColorSpace.Named.SRGB))\n返回具有指定的宽度和高度的可变位图。\n\nMatrix\trotationMatrix(degrees: Float, px: Float = 0.0f, py: Float = 0.0f)\n创建一个旋转矩阵，该矩阵由围绕位于坐标（px，py）处的轴心点的旋转角度（以度为单位）定义。\n\nMatrix\tscaleMatrix(sx: Float = 1.0f, sy: Float = 1.0f)\n创建一个缩放矩阵，该矩阵在 x 轴和 y 轴上的缩放系数分别为 sx 和 sy。\n\nMatrix\ttranslationMatrix(tx: Float = 0.0f, ty: Float = 0.0f)\n创建一个平移矩阵，该矩阵在 x 轴和 y 轴上的平移量分别为 tx 和 ty。\n\nandroidx.core.graphics.drawable\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.graphics.Bitmap\n对于 android.graphics.Color\n对于 android.graphics.drawable.Drawable\n对于 android.net.Uri\n对于 kotlin.ByteArray\n对于 kotlin.Int\nandroidx.core.location\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.location.Location\nandroidx.core.net\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.net.Uri\n对于 java.io.File\n对于 kotlin.String\nandroidx.core.os\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.os.Handler\n顶级函数\nandroidx.core.text\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.text.Spannable\n对于 android.text.SpannableStringBuilder\n对于 android.text.Spanned\n对于 kotlin.CharSequence\n对于 kotlin.String\n扩展属性\n对于 java.util.Locale\n顶级函数\nandroidx.core.transition\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.transition.Transition\nandroidx.core.util\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.util.AtomicFile\n对于 android.util.LongSparseArray\n对于 android.util.Pair\n对于 android.util.Range\n对于 android.util.Size\n对于 android.util.SizeF\n对于 android.util.SparseArray\n对于 android.util.SparseBooleanArray\n对于 android.util.SparseIntArray\n对于 android.util.SparseLongArray\n对于 kotlin.Double\n对于 kotlin.Float\n对于 kotlin.Pair\n对于 kotlin.Short\n对于 kotlin.String\n对于 kotlin.ranges.ClosedRange\n扩展属性\n对于 android.util.LongSparseArray\n对于 android.util.SparseArray\n对于 android.util.SparseBooleanArray\n对于 android.util.SparseIntArray\n对于 android.util.SparseLongArray\n顶级函数\nLruCache<K, V>\tlruCache(maxSize: Int, crossinline sizeOf: (key: K, value: V) -> Int = { _, _ -> 1 }, crossinline create: (key: K) -> V? = { null as V? }, crossinline onEntryRemoved: (evicted: Boolean, key: K, oldValue: V, newValue: V?) -> Unit = { _, _, _, _ -> })\n创建具有指定参数的 LruCache。\n\ninfix Range<T>\tT.rangeTo(that: T)\n创建一个介于此可比较值和该值之间的范围。\n\nandroidx.core.view\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.view.Menu\n对于 android.view.View\n对于 android.view.ViewGroup\n对于 android.view.ViewGroup.MarginLayoutParams\n扩展属性\n对于 android.view.Menu\n对于 android.view.View\n对于 android.view.ViewGroup\n依赖项\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n扩展函数\n对于 android.widget.TextView\nTextWatcher\tTextView.addTextChangedListener(crossinline beforeTextChanged: (text: CharSequence?, start: Int, count: Int, after: Int) -> Unit = { _, _, _, _ -> }, crossinline onTextChanged: (text: CharSequence?, start: Int, count: Int, after: Int) -> Unit = { _, _, _, _ -> }, crossinline afterTextChanged: (text: Editable?) -> Unit = {})\n使用提供的操作向此 TextView 添加文本更改监听器\n\nTextWatcher\tTextView.doAfterTextChanged(crossinline action: (text: Editable?) -> Unit)\n添加将在文本更改后调用的操作。\n\nTextWatcher\tTextView.doBeforeTextChanged(crossinline action: (text: CharSequence?, start: Int, count: Int, after: Int) -> Unit)\n添加将在文本更改之前调用的操作。\n\nTextWatcher\tTextView.doOnTextChanged(crossinline action: (text: CharSequence?, start: Int, count: Int, after: Int) -> Unit)\n添加将在文本更改时调用的操作。\n\nandroidx.dynamicanimation.animation\n依赖项\n    dependencies {\n        implementation \"androidx.dynamicanimation:dynamicanimation-ktx:1.0.0-alpha03\"\n    }\n    \n扩展函数\n对于 SpringAnimation\n顶级函数\nandroidx.fragment.app\n依赖项\ndependencies {\n    implementation \"androidx.fragment:fragment-ktx:1.2.5\"\n}\n扩展函数\n对于 android.view.View\n对于 Fragment\n对于 FragmentTransaction\n对于 FragmentManager\nandroidx.fragment.app.testing\n依赖项\ndependencies {\n    implementation \"androidx.fragment:fragment-testing:1.2.5\"\n}\n顶级函数\nandroidx.lifecycle\n依赖项\n    dependencies {\n        implementation \"androidx.lifecycle:lifecycle-livedata-core-ktx:2.2.0\"\n        implementation \"androidx.lifecycle:lifecycle-livedata-ktx:2.2.0\"\n        implementation \"androidx.lifecycle:lifecycle-reactivestreams-ktx:2.2.0\"\n        implementation \"androidx.lifecycle:lifecycle-runtime-ktx:2.2.0\"\n        implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0\"\n    }\n    \n扩展函数\n对于 kotlinx.coroutines.flow.Flow\n对于 org.reactivestreams.Publisher\n对于 LiveData\n对于 ViewModelProvider\nVM\tViewModelProvider.get()\n返回现有的 ViewModel，或者在相应范围内（通常为 Fragment 或 Activity）创建一个与此 ViewModelProvider 关联的新 ViewModel。\n\n对于 LifecycleOwner\n对于 Lifecycle\n扩展属性\n对于 Lifecycle\n对于 LifecycleOwner\n对于 ViewModel\n顶级函数\nandroidx.navigation\n依赖项\ndependencies {\n    implementation \"androidx.navigation:navigation-runtime-ktx:2.3.0-rc01\"\n    implementation \"androidx.navigation:navigation-fragment-ktx:2.3.0-rc01\"\n    implementation \"androidx.navigation:navigation-ui-ktx:2.3.0-rc01\"\n}\n扩展函数\n对于 android.app.Activity\n对于 android.view.View\n对于 NavGraphBuilder\n对于 NavGraph\n对于 NavController\n对于 NavHost\n对于 NavigatorProvider\n对于 Fragment\n顶级函数\nandroidx.navigation.fragment\n依赖项\ndependencies {\n    implementation \"androidx.navigation:navigation-fragment-ktx:2.3.0-rc01\"\n}\n扩展函数\n对于 NavGraphBuilder\n对于 Fragment\n顶级函数\nandroidx.navigation.ui\n依赖项\ndependencies {\n    implementation \"androidx.navigation:navigation-ui-ktx:2.3.0-rc01\"\n}\n扩展函数\n对于 android.view.MenuItem\n对于 androidx.appcompat.app.AppCompatActivity\n对于 androidx.appcompat.widget.Toolbar\n对于 com.google.android.material.appbar.CollapsingToolbarLayout\n对于 com.google.android.material.bottomnavigation.BottomNavigationView\n对于 com.google.android.material.navigation.NavigationView\n对于 NavController\n顶级函数\nandroidx.paging\n依赖项\n    dependencies {\n        implementation \"androidx.paging:paging-common-ktx:2.1.2\"\n        implementation \"androidx.paging:paging-runtime-ktx:2.1.2\"\n        implementation \"androidx.paging:paging-rxjava2-ktx:2.1.2\"\n    }\n    \n扩展函数\n对于 Factory\nFlowable<PagedList<Value>>\tDataSource.Factory<Key, Value>.toFlowable(config: PagedList.Config, initialLoadKey: Key? = null, boundaryCallback: PagedList.BoundaryCallback<Value>? = null, fetchScheduler: Scheduler? = null, notifyScheduler: Scheduler? = null, backpressureStrategy: BackpressureStrategy = BackpressureStrategy.LATEST)\n从此 DataSource.Factory 中构造一个 Flowable<PagedList>，从而为 RxPagedListBuilder 提供便利。\n\nFlowable<PagedList<Value>>\tDataSource.Factory<Key, Value>.toFlowable(pageSize: Int, initialLoadKey: Key? = null, boundaryCallback: PagedList.BoundaryCallback<Value>? = null, fetchScheduler: Scheduler? = null, notifyScheduler: Scheduler? = null, backpressureStrategy: BackpressureStrategy = BackpressureStrategy.LATEST)\n从此 DataSource.Factory 中构造一个 Flowable<PagedList>，从而为 RxPagedListBuilder 提供便利。\n\nLiveData<PagedList<Value>>\tDataSource.Factory<Key, Value>.toLiveData(config: PagedList.Config, initialLoadKey: Key? = null, boundaryCallback: PagedList.BoundaryCallback<Value>? = null, fetchExecutor: Executor = ArchTaskExecutor.getIOThreadExecutor())\n从此 DataSource.Factory 中构造一个 LiveData<PagedList>，从而为 LivePagedListBuilder 提供便利。\n\nLiveData<PagedList<Value>>\tDataSource.Factory<Key, Value>.toLiveData(pageSize: Int, initialLoadKey: Key? = null, boundaryCallback: PagedList.BoundaryCallback<Value>? = null, fetchExecutor: Executor = ArchTaskExecutor.getIOThreadExecutor())\n从此 DataSource.Factory 中构造一个 LiveData<PagedList>，从而为 LivePagedListBuilder 提供便利。\n\nObservable<PagedList<Value>>\tDataSource.Factory<Key, Value>.toObservable(config: PagedList.Config, initialLoadKey: Key? = null, boundaryCallback: PagedList.BoundaryCallback<Value>? = null, fetchScheduler: Scheduler? = null, notifyScheduler: Scheduler? = null)\n从此 DataSource.Factory 中构造一个 Observable<PagedList>，从而为 RxPagedListBuilder 提供便利。\n\nObservable<PagedList<Value>>\tDataSource.Factory<Key, Value>.toObservable(pageSize: Int, initialLoadKey: Key? = null, boundaryCallback: PagedList.BoundaryCallback<Value>? = null, fetchScheduler: Scheduler? = null, notifyScheduler: Scheduler? = null)\n从此 DataSource.Factory 中构造一个 Observable<PagedList>，从而为 RxPagedListBuilder 提供便利。\n\n顶级函数\nPagedList.Config\tConfig(pageSize: Int, prefetchDistance: Int = pageSize, enablePlaceholders: Boolean = true, initialLoadSizeHint: Int = pageSize * PagedList.Config.Builder.DEFAULT_INITIAL_PAGE_MULTIPLIER, maxSize: Int = PagedList.Config.MAX_SIZE_UNBOUNDED)\n构造一个 PagedList.Config，从而为 PagedList.Config.Builder 提供便利。\n\nPagedList<Value>\tPagedList(dataSource: DataSource<Key, Value>, config: PagedList.Config, notifyExecutor: Executor, fetchExecutor: Executor, boundaryCallback: PagedList.BoundaryCallback<Value>? = null, initialKey: Key? = null)\n构造一个 PagedList，从而为 PagedList.Builder 提供便利。\n\nandroidx.palette.graphics\n依赖项\n    dependencies {\n        implementation \"androidx.palette:palette-ktx:1.0.0\"\n    }\n    \n扩展函数\n对于 Palette\nandroidx.preference\n依赖项\ndependencies {\n    implementation \"androidx.preference:preference-ktx:1.1.1\"\n}\n扩展函数\n对于 PreferenceGroup\n扩展属性\n对于 PreferenceGroup\nandroidx.room\n依赖项\n    dependencies {\n        implementation \"androidx.room:room-ktx:2.2.5\"\n    }\n    \n扩展函数\n对于 RoomDatabase\nandroidx.slice.builders\n依赖项\n    dependencies {\n        implementation \"androidx.slice:slice-builders-ktx:1.0.0-alpha07\"\n    }\n    \n扩展函数\n对于 GridRowBuilderDsl\n对于 ListBuilderDsl\n顶级函数\nandroidx.sqlite.db\n依赖项\n    dependencies {\n        implementation \"androidx.sqlite:sqlite-ktx:2.1.0\"\n    }\n    \n扩展函数\n对于 SupportSQLiteDatabase\nandroidx.work\n依赖项\n扩展函数\n对于 com.google.common.util.concurrent.ListenableFuture\n对于 Operation\n对于 Data\n对于 Builder\n顶级函数\nandroidx.work.testing\n依赖项\n    dependencies {\n        implementation \"androidx.work:work-testing:2.3.4\"\n    }\n    \n顶级函数\nTestListenableWorkerBuilder<W>\tTestListenableWorkerBuilder(context: Context, inputData: Data = Data.EMPTY, tags: List<String> = emptyList(), runAttemptCount: Int = 1, triggeredContentUris: List<Uri> = emptyList(), : List<String> = emptyList())\n构建 TestListenableWorkerBuilder 实例。\n\nTestWorkerBuilder<W>\tTestWorkerBuilder(context: Context, executor: Executor, inputData: Data = Data.EMPTY, tags: List<String> = emptyList(), runAttemptCount: Int = 1, triggeredContentUris: List<Uri> = emptyList(), triggeredContentAuthorities: List<String> = emptyList())\n构建 TestWorkerBuilder 实例。\n\ncom.google.android.play.core.ktx\n依赖项\ndependencies {\n    implementation \"com.google.android.play:core-ktx:1.8.0\"\n}\n扩展函数\n对于 com.google.android.play.core.appupdate.AppUpdateManager\n对于 com.google.android.play.core.splitinstall.SplitInstallManager\n扩展属性\n对于 com.google.android.play.core.appupdate.AppUpdateInfo\n对于 com.google.android.play.core.install.InstallState\n对于 com.google.android.play.core.splitinstall.SplitInstallSessionState\n顶级函数\nSplitInstallStateUpdatedListener\tSplitInstallStateUpdatedListener(onRequiresConfirmation: (SplitInstallSessionState) -> Unit, onInstalled: (SplitInstallSessionState) -> Unit, onFailed: (SplitInstallSessionState) -> Unit = {}, onPending: (SplitInstallSessionState) -> Unit = {}, onDownloaded: (SplitInstallSessionState) -> Unit = {}, onDownloading: (SplitInstallSessionState) -> Unit = {}, onInstalling: (SplitInstallSessionState) -> Unit = {}, onCanceling: (SplitInstallSessionState) -> Unit = {}, onCanceled: (SplitInstallSessionState) -> Unit = {}, onNonTerminalStatus: (SplitInstallSessionState) -> Unit = {}, onTerminalStatus: (SplitInstallSessionState) -> Unit = {})\n用于创建 SplitInstallStateUpdatedListener 的便捷函数。\n\nContent and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2020-08-05 UTC."}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397423436},"updatedAt":{"$$date":1597399994348},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"tGvGBjogUAN4sXTX"}
{"name":"py-布尔值","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：\n\n>>> True\nTrue\n>>> False\nFalse\n>>> 3 > 2\nTrue\n>>> 3 > 5\nFalse\n布尔值可以用and、or和not运算。\n\nand运算是与运算，只有所有都为True，and运算结果才是True：\n\n>>> True and True\nTrue\n>>> True and False\nFalse\n>>> False and False\nFalse\n>>> 5 > 3 and 3 > 1\nTrue\nor运算是或运算，只要其中有一个为True，or运算结果就是True：\n\n>>> True or True\nTrue\n>>> True or False\nTrue\n>>> False or False\nFalse\n>>> 5 > 3 or 1 > 3\nTrue\nnot运算是非运算，它是一个单目运算符，把True变成False，False变成True：\n\n>>> not True\nFalse\n>>> not False\nTrue\n>>> not 1 > 2\nTrue\n布尔值经常用在条件判断中，比如：\n\nif age >= 18:\n    print('adult')\nelse:\n    print('teenager')"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973925643},"updatedAt":{"$$date":1594974102005},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"tSrhoxH59Kxw0xdE"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973263497},"updatedAt":{"$$date":1594973263497},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"taGSpoVdFPCaRnIn"}
{"name":"py-命名关键字参数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。\n\n仍以person()函数为例，我们希望检查是否有city和job参数：\n\ndef person(name, age, **kw):\n    if 'city' in kw:\n        # 有city参数\n        pass\n    if 'job' in kw:\n        # 有job参数\n        pass\n    print('name:', name, 'age:', age, 'other:', kw)\n但是调用者仍可以传入不受限制的关键字参数：\n\n>>> person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)\n如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：\n\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\n和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\n\n调用方式如下：\n\n>>> person('Jack', 24, city='Beijing', job='Engineer')\nJack 24 Beijing Engineer\n如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n\ndef person(name, age, *args, city, job):\n    print(name, age, args, city, job)\n命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：\n\n>>> person('Jack', 24, 'Beijing', 'Engineer')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: person() takes 2 positional arguments but 4 were given\n由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。\n\n命名关键字参数可以有缺省值，从而简化调用：\n\ndef person(name, age, *, city='Beijing', job):\n    print(name, age, city, job)\n由于命名关键字参数city具有默认值，调用时，可不传入city参数：\n\n>>> person('Jack', 24, job='Engineer')\nJack 24 Beijing Engineer\n使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：\n\ndef person(name, age, city, job):\n    # 缺少 *，city和job被视为位置参数\n    pass\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977481006},"updatedAt":{"$$date":1594979296907},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"tsBA6zrF1g6JdEWb"}
{"name":"ad-upload-to-maven","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"如何使用：\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\nupload.gradle如下：\n\n\n\nif(upLoadJcenterFlag){\n    apply from: rootProject.file(\"./gradle/bintrayupload.gradle\")\n}else{\n    apply from: rootProject.file(\"./gradle/upload_local_maven.gradle\")\n}\n\n\n\n\nbintrayupload.gradle如下：\n\n\n// 构建Maven依赖库脚本\napply plugin: 'com.github.dcendents.android-maven'\napply plugin: 'com.jfrog.bintray'\n\n// 仓库名\ndef repoName = 'maven'\n// 项目主页\ndef siteUrl = SITE_URL\n// 项目的git地址\ndef gitUrl = GIT_URL\n// 发布到JCenter上的项目名字\ndef libName = POM_ARTIFACT_ID\n// 项目描述\ndef projectDescription = PROJECT_DESC\n\ngroup = GROUP\nversion = VERSION_NAME\n\ntask sourcesJar(type: Jar) {\n    from android.sourceSets.main.java.srcDirs\n    classifier = 'sources'\n}\n\nartifacts {\n    archives sourcesJar\n}\n\n// 配置maven库，生成POM.xml文件\ninstall {\n    repositories.mavenInstaller {\n        // This generates POM.xml with proper parameters\n        pom {\n            project {\n                packaging 'jar'\n                //项目描述\n                name projectDescription\n                url siteUrl\n                licenses {\n                    license {\n                        //开源协议\n                        name 'The Apache Software License, Version 2.0'\n                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'\n                    }\n                }\n                developers {\n                    developer {\n                        //开发者的个人信息\n                        id 'ksdeveloper'\n                        name 'ksdeveloper'\n                        email 'kaishustory@gmail.com'\n                    }\n                }\n                scm {\n                    connection gitUrl\n                    developerConnection gitUrl\n                    url siteUrl\n                }\n            }\n        }\n    }\n}\n\n//上传到JCenter\nProperties properties = new Properties()\nproperties.load(project.rootProject.file('local.properties').newDataInputStream())\n\nbintray {\n    user = properties.getProperty(\"bintray.user\")    //读取 local.properties 文件里面的 bintray.user\n    key = properties.getProperty(\"bintray.apikey\")   //读取 local.properties 文件里面的 bintray.apikey\n    configurations = ['archives']\n    pkg {\n        //注意：这里的repo值必须要和创建Maven仓库的时候的名字一样\n        repo = repoName\n        //发布到JCenter上的项目名字\n        name = libName\n        //项目描述\n        desc = projectDescription\n        websiteUrl = siteUrl\n        vcsUrl = gitUrl\n        licenses = [\"Apache-2.0\"]\n        publish = true\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nupload_local_maven.gradle如下：\n\n\n\napply plugin: 'maven'\n\ndef uploadReleaseUrl() {\n    def url = RELEASE_REPOSITORY_URL\n    if (IS_ANDROIDX) {\n        url = RELEASE_REPOSITORY_ANDROID_X_URL\n    }\n    return url\n}\n\ndef uploadSnapshotUrl() {\n    def url = SNAPSHOT_REPOSITORY_URL\n    if (IS_ANDROIDX) {\n        url = SNAPSHOT_REPOSITORY_ANDROID_X_URL\n    }\n    return url\n}\n\ndef getRepositoryUsername() {\n    return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : \"\"\n}\n\ndef getRepositoryPassword() {\n    return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : \"\"\n}\n\nafterEvaluate { project ->\n    uploadArchives {\n        repositories {\n            mavenDeployer {\n                pom.groupId = GROUP\n                pom.artifactId = POM_ARTIFACT_ID\n                pom.version = VERSION_NAME\n                repository(url: uploadReleaseUrl()) {\n                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())\n                }\n                snapshotRepository(url: uploadSnapshotUrl()) {\n                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())\n                }\n            }\n        }\n    }\n//    task androidJavadocs(type: Javadoc) {\n//        source = android.sourceSets.main.java.srcDirs\n//        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))\n//    }\n//    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {\n//        classifier = 'javadoc'\n//        from androidJavadocs.destinationDir\n//    }\n    task androidSourcesJar(type: Jar) {\n        classifier = 'sources'\n        //from android.sourceSets.main.java.sourceFiles\n        from android.sourceSets.main.java.srcDirs\n    }\n    artifacts {\n        archives androidSourcesJar\n//        archives androidJavadocsJar\n    }\n}\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515784159},"updatedAt":{"$$date":1598517541546},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"tztJmsgw1YdXP7w2"}
{"name":"ad-upload_local_maven.gradle","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\napply plugin: 'maven'\n\ndef getPropertyFromLocalProperties(key) {\n    File file = project.rootProject.file('local.properties')\n    if (file.exists()) {\n        Properties properties = new Properties()\n        properties.load(file.newDataInputStream())\n        return properties.getProperty(key)\n    }\n}\n\n\ndef hasAndroidPlugin() {\n    return getPlugins().inject(false) { a, b ->\n        def classStr = b.getClass().name\n        def isAndroid = (\"com.android.build.gradle.LibraryPlugin\" == classStr) || (\"com.android.build.gradle.AppPlugin\" == classStr)\n        a || isAndroid\n    }\n}\n\ndef isReleaseBuild() {\n    return VERSION_NAME.contains(\"SNAPSHOT\") == false\n}\n\ndef getRepositoryUrl() {\n    return isReleaseBuild() ? getPropertyFromLocalProperties(\"RELEASE_REPOSITORY_URL\") : getPropertyFromLocalProperties(\"SNAPSHOT_REPOSITORY_URL\")\n}\n\nafterEvaluate { project ->\n    uploadArchives {\n        repositories {\n            mavenDeployer {\n                pom.groupId = getPropertyFromLocalProperties(\"GROUP\")\n                pom.artifactId = POM_ARTIFACT_ID\n                pom.version = VERSION_NAME\n                repository(url: getRepositoryUrl()) {\n                    authentication(userName: getPropertyFromLocalProperties(\"NEXUS_USERNAME\"), password: getPropertyFromLocalProperties(\"NEXUS_PASSWORD\"))\n                }\n            }\n        }\n    }\n\n    task androidSourcesJar(type: Jar) {\n        if (hasAndroidPlugin()) {\n            from (android.sourceSets.main.java.srcDirs,android.sourceSets.main.jniLibs.srcDirs)\n            classifier = 'sources'\n        } else {\n            from sourceSets.main.allSource\n            classifier = 'sources'\n        }\n    }\n\n    artifacts {\n        archives androidSourcesJar\n    }\n}\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539539819},"updatedAt":{"$$date":1598539729040},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"uGGYZOP71XMnQIye"}
{"name":"qk-ks_component_voicerecorder","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\nlibs\narmeabi-v7a\nlibmp3lame.so\nsrc\nmain\ncpp\njava\ncom\nmp3recorder\nutil\nDataEncodeThread\nMP3Recorder\nMp3VoiceRecorder\nPCMFormat\nvoiceanalysis\nutil\nKsVoiceAnalysisConfig\nRecordVoiceListener\nTencentVoiceAnalysis\n\n\n\n\n\n\n\n\n\npublic class KsVoiceAnalysisConfig {\n\n    public static String appId = \"1255565373\";\n    public static String secretId = \"AKIDnMk296QfBfjgW2vd1ylwKRI2h9MNfZiQ\";\n    public static String secretKey = \"nJZ4NPBgwwf7TfeOr52iAXfYha2FApOm\";\n    public static boolean isInitOral = false;\n\n    public static void initOral(String aId, String sectId, String sectKey) {\n        appId = aId;\n        secretId = sectId;\n        secretKey = sectKey;\n        isInitOral = true;\n    }\n\n\n//    自行传入appId, secretId, secretKey等参数\n    public static final String soeAppId = \"\";\n    public static final String hcmAppId = \"\";\n    public static final String token = \"\";\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic interface RecordVoiceListener {\n\n    void onScoreOut(double score, String fileName);\n\n    void onAutoComplete();\n\n    void onError(int errorCode, String errorMsg);\n\n    /**\n     * 当声音大小发生变化\n     *\n     * @param newVolume 新的变化值\n     */\n    void onVolumeChanged(int newVolume);\n\n    /**\n     * 录音开始了\n     */\n    void onRecordStarted();\n\n    /**\n     * 静音模式\n     */\n    default void onSilence() {\n\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\npublic class TencentVoiceAnalysis implements Handler.Callback {\n\n    private final String TAG = \"CampVoiceAnalysis\";\n    //自动结束录音\n    private final int MESSAGE_AUDO_STOP_RECORD_VOICE = 1;\n    private final int MESSAGE_RECORD_VIDEO_COMPLETE = 2;\n    private final int MESSAGE_END_OF_VOICE_SCORE = 3;\n    private final int MESSAGE_NO_SOUND_DETECTED = 4;\n    private final int MESSAGE_VOICE_CHANGED = 5;\n    private final int MESSAGE_RECORD_START = 6;\n\n    private String RECORD_VOICE_FILE_NAME = \"kaishuOral.mp3\";\n    private String RECORD_VOICE_FILE_FOLDER = \"tencent_analysis_file\";\n    private Context mContext;\n\n    private Handler mHandler;\n    private TAIOralEvaluation mTaiOralEval;\n    private int mMaxVoiceSecond;\n    private int mSecond;//记录音频时长\n    private RecordVoiceListener mVoiceListener;\n\n    private boolean bNeedScoreResult = true;\n    private String mFileName = \"\";\n\n    //评测模式，默认英语\n    private int mServerType = TAIOralEvaluationServerType.ENGLISH;\n    //默认句子评估模式\n    private int mEvalMode = TAIOralEvaluationEvalMode.SENTENCE;\n    //文本模式\n    private int mTextMode = TAIOralEvaluationTextMode.NORMAL;\n    //苛刻指数[1.0-4.0] 1.0 简单\n    private float mScoreCoeff = 1.0f;\n    //存储模式，暂时无用\n    private int mStorageMode = TAIOralEvaluationStorageMode.DISABLE;\n    //默认超时时间\n    private int mTimeOut = 5;\n    //重试次数\n    private int mRetryTime = 5;\n\n    public TencentVoiceAnalysis(Context context) {\n        init(context);\n    }\n\n    public TencentVoiceAnalysis(Context context, String fileFolder, String fileName) {\n        init(context);\n        initParams(fileFolder, fileName);\n    }\n\n    private void init(Context context) {\n        this.mContext = context;\n        checkOralIsInitInApplication();\n        mHandler = new Handler(new WeakReference<>(TencentVoiceAnalysis.this).get());\n        checkaiOralEvalIsInit();\n    }\n\n    /**\n     * 使用智玲语音需要初始化appID，secretKey\n     */\n    private void checkOralIsInitInApplication() {\n        if (!KsVoiceAnalysisConfig.isInitOral) {\n            throw new IllegalArgumentException(\"Please initialize the sdk before useing it in your application.\");\n        }\n    }\n\n    private void checkaiOralEvalIsInit() {\n        if (this.mTaiOralEval == null) {\n            this.mTaiOralEval = new TAIOralEvaluation();\n        }\n    }\n\n    /**\n     *\n     * @param fileFolder\n     * @param fileName\n     */\n    public void initParams(String fileFolder, String fileName) {\n        if (!TextUtils.isEmpty(fileFolder)) {\n            this.RECORD_VOICE_FILE_FOLDER = fileFolder;\n        }\n\n        if (!TextUtils.isEmpty(fileName)) {\n            this.RECORD_VOICE_FILE_NAME = fileName;\n        }\n    }\n\n    @Override\n    public boolean handleMessage(Message msg) {\n        switch (msg.what) {\n            case MESSAGE_AUDO_STOP_RECORD_VOICE:\n                mSecond ++;\n                //LogUtil.d(TAG, \"录制了 \" + mSecond + \" 秒的音频\");\n                if (mSecond >= mMaxVoiceSecond) {\n                    stopRecord(true);\n                    mSecond = 0;\n                    return false;\n                }\n                mHandler.sendEmptyMessageDelayed(MESSAGE_AUDO_STOP_RECORD_VOICE, 1000);\n                break;\n            case MESSAGE_RECORD_VIDEO_COMPLETE://录音结束\n                boolean needCallBack = (boolean) msg.obj;\n                //LogUtil.d(TAG, \"结束了音频的录制 \" + needCallBack);\n                if (needCallBack && mVoiceListener != null) {\n                    mVoiceListener.onAutoComplete();\n                } else if (!needCallBack) {\n                    //LogUtil.d(TAG, \"no callback events required.\");\n                }\n                break;\n            case MESSAGE_END_OF_VOICE_SCORE://评分分数\n                double score = (double) msg.obj;\n                //LogUtil.d(TAG, \"评分的分数= \" + score);\n                if (mVoiceListener != null && bNeedScoreResult) {\n                    mVoiceListener.onScoreOut(score, mFileName);\n                }\n                break;\n            case MESSAGE_NO_SOUND_DETECTED://静音检测\n//                LogUtil.d(TAG, \"检测到静音模式\");\n                if (mVoiceListener != null) {\n                    mVoiceListener.onSilence();\n                }\n\n                break;\n            case MESSAGE_VOICE_CHANGED://音量变化\n//                LogUtil.d(TAG, \"音量发生了变化\");\n                if(mVoiceListener!=null){\n                    if(msg.obj instanceof Integer){\n                        mVoiceListener.onVolumeChanged((int)msg.obj);\n                    }\n\n                }\n\n                break;\n            case MESSAGE_RECORD_START://开始录音的回调\n//                LogUtil.d(TAG, \"开始录音\");\n//                if (mVoiceListener != null) {\n//                    mVoiceListener.onError(5000, \"录音出现异常，再试一次吧\");\n//                }\n\n                if (mVoiceListener != null) {\n                    mVoiceListener.onRecordStarted();\n                }\n                break;\n        }\n        return false;\n    }\n\n    /**\n     * 开始录音方法\n     * @param second 最长录制时间\n     * @param voiceText 待评测的文案\n     * @param listener 录音结果回调\n     */\n    public void startRecorder(int second, String voiceText, RecordVoiceListener listener) {\n        this.mMaxVoiceSecond = second;\n        this.mVoiceListener = listener;\n        mSecond = 0;\n\n        if (second > 0) {//需要倒计时结束\n            if (mHandler.hasMessages(MESSAGE_AUDO_STOP_RECORD_VOICE)) {\n                //LogUtil.d(TAG, \"已经开始了计时器\");\n                mHandler.removeCallbacksAndMessages(MESSAGE_AUDO_STOP_RECORD_VOICE);\n            }\n            mHandler.sendEmptyMessageDelayed(MESSAGE_AUDO_STOP_RECORD_VOICE, 1000);\n        }\n\n        AnalysisUtil.delteFiles(getStorageFile(RECORD_VOICE_FILE_NAME));\n        recordAudioByOral(voiceText);\n    }\n\n    /**\n     * 停止录音\n     * @param needCallBack 是否需要事件回调\n     */\n    public void stopRecord(final boolean needCallBack) {\n        bNeedScoreResult = needCallBack;\n        mHandler.removeCallbacksAndMessages(null);\n        if (mTaiOralEval.isRecording()) {\n            this.mTaiOralEval.stopRecordAndEvaluation(new TAIOralEvaluationCallback() {\n                @Override\n                public void onResult(TAIError error) {\n                    if (mHandler != null) {\n                        mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_RECORD_VIDEO_COMPLETE, needCallBack));\n                    }\n                }\n            });\n        } else {\n            Log.d(TAG, \"stop record error, no recording voice.\");\n        }\n    }\n\n    /**\n     * 智聆口语评测 SDK\n     * @param voiceText 评测文本\n     */\n    private void recordAudioByOral(String voiceText) {\n        checkaiOralEvalIsInit();\n        final File file = getStorageFile(RECORD_VOICE_FILE_NAME);\n        mFileName = file.getAbsolutePath();\n        this.mTaiOralEval.setListener(new TAIOralEvaluationListener() {\n            @Override\n            public void onEvaluationData(final TAIOralEvaluationData data, final TAIOralEvaluationRet result, final TAIError error) {\n                //评测出现错误\n                if (error.code != 0 && mVoiceListener != null) {\n                    mVoiceListener.onError(error.code, error.desc);\n                    return;\n                }\n\n                AnalysisUtil.writeFileToSDCard(data.audio, file, true, false);\n                if (result != null && mHandler != null) {//result 为空说明还是在按照时间片录制，不为空是有检测结果\n                    mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_END_OF_VOICE_SCORE, result.suggestedScore));\n                }\n            }\n\n            @Override\n            public void onEndOfSpeech() {\n                //静音检测回调\n                if (mHandler != null) {\n                    mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_NO_SOUND_DETECTED));\n                }\n            }\n\n            @Override\n            public void onVolumeChanged(final int volume) {\n                if (mHandler != null) {\n                    Message message = mHandler.obtainMessage(MESSAGE_VOICE_CHANGED);\n                    message.obj = volume;\n                    mHandler.sendMessage(message);\n                }\n            }\n        });\n\n        TAIOralEvaluationParam param = new TAIOralEvaluationParam();\n        param.context = mContext;\n        param.sessionId = UUID.randomUUID().toString();\n        param.appId = KsVoiceAnalysisConfig.appId;\n        param.soeAppId = KsVoiceAnalysisConfig.soeAppId;\n        param.secretId = KsVoiceAnalysisConfig.secretId;\n        param.secretKey = KsVoiceAnalysisConfig.secretKey;\n        param.token = KsVoiceAnalysisConfig.token;\n        int evalMode = mEvalMode;//评估模式\n        param.workMode = TAIOralEvaluationWorkMode.STREAM;//传输模式\n        param.evalMode = evalMode;\n        param.storageMode = mStorageMode;\n        param.fileType = TAIOralEvaluationFileType.MP3;\n        param.serverType = mServerType;// TAIOralEvaluationServerType.ENGLISH;\n        param.textMode = mTextMode;//文本模式\n        param.scoreCoeff = mScoreCoeff;//苛刻指数[1.0-4.0]\n        param.refText = voiceText;//被评估的文本\n        param.timeout = mTimeOut;//默认超时时间 30s\n        param.retryTimes = mRetryTime;//重试次数\n\n        TAIRecorderParam recordParam = new TAIRecorderParam();\n        recordParam.fragSize = (int) (1.0 * 1024);\n        recordParam.fragEnable = true;\n        recordParam.vadEnable = true;\n        recordParam.vadInterval = 4000;\n        this.mTaiOralEval.setRecorderParam(recordParam);\n        this.mTaiOralEval.startRecordAndEvaluation(param, new TAIOralEvaluationCallback() {\n            @Override\n            public void onResult(final TAIError error) {\n                //start record\n                if (mHandler != null) {\n                    mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_RECORD_START));\n                }\n            }\n        });\n\n    }\n\n    /**\n     * 提供的服务类型，目前只支持汉语和英语\n     * @param serverType 语音评测类型 TAIOralEvaluationServerType.ENGLISH, TAIOralEvaluationServerType.CHINESE\n     * @return\n     */\n    public TencentVoiceAnalysis setServerType(int serverType) {\n        this.mServerType = serverType;\n        return this;\n    }\n\n    /**\n     * 设置评估模式\n     * @param evalMode TAIOralEvaluationEvalMode.SENTENCE\n     * @return\n     */\n    public TencentVoiceAnalysis setEvalMode(int evalMode) {\n        this.mEvalMode = evalMode;\n        return this;\n    }\n\n    /**\n     * 文本评估模式\n     * 只支持两种：普通文本 和 音素结构文本，后面的不知道是啥意思\n     * @param textMode TAIOralEvaluationTextMode.NORMAL\n     * @return\n     */\n    public TencentVoiceAnalysis setTextMode(int textMode) {\n        this.mTextMode = textMode;\n        return this;\n    }\n\n    /**\n     * 设置严苛模式 1.0 - 4.0 ，1.0  - 4.0 由简单到难\n     * @param scoreCoeff\n     * @return\n     */\n    public TencentVoiceAnalysis setScoreCoeff(float scoreCoeff) {\n        this.mScoreCoeff = scoreCoeff;\n        return this;\n    }\n\n    /**\n     * 设置存储模式，内部或外部存储，暂时没有用到\n     * @param storageMode TAIOralEvaluationStorageMode.DISABLE\n     * @return\n     */\n    public TencentVoiceAnalysis setStorageMode(int storageMode) {\n        this.mStorageMode = storageMode;\n        return this;\n    }\n\n    /**\n     * 设置超时时间\n     * @param timeout 单位秒\n     * @return\n     */\n    public TencentVoiceAnalysis setTimeOut(int timeout) {\n        mTimeOut = timeout;\n        return this;\n    }\n\n    /**\n     * 设置重试次数\n     * @param retryTime\n     * @return\n     */\n    public TencentVoiceAnalysis setRetryTime(int retryTime) {\n        mRetryTime = retryTime;\n        return this;\n    }\n\n    /**\n     * 创建存储文件\n     */\n    private File getStorageFile(String fileName) {\n        File fileDir = AnalysisUtil.getIndividualCacheDirectory(mContext, RECORD_VOICE_FILE_FOLDER);\n        if (!fileDir.exists()) {\n            fileDir.mkdirs();\n        }\n        return new File(fileDir.getAbsolutePath() + File.separator + fileName);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 101\n        versionName \"101\"\n\n        externalNativeBuild {\n            cmake {\n                cppFlags \"-fexceptions\"\n                cFlags \"-DSTDC_HEADERS\"\n                arguments \"-DANDROID_ARM_NEON=TRUE\"\n            }\n        }\n\n        ndk {\n            abiFilters 'armeabi-v7a'\n        }\n    }\n\n    sourceSets{\n        main {\n            jniLibs.srcDirs = ['libs']\n        }\n    }\n\n    repositories {\n        flatDir { dirs 'libs' }\n    }\n\n    splits {//删除64位的so库\n        abi {\n            enable true\n            reset()\n            include 'armeabi-v7a'\n            universalApk false\n        }\n    }\n\n    //    externalNativeBuild {\n//        cmake {\n//            path \"CMakeLists.txt\"\n//        }\n//    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    compileOptions {\n        sourceCompatibility = 1.8\n        targetCompatibility = 1.8\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n    implementation 'androidx.core:core-ktx:1.0.2'\n\n    api deps.kotlin.coroutines_core\n    api deps.kotlin.coroutines_android\n\n    api 'com.tencent.taisdk:TAISDK:1.2.3.35'\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598584070416},"updatedAt":{"$$date":1598584981538},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uLWhP4Cu8jj7dH7B"}
{"name":"qk-ks_component_tracker","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    libraryVariants.all {\n        it.getGenerateBuildConfigProvider()\n    }\n\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    android {\n        lintOptions {\n            abortOnError false\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\n    implementation deps.kotlin.coroutines_core\n    implementation deps.kotlin.coroutines_android\n\n    if (develop) {\n        implementation project(':ks_component_net')\n    } else {\n        implementation ks.component_net\n    }\n    implementation deps.google_gson\n    implementation 'org.litepal.android:kotlin:3.0.0'\n}\n\n////这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\nassets\nlitepal.xml\njava\ntracker\ndata\nKsTrackerService\nTrackerHolder\nTrackerRepository\ndb\nTrackerDb\ndelegate\nKsTrackerDelegate\nutils\nBase64Local\nKsTrackerDataUtils\nLogUtil\nTimeDateUtils\nKsTrackConfiguration\nTracker\nUPLOAD_CATEGORY\n\n\n\n\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<litepal>\n    <!--\n        Define the database name of your application.\n        By default each database name should be end with .db.\n        If you didn't name your database end with .db,\n        LitePal would plus the suffix automatically for you.\n        For example:\n        <dbname value=\"demo\" />\n    -->\n    <dbname value=\"trackCache\" />\n\n    <!--\n        Define the version of your database. Each time you want\n        to upgrade your database, the version tag would helps.\n        Modify the models you defined in the mapping tag, and just\n        make the version value plus one, the upgrade of database\n        will be processed automatically without concern.\n            For example:\n        <version value=\"1\" />\n    -->\n    <version value=\"1\" />\n\n    <!--\n        Define your models in the list with mapping tag, LitePal will\n        create tables for each mapping class. The supported fields\n        defined in models will be mapped into columns.\n        For example:\n        <list>\n            <mapping class=\"com.test.model.Reader\" />\n            <mapping class=\"com.test.model.Magazine\" />\n        </list>\n    -->\n    <list>\n        <mapping class=\"com.ks.tracker.db.TrackerDb\"></mapping>\n    </list>\n\n    <!--\n        Define where the .db file should be. \"internal\" means the .db file\n        will be stored in the database folder of internal storage which no\n        one can access. \"external\" means the .db file will be stored in the\n        path to the directory on the primary external storage device where\n        the application can place persistent files it owns which everyone\n        can access. \"internal\" will act as default.\n        For example:\n        <storage value=\"external\" />\n    -->\n\n    <!-- 直接设置这个，就表示数据库存储的位置，直接打开手机存储就可以找到 -->\n    <!--<storage value=\"guolin/database\" />-->\n</litepal>\n\n\n\n\n\n\n\n\n\n\ninterface KsTrackerService {\n\n    /**\n     * 上传打点\n     * @return\n     */\n    @Headers(NetConstants.HeaderContentTypeLong,\"${GlobalUrlManager.DOMAIN}:accesslogs\")\n    @POST(\"v1/pagelog/accesslogs\")\n    suspend fun accessLogs(@Body requestBody: RequestBody): KsResponse<Any>\n}\n\n\n\nclass TrackerRepository : KsBaseRepository() {\n\n    suspend fun upLoadTrackerData(\n        jsonObject: String\n    ): KsResult<Any> {\n\n        return safeApiCall(call = { upLoadTrackerData2(jsonObject.toRequestBody()) })\n    }\n\n    private suspend fun upLoadTrackerData2(\n        requestBody: RequestBody\n    ): KsResult<Any> =\n        executeResponse(getService().accessLogs(requestBody))\n\n\n    private fun getService(): KsTrackerService =\n        KsRetrofitClient.getService(KsTrackerService::class.java)\n}\n\nobject TrackerHolder {\n\n    private lateinit var requestContent: String\n\n    private val trackerRepository by lazy { TrackerRepository() }\n\n    suspend fun accessLogs(\n        data: String\n    ): KsResult<Any> {\n        requestContent = if (KsTrackerDataUtils.hasLower(data) === true) {\n            data\n        } else {\n            Gson().toJson(data)\n        }\n        LogUtil.i(\" content =$requestContent\")\n        return trackerRepository.upLoadTrackerData(requestContent)\n    }\n\n}\n\n\n\n\n\n\n\n\nclass TrackerDb(var type: String?, private var userData: String?, var eventTime: String?) :\n    LitePalSupport() {\n\n    override fun toString(): String {\n        return userData.toString()\n    }\n}\n\n\n\n\n\n\n\n@Keep\nobject KsTrackerDelegate {\n\n    private val KEY_TRACKER_COUNT: String = \"key_tracker_count\"\n    var uploadCount: Int by Preference(KEY_TRACKER_COUNT, 6)\n\n    var strategyStarted: Boolean = false\n    private var config: KsTrackerConfig? = null\n    private var isInit: Boolean = false\n    fun init(config: KsTrackerConfig) {\n        if (isInit) {\n            return\n        }\n        KsTrackerDelegate.config = config\n        isInit = true\n    }\n\n\n    fun getDynamicSuperProperties(): JSONObject {\n        return checkConfig().getDynamicSuperProperties()\n    }\n\n    fun getProjectName(): String {\n        return checkConfig().getProjectName()\n    }\n\n    fun getDeviceId(): String {\n        return checkConfig().getDeviceId()\n    }\n\n    interface KsTrackerConfig {\n        fun getDynamicSuperProperties(): JSONObject\n        fun getProjectName(): String\n        fun getDeviceId(): String\n    }\n\n\n    fun checkConfig(): KsTrackerConfig {\n        if (config == null) {\n            throw RuntimeException(\"请先调用 KsTrackerDelegate.init(config: KsTrackerConfig) 初始化 打点的基本信息\")\n        }\n\n        return config!!\n    }\n}\n\n\n\n\n\n\n\n\nclass KsTrackConfiguration {\n\n    var isOpenLog: Boolean = false\n        private set\n\n    /**\n     * 上传策略\n     */\n    private var uploadCategory: Int = 0\n\n\n    private var mFlushBulkSize = 10\n\n    /**\n     * 按分上传----默认15秒--最大60分钟\n     */\n    private var mSeconds = 15\n\n    /**\n     * 设置本地缓存最多事件条数，默认为 10000 条\n     */\n    private var mMaxCacheSize = 10000\n\n\n    private var _uploadCategory: UPLOAD_CATEGORY? = null\n\n    init {\n        isOpenLog = false\n        _uploadCategory = UPLOAD_CATEGORY.NEXT_LAUNCH\n    }\n\n    fun openLog(openLog: Boolean): KsTrackConfiguration {\n        LogUtil.openLog(openLog)\n        this.isOpenLog = openLog\n        return this\n    }\n\n\n    fun initializeDb(context: Context): KsTrackConfiguration {\n        LitePal.initialize(context)\n        return this\n    }\n\n\n    fun setFlushBulkSize(flushBulkSize: Int): KsTrackConfiguration {\n        this.mFlushBulkSize = flushBulkSize\n        return this\n    }\n\n\n    fun setMaxCacheSize(maxCacheSize: Int): KsTrackConfiguration {\n        mMaxCacheSize = when {\n            maxCacheSize >= 10000 -> 10000\n            else -> maxCacheSize\n        }\n        return this\n    }\n\n    fun setSeconds(seconds: Int): KsTrackConfiguration {\n        if (seconds > 60 * 1000) {\n            mSeconds = 60 * 1000\n        } else {\n            this.mSeconds = seconds\n        }\n        return this\n    }\n\n\n    fun setUploadCategory(uploadCategory: Int): KsTrackConfiguration {\n        this.uploadCategory = uploadCategory\n        this._uploadCategory = UPLOAD_CATEGORY.getCategory(uploadCategory)\n        return this\n    }\n\n\n    fun getUploadCategory(): UPLOAD_CATEGORY? {\n        return _uploadCategory\n    }\n\n\n    fun getmFlushBulkSize(): Int {\n        return mFlushBulkSize\n    }\n\n    fun getmMaxCacheSize(): Int {\n        return mMaxCacheSize\n    }\n\n    fun getSeconds(): Int {\n        return mSeconds\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598584071467},"updatedAt":{"$$date":1598585338899},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uP1R4NHQGfKlt1Sk"}
{"name":"kotlin-排序 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-ordering.html\n排序 - Kotlin 语言中文站\n14-18 minutes\n改进翻译\n元素的顺序是某些集合类型的一个重要方面。 例如，如果拥有相同元素的两个列表的元素顺序不同，那么这两个列表也不相等。\n\n在 Kotlin 中，可以通过多种方式定义对象的顺序。\n\n首先，有 自然 顺序。它是为 Comparable 接口的继承者定义的。 当没有指定其他顺序时，使用自然顺序为它们排序。\n\n大多数内置类型是可比较的：\n\n数值类型使用传统的数值顺序：1 大于 0； -3.4f 大于 -5f，以此类推。\nChar 和 String 使用字典顺序： b 大于 a； world 大于 hello。\n如需为用户定义的类型定义一个自然顺序，可以让这个类型继承 Comparable。 这需要实现 compareTo() 函数。 compareTo() 必须将另一个具有相同类型的对象作为参数并返回一个整数值来显示哪个对象更大：\n\n正值表明接收者对象更大。\n负值表明它小于参数。\n0 说明对象相等。\n下面是一个类，可用于排序由主版本号和次版本号两部分组成的版本。\n\nclass Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        } else if (this.minor != other.minor) {\n            return this.minor - other.minor\n        } else return 0\n    }\n}\n\nfun main() {    \n    println(Version(1, 2) > Version(1, 3))\n    println(Version(2, 0) > Version(1, 5))\n}\n自定义 顺序让你可以按自己喜欢的方式对任何类型的实例进行排序。 特别是，你可以为不可比较类型定义顺序，或者为可比较类型定义非自然顺序。 如需为类型定义自定义顺序，可以为其创建一个 Comparator。 Comparator 包含 compare() 函数：它接受一个类的两个实例并返回它们之间比较的整数结果。 如上所述，对结果的解释与 compareTo() 的结果相同。\n\nfun main() {\n//sampleStart\n    val lengthComparator = Comparator { str1: String, str2: String -> str1.length - str2.length }\n    println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(lengthComparator))\n//sampleEnd\n}\n\n有了 lengthComparator，你可以按照字符串的长度而不是默认的字典顺序来排列字符串。\n\n定义一个 Comparator 的一种比较简短的方式是标准库中的 compareBy() 函数。 compareBy() 接受一个 lambda 表达式，该表达式从一个实例产生一个 Comparable 值，并将自定义顺序定义为生成值的自然顺序。 使用 compareBy()，上面示例中的长度比较器如下所示：\n\nfun main() {\n//sampleStart    \nprintln(listOf(\"aaa\", \"bb\", \"c\").sortedWith(compareBy { it.length }))\n//sampleEnd\n}\n\nKotlin 集合包提供了用于按照自然顺序、自定义顺序甚至随机顺序对集合排序的函数。 在此页面上，我们将介绍适用于只读集合的排序函数。 这些函数将它们的结果作为一个新集合返回，集合里包含了按照请求顺序排序的来自原始集合的元素。 如果想学习就地对可变集合排序的函数，请参见 List 相关操作。\n\n基本的函数 sorted() 和 sortedDescending() 返回集合的元素，这些元素按照其自然顺序升序和降序排序。 这些函数适用于 Comparable 元素的集合。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(\"Sorted ascending: ${numbers.sorted()}\")\n    println(\"Sorted descending: ${numbers.sortedDescending()}\")\n//sampleEnd\n}\n\n为了按照自定义顺序排序或者对不可比较对象排序，可以使用函数 sortedBy() 和 sortedByDescending()。 它们接受一个将集合元素映射为 Comparable 值的选择器函数，并以该值的自然顺序对集合排序。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    val sortedNumbers = numbers.sortedBy { it.length }\n    println(\"Sorted by length ascending: $sortedNumbers\")\n    val sortedByLast = numbers.sortedByDescending { it.last() }\n    println(\"Sorted by the last letter descending: $sortedByLast\")\n//sampleEnd\n}\n\n如需为集合排序定义自定义顺序，可以提供自己的 Comparator。 为此，调用传入 Comparator 的 sortedWith() 函数。 使用此函数，按照字符串长度排序如下所示：\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Sorted by length ascending: ${numbers.sortedWith(compareBy { it.length })}\")\n//sampleEnd\n}\n\n你可以使用 reversed() 函数以相反的顺序检索集合。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.reversed())\n//sampleEnd\n}\n\nreversed() 返回带有元素副本的新集合。 因此，如果你之后改变了原始集合，这并不会影响先前获得的 reversed() 的结果。\n\n另一个反向函数——asReversed()——返回相同集合实例的一个反向视图，因此，如果原始列表不会发生变化，那么它会比 reversed() 更轻量，更合适。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n//sampleEnd\n}\n\n如果原始列表是可变的，那么其所有更改都会反映在其反向视图中，反之亦然。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n    numbers.add(\"five\")\n    println(reversedNumbers)\n//sampleEnd\n}\n\n但是，如果列表的可变性未知或者源根本不是一个列表，那么 reversed() 更合适，因为其结果是一个未来不会更改的副本。\n\n最后，shuffled() 函数返回一个包含了以随机顺序排序的集合元素的新的 List。 你可以不带参数或者使用 Random 对象来调用它。\n\nfun main() {\n//sampleStart\n     val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n     println(numbers.shuffled())\n//sampleEnd\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382133880},"updatedAt":{"$$date":1597384948720},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uVUfBjuYBql1DWTa"}
{"name":"kotlin-kotlin入门中文教程（1）","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\njuejin.im /post/6844904017408032781\nkotlin入门中文教程（1） - 掘金\n叶志陈 2019年12月10日 阅读 4422 已关注\n36-46 minutes\n本文已收录至学习笔记大全：JavaKotlinAndroidGuide\n\n作者：leavesC\n\n[TOC]\n\n一、Hello World\n按照国际惯例，学习一门新的语言通常都是从 Hello World 开始的，在这里也不例外\n\npackage main\n\nfun main(args: Array<String>) {\n    println(\"Hello World\")\n}\n复制代码\n从这个简单的函数就可以列出 kotlin 和 Java 的几点不同\n\n函数可以定义在文件的最外层，不需要把它放在类中\n用关键字 fun 来声明一个函数\n参数类型写在变量名之后，这有助于在类型自动推导时省略类型声明\n数组就是类。和 Java 不同，kotlin 没有声明数组类型的特殊语法\n使用 println 代替了 System.out.println ，这是 kotlin 标准库提供的对 Java 标准库函数的封装\n可以省略代码结尾的分号\n此外，kotlin 的最新版本已经可以省略 main 方法的参数了\n\n二、Package\nkotlin 文件都以一条 package 语句开头，文件中定义的所有声明（类、函数和属性）都会被放到这个包中。如果其他文件中定义的声明也有相同的包，这个文件可以直接使用它们，如果包不相同则需要导入它们\n\n包的声明应处于源文件顶部，import 语句紧随其后\n\npackage base\n\nimport java.text.SimpleDateFormat\nimport java.util.*\n复制代码\nkotlin 不区分导入的是类还是函数，允许使用 import 关键字导入任何种类的声明。此外，也可以在包名称后加上 .* 来导入特定包中定义的所有声明，这不仅会让包中定义的类可见，也会让顶层函数和属性可见\n\npackage learn.package2\n\nval index = 10\n\nfun Test(status: Boolean) = println(status)\n\nclass Point(val x: Int, val y: Int) {\n\n    val isEquals1: Boolean\n        get() {\n            return x == y\n        }\n\n    val isEquals2\n        get() = x == y\n\n    var isEquals3 = false\n        get() = x > y\n        set(value) {\n            field = !value\n        }\n\n}\n复制代码\npackage learn.package1\n\nimport learn.package2.Point\nimport learn.package2.Test\nimport learn.package2.index\n\nfun main() {\n    val point = Point(10, index)\n    Test(true)\n}\n复制代码\nJava 语言规定类要放到和包结构匹配的文件夹目录结构中，而 kotlin 允许把多个类放到同一个文件中，文件名也可以任意选择。kotlin 也没有对磁盘上源文件的布局强加任何限制，包层级结构不需要遵循目录层级结构 ,但最好还是遵循 Java 的目录布局并根据包结构把源码文件放到相应的目录中\n\n如果包名出现命名冲突，可以使用 as 关键字在本地重命名冲突项来消歧义\n\nimport learn.package1.Point\nimport learn.package2.Point as PointTemp \n复制代码\nkotlin 中也有一个类似的概念可以用来重命名现有类型，叫做类型别名。类型别名用于为现有类型提供一个替代名称，如果类型名称比较长，就可以通过引入一个较短或者更为简略的名称来方便记忆\n\n类型别名不会引入新的类型，依然相应其底层类型，所以在下述代码中输出的 class 类型是一致的\n\nclass Base {\n\n    class InnerClass\n\n}\n\ntypealias BaseInner = Base.InnerClass\n\nfun main() {\n    val baseInner1 = Base.InnerClass()\n    val baseInner2 = BaseInner()\n    println(baseInner1.javaClass) \n    println(baseInner2.javaClass) \n}\n复制代码\n三、变量与数据类型\n在 Java 中，大部分的变量是可变的（非 final 的），意味着任何可以访问到这个变量的代码都可以去修改它。而在 kotlin 中，变量可以分为 可变变量(var) 和 不可变变量(val) 两类\n\n声明变量的关键字有两个：\n\nval（value / varible+final）——不可变引用。使用 val 声明的变量不能在初始化之后再次赋值，对应的是 Java 中的 final 变量\nvar（variable）——可变引用。var 变量的值可以被改变，对应的是 Java 中的非 final 变量\n不可变变量在赋值之后就不能再去改变它的状态了，因此不可变变量可以说是线程安全的，因为它们无法改变，所有线程访问到的对象都是同一个，因此也不需要去做访问控制。开发者应当尽可能地使用不可变变量，这样可以让代码更加接近函数式编程风格\n\n编程领域中也推崇一种开发原则：尽可能使用 val，不可变对象及纯函数来设计程序。这样可以尽量避免副作用带来的影响\n\nfun main() {\n    \n    \n    val intValue: Int = 100\n\n    \n    var doubleValue: Double = 100.0\n}\n复制代码\n在声明变量时我们通常不需要显式指明变量的类型，这可以由编译器根据上下文自动推导出来。如果只读变量在声明时没有初始值，则必须指明变量类型，且在使用前必须确保在各个分支条件下变量可以被初始化，否则编译期会报异常\n\nfun main() {\n    val intValue = 1002222222222\n    val doubleValue = 100.0\n    val longValue = 100L\n\n    \n    val intValue2: Int\n    if (false) {\n        intValue2 = 10\n    }\n    println(intValue2) \n}\n复制代码\n3.1、基本数据类型\n与 Java 不同，kotlin 并不区分基本数据类型和它的包装类，在 kotlin 中一切都是对象，可以在任何变量上调用其成员函数和属性。kotlin 没有像 Java 中那样的原始基本类型，但 byte、char、integer、float 或者 boolean 等类型仍然有保留，但是全部都作为对象存在\n\n对于基本类型，kotlin 相比 Java 有几点特殊的地方\n\n数字、字符和布尔值可以在运行时表示为原生类型值，但对开发者来说，它们看起来就像普通的类\n对于数字没有隐式拓宽转换，而在 Java 中 int 可以隐式转换为 long\n所有未超出 Int 最⼤值的整型值初始化的变量都会自动推断为 Int 类型，如果初始值超过了其最⼤值，则会推断为 Long 类型， 如需显式指定 Long 类型值可在该值后追加 L 后缀\n字符不能视为数字\n不支持八进制\n    \n\n    val intIndex: Int = 100\n    \n    val intIndex = 100\n\n    \n    val doubleIndex: Double = intIndex.toDouble()\n    \n    \n\n    val intValue: Int = 1\n    val longValue: Long = 1\n    \n    \n\n    \n    val ch: Char = 'c'\n    val charValue: Int = ch.toInt()\n    \n    \n\n    \n    val value1 = 0b00101\n    \n    val value2 = 0x123\n复制代码\n此外，kotlin 的可空类型不能用 Java 的基本数据类型表示，因为 null 只能被存储在 Java 的引用类型的变量中，这意味着只要使用了基本数据类型的可空版本，它就会被编译成对应的包装类型\n\n    \n    val intValue_1: Int = 200\n    \n    val intValue_2: Int? = intValue_1\n    val intValue_3: Int? = intValue_1\n    \n    println(intValue_2 == intValue_3)\n    \n    println(intValue_2 === intValue_3)\n复制代码\n如果 intValue_1 的值是100，就会发现 intValue_2 === intValue_3 的比较结果是 true，这就涉及到 Java 对包装类对象的重复使用问题了\n\n3.2、字符串\nkotlin 与 Java 一样用 String 类型来表示字符串，字符串是不可变的，可以使用索引运算符访问[] 来访问包含的单个字符，也可以用 for 循环来迭代字符串，此外也可以用 + 来连接字符串\n\n    val str = \"leavesC\"\n    println(str[1])\n    for (c in str) {\n        println(c)\n    }\n    val str1 = str + \" hello\"\n复制代码\nkotlin 支持在字符串字面值中引用局部变量，只需要在变量名前加上字符 $ 即可，此外还可以包含用花括号括起来的表达式，此时会自动求值并把结果合并到字符串中\n\n    val intValue = 100\n    \n    println(\"intValue value is $intValue\") \n    \n    println(\"(intValue + 100) value is ${intValue + 100}\")   \n复制代码\n如果你需要在原始字符串中表示字面值（$）字符（它不支持反斜杠转义），可以用下列语法：\n\n    val price = \"${'\n   \n  \n  \n  \n\n\n}100.99\"\n    println(price)  \n复制代码\n3.3、数组\nkotlin 中的数组是带有类型参数的类，其元素类型被指定为相应的类型参数，使用 Array 类来表示， Array 类定义了 get 与 set 函数（按照运算符重载约定这会转变为 [ ] ）以及 size 属性等\n\n创建数组的方法有以下几种：\n\n用 arrayOf 函数创建一个数组，包含的元素是指定为该函数的实参\n用 arrayOfNulls 创建一个给定大小的数组，包含的元素均为 null，只能用来创建包含元素类型可空的数组\n调用 Array 类的构造方法，传递数组的大小和一个 lambda 表达式，调用 lambda 表达式来创建每一个数组元素\n    \n    val array1 = arrayOf(\"leavesC\", \"叶\", \"https://github.com/leavesC\")\n\n    array1[0] = \"leavesC\"\n    println(array1[1])\n    println(array1.size)\n\n    \n    val array2 = arrayOfNulls<String>(10)\n\n    \n    val array3 = Array(26) { i -> ('a' + i).toString() }\n复制代码\n需要注意的是，数组类型的类型参数始终会变成对象类型，因此声明 Array< Int > 将是一个包含装箱类型（java.lang.Integer）的数组。如果想要创建没有装箱的基本数据类型的数组，必须使用一个基本数据类型数组的特殊类\n\n为了表示基本数据类型的数组，kotlin 为每一种基本数据类型都提供了若干相应的类并做了特殊的优化。例如，有 IntArray、ByteArray、BooleanArray 等类型，这些类型都会被编译成普通的 Java 基本数据类型数组，比如 int[]、byte[]、boolean[] 等，这些数组中的值存储时没有进行装箱，而是使用了可能的最高效的方式。需要注意，IntArray 等并不是 Array 的子类\n\n要创建一个基本数据类型的数组，有以下几种方式：\n\n向对应类型的类（如 IntArray）的构造函数传递数组大小，这将返回一个使用对应基本数据类型默认值初始化好的数组\n向对应类型的类（如 IntArray）的构造函数传递数组大小以及用来初始化每个元素的 lambda\n向工厂函数（如 charArrayOf）传递变长参数的值，从而得到指定元素值的数组\n    \n    val intArray = IntArray(5)\n    \n    val doubleArray = DoubleArray(5) { Random().nextDouble() }\n    \n    val charArray = charArrayOf('H', 'e', 'l', 'l', 'o')\n复制代码\n3.4、Any 和 Any?\nAny 类型是 kotlin 所有非空类型的超类型，包括像 Int 这样的基本数据类型\n\n如果把基本数据类型的值赋给 Any 类型的变量，则会自动装箱\n\nval any: Any = 100\nprintln(any.javaClass) \n复制代码\n如果想要使变量可以存储包括 null 在内的所有可能的值，则需要使用 Any?\n\nval any: Any? = null\n复制代码\n3.5、Unit\nkotlin 中的 Unit 类型类似于 Java 中的 void，可以用于函数没有返回值时的情况\n\nfun check(): Unit {\n\n}\n\n\nfun check() {\n\n}\n复制代码\nUnit 是一个完备的类型，可以作为类型参数，但 void 不行\n\ninterface Test<T> {\n    fun test(): T\n}\n\nclass NoResultClass : Test<Unit> {\n    \n    \n    override fun test() {\n\n    }\n\n}\n复制代码\n3.6、Nothing\nNothing 类型没有任何值，只有被当做函数返回值使用，或者被当做泛型函数返回值的类型参数使用时才会有意义，可以用 Nothing 来表示一个函数不会被正常终止，从而帮助编译器对代码进行诊断\n\n编译器知道返回值为 Nothing 类型的函数从不正常终止，所以编译器会把 name1 的类型推断为非空，因为 name1 在为 null 时的分支处理会始终抛出异常\n\ndata class User(val name: String?)\n\nfun fail(message: String): Nothing {\n    throw IllegalStateException(message)\n}\n\nfun main() {\n    val user = User(\"leavesC\")\n    val name = user.name ?: fail(\"no name\")\n    println(name) \n\n    val user1 = User(null)\n    val name1 = user1.name ?: fail(\"no name\")\n    println(name1.length) \n}\n复制代码\n四、函数\nkotlin 中的函数以关键字 fun 作为开头，函数名称紧随其后，再之后是用括号包裹起来的参数列表，如果函数有返回值，则再加上返回值类型，用一个冒号与参数列表隔开\n\n        \n        \n        fun getNameLastChar(): Char {\n            return name.get(name.length - 1)\n        }\n复制代码\n        \n        \n        fun test1(str: String, int: Int): Int {\n            return str.length + int\n        }\n复制代码\n此外，表达式函数体的返回值类型可以省略，返回值类型可以自动推断，这种用单行表达式与等号定义的函数叫做表达式函数体。但对于一般情况下的有返回值的代码块函数体，必须显式地写出返回类型和 return 语句\n\n        \n        \n        \n        fun getNameLastChar() = name.get(name.length - 1)\n复制代码\n如果函数没有有意义的返回值，则可以声明为 Unit ，也可以省略 Unit\n\n以下三种写法都是等价的\n\n        fun test(str: String, int: Int): Unit {\n            println(str.length + int)\n        }\n\n        fun test(str: String, int: Int) {\n            println(str.length + int)\n        }\n\n        fun test(str: String, int: Int) = println(str.length + int)\n复制代码\n4.1、命名参数\n为了增强代码的可读性，kotlin 允许我们使用命名参数，即在调用某函数的时候，可以将函数参数名一起标明，从而明确地表达该参数的含义与作用，但是在指定了一个参数的名称后，之后的所有参数都需要标明名称\n\nfun main() {\n    \n    \n    compute(index = 120, value = \"leavesC\")\n    compute(130, value = \"leavesC\")\n}\n\nfun compute(index: Int, value: String) {\n\n}\n复制代码\n4.2、默认参数值\n可以在声明函数的时候指定参数的默认值，从而避免创建重载的函数\n\nfun main() {\n    compute(24)\n    compute(24, \"leavesC\")\n}\n\nfun compute(age: Int, name: String = \"leavesC\") {\n\n}\n复制代码\n对于以上这个例子，如果按照常规的调用语法时，必须按照函数声明定义的参数顺序来给定参数，可以省略的只有排在末尾的参数\n\nfun main() {\n    \n    \n    \n    \n    compute(\"leavesC\", 24)\n}\n\nfun compute(name: String = \"leavesC\", age: Int, value: Int = 100) {}\n复制代码\n如果使用命名参数，可以省略任何有默认值的参数，而且也可以按照任意顺序传入需要的参数\n\nfun main() {\n    compute(age = 24)\n    compute(age = 24, name = \"leavesC\")\n    compute(age = 24, value = 90, name = \"leavesC\")\n    compute(value = 90, age = 24, name = \"leavesC\")\n}\n\nfun compute(name: String = \"leavesC\", age: Int, value: Int = 100) {\n\n}\n复制代码\n4.3、可变参数\n可变参数可以让我们把任意个数的参数打包到数组中传给函数，kotlin 的语法相比 Java 有所不同，改为通过使用 varage 关键字声明可变参数\n\n例如，以下的几种函数调用方式都是正确的\n\nfun main() {\n    compute()\n    compute(\"leavesC\")\n    compute(\"leavesC\", \"叶应是叶\")\n    compute(\"leavesC\", \"叶应是叶\", \"叶\")\n}\n\nfun compute(vararg name: String) {\n    name.forEach { println(it) }\n}\n复制代码\n在 Java 中，可以直接将数组传递给可变参数，而 kotlin 要求显式地解包数组，以便每个数组元素在函数中能够作为单独的参数来调用，这个功能被称为展开运算符，使用方式就是在数组参数前加一个 *\n\nfun main() {\n    val names = arrayOf(\"leavesC\", \"叶应是叶\", \"叶\")\n    compute(* names)\n}\n\nfun compute(vararg name: String) {\n    name.forEach { println(it) }\n}\n复制代码\n4.4、局部函数\nkotlin 支持在函数中嵌套函数，被嵌套的函数称为局部函数\n\nfun main() {\n    compute(\"leavesC\", \"country\")\n}\n\nfun compute(name: String, country: String) {\n    fun check(string: String) {\n        if (string.isEmpty()) {\n            throw IllegalArgumentException(\"参数错误\")\n        }\n    }\n    check(name)\n    check(country)\n}\n复制代码\n五、表达式和条件循环\n5.1、语句和表达式\n这里需要先区分“语句”和“表达式”这两个概念。语句是可以单独执行，能够产生实际效果的代码，表现为赋值逻辑、打印操作、流程控制等形式，Java 中的流程控制（if，while，for）等都是语句。表达式可以是一个值、变量、常量、操作符、或它们之间的组合，表达式可以看做是包含返回值的语句\n\n例如，以下的赋值操作、流程控制、打印输出都是语句，其是作为一个整体存在的，且不包含返回值\n\n    val a = 10\n    for (i in 0..a step 2) {\n        println(i)\n    }\n复制代码\n再看几个表达式的例子\n\n1       \n++1     \n\nfun getLength(str: String?): Int {\n    return if (str.isNullOrBlank()) 0 else str.length\n}\n复制代码\n5.2、If 表达式\nif 的分支可以是代码块，最后的表达式作为该块的返回值\n\n    val maxValue = if (20 > 10) {\n        println(\"maxValue is 20\")\n        20\n    } else {\n        println(\"maxValue is 10\")\n        10\n    }\n    println(maxValue) \n复制代码\n以下代码可以显示地看出 if 的返回值，完全可以用来替代 Java 中的三元运算符，因此 kotlin 并没有三元运算符\n\n    val list = listOf(1, 4, 10, 4, 10, 30)\n    val value = if (list.size > 0) list.size else null\n    println(value)  \n复制代码\n如果 if 表达式分支是用于执行某个命令，那么此时的返回值类型就是 Unit ，此时的 if 语句就看起来和 Java 的一样了\n\n    val value1 = if (list.size > 0) println(\"1\") else println(\"2\")\n    println(value1.javaClass)   \n复制代码\n如果将 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支\n\n5.3、when 表达式\nwhen 表达式与 Java 中的 switch/case 类似，但是要强大得多。when 既可以被当做表达式使用也可以被当做语句使用，when 将参数和所有的分支条件顺序比较直到某个分支满足条件，然后它会运行右边的表达式。如果 when 被当做表达式来使用，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。与 Java 的 switch/case 不同之处是 When 表达式的参数可以是任何类型，并且分支也可以是一个条件\n\n和 if 一样，when 表达式每一个分支可以是一个代码块，它的值是代码块中最后的表达式的值，如果其它分支都不满足条件将会求值于 else 分支\n\n如果 when 作为一个表达式使用，则必须有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了。如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔\n\n    val value = 2\n    when (value) {\n        in 4..9 -> println(\"in 4..9\") \n        3 -> println(\"value is 3\")    \n        2, 6 -> println(\"value is 2 or 6\")    \n        is Int -> println(\"is Int\")   \n        else -> println(\"else\")       \n    }\n复制代码\nfun main() {\n    \n    fun parser(obj: Any): String =\n            when (obj) {\n                1 -> \"value is 1\"\n                \"4\" -> \"value is string 4\"\n                is Long -> \"value type is long\"\n                else -> \"unknown\"\n            }\n    println(parser(1))\n    println(parser(1L))\n    println(parser(\"4\"))\n    println(parser(100L))\n    println(parser(100.0))\n}\n\nvalue is 1\nvalue type is long\nvalue is string 4\nvalue type is long\nunknown\n复制代码\n此外，When 循环也可以不带参数\n\n    when {\n        1 > 5 -> println(\"1 > 5\")\n        3 > 1 -> println(\"3 > 1\")\n    }\n复制代码\n5.4、for 循环\n和 Java 中的 for 循环最为类似的形式是\n\n    val list = listOf(1, 4, 10, 34, 10)\n    for (value in list) {\n        println(value)\n    }\n复制代码\n通过索引来遍历\n\n    val items = listOf(\"H\", \"e\", \"l\", \"l\", \"o\")\n    \n    for (index in items.indices) {\n        println(\"${index}对应的值是：${items[index]}\")\n    }\n复制代码\n也可以在每次循环中获取当前索引和相应的值\n\n    val list = listOf(1, 4, 10, 34, 10)\n    for ((index, value) in list.withIndex()) {\n        println(\"index : $index , value :$value\")\n    }\n复制代码\n也可以自定义循环区间\n\n    for (index in 2..10) {\n        println(index)\n    }\n复制代码\n5.5、while 和 do/while 循环\nwhile 和 do/while 与 Java 中的区别不大\n\n    val list = listOf(1, 4, 15, 2, 4, 10, 0, 9)\n    var index = 0\n    while (index < list.size) {\n        println(list[index])\n        index++\n    }\n复制代码\n    val list = listOf(1, 4, 15, 2, 4, 10, 0, 9)\n    var index = 0\n    do {\n        println(list[index])\n        index++\n    } while (index < list.size)\n复制代码\n5.6、返回和跳转\nkotlin 有三种结构化跳转表达式：\n\nreturn 默认从最直接包围它的函数或者匿名函数返回\nbreak 终止最直接包围它的循环\ncontinue 继续下一次最直接包围它的循环\n在 kotlin 中任何表达式都可以用标签（label）来标记，标签的格式为标识符后跟 @ 符号，例如：abc@ 、fooBar@ 都是有效的标签\n\nfun main() {\n    fun1()\n}\n\nfun fun1() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    loop@ for (it in list) {\n        if (it == 8) {\n            continue\n        }\n        if (it == 23) {\n            break@loop\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n}\n复制代码\nvalue is 1\nvalue is 4\nvalue is 6\nvalue is 12\nfunction end\n复制代码\nkotlin 有函数字面量、局部函数和对象表达式。因此 kotlin 的函数可以被嵌套\n\n标签限制的 return 允许我们从外层函数返回，最重要的一个用途就是从 lambda 表达式中返回。通常情况下使用隐式标签更方便，该标签与接受该 lambda 的函数同名\n\nfun main() {\n    fun1()\n    fun2()\n    fun3()\n    fun4()\n    fun5()\n}\n\nfun fun1() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    list.forEach {\n        if (it == 8) {\n            return\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n\n\n\n\n}\n\nfun fun2() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    list.forEach {\n        if (it == 8) {\n            return@fun2\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n\n\n\n\n}\n\n\nfun fun3() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    list.forEach {\n        if (it == 8) {\n            return@forEach\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n    \n\n\n\n\n\n\n\n}\n\nfun fun4() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    list.forEach loop@{\n        if (it == 8) {\n            return@loop\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n\n\n\n\n\n\n\n\n}\n\nfun fun5() {\n    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {\n        if (value == 3) {\n            \n            return\n        }\n        println(\"value is $value\")\n    })\n    println(\"function end\")\n}\n复制代码\n六、区间\nRanges 表达式使用一个 .. 操作符来声明一个闭区间，它被用于定义实现了一个 RangTo 方法\n\n以下三种声明形式是等价的\n\n    var index = 5\n    \n    if (index >= 0 && index <= 10) {\n\n    }\n\n    if (index in 0..10) {\n\n    }\n\n    if (index in 0.rangeTo(10)) {\n        \n    }\n复制代码\n数字类型的 ranges 在被迭代时，编译器会将它们转换为与 Java 中使用 index 的 for 循环的相同字节码的方式来进行优化\n\nRanges 默认会自增长，所以如果像以下的代码就不会被执行\n\n    for (index in 10..0) {\n        println(index)\n    }\n复制代码\n可以改用 downTo 函数来将之改为递减\n\n    for (index in 10 downTo 0) {\n        println(index)\n    }\n复制代码\n可以在 ranges 中使用 step 来定义每次循环递增或递增的长度：\n\n    for (index in 1..8 step 2){\n        println(index)\n    }\n    for (index in 8 downTo 1 step 2) {\n        println(index)\n    }\n复制代码\n以上声明的都是闭区间，如果想声明的是开区间，可以使用 until 函数：\n\n    for (index in 0 until 4){\n        println(index)\n    }\n复制代码\n扩展函数 reversed() 可用于返回将区间反转后的序列\n\n    val rangeTo = 1.rangeTo(3)\n    for (i in rangeTo) {\n        println(i) \n    }\n    for (i in rangeTo.reversed()) {\n        println(i) \n    }\n复制代码\n七、修饰符\n7.1、final 和 oepn\nkotlin 中的类和方法默认都是 final 的，即不可继承的，如果想允许创建一个类的子类，需要使用 open 修饰符来标识这个类，此外，也需要为每一个希望被重写的属性和方法添加 open 修饰符\n\nopen class View {\n    open fun click() {\n\n    }\n\t\n    fun longClick() {\n\n    }\n}\n\nclass Button : View() {\n    override fun click() {\n        super.click()\n    }\n}\n复制代码\n如果重写了一个基类或者接口的成员，重写了的成员同样默认是 open 的。例如，如果 Button 类是 open 的，则其子类也可以重写其 click() 方法\n\nopen class Button : View() {\n    override fun click() {\n        super.click()\n    }\n}\n\nclass CompatButton : Button() {\n    override fun click() {\n        super.click()\n    }\n}\n复制代码\n如果不想要类的子类重写该方法的实现，可以显式地将重写的成员标记为 final\n\nopen class Button : View() {\n    override final fun click() {\n        super.click()\n    }\n}\n复制代码\n7.2、public\npublic 修饰符是限制级最低的修饰符，是默认的修饰符。如果一个定义为 public 的成员被包含在一个 private 修饰的类中，那么这个成员在这个类以外也是不可见的\n\n7.3、protected\nprotected 修饰符只能被用在类或者接口中的成员上。在 Java 中，可以从同一个包中访问一个 protected 的成员，但对于 kotlin 来说，protected 成员只在该类和它的子类中可见。此外，protected 不适用于顶层声明\n\n7.4、internal\n一个定义为 internal 的包成员，对其所在的整个 module 可见。如果它是一个其它领域的成员，它就需要依赖那个领域的可见性了。比如，如果我们写了一个 private 类，那么它的 internal 修饰的函数的可见性就会限制于它所在的这个类的可见性\n\n我们可以访问同一个 module 中的 internal 修饰的类，但是其它 module 是访问不到该 internal 类的，该修饰符可用于对外发布的开源库，将开源库中不希望被外部引用的代码设为 internal 权限，可避免对外部引用库造成混淆\n\n根据 Jetbrains 的定义，一个 module 应该是一个单独的功能性的单位，可以看做是一起编译的 kotlin 文件的集合，它应该是可以被单独编译、运行、测试、debug 的。相当于在 Android Studio 中主工程引用的 module，Eclipse 中在一个 workspace 中的不同的 project\n\n7.5、private\nprivate 修饰符是限制级最高的修饰符，kotlin 允许在顶层声明中使用 private 可见性，包括类、函数和属性，这表示只在自己所在的文件中可见，所以如果将一个类声明为 private，就不能在定义这个类之外的地方中使用它。此外，如果在一个类里面使用了 private 修饰符，那访问权限就被限制在这个类里面，继承这个类的子类也不能使用它。所以如果类、对象、接口等被定义为 private，那么它们只对被定义所在的文件可见。如果被定义在了类或者接口中，那它们只对这个类或者接口可见\n\n7.6、总结\n修饰符\t类成员\t顶层声明\npublic（默认）\t所有地方可见\t所有地方可见\ninternal\t模块中可见\t模块中可见\nprotected\t子类中可见\t\nprivate\t类中可见\t文件中可见\n八、空安全\n8.1、可空性\n在 kotlin 中，类型系统将一个引用分为可以容纳 null （可空引用）或者不能容纳 null（非空引用）两种类型。 例如，String 类型的常规变量不能指向 null\n\n    var name: String = \"leavesC\"\n    \n    \n复制代码\n如果希望一个变量可以储存 null 引用，需要显式地在类型名称后面加上问号\n\n    var name: String? = \"leavesC\"\n    name = null\n复制代码\n问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用：Int?、Doubld? 、Long? 等\n\nkotlin 对可空类型的显式支持有助于防止 NullPointerException 导致的异常问题，编译器不允许不对可空变量做 null 检查就直接调用其属性。这个强制规定使得开发者必须在编码初期就考虑好变量的可赋值范围并为其各个情况做好分支处理\n\nfun check(name: String?): Boolean {\n    \n    return name.isNotEmpty()\n}\n复制代码\n正确的做法事显式地进行 null 检查\n\nfun check(name: String?): Boolean {\n    if (name != null) {\n        return name.isNotEmpty()\n    }\n    return false\n}\n复制代码\n8.2、安全调用运算符：?.\n安全调用运算符：?. 允许把一次 null 检查和一次方法调用合并为一个操作，如果变量值非空，则方法或属性会被调用，否则直接返回 null\n\n例如，以下两种写法是完全等同的：\n\nfun check(name: String?) {\n    if (name != null) {\n        println(name.toUpperCase())\n    } else {\n        println(null)\n    }\n}\n\nfun check(name: String?) {\n    println(name?.toUpperCase())\n}\n复制代码\n8.3、Elvis 运算符：?:\nElvis 运算符：?: 用于替代 ?. 直接返回默认值 null 的情况，Elvis 运算符接收两个运算数，如果第一个运算数不为 null ，运算结果就是其运算结果值，如果第一个运算数为 null ，运算结果就是第二个运算数\n\n例如，以下两种写法是完全等同的：\n\nfun check(name: String?) {\n    if (name != null) {\n        println(name)\n    } else {\n        println(\"default\")\n    }\n}\n\nfun check(name: String?) {\n    println(name ?: \"default\")\n}\n复制代码\n8.4、安全转换运算符：as?\n安全转换运算符：as? 用于把值转换为指定的类型，如果值不适合该类型则返回 null\n\nfun check(any: Any?) {\n    val result = any as? String\n    println(result ?: println(\"is not String\"))\n}\n复制代码\n8.5、非空断言：!!\n非空断言用于把任何值转换为非空类型，如果对 null 值做非空断言，则会抛出异常\n\nfun main() {\n    var name: String? = \"leavesC\"\n    check(name) \n\n    name = null\n    check(name) \n}\n\nfun check(name: String?) {\n    println(name!!.length)\n}\n复制代码\n8.6、可空类型的扩展\n为可空类型定义扩展函数是一种更强大的处理 null 值的方式，可以允许接收者为 null 的调用，并在该函数中处理 null ，而不是在确保变量不为 null 之后再调用它的方法\n\n例如，如下方法可以被正常调用而不会发生空指针异常\n\n    val name: String? = null\n    println(name.isNullOrEmpty()) \n复制代码\nisNullOrEmpty() 的方法签名如下所示，可以看到这是为可空类型 CharSequence? 定义的扩展函数，方法中已经处理了方法调用者为 null 的情况\n\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n    return this == null || this.length == 0\n}\n复制代码\n8.7、平台类型\n平台类型是 kotlin 对 java 所作的一种平衡性设计。kotlin 将对象的类型分为了可空类型和不可空类型两种，但 java 平台的一切对象类型均为可空的，当在 kotlin 中引用 java 变量时，如果将所有变量均归为可空类型，最终将多出许多 null 检查；如果均看成不可空类型，那么就很容易就写出忽略了NPE 风险的代码。为了平衡两者，kotlin 引入了平台类型，即当在 kotlin 中引用 java 变量值时，既可以将之看成可空类型，也可以将之看成不可空类型，由开发者自己来决定是否进行 null 检查\n\n九、类型的检查与转换\n9.1、类型检查\nis 与 !is 操作符用于在运行时检查对象是否符合给定类型：\n\nfun main() {\n    val strValue = \"leavesC\"\n    parserType(strValue) \n    val intValue = 100\n    parserType(intValue) \n    val doubleValue = 100.22\n    parserType(doubleValue) \n    val longValue = 200L\n    parserType(longValue) \n}\n\nfun parserType(value: Any) {\n    when (value) {\n        is String -> println(\"value is String , length : ${value.length}\")\n        is Int -> println(\"value is Int , toLong : ${value.toLong()}\")\n        !is Long -> println(\"value !is Long\")\n        else -> println(\"unknown\")\n    }\n}\n复制代码\n9.2、智能转换\n在许多情况下，不需要在 kotlin 中使用显式转换操作符，因为编译器跟踪不可变值的 is 检查以及显式转换，并在需要时自动插入安全的转换\n\n例如，对于以下例子来说，当判断 value 为 String 类型通过时，就可以直接将 value 当做 String 类型变量并调用其内部属性\n\nfun main() {\n    val strValue = \"leavesC\"\n    parserType(strValue) \n\n    val intValue = 100\n    parserType(intValue) \n\n    val doubleValue = 100.22\n    parserType(doubleValue) \n\n    val longValue = 200L\n    parserType(longValue) \n}\n\nfun parserType(value: Any) {\n    when (value) {\n        is String -> println(\"value is String , length : ${value.length}\")\n        is Int -> println(\"value is Int , toLong : ${value.toLong()}\")\n        !is Long -> println(\"value !is Long\")\n        else -> println(\"unknown\")\n    }\n}\n复制代码\n编译器会指定根据上下文环境，将变量智能转换为合适的类型\n\n    if (value !is String) return\n    \n    println(value.length)\n\n    \n    if (value !is String || value.length > 0) {\n\n    }\n\n    \n    if (value is String && value.length > 0) {\n\n    }\n复制代码\n9.3、不安全的转换操作符\n如果转换是不可能的，转换操作符 as 会抛出一个异常。因此，我们称之为不安全的转换操作符\n\nfun main() {\n    parserType(\"leavesC\") \n    parserType(10) \n}\n\nfun parserType(value: Any) {\n    val tempValue = value as String\n    println(\"value is String , length is ${tempValue.length}\")\n}\n复制代码\n需要注意的是，null 不能转换为 String 变量，因为该类型不是可空的\n\n因此如下转换会抛出异常\n\n    val x = null\n    val y: String = x as String \n复制代码\n为了匹配安全，可以转换的类型声明为可空类型\n\n    val x = null\n    val y: String? = x as String?\n复制代码\n9.4、安全的转换操作符\n可以使用安全转换操作符 as? 来避免在转换时抛出异常，它在失败时返回 null\n\n    val x = null\n    val y: String? = x as? String\n复制代码\n尽管以上例子 as? 的右边是一个非空类型的 String，但是其转换的结果是可空的\n\n十、类\n10.1、基本概念\n类的概念就是把数据和处理数据的代码封装成一个单一的实体。在 Java 中，数据存储在一个私有字段中，通过提供访问器方法：getter 和 setter 来访问或者修改数据\n\n在 Java 中以下的示例代码是很常见的，Point 类包含很多重复的代码：通过构造函数把参数赋值给有着相同名称的字段，通过 getter 来获取属性值\n\npublic final class Point {\n\n   private final int x;\n   \n   private final int y;\n   \n   public Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n   }\n\n   public final int getX() {\n      return this.x;\n   }\n\n   public final int getY() {\n      return this.y;\n   }\n   \n}\n复制代码\n使用 kotlin 来声明 Point 类则只需要一行代码，两者完全等同\n\nclass Point(val x: Int, val y: Int)\n复制代码\nkotlin 也使用关键字 class 来声明类，类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成，类头与类体都是可选的，如果一个类没有类体，可以省略花括号。此外，kotlin 中类默认是 publish（公有的） 且 final （不可继承）的\n\nkotlin 区分了主构造方法（在类体外部声明）和次构造方法（在类体内部声明），一个类可以有一个主构造函数和多个次构造函数，此外也允许在初始化代码块中 init 添加额外的初始化逻辑\n\n10.2、主构造函数\n主构造函数是类头的一部分，跟在类名（和可选的类型参数）后，主构造函数的参数可以是可变的（var）或只读的（val）\n\nclass Point constructor(val x: Int, val y: Int) {\n\n}\n复制代码\n如果主构造函数没有任何注解或者可见性修饰符，可以省略 constructor 关键字\n\nclass Point(val x: Int, val y: Int) {\n\n}\n\n\nclass Point(val x: Int, val y: Int)\n复制代码\n如果构造函数有注解或可见性修饰符，则 constructor 关键字是必需的，并且这些修饰符在它前面\n\nclass Point public @Inject constructor(val x: Int, val y: Int) {\n\n}\n复制代码\n主构造函数不能包含任何的代码，初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中，初始化块包含了在类被创建时执行的代码，主构造函数的参数可以在初始化块中使用。如果需要的话，也可以在一个类中声明多个初始化语句块。需要注意的是，构造函数的参数如果用 val/var 进行修饰，则相当于在类内部声明了一个同名的全局属性。如果不加 val/var 进行修饰，则构造函数只能在 init 函数块和全局属性初始化时进行引用\n\n此外，要创建一个类的实例不需要使用 Java 中的 new 关键字，像普通函数一样调用构造函数即可\n\nclass Point(val x: Int, val y: Int) {\n\n    init {\n        println(\"initializer blocks , x value is: $x , y value is: $y\")\n    }\n\n}\n\nfun main() {\n    Point(1, 2) \n}\n复制代码\n主构造函数的参数也可以在类体内声明的属性初始化器中使用\n\nclass Point(val x: Int, val y: Int) {\n\n    private val localX = x + 1\n\n    private val localY = y + 1\n\n    init {\n        println(\"initializer blocks , x value is: $x , y value is: $y\")\n        println(\"initializer blocks , localX value is: $localX , localY value is: $localY\")\n    }\n\n}\n\nfun main() {\n    Point(1, 2)\n    \n    \n}\n复制代码\n10.3、次构造函数\n类也可以声明包含前缀 constructor 的次构造函数。如果类有一个主构造函数，每个次构造函数都需要直接委托给主构造函数或者委托给另一个次构造函数以此进行间接委托，用 this 关键字来进行指定即可\n\nclass Point(val x: Int, val y: Int) {\n\n    private val localX = x + 1\n\n    private val localY = y + 1\n\n    init {\n        println(\"initializer blocks , x value is: $x , y value is: $y\")\n        println(\"initializer blocks , localX value is: $localX , localY value is: $localY\")\n    }\n\n    constructor(base: Int) : this(base + 1, base + 1) {\n        println(\"constructor(base: Int)\")\n    }\n\n    constructor(base: Long) : this(base.toInt()) {\n        println(\"constructor(base: Long)\")\n    }\n\n}\n\nfun main() {\n    Point(100)\n    \n    \n    \n    Point(100L)\n    \n    \n    \n    \n}\n复制代码\n初始化块中的代码实际上会成为主构造函数的一部分，委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块。如果一个非抽象类没有声明任何（主或次）构造函数，会默认生成一个不带参数的公有主构造函数\n\n10.4、属性\n在 Java 中，字段和其访问器的组合被称作属性。在 kotlin 中，属性是头等的语言特性，完全替代了字段和访问器方法。在类中声明一个属性和声明一个变量一样是使用 val 和 var 关键字。val 变量只有一个 getter ，var 变量既有 getter 也有 setter\n\nfun main() {\n    val user = User()\n    println(user.name)\n    user.age = 200\n}\n\nclass User() {\n\n    val name: String = \"leavesC\"\n\n    var age: Int = 25\n\n}\n复制代码\n10.5、自定义访问器\n访问器的默认实现逻辑很简单：创建一个存储值的字段，以及返回属性值的 getter 和更新属性值的 setter。如果需要的话，也可以自定义访问器\n\n例如，以下就声明了三个带自定义访问器的属性\n\nclass Point(val x: Int, val y: Int) {\n\n    val isEquals1: Boolean\n        get() {\n            return x == y\n        }\n\n    val isEquals2\n        get() = x == y\n\n    var isEquals3 = false\n        get() = x > y\n        set(value) {\n            field = !value\n        }\n\n}\n复制代码\n如果仅需要改变一个访问器的可见性或者为其添加注解，那么可以定义访问器而不定义其实现\n\nfun main() {\n    val point = Point(10, 10)\n    println(point.isEquals1)\n    \n    \n}\n\nclass Point(val x: Int, val y: Int) {\n\n    var isEquals1: Boolean = false\n        get() {\n            return x == y\n        }\n        private set\n    \n}\n复制代码\n10.6、延迟初始化\n一般地，非空类型的属性必须在构造函数中初始化，但像使用了 Dagger2 这种依赖注入框架的项目来说就十分的不方便了，为了应对这种情况，可以用 lateinit 修饰符来标记该属性，用于告诉编译器该属性会在稍后的时间被初始化\n\n用 lateinit 修饰的属性或变量必须为非空类型，并且不能是原生类型\n\nclass Point(val x: Int, val y: Int)\n\nclass Example {\n\n    lateinit var point: Point\n\n    var point2: Point\n\n    constructor() {\n        point2 = Point(10, 20)\n    }\n    \n}\n复制代码\n如果访问了一个未经过初始化的 lateinit 变量，则会抛出一个包含具体原因（该变量未初始化）的异常信息\n\nException in thread \"main\" kotlin.UninitializedPropertyAccessException: lateinit property point has not been initialized\n复制代码\n十一、类的分类\n11.1、抽象类\n声明为 abstract 的类内部可以包含没有实现体的成员方法，且该成员方法也用 abstract 标记，这种类称为抽象类，包含的没有实现体的方法称为抽象方法\n\n此外，我们并不需要用 open 标注一个抽象类或者抽象方法，因为这是默认声明的\n\nabstract class BaseClass {\n    abstract fun fun1()\n}\n\nclass Derived : BaseClass() {\n    override fun fun1() {\n        \n    }\n}\n复制代码\n11.2、数据类\n数据类是一种非常强大的类，可以避免重复创建 Java 中的用于保存状态但又操作非常简单的 POJO 的模版代码，它们通常只提供了用于访问它们属性的简单的 getter 和 setter\n\n定义一个新的数据类非常简单，例如\n\ndata class Point(val x: Int, val y: Int)\n复制代码\n数据类默认地为主构造函数中声明的所有属性生成了如下几个方法\n\ngetter、setter（需要是 var）\ncomponentN()。按主构造函数的属性声明顺序进行对应\ncopy()\ntoString()\nhashCode()\nequals()\n为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：\n\n主构造函数需要包含一个参数\n主构造函数的所有参数需要标记为 val 或 var\n数据类不能是抽象、开放、密封或者内部的\n可以利用 IDEA 来反编译查看 Point 类的 Java 实现，了解其内部实现\n\npublic final class Point {\n   private final int x;\n   private final int y;\n\n   public final int getX() {\n      return this.x;\n   }\n\n   public final int getY() {\n      return this.y;\n   }\n\n   public Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n   }\n\n   public final int component1() {\n      return this.x;\n   }\n\n   public final int component2() {\n      return this.y;\n   }\n\n   @NotNull\n   public final Point copy(int x, int y) {\n      return new Point(x, y);\n   }\n\n   \n   \n   @NotNull\n   public static Point copy$default(Point var0, int var1, int var2, int var3, Object var4) {\n      if ((var3 & 1) != 0) {\n         var1 = var0.x;\n      }\n\n      if ((var3 & 2) != 0) {\n         var2 = var0.y;\n      }\n\n      return var0.copy(var1, var2);\n   }\n\n   public String toString() {\n      return \"Point(x=\" + this.x + \", y=\" + this.y + \")\";\n   }\n\n   public int hashCode() {\n      return this.x * 31 + this.y;\n   }\n\n   public boolean equals(Object var1) {\n      if (this != var1) {\n         if (var1 instanceof Point) {\n            Point var2 = (Point)var1;\n            if (this.x == var2.x && this.y == var2.y) {\n               return true;\n            }\n         }\n\n         return false;\n      } else {\n         return true;\n      }\n   }\n}\n复制代码\n通过数据类可以简化很多的通用操作，可以很方便地进行：格式化输出变量值、映射对象到变量、对比变量之间的相等性、复制变量等操作\n\nfun main() {\n    val point1 = Point(10, 20)\n    val point2 = Point(10, 20)\n    println(\"point1 toString() : $point1\") \n    println(\"point2 toString() : $point2\") \n\n    val (x, y) = point1\n    println(\"point1 x is $x,point1 y is $y\") \n\n    \n    \n    println(\"point1 == point2 : ${point1 == point2}\") \n    println(\"point1 === point2 : ${point1 === point2}\") \n\n    val point3 = point1.copy(y = 30)\n    println(\"point3 toString() : $point3\") \n}\n复制代码\n需要注意的是，数据类的 toString()、equals()、hashCode()、copy() 等方法只考虑主构造函数中声明的属性，因此在比较两个数据类对象的时候可能会有一些意想不到的结果\n\ndata class Point(val x: Int) {\n\n    var y: Int = 0\n\n}\n\nfun main() {\n    val point1 = Point(10)\n    point1.y = 10\n\n    val point2 = Point(10)\n    point2.y = 20\n\n    println(\"point1 == point2 : ${point1 == point2}\") \n    println(\"point1 === point2 : ${point1 === point2}\") \n}\n复制代码\n11.3、密封类\nSealed 类（密封类）用于对类可能创建的子类进行限制，用 Sealed 修饰的类的直接子类只允许被定义在 Sealed 类所在的文件中（密封类的间接继承者可以定义在其他文件中），这有助于帮助开发者掌握父类与子类之间的变动关系，避免由于代码更迭导致的潜在 bug，且密封类的构造函数只能是 private 的\n\n例如，对于 View 类，其子类只能定义在与之同一个文件里，Sealed 修饰符修饰的类也隐含表示该类为 open 类，因此无需再显式地添加 open 修饰符\n\nsealed class View {\n\n    fun click() {\n\n    }\n\n}\n\nclass Button : View() {\n\n}\n\nclass TextView : View() {\n\n}\n复制代码\n因为 Sealed 类的子类对于编译器来说是可控的，所以如果在 when 表达式中处理了所有 Sealed 类的子类，那就不需要再提供 else 默认分支。即使以后由于业务变动又新增了 View 子类，编译器也会检测到 check 方法缺少分支检查后报错，所以说 check 方法是类型安全的\n\nfun check(view: View): Boolean {\n    when (view) {\n        is Button -> {\n            println(\"is Button\")\n            return true\n        }\n        is TextView -> {\n            println(\"is TextView\")\n            return true\n        }\n    }\n}\n复制代码\n11.4、枚举类\nkotlin 也提供了枚举的实现，相比 Java 需要多使用 class 关键字来声明枚举\n\nenum class Day {\n    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY\n}\n复制代码\n枚举可以声明一些参数\n\nenum class Day(val index: Int) {\n    SUNDAY(0), MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6)\n}\n复制代码\n此外，枚举也可以实现接口\n\ninterface OnChangedListener {\n\n    fun onChanged()\n\n}\n\nenum class Day(val index: Int) : OnChangedListener {\n    SUNDAY(0) {\n        override fun onChanged() {\n\n        }\n    },\n    MONDAY(1) {\n        override fun onChanged() {\n            \n        }\n    }\n}\n复制代码\n枚举也包含有一些共有函数\n\nfun main() {\n    val day = Day.FRIDAY\n    \n    val value = day.index  \n    \n    val value1 = Day.valueOf(\"SUNDAY\") \n    \n    val value2 = Day.values()\n    \n    val value3 = Day.SUNDAY.name \n    \n    val value4 = Day.TUESDAY.ordinal \n}\n复制代码\n11.5、匿名内部类\n使用对象表达式来创建匿名内部类实例\n\ninterface OnClickListener {\n\n    fun onClick()\n\n}\n\nclass View {\n\n    fun setClickListener(clickListener: OnClickListener) {\n\n    }\n\n}\n\nfun main() {\n    val view = View()\n    view.setClickListener(object : OnClickListener {\n        override fun onClick() {\n\n        }\n\n    })\n}\n复制代码\n11.6、嵌套类\n在 kotlin 中在类里面再定义的类默认是嵌套类，此时嵌套类不会包含对外部类的隐式引用\n\nclass Outer {\n\n    private val bar = 1\n\n    class Nested {\n        fun foo1() = 2\n        \n        \n    }\n}\n\nfun main() {\n    val demo = Outer.Nested().foo1()\n}\n复制代码\n以上代码通过 IDEA 反编译后可以看到其内部的 Java 实现方式\n\n可以看到 Nested 其实就是一个静态类，因此 foo2() 不能访问外部类的非静态成员，也不用先声明 Outer 变量再指向 Nested 类，而是直接通过 Outer 类指向 Nested 类\n\npublic final class Outer {\n   private final int bar = 1;\n\n   public static final class Nested {\n      public final int foo1() {\n         return 2;\n      }\n   }\n}\n\npublic final class MainkotlinKt {\n   public static final void main(@NotNull String[] args) {\n      Intrinsics.checkParameterIsNotNull(args, \"args\");\n      int demo = (new Outer.Nested()).foo1();\n   }\n}\n复制代码\n11.7、内部类\n如果需要去访问外部类的成员，需要用 inner 修饰符来标注被嵌套的类，这称为内部类。内部类会隐式持有对外部类的引用\n\nclass Outer {\n\n    private val bar = 1\n\n    inner class Nested {\n        fun foo1() = 2\n        fun foo2() = bar\n    }\n}\n\nfun main() {\n    val demo = Outer().Nested().foo2()\n}\n复制代码\n再来看其内部的 Java 实现方式\n\n使用 inner 来声明 Nested 类后，就相当于将之声明为非静态内部类，因此 foo2() 能访问其外部类的非静态成员，在声明 Nested 变量前也需要通过 Outer 变量来指向其内部的 Nested 类\n\npublic final class Outer {\n   private final int bar = 1;\n\n   public final class Nested {\n      public final int foo1() {\n         return 2;\n      }\n\n      public final int foo2() {\n         return Outer.this.bar;\n      }\n   }\n}\n\npublic final class MainkotlinKt {\n   public static final void main(@NotNull String[] args) {\n      Intrinsics.checkParameterIsNotNull(args, \"args\");\n      int demo = (new Outer().new Nested()).foo2();\n   }\n}\n复制代码\n类A在类B中声明\t在Java中\t在kotlin中\n嵌套类（不存储外部类的引用）\tstatic class A\tclass A\n内部类（存储外部类的引用）\tclass A\tinner class A\n十二、接口\n12.1、抽象方法与默认方法\nkotlin 中的接口与 Java 8 中的类似，可以包含抽象方法的定义以及非抽象方法的实现，不需要使用 default 关键字来标注有默认实现的非抽象方法，但在实现接口的抽象方法时需要使用 override 进行标注\n\nfun main() {\n    val view = View()\n    view.click()\n    view.longClick()\n}\n\nclass View : Clickable {\n    \n    override fun click() {\n        println(\"clicked\")\n    }\n\n}\n\ninterface Clickable {\n    fun click()\n    fun longClick() = println(\"longClicked\")\n}\n复制代码\n如果一个类实现了多个接口，而接口包含带有默认实现且签名相同的方法，此时编译器就会要求开发者必须显式地实现该方法，可以选择在该方法中调用不同接口的相应实现\n\nclass View : Clickable, Clickable2 {\n\n    override fun click() {\n        println(\"clicked\")\n    }\n\n    override fun longClick() {\n        super<Clickable>.longClick()\n        super<Clickable2>.longClick()\n    }\n}\n\ninterface Clickable {\n    fun click()\n    fun longClick() = println(\"longClicked\")\n}\n\ninterface Clickable2 {\n    fun click()\n    fun longClick() = println(\"longClicked2\")\n}\n复制代码\n12.2、抽象属性\n接口中可以包含抽象属性声明，接口不定义该抽象属性是应该存储到一个支持字段还是通过 getter 来获取，接口本身并不包含任何状态，因此只有实现这个接口的类在需要的情况下会存储这个值\n\n看以下例子，Button 类和 TextView 类都实现了 Clickable 接口，并都提供了取得 statusValue 值的方式\n\nButton 类提供了一个自定义的 getter 用于在每次访问时重新获取 statusValue 值，因此在多次获取属性值时其值可能都会不一致，因为每次 getRandom() 方法都会被调用\n\nTextView 类中的 statusValue 属性有一个支持字段来存储在类初始化时得到的数据，因此其值在初始化后是不会再次获取值，即 TextView 类中的 getRandom() 只会被调用一次\n\nfun main() {\n    val button = Button()\n    println(button.statusValue)\n    val textView = TextView()\n    println(textView.statusValue)\n}\n\nclass Button : Clickable {\n\n    override val statusValue: Int\n        get() = getRandom()\n\n    private fun getRandom() = Random().nextInt(10)\n\n}\n\nclass TextView : Clickable {\n\n    override val statusValue: Int = getRandom()\n\n    private fun getRandom() = Random().nextInt(10)\n\n}\n\ninterface Clickable {\n\n    val statusValue: Int\n\n}\n复制代码\n除了可以声明抽象属性外，接口还可以包含具有 getter 和 setter 的属性，只要它们没有引用一个支持字段（支持字段需要在接口中存储状态，而这是不允许的）\n\ninterface Clickable {\n\n    val statusValue: Int\n\n    val check: Boolean\n        get() = statusValue > 10\n    \n}\n复制代码\n十三、继承\n在 kotlin 中所有类都有一个共同的超类 Any ，对于没有超类声明的类来说它就是默认超类。需要注意的是， Any 并不是 java.lang.Object ，它除了 equals() 、 hashCode() 与 toString() 外没有其他属性或者函数\n\n要声明一个显式的超类，需要把父类名放到类头的冒号之后\n\nopen class Base()\n\nclass SubClass() : Base()\n复制代码\n当中，类上的 open 标注与 Java 中的 final 含义相反，用于允许其它类从这个类继承。默认情况下，kotlin 中所有的类都是 final\n\n如果派生类有一个主构造函数，其基类型必须直接或间接调用基类的主构造函数\n\nopen class Base(val str: String)\n\nclass SubClass(val strValue: String) : Base(strValue)\n\nclass SubClass2 : Base {\n\n    constructor(strValue: String) : super(strValue)\n\n    constructor(intValue: Int) : super(intValue.toString())\n\n    constructor(doubValue: Double) : this(doubValue.toString())\n\n}\n复制代码\n13.1、覆盖方法\n与 Java 不同，kotlin 需要显式标注可覆盖的成员和覆盖后的成员：\n\nopen class Base() {\n    open fun fun1() {\n\n    }\n\n    fun fun2() {\n        \n    }\n}\n\nclass SubClass() : Base() {\n    override fun fun1() {\n        super.fun1()\n    }\n}\n复制代码\n用 open 标注的函数才可以被子类重载，子类用 override 表示该函数是要对父类的同签名函数进行覆盖。标记为 override 的成员本身也是开放的，也就是说，它可以被子类覆盖。如果想禁止再次覆盖，可以使用 final 关键字标记 如果父类没有使用 open 对函数进行标注，则子类不允许定义相同签名的函数。对于一个 final 类（没有用 open 标注的类）来说，使用 open 标记属性和方法是无意义的\n\n13.2、属性覆盖\n属性覆盖与方法覆盖类似。在超类中声明为 open 的属性，如果要进行覆盖则必须在派生类中重新声明且以 override 开头，并且它们必须具有兼容的类型\n\n每个声明的属性可以由具有初始化器的属性或者具有 getter 方法的属性覆盖\n\nopen class Base {\n    open val x = 10\n\n    open val y: Int\n        get() {\n            return 100\n        }\n}\n\nclass SubClass : Base() {\n    override val x = 100\n\n    override var y = 200\n}\n\nfun main() {\n    val base = Base()\n    println(base.x) \n    println(base.y) \n\n    val base1: Base = SubClass()\n    println(base1.x) \n    println(base1.y) \n\n    val subClass = SubClass()\n    println(subClass.x) \n    println(subClass.y) \n}\n复制代码\n此外，也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。因为一个 val 属性本质上声明了一个 getter 方法，而将其覆盖为 var 只是在子类中额外声明一个 setter 方法\n\n可以在主构造函数中使用 override 关键字作为属性声明的一部分\n\nopen class Base {\n    open val str: String = \"Base\"\n}\n\nclass SubClass(override val str: String) : Base()\n\nfun main() {\n    val base = Base()\n    println(base.str) \n\n    val subClass = SubClass(\"leavesC\")\n    println(subClass.str) \n}\n复制代码\n13.3、调用超类实现\n派生类可以通过 super 关键字调用其超类的函数与属性访问器的实现\n\nopen class BaseClass {\n    open fun fun1() {\n        println(\"BaseClass fun1\")\n    }\n}\n\nclass SubClass : BaseClass() {\n\n    override fun fun1() {\n        super.fun1()\n    }\n\n}\n复制代码\n对于内部类来说，其本身就可以直接调用调用外部类的函数\n\nopen class BaseClass2 {\n    private fun fun1() {\n        println(\"BaseClass fun1\")\n    }\n\n    inner class InnerClass {\n        fun fun2() {\n            fun1()\n        }\n    }\n\n}\n复制代码\n但如果想要在一个内部类中访问外部类的超类，则需要通过由外部类名限定的 super 关键字来实现\n\nopen class BaseClass {\n    open fun fun1() {\n        println(\"BaseClass fun1\")\n    }\n}\n\nclass SubClass : BaseClass() {\n\n    override fun fun1() {\n        println(\"SubClass fun1\")\n    }\n\n    inner class InnerClass {\n\n        fun fun2() {\n            super@SubClass.fun1()\n        }\n\n    }\n\n}\n\nfun main() {\n    val subClass = SubClass()\n    val innerClass = subClass.InnerClass()\n    \n    innerClass.fun2()\n}\n复制代码\n如果一个类从它的直接超类和实现的接口中继承了相同成员的多个实现， 则必须覆盖这个成员并提供其自己的实现来消除歧义\n\n为了表示采用从哪个超类型继承的实现，使用由尖括号中超类型名限定的 super 来指定，如 super< BaseClass >\n\nopen class BaseClass {\n    open fun fun1() {\n        println(\"BaseClass fun1\")\n    }\n}\n\ninterface BaseInterface {\n    \n    fun fun1() {\n        println(\"BaseInterface fun1\")\n    }\n}\n\nclass SubClass() : BaseClass(), BaseInterface {\n    override fun fun1() {\n        \n        super<BaseClass>.fun1()\n        \n        super<BaseInterface>.fun1()\n    }\n}\n复制代码\n十四、集合\n14.1、只读集合与可变集合\nkotlin 的集合设计和 Java 不同的另一项特性是：kotlin 把访问数据的接口和修改集合数据的接口分开了，kotlin.collections.Collection 接口提供了遍历集合元素、获取集合大小、判断集合是否包含某元素等操作，但这个接口没有提供添加和移除元素的方法。kotlin.collections.MutableCollection 接口继承于 kotlin.collections.Collection 接口，扩展出了用于添加、移除、清空元素的方法\n\n就像 kotlin 对 val 和 var 的区分一样，只读集合接口与可变集合接口的分离能提高对代码的可控性，如果函数接收 Collection 作为形参，那么就可以知道该函数不会修改集合，而只是对数据进行读取\n\n以下是用来创建不同类型集合的函数\n\n集合元素\t只读\t可变\nList\tlistOf\tmutableListOf、arrayListOf\nSet\tsetOf\tmutableSetOf、hashSetOf、linkedSetOf、sortedSetOf\nMap\tmapOf\tmutableMapOf、hashMapOf、linkedMapOf、sortedMapOf\n    val list = listOf(10, 20, 30, 40)\n    \n    \n    println(list.size)\n    println(list.contains(20))\n\n    val mutableList = mutableListOf(\"leavesC\", \"叶应是叶\", \"叶\")\n    mutableList.add(\"Ye\")\n    println(mutableList.size)\n    println(mutableList.contains(\"leavesC\"))\n复制代码\n14.2、集合与 Java\n因为 Java 并不会区分只读集合与可变集合，即使 kotlin 中把集合声明为只读的， Java 代码也可以修改这个集合，而 Java 代码中的集合对 kotlin 来说也是可变性未知的，kotlin 代码可以将之视为只读的或者可变的，包含的元素也是可以为 null 或者不为 null 的\n\n例如，在 Java 代码中 names 这么一个 List< String > 类型的变量\n\npublic class JavaMain {\n\n    public static List<String> names = new ArrayList<>();\n\n    static {\n        names.add(\"leavesC\");\n        names.add(\"Ye\");\n    }\n\n}\n复制代码\n在 kotlin 中可以用以下四种方式来引用变量 names\n\n    val list1: List<String?> = JavaMain.names\n\n    val list2: List<String> = JavaMain.names\n\n    val list3: MutableList<String> = JavaMain.names\n\n    val list4: MutableList<String?> = JavaMain.names\n复制代码\n14.3、只读集合的可变性\n只读集合不一定就是不可变的。例如，假设存在一个拥有只读类型接口的对象，该对象存在两个不同的引用，一个只读，一个可变，当可变引用修改了该对象后，这对只读引用来说就相当于“只读集合被修改了”，因此只读集合并不总是线程安全的。如果需要在多线程环境下处理数据，需要保证正确地同步了对数据的访问，或者使用支持并发访问的数据结构\n\n例如，list1 和 list1 引用到同一个集合对象， list3 对集合的修改同时会影响到 list1\n\n    val list1: List<String> = JavaMain.names\n    val list3: MutableList<String> = JavaMain.names\n    list1.forEach { it -> println(it) } \n    list3.forEach { it -> println(it) } \n    for (index in list3.indices) {\n        list3[index] = list3[index].toUpperCase()\n    }\n    list1.forEach { it -> println(it) } \n复制代码\n14.4、集合与可空性\n集合的可空性可以分为三种：\n\n可以包含为 null 的集合元素\n集合本身可以为 null\n集合本身可以为 null，且可以包含为 null 的集合元素\n例如，intList1 可以包含为 null 的集合元素，但集合本身不能指向 null；intList2 不可以包含为 null 的集合元素，但集合本身可以指向 null；intList3 可以包含为 null 的集合元素，且集合本身能指向 null\n\n    \n    val intList1: List<Int?> = listOf(10, 20, 30, 40, null)\n    \n    var intList2: List<Int>? = listOf(10, 20, 30, 40)\n    intList2 = null\n    \n    var intList3: List<Int?>? = listOf(10, 20, 30, 40, null)\n    intList3 = null\n复制代码"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304154049},"updatedAt":{"$$date":1597305351662},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ucpammJ89ZaGKx2m"}
{"name":"jquery-","folderId":"kp0_vYmyP","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975877217},"updatedAt":{"$$date":1598975877217},"folder":{"id":"kp0_vYmyP","name":"jq","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"udgNZyntj13lmeLp"}
{"name":"kotlin-在 Kotlin 中调用 Java 代码","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nKotlin 1.3.72\n博客  论坛  学习 社区 教学 演练 \n语言指南\n教程\n图书\n解构声明\n类型检测与转换\nThis 表达式\n相等性\n操作符重载\n空安全\n异常\n注解\n反射\n作用域函数\n类型安全的构建器\nOpt-in Requirements\n标准库\nkotlin.test\n关键字与操作符\n语法\n编码风格约定\nKotlin 中调用 Java\nJava 中调用 Kotlin\n完整 Kotlin 参考（PDF）\n完整 Kotlin 参考（字大PDF）\n完整 Kotlin 参考（ePUB）\n完整 Kotlin 参考（Mobi）\n 改进翻译\n在 Kotlin 中调用 Java 代码\nKotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以很顺利地调用 Kotlin 代码。在本节中我们会介绍从 Kotlin 中调用 Java 代码的一些细节。\n\n几乎所有 Java 代码都可以使用而没有任何问题：\n\nimport java.util.*\n​\nfun demo(source: List<Int>) {\n    val list = ArrayList<Int>()\n    // “for”-循环用于 Java 集合：\n    for (item in source) {\n        list.add(item)\n    }\n    // 操作符约定同样有效：\n    for (i in 0..source.size - 1) {\n        list[i] = source[i] // 调用 get 和 set\n    }\n}\nGetter 和 Setter\n遵循 Java 约定的 getter 和 setter 的方法（名称以 get 开头的无参数方法和以 set 开头的单参数方法）在 Kotlin 中表示为属性。 Boolean 访问器方法（其中 getter 的名称以 is 开头而 setter 的名称以 set 开头）会表示为与 getter 方法具有相同名称的属性。 例如：\n\nimport java.util.Calendar\n​\nfun calendarDemo() {\n    val calendar = Calendar.getInstance()\n    if (calendar.firstDayOfWeek == Calendar.SUNDAY) {  // 调用 getFirstDayOfWeek()\n        calendar.firstDayOfWeek = Calendar.MONDAY      // 调用ll setFirstDayOfWeek()\n    }\n    if (!calendar.isLenient) {                         // 调用 isLenient()\n        calendar.isLenient = true                      // 调用 setLenient()\n    }\n}\n请注意，如果 Java 类只有一个 setter，它在 Kotlin 中不会作为属性可见，因为 Kotlin 目前不支持只写（set-only）属性。\n\n返回 void 的方法\n如果一个 Java 方法返回 void，那么从 Kotlin 调用时中返回 Unit。 万一有人使用其返回值，它将由 Kotlin 编译器在调用处赋值， 因为该值本身是预先知道的（是 Unit）。\n\n将 Kotlin 中是关键字的 Java 标识符进行转义\n一些 Kotlin 关键字在 Java 中是有效标识符：in、 object、 is 等等。 如果一个 Java 库使用了 Kotlin 关键字作为方法，你仍然可以通过反引号（`）字符转义它来调用该方法：\n\nfoo.`is`(bar)\n空安全与平台类型\nJava 中的任何引用都可能是 null，这使得 Kotlin 对来自 Java 的对象要求严格空安全是不现实的。 Java 声明的类型在 Kotlin 中会被特别对待并称为平台类型。对这种类型的空检测会放宽， 因此它们的安全保证与在 Java 中相同（更多请参见下文）。\n\n考虑以下示例：\n\nval list = ArrayList<String>() // 非空（构造函数结果）\nlist.add(\"Item\")\nval size = list.size // 非空（原生 int）\nval item = list[0] // 推断为平台类型（普通 Java 对象）\n当我们调用平台类型变量的方法时，Kotlin 不会在编译时报告可空性错误， 但在运行时调用可能会失败，因为空指针异常或者 Kotlin 生成的阻止空值传播的断言：\n\nitem.substring(1) // 允许，如果 item == null 可能会抛出异常\n平台类型是不可标示的，意味着不能在语言中明确地写下它们。 当把一个平台值赋值给一个 Kotlin 变量时，可以依赖类型推断（该变量会具有推断出的的平台类型， 如上例中 item 所具有的类型），或者我们可以选择我们期望的类型（可空或非空类型均可）：\n\nval nullable: String? = item // 允许，没有问题\nval notNull: String = item // 允许，运行时可能失败\n如果我们选择非空类型，编译器会在赋值时触发一个断言。这防止 Kotlin 的非空变量保存空值。当我们把平台值传递给期待非空值等的 Kotlin 函数时，也会触发断言。 总的来说，编译器尽力阻止空值通过程序向远传播（尽管鉴于泛型的原因，有时这不可能完全消除）。\n\n平台类型表示法\n如上所述，平台类型不能在程序中显式表述，因此在语言中没有相应语法。 然而，编译器和 IDE 有时需要（在错误信息中、参数信息中等）显示他们，所以我们用一个助记符来表示他们：\n\nT! 表示“T 或者 T?”，\n(Mutable)Collection<T>! 表示“可以可变或不可变、可空或不可空的 T 的 Java 集合”，\nArray<(out) T>! 表示“可空或者不可空的 T（或 T 的子类型）的 Java 数组”\n可空性注解\n具有可空性注解的Java类型并不表示为平台类型，而是表示为实际可空或非空的 Kotlin 类型。编译器支持多种可空性注解，包括：\n\nJetBrains （org.jetbrains.annotations 包中的 @Nullable 和 @NotNull）\nAndroid（com.android.annotations 和 android.support.annotations)\nJSR-305（javax.annotation，详见下文）\nFindBugs（edu.umd.cs.findbugs.annotations）\nEclipse（org.eclipse.jdt.annotation）\nLombok（lombok.NonNull）。\n你可以在 Kotlin 编译器源代码中找到完整的列表。\n\n注解类型参数\n可以标注泛型类型的类型参数，以便同时为其提供可空性信息。例如，考虑这些 Java 声明的注解：\n\n@NotNull\nSet<@NotNull String> toSet(@NotNull Collection<@NotNull String> elements) { …… }\n在 Kotlin 中可见的是以下签名：\n\nfun toSet(elements: (Mutable)Collection<String>) : (Mutable)Set<String> { …… }\n请注意 String 类型参数上的 @NotNull 注解。如果没有的话，类型参数会是平台类型：\n\nfun toSet(elements: (Mutable)Collection<String!>) : (Mutable)Set<String!> { …… }\n标注类型参数适用于面向 Java 8 或更高版本环境，并且要求可空性注解支持 TYPE_USE 目标（org.jetbrains.annotations 15 或以上版本支持）。\n\n注：由于当前的技术限制，IDE 无法正确识别用作依赖的已编译 Java 库中类型参数上的这些注解。\n\nJSR-305 支持\n已支持 JSR-305 中定义的 @Nonnull 注解来表示 Java 类型的可空性。\n\n如果 @Nonnull(when = ...) 值为 When.ALWAYS，那么该注解类型会被视为非空；When.MAYBE 与 When.NEVER 表示可空类型；而 When.UNKNOWN 强制类型为平台类型。\n\n可针对 JSR-305 注解编译库，但不需要为库的消费者将注解构件（如 jsr305.jar）指定为编译依赖。Kotlin 编译器可以从库中读取 JSR-305 注解，并不需要该注解出现在类路径中。\n\n自 Kotlin 1.1.50 起， 也支持自定义可空限定符（KEEP-79） （见下文）。\n\n类型限定符别称（自 1.1.50 起）\n如果一个注解类型同时标注有 @TypeQualifierNickname 与 JSR-305 @Nonnull（或者它的其他别称，如 @CheckForNull），那么该注解类型自身将用于 检索精确的可空性，且具有与该可空性注解相同的含义：\n\n@TypeQualifierNickname\n@Nonnull(when = When.ALWAYS)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyNonnull {\n}\n​\n@TypeQualifierNickname\n@CheckForNull // 另一个类型限定符别称的别称\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyNullable {\n}\n​\ninterface A {\n    @MyNullable String foo(@MyNonnull String x);\n    // 在 Kotlin（严格模式）中：`fun foo(x: String): String?`\n​\n    String bar(List<@MyNonnull String> x);\n    // 在 Kotlin（严格模式）中：`fun bar(x: List<String>!): String!`\n}\n类型限定符默认值（自 1.1.50 起）\n@TypeQualifierDefault 引入应用时在所标注元素的作用域内定义默认可空性的注解。\n\n这些注解类型应自身同时标注有 @Nonnull（或其别称）与 @TypeQualifierDefault(...)注解， 后者带有一到多个 ElementType 值：\n\nElementType.METHOD 用于方法的返回值；\nElementType.PARAMETER 用于值参数；\nElementType.FIELD 用于字段；以及\nElementType.TYPE_USE（自 1.1.60 起）适用于任何类型，包括类型参数、类型参数的上界与通配符类型。\n当类型并未标注可空性注解时使用默认可空性，并且该默认值是由最内层标注有带有与所用类型相匹配的 ElementType 的类型限定符默认注解的元素确定。\n\n@Nonnull\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})\npublic @interface NonNullApi {\n}\n​\n@Nonnull(when = When.MAYBE)\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})\npublic @interface NullableApi {\n}\n​\n@NullableApi\ninterface A {\n    String foo(String x); // fun foo(x: String?): String?\n​\n    @NotNullApi // 覆盖来自接口的默认值\n    String bar(String x, @Nullable String y); // fun bar(x: String, y: String?): String\n​\n    // 由于 `@NullableApi` 具有 `TYPE_USE` 元素类型，\n    // 因此认为 List<String> 类型参数是可空的：\n    String baz(List<String> x); // fun baz(List<String?>?): String?\n​\n    // “x”参数仍然是平台类型，因为有显式\n    // UNKNOWN 标记的可空性注解：\n    String qux(@Nonnull(when = When.UNKNOWN) String x); // fun baz(x: String!): String?\n}\n注意：本例中的类型只在启用了严格模式时出现，否则仍是平台类型。参见 @UnderMigration 注解与编译器配置两节。\n\n也支持包级的默认可空性：\n\n// 文件：test/package-info.java\n@NonNullApi // 默认将“test”包中所有类型声明为不可空\npackage test;\n@UnderMigration 注解（自 1.1.60 起）\n库的维护者可以使用 @UnderMigration 注解（在单独的构件 kotlin-annotations-jvm 中提供）来定义可为空性类型限定符的迁移状态。\n\n@UnderMigration(status = ...) 中的状态值指定了编译器如何处理 Kotlin 中注解类型的不当用法（例如，使用 @MyNullable 标注的类型值作为非空值）：\n\nMigrationStatus.STRICT 使注解像任何纯可空性注解一样工作，即对不当用法报错并影响注解声明内的类型在 Kotlin 中的呈现；\n\n对于 MigrationStatus.WARN，不当用法报为警告而不是错误； 但注解声明内的类型仍是平台类型；而\n\nMigrationStatus.IGNORE 则使编译器完全忽略可空性注解。\n\n库的维护者还可以将 @UnderMigration 状态添加到类型限定符别称与类型限定符默认值：\n\n@Nonnull(when = When.ALWAYS)\n@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})\n@UnderMigration(status = MigrationStatus.WARN)\npublic @interface NonNullApi {\n}\n​\n// 类中的类型是非空的，但是只报警告\n// 因为 `@NonNullApi` 标注了 `@UnderMigration(status = MigrationStatus.WARN)`\n@NonNullApi\npublic class Test {}\n注意：可空性注解的迁移状态并不会从其类型限定符别称继承，而是适用于默认类型限定符的用法。\n\n如果默认类型限定符使用类型限定符别称，并且它们都标注有 @UnderMigration，那么使用默认类型限定符的状态。\n\n编译器配置\n可以通过添加带有以下选项的 -Xjsr305 编译器标志来配置 JSR-305 检测：\n\n-Xjsr305={strict|warn|ignore} 设置非 @UnderMigration 注解的行为。 自定义的可空性限定符，尤其是 @TypeQualifierDefault 已经在很多知名库中流传，而用户更新到包含 JSR-305 支持的 Kotlin 版本时可能需要平滑迁移。自 Kotlin 1.1.60 起，这一标志只影响非 @UnderMigration 注解。\n\n-Xjsr305=under-migration:{strict|warn|ignore}（自 1.1.60 起）覆盖 @UnderMigration 注解的行为。 用户可能对库的迁移状态有不同的看法： 他们可能希望在官方迁移状态为 WARN 时报错误，反之亦然，他们可能希望推迟错误报告直到他们完成迁移。\n\n-Xjsr305=@<fq.name>:{strict|warn|ignore}（自 1.1.60 起）覆盖单个注解的行为，其中 <fq.name>是该注解的完整限定类名。对于不同的注解可以多次出现。这对于管理特定库的迁移状态非常有用。\n\n其中 strict、 warn 与 ignore 值的含义与 MigrationStatus 中的相同，并且只有 strict 模式会影响注解声明中的类型在 Kotlin 中的呈现。\n\n注意：内置的 JSR-305 注解 @Nonnull、 @Nullable 与 @CheckForNull 总是启用并影响所注解的声明在 Kotlin 中呈现，无论如何配置编译器的 -Xjsr305 标志。\n\n例如，将 -Xjsr305=ignore -Xjsr305=under-migration:ignore -Xjsr305=@org.library.MyNullable:warn 添加到编译器参数中，会使编译器对由 @org.library.MyNullable 标注的不当用法生成警告，而忽略所有其他 JSR-305 注解。\n\n对于 kotlin 1.1.50+/1.2 版本，其默认行为等同于 -Xjsr305=warn。 strict 值应认为是实验性的（以后可能添加更多检测）。\n\n已映射类型\nKotlin 特殊处理一部分 Java 类型。这样的类型不是“按原样”从 Java 加载，而是 映射 到相应的 Kotlin 类型。 映射只发生在编译期间，运行时表示保持不变。 Java 的原生类型映射到相应的 Kotlin 类型（请记住平台类型）：\n\nJava 类型\tKotlin 类型\nbyte\tkotlin.Byte\nshort\tkotlin.Short\nint\tkotlin.Int\nlong\tkotlin.Long\nchar\tkotlin.Char\nfloat\tkotlin.Float\ndouble\tkotlin.Double\nboolean\tkotlin.Boolean\n一些非原生的内置类型也会作映射：\n\nJava 类型\tKotlin 类型\njava.lang.Object\tkotlin.Any!\njava.lang.Cloneable\tkotlin.Cloneable!\njava.lang.Comparable\tkotlin.Comparable!\njava.lang.Enum\tkotlin.Enum!\njava.lang.Annotation\tkotlin.Annotation!\njava.lang.CharSequence\tkotlin.CharSequence!\njava.lang.String\tkotlin.String!\njava.lang.Number\tkotlin.Number!\njava.lang.Throwable\tkotlin.Throwable!\nJava 的装箱原始类型映射到可空的 Kotlin 类型：\n\nJava type\tKotlin type\njava.lang.Byte\tkotlin.Byte?\njava.lang.Short\tkotlin.Short?\njava.lang.Integer\tkotlin.Int?\njava.lang.Long\tkotlin.Long?\njava.lang.Character\tkotlin.Char?\njava.lang.Float\tkotlin.Float?\njava.lang.Double\tkotlin.Double?\njava.lang.Boolean\tkotlin.Boolean?\n请注意，用作类型参数的装箱原始类型映射到平台类型： 例如，List<java.lang.Integer> 在 Kotlin 中会成为 List<Int!>。\n\n集合类型在 Kotlin 中可以是只读的或可变的，因此 Java 集合类型作如下映射： （下表中的所有 Kotlin 类型都驻留在 kotlin.collections包中）:\n\nJava 类型\tKotlin 只读类型\tKotlin 可变类型\t加载的平台类型\nIterator<T>\tIterator<T>\tMutableIterator<T>\t(Mutable)Iterator<T>!\nIterable<T>\tIterable<T>\tMutableIterable<T>\t(Mutable)Iterable<T>!\nCollection<T>\tCollection<T>\tMutableCollection<T>\t(Mutable)Collection<T>!\nSet<T>\tSet<T>\tMutableSet<T>\t(Mutable)Set<T>!\nList<T>\tList<T>\tMutableList<T>\t(Mutable)List<T>!\nListIterator<T>\tListIterator<T>\tMutableListIterator<T>\t(Mutable)ListIterator<T>!\nMap<K, V>\tMap<K, V>\tMutableMap<K, V>\t(Mutable)Map<K, V>!\nMap.Entry<K, V>\tMap.Entry<K, V>\tMutableMap.MutableEntry<K,V>\t(Mutable)Map.(Mutable)Entry<K, V>!\nJava 的数组按下文所述映射：\n\nJava 类型\tKotlin 类型\nint[]\tkotlin.IntArray!\nString[]\tkotlin.Array<(out) String>!\n注意：这些 Java 类型的静态成员不能在相应 Kotlin 类型的伴生对象中直接访问。要调用它们，请使用 Java 类型的完整限定名，例如 java.lang.Integer.toHexString(foo)。\n\nKotlin 中的 Java 泛型\nKotlin 的泛型与 Java 有点不同（参见泛型）。当将 Java 类型导入 Kotlin 时，我们会执行一些转换：\n\nJava 的通配符转换成类型投影，\nFoo<? extends Bar> 转换成 Foo<out Bar!>!，\nFoo<? super Bar> 转换成 Foo<in Bar!>!；\nJava的原始类型转换成星投影，\nList 转换成 List<*>!，即 List<out Any?>!。\n和 Java 一样，Kotlin 在运行时不保留泛型，即对象不携带传递到他们构造器中的那些类型参数的实际类型。 即 ArrayList<Integer>() 和 ArrayList<Character>() 是不能区分的。 这使得执行 is-检测不可能照顾到泛型。 Kotlin 只允许 is-检测星投影的泛型类型：\n\nif (a is List<Int>) // 错误：无法检测它是否真的是一个 Int 列表\n// but\nif (a is List<*>) // OK：不保证列表的内容\nJava 数组\n与 Java 不同，Kotlin 中的数组是不型变的。这意味着 Kotlin 不允许我们把一个 Array<String> 赋值给一个 Array<Any>， 从而避免了可能的运行时故障。Kotlin 也禁止我们把一个子类的数组当做超类的数组传递给 Kotlin 的方法， 但是对于 Java 方法，这是允许的（通过 Array<(out) String>! 这种形式的平台类型）。\n\nJava 平台上，数组会使用原生数据类型以避免装箱/拆箱操作的开销。 由于 Kotlin 隐藏了这些实现细节，因此需要一个变通方法来与 Java 代码进行交互。 对于每种原生类型的数组都有一个特化的类（IntArray、 DoubleArray、 CharArray 等等）来处理这种情况。 它们与 Array 类无关，并且会编译成 Java 原生类型数组以获得最佳性能。\n\n假设有一个接受 int 数组索引的 Java 方法：\n\n    public void removeIndices(int[] indices) {\n\npublic class JavaArrayExample {\n​\n    public void removeIndices(int[] indices) {\n        // 在此编码……\n    }\n}\n在 Kotlin 中你可以这样传递一个原生类型的数组：\n\n)\nval javaObj = JavaArrayExample()\nval array = intArrayOf(0, 1, 2, 3)\njavaObj.removeIndices(array)  // 将 int[] 传给方法\n当编译为 JVM 字节代码时，编译器会优化对数组的访问，这样就不会引入任何开销：\n\nval array = arrayOf(1, 2, 3, 4)\narray[1] = array[1] * 2 // 不会实际生成对 get() 和 set() 的调用\nfor (x in array) { // 不会创建迭代器\n    print(x)\n}\n即使当我们使用索引定位时，也不会引入任何开销：\n\n\n    array[i] += 2\n}\nfor (i in array.indices) {// 不会创建迭代器\n    array[i] += 2\n}\n最后，in-检测也没有额外开销：\n\n}\nif (i in array.indices) { // 同 (i >= 0 && i < array.size)\n    print(array[i])\n}\nJava 可变参数\nJava 类有时声明一个具有可变数量参数（varargs）的方法来使用索引：\n\n(\npublic class JavaArrayExample {\n​\n    public void removeIndicesVarArg(int... indices) {\n        // 在此编码……\n    }\n}\n在这种情况下，你需要使用展开运算符 * 来传递 IntArray：\n\njavaObj.removeIndicesVarArg(*array)\nval javaObj = JavaArrayExample()\nval array = intArrayOf(0, 1, 2, 3)\njavaObj.removeIndicesVarArg(*array)\n目前无法传递 null 给一个声明为可变参数的方法。\n\n操作符\n由于 Java 无法标记用于运算符语法的方法，Kotlin 允许具有正确名称和签名的任何 Java 方法作为运算符重载和其他约定（invoke() 等）使用。 不允许使用中缀调用语法调用 Java 方法。\n\n受检异常\n在 Kotlin 中，所有异常都是非受检的，这意味着编译器不会强迫你捕获其中的任何一个。 因此，当你调用一个声明受检异常的 Java 方法时，Kotlin 不会强迫你做任何事情：\n\nfun render(list: List<*>, to: Appendable) {\n    for (item in list) {\n        to.append(item.toString()) // Java 会要求我们在这里捕获 IOException\n    }\n}\n对象方法\n当 Java 类型导入到 Kotlin 中时，类型 java.lang.Object 的所有引用都成了 Any。 而因为 Any 不是平台指定的，它只声明了 toString()、hashCode() 和 equals() 作为其成员， 所以为了能用到 java.lang.Object 的其他成员，Kotlin 要用到扩展函数。\n\nwait()/notify()\n类型 Any 的引用没有提供 wait() 与 notify() 方法。通常不鼓励使用它们，而建议使用 java.util.concurrent。 如果确实需要调用这两个方法的话，那么可以将引用转换为 java.lang.Object：\n\n(foo as java.lang.Object).wait()\ngetClass()\n要取得对象的 Java 类，请在类引用上使用 java 扩展属性：\n\n.\nval fooClass = foo::class.java\n上面的代码使用了自 Kotlin 1.1 起支持的绑定的类引用。你也可以使用 javaClass 扩展属性：\n\njavaClass\nval fooClass = foo.javaClass\nclone()\n要覆盖 clone()，需要继承 kotlin.Cloneable：\n\nclass Example : Cloneable {\n    override fun clone(): Any { …… }\n}\n不要忘记《Effective Java》第三版 的第 13 条: 谨慎地改写clone。\n\nfinalize()\n要覆盖 finalize()，所有你需要做的就是简单地声明它，而不需要 override 关键字：\n\n    protected fun finalize() {\n\nclass C {\n    protected fun finalize() {\n        // 终止化逻辑\n    }\n}\n根据 Java 的规则，finalize() 不能是 private 的。\n\n从 Java 类继承\n在 kotlin 中，类的超类中最多只能有一个 Java 类（以及按你所需的多个 Java 接口）。\n\n访问静态成员\nJava 类的静态成员会形成该类的“伴生对象”。我们无法将这样的“伴生对象”作为值来传递， 但可以显式访问其成员，例如：\n\nif (Character.isLetter(a)) { …… }\n要访问已映射到 Kotlin 类型的 Java 类型的静态成员，请使用 Java 类型的完整限定名：java.lang.Integer.bitCount(foo)。\n\nJava 反射\nJava 反射适用于 Kotlin 类，反之亦然。如上所述，你可以使用 instance::class.java, ClassName::class.java 或者 instance.javaClass 通过 java.lang.Class 来进入 Java 反射。\n\n其他支持的情况包括为一个 Kotlin 属性获取一个 Java 的 getter/setter 方法或者幕后字段、为一个 Java 字段获取一个 KProperty、为一个 KFunction 获取一个 Java 方法或者构造函数，反之亦然。\n\nSAM 转换\n就像 Java 8 一样，Kotlin 支持 SAM 转换。这意味着 Kotlin 函数字面值可以被自动的转换成只有一个非默认方法的 Java 接口的实现，只要这个方法的参数类型能够与这个 Kotlin 函数的参数类型相匹配。\n\n你可以这样创建 SAM 接口的实例：\n\nval runnable = Runnable { println(\"This runs in a runnable\") }\n……以及在方法调用中：\n\nval executor = ThreadPoolExecutor()\n// Java 签名：void execute(Runnable command)\nexecutor.execute { println(\"This runs in a thread pool\") }\n如果 Java 类有多个接受函数式接口的方法，那么可以通过使用将 lambda 表达式转换为特定的 SAM 类型的适配器函数来选择需要调用的方法。这些适配器函数也会按需由编译器生成：\n\nexecutor.execute(Runnable { println(\"This runs in a thread pool\") })\n请注意，SAM 转换只适用于接口，而不适用于抽象类，即使这些抽象类也只有一个抽象方法。\n\n还要注意，此功能只适用于 Java 互操作；因为 Kotlin 具有合适的函数类型，所以不需要将函数自动转换为 Kotlin 接口的实现，因此不受支持。\n\n在 Kotlin 中使用 JNI\n要声明一个在本地（C 或 C++）代码中实现的函数，你需要使用 external 修饰符来标记它：\n\nfun\nexternal fun foo(x: Int): Double\n其余的过程与 Java 中的工作方式完全相同。\n\n博客\n论坛\n问题跟踪\nGitHub\nTwitter\n为 Kotlin 做贡献\n\n抢先体验预览\n\n安全性\n\n宣传资料\n\n采用 Apache 2 授权许可\nKotlin 商标受 Kotlin 基金会保护\nKotlin 语言与 Kotlin 官方英文站由\nJetBrains\n赞助及开发；\n本站由\n灰蓝天际\n、\n晓_晨DEV\n、\n乔禹昂\n、\n高金龙\n、\nHoshinoTented\n、\n刘文俊\n、\n常少威\n、\nYue-plus\n、\nGuolianxing\n \n等\n译\nesc"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386579211},"updatedAt":{"$$date":1597397406075},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uom79z59VxzEZtkS"}
{"name":"py-关键字参数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：\n\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：\n\n>>> person('Michael', 30)\nname: Michael age: 30 other: {}\n也可以传入任意个数的关键字参数：\n\n>>> person('Bob', 35, city='Beijing')\nname: Bob age: 35 other: {'city': 'Beijing'}\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。\n\n和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\n\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, city=extra['city'], job=extra['job'])\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n当然，上面复杂的调用可以用简化的写法：\n\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, **extra)\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977480015},"updatedAt":{"$$date":1594977798453},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uqhi3nZkJoZuCpSx"}
{"name":"css-CSS 导航栏","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS 导航栏\n垂直\n主页\n新闻\n联系\n关于\n水平\n主页新闻联系关于\n主页\n新闻\n联系\n关于\n导航栏\n熟练使用导航栏，对于任何网站都非常重要。\n\n使用CSS你可以转换成好看的导航栏而不是枯燥的HTML菜单。\n\n导航栏=链接列表\n作为标准的HTML基础一个导航栏是必须的\n\n。在我们的例子中我们将建立一个标准的HTML列表导航栏。\n\n导航条基本上是一个链接列表，所以使用 <ul> 和 <li>元素非常有意义：\n\n实例\n<ul>\n  <li><a href=\"#home\">主页</a></li>\n  <li><a href=\"#news\">新闻</a></li>\n  <li><a href=\"#contact\">联系</a></li>\n  <li><a href=\"#about\">关于</a></li>\n</ul>\n\n尝试一下 »\n现在，让我们从列表中删除边距和填充：\n\n实例\nul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n}\n\n尝试一下 »\n例子解析：\n\nlist-style-type:none - 移除列表前小标志。一个导航栏并不需要列表标记\n移除浏览器的默认设置将边距和填充设置为0\n上面的例子中的代码是垂直和水平导航栏使用的标准代码。\n\n垂直导航栏\n上面的代码，我们只需要 <a>元素的样式，建立一个垂直的导航栏：\n\n实例\na\n{\n    display:block;\n    width:60px;\n}\n\n尝试一下 »\n示例说明：\n\ndisplay:block - 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度\nwidth:60px - 块元素默认情况下是最大宽度。我们要指定一个60像素的宽度\n提示：查看 完整样式的垂直导航栏的示例。\n\n注意： 请务必指定 <a>元素在垂直导航栏的的宽度。如果省略宽度，IE6可能产生意想不到的效果。\n\n垂直导航条实例\n创建一个简单的垂直导航条实例，在鼠标移动到选项时，修改背景颜色：\n\n主页\n新闻\n联系\n关于\n\n实例\nul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n    width: 200px;\n    background-color: #f1f1f1;\n}\n \nli a {\n    display: block;\n    color: #000;\n    padding: 8px 16px;\n    text-decoration: none;\n}\n \n/* 鼠标移动到选项上修改背景颜色 */\nli a:hover {\n    background-color: #555;\n    color: white;\n}\n\n尝试一下 »\n激活/当前导航条实例\n在点击了选项后，我们可以添加 \"active\" 类来标准哪个选项被选中：\n\n主页\n新闻\n联系\n关于\n实例\n.active {\n    background-color: #4CAF50;\n    color: white;\n}\n\n尝试一下 »\n创建链接并添加边框\n可以在 <li> or <a> 上添加text-align:center 样式来让链接居中。\n\n可以在 border <ul> 上添加 border 属性来让导航栏有边框。如果要在每个选项上添加边框，可以在每个 <li> 元素上添加border-bottom :\n\n实例\nul {\n    border: 1px solid #555;\n}\n \nli {\n    text-align: center;\n    border-bottom: 1px solid #555;\n}\n \nli:last-child {\n    border-bottom: none;\n}\n\n尝试一下 »\n全屏高度的固定导航条\n接下来我们创建一个左边是全屏高度的固定导航条，右边是可滚动的内容。\n\n实例\nul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n    width: 25%;\n    background-color: #f1f1f1;\n    height: 100%; /* 全屏高度 */\n    position: fixed; \n    overflow: auto; /* 如果导航栏选项多，允许滚动 */\n}\n\n尝试一下 »\n注意: 该实例可以在移动设备上使用。\n\n水平导航栏\n有两种方法创建横向导航栏。使用内联(inline)或浮动(float)的列表项。\n\n这两种方法都很好，但如果你想链接到具有相同的大小，你必须使用浮动的方法。\n\n内联列表项\n建立一个横向导航栏的方法之一是指定元素， 上述代码是标准的内联:\n\n实例\nli\n{\n    display:inline;\n}\n\n尝试一下 »\n实例解析：\n\ndisplay:inline; -默认情况下，<li>元素是块元素。在这里，我们删除换行符之前和之后每个列表项，以显示一行。\n提示: 查看 完整样式的水平导航栏的示例。\n\n浮动列表项\n在上面的例子中链接有不同的宽度。\n\n对于所有的链接宽度相等，浮动 <li>元素，并指定为 <a>元素的宽度：\n\n实例\nli\n{\n    float:left;\n}\na\n{\n    display:block;\n    width:60px;\n}\n\n尝试一下 »\n实例解析：\n\nfloat:left - 使用浮动块元素的幻灯片彼此相邻\ndisplay:block - 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度\nwidth:60px - 块元素默认情况下是最大宽度。我们要指定一个60像素的宽度\n提示:查看 完全样式的横向导航栏的示例。\n\n水平导航条实例\n创建一个水平导航条，在鼠标移动到选项后修改背景颜色。\n\n实例\nul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n    overflow: hidden;\n    background-color: #333;\n}\n \nli {\n    float: left;\n}\n \nli a {\n    display: block;\n    color: white;\n    text-align: center;\n    padding: 14px 16px;\n    text-decoration: none;\n}\n \n/*鼠标移动到选项上修改背景颜色 */\nli a:hover {\n    background-color: #111;\n}\n\n尝试一下 »\n激活/当前导航条实例\n在点击了选项后，我们可以添加 \"active\" 类来标准哪个选项被选中：\n\n实例\n.active {\n    background-color: #4CAF50;\n}\n\n尝试一下 »\n链接右对齐\n将导航条最右边的选项设置右对齐 (float:right;)：\n\n实例\n<ul>\n  <li><a href=\"#home\">主页</a></li>\n  <li><a href=\"#news\">新闻</a></li>\n  <li><a href=\"#contact\">联系</a></li>\n  <li style=\"float:right\"><a class=\"active\" href=\"#about\">关于</a></li>\n</ul>\n\n尝试一下 »\n添加分割线\n<li> 通过 border-right 样式来添加分割线:\n\n实例\n/* 除了最后一个选项(last-child) 其他的都添加分割线 */\nli {\n    border-right: 1px solid #bbb;\n}\n \nli:last-child {\n    border-right: none;\n}\n\n尝试一下 »\n固定导航条\n可以设置页面的导航条固定在头部或者底部：\n\n固定在头部\nul {\n    position: fixed;\n    top: 0;\n    width: 100%;\n}\n\n尝试一下 »\n固定在底部\nul {\n    position: fixed;\n    bottom: 0;\n    width: 100%;\n}\n\n尝试一下 »\n注意: 该实例可以在移动设备上使用。\n\n灰色水平导航条\n固定在底部\nul {\n    border: 1px solid #e7e7e7;\n    background-color: #f3f3f3;\n}\n \nli a {\n    color: #666;\n}\n\n尝试一下 »\n更多实例\n响应式顶部导航：如何使用 CSS3 媒体查询来创建一个响应式导航。\n\n响应式边栏导航：如何使用 CSS3 媒体查询来创建一个边栏导航。\n\n导航下拉菜单：在导航条内部设置下拉菜单\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973614938},"updatedAt":{"$$date":1598974094172},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"v7Mr1ebM2CZKItyR"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977500875},"updatedAt":{"$$date":1594977500875},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"vB8S8cojs8ZzQ4Y6"}
{"name":"qk-ks_lib_loadinglayout","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.kotlin.stdlib_jdk\n    implementation deps.androidx.core_ktx\n    implementation deps.androidx.appcompat\n}\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\nclass LoadingLayout : FrameLayout {\n    interface OnInflateListener {\n        fun onInflate(inflated: View?)\n    }\n\n    constructor(context: Context) : this(context, null, R.attr.styleLoadingLayout)\n    constructor(context: Context, attributeSet: AttributeSet?) : this(\n        context,\n        attributeSet,\n        R.attr.styleLoadingLayout\n    )\n\n    /**\n     * 不用管 这个 提示，用了use了\n     * @param context Context\n     * @param attributeSet AttributeSet?\n     * @param defStyleAttr Int\n     * @constructor\n     */\n    @SuppressLint(\"Recycle\")\n    constructor(\n        context: Context,\n        attributeSet: AttributeSet?,\n        defStyleAttr: Int = R.attr.styleLoadingLayout\n    ) : super(context, attributeSet, defStyleAttr) {\n\n\n        mInflater = LayoutInflater.from(context)\n\n        context.obtainStyledAttributes(\n            attributeSet,\n            R.styleable.LoadingLayout,\n            defStyleAttr,\n            R.style.LoadingLayout_Style\n        ).use { typedArray ->\n            mEmptyImage =\n                typedArray.getResourceId(R.styleable.LoadingLayout_llEmptyImage, View.NO_ID)\n            mEmptyText = typedArray.getString(R.styleable.LoadingLayout_llEmptyText) ?: \"\"\n\n            mErrorImage =\n                typedArray.getResourceId(R.styleable.LoadingLayout_llErrorImage, View.NO_ID)\n            mErrorText = typedArray.getString(R.styleable.LoadingLayout_llErrorText)\n//            mRetryText = typedArray.getString(R.styleable.LoadingLayout_llRetryText) ?: \"\"\n\n            mTextColor = typedArray.getColor(R.styleable.LoadingLayout_llTextColor, -0x666667)\n            mTextSize =\n                typedArray.getDimensionPixelSize(R.styleable.LoadingLayout_llTextSize, dp2px(16f))\n\n            mButtonTextColor =\n                typedArray.getColor(R.styleable.LoadingLayout_llButtonTextColor, -0x666667)\n            mButtonTextSize =\n                typedArray.getDimensionPixelSize(\n                    R.styleable.LoadingLayout_llButtonTextSize,\n                    dp2px(16f)\n                )\n            mButtonBackground = typedArray.getDrawable(R.styleable.LoadingLayout_llButtonBackground)\n\n            mEmptyResId =\n                typedArray.getResourceId(\n                    R.styleable.LoadingLayout_llEmptyResId,\n                    R.layout.loading_layout_empty\n                )\n            mLoadingResId = typedArray.getResourceId(\n                R.styleable.LoadingLayout_llLoadingResId,\n                R.layout.loading_layout_loading\n            )\n            mErrorResId =\n                typedArray.getResourceId(\n                    R.styleable.LoadingLayout_llErrorResId,\n                    R.layout.loading_layout_error\n                )\n        }\n\n\n    }\n\n    private var mEmptyImage: Int = 0\n    private var mEmptyText: CharSequence = \"\"\n    private var mErrorImage: Int = 0\n    private var mErrorText: CharSequence? = \"\"\n//    private var mRetryText: CharSequence = \"\"\n    private var mRetryButtonClickListener =\n        OnClickListener { v ->\n            mRetryListener?.onClick(v)\n        }\n    var mRetryListener: OnClickListener? = null\n    var mOnEmptyInflateListener: OnInflateListener? = null\n    var mOnErrorInflateListener: OnInflateListener? = null\n    private var mTextColor: Int = 0\n    private var mTextSize: Int = 0\n    private var mButtonTextColor: Int = 0\n    private var mButtonTextSize: Int = 0\n    private var mButtonBackground: Drawable? = null\n    var mEmptyResId = View.NO_ID\n    var mLoadingResId = View.NO_ID\n    var mErrorResId = View.NO_ID\n    var mContentId = View.NO_ID\n    var mLayouts: MutableMap<Int, View?> =\n        HashMap()\n\n\n    private fun dp2px(dp: Float): Int {\n        return (resources.displayMetrics.density * dp).toInt()\n    }\n\n    var mInflater: LayoutInflater\n    override fun onFinishInflate() {\n        super.onFinishInflate()\n        if (childCount == 0) {\n            return\n        }\n        if (childCount > 1) {\n            removeViews(1, childCount - 1)\n        }\n        val view = getChildAt(0)\n        setContentView(view)\n        showLoading()\n    }\n\n    private fun setContentView(view: View) {\n        mContentId = view.id\n        mLayouts[mContentId] = view\n    }\n\n    fun setLoading(@LayoutRes id: Int): LoadingLayout {\n        if (mLoadingResId != id) {\n            remove(mLoadingResId)\n            mLoadingResId = id\n        }\n        return this\n    }\n\n    fun setEmpty(@LayoutRes id: Int): LoadingLayout {\n        if (mEmptyResId != id) {\n            remove(mEmptyResId)\n            mEmptyResId = id\n        }\n        return this\n    }\n\n    fun setOnEmptyInflateListener(listener: OnInflateListener): LoadingLayout {\n        mOnEmptyInflateListener = listener\n        mOnEmptyInflateListener?.run {\n            if (mLayouts.containsKey(mEmptyResId)) {\n                onInflate(mLayouts[mEmptyResId])\n            }\n        }\n        return this\n    }\n\n    fun setOnErrorInflateListener(listener: OnInflateListener): LoadingLayout {\n        mOnErrorInflateListener = listener\n        if (mOnErrorInflateListener != null && mLayouts.containsKey(mErrorResId)) {\n            listener.onInflate(mLayouts[mErrorResId])\n        }\n        return this\n    }\n\n    fun setEmptyImage(@DrawableRes resId: Int): LoadingLayout {\n        mEmptyImage = resId\n        image(mEmptyResId, R.id.empty_image, mEmptyImage)\n        return this\n    }\n\n    fun setEmptyText(value: String): LoadingLayout {\n        mEmptyText = value\n        text(mEmptyResId, R.id.empty_text, mEmptyText)\n        return this\n    }\n\n    fun setErrorImage(@DrawableRes resId: Int): LoadingLayout {\n        mErrorImage = resId\n        image(mErrorResId, R.id.error_retry_image, mErrorImage)\n        return this\n    }\n\n    fun setErrorText(value: String): LoadingLayout {\n        mErrorText = value\n        text(mErrorResId, R.id.error_text, mErrorText)\n        return this\n    }\n\n//    fun setRetryText(text: String): LoadingLayout {\n//        mRetryText = text\n//        text(mErrorResId, R.id.retry_button, mRetryText)\n//        return this\n//    }\n\n    fun setRetryListener(listener: OnClickListener?): LoadingLayout {\n        mRetryListener = listener\n        return this\n    }\n\n    fun showLoading() {\n        show(mLoadingResId)\n    }\n\n    fun showEmpty() {\n        show(mEmptyResId)\n    }\n\n    fun showError() {\n        show(mErrorResId)\n    }\n\n    fun showContent() {\n        show(mContentId)\n    }\n\n    private fun show(layoutId: Int) {\n        for (view in mLayouts.values) {\n            view?.visibility = View.GONE\n        }\n        layout(layoutId)?.visibility = View.VISIBLE\n    }\n\n    private fun remove(layoutId: Int) {\n        if (mLayouts.containsKey(layoutId)) {\n            val vg = mLayouts.remove(layoutId)\n            removeView(vg)\n        }\n    }\n\n    private fun layout(layoutId: Int): View? {\n        if (mLayouts.containsKey(layoutId)) {\n            return mLayouts[layoutId]\n        }\n        val layout = mInflater.inflate(layoutId, this, false)\n        layout.visibility = View.GONE\n        addView(layout)\n        mLayouts[layoutId] = layout\n        when (layoutId) {\n            mEmptyResId -> {\n                (layout.findViewById<View>(R.id.empty_image) as? ImageView)?.run {\n                    setImageResource(mEmptyImage)\n                    setOnClickListener {\n                        mRetryListener?.onClick(it)\n                    }\n\n                    (layout.findViewById<View>(R.id.empty_text) as? TextView)?.run {\n                        text = mEmptyText\n                        setTextColor(mTextColor)\n                        setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextSize.toFloat())\n                    }\n\n                }\n\n                mOnEmptyInflateListener?.onInflate(layout)\n            }\n            mErrorResId -> {\n                val retryImage = layout.findViewById<View>(R.id.error_retry_image) as? ImageView\n                retryImage?.setImageResource(mErrorImage)\n                retryImage?.setOnClickListener(mRetryButtonClickListener)\n\n                (layout.findViewById<View>(R.id.error_text) as? TextView)?.run {\n                    text = mErrorText\n                    setTextColor(mTextColor)\n                    setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextSize.toFloat())\n\n                }\n                //            (layout.findViewById<View>(R.id.retry_button) as? TextView)?.run {\n                //                text = mRetryText\n                //                setTextColor(mButtonTextColor)\n                //                setTextSize(TypedValue.COMPLEX_UNIT_PX, mButtonTextSize.toFloat())\n                //                background = mButtonBackground\n                //                setOnClickListener(mRetryButtonClickListener)\n                //            }\n                mOnErrorInflateListener?.onInflate(layout)\n            }\n            mLoadingResId -> {\n                val tvLoading = layout.findViewById<View>(R.id.loading_view)\n                val anim: Animation =\n                    AnimationUtils.loadAnimation(context, R.anim.animation_progress)\n                anim.interpolator = LinearInterpolator ()\n                anim.repeatCount = -1\n                tvLoading.startAnimation(anim)\n            }\n        }\n        return layout\n    }\n\n    private fun text(layoutId: Int, ctrlId: Int, value: CharSequence?) {\n        if (mLayouts.containsKey(layoutId)) {\n            val view =\n                mLayouts[layoutId]?.findViewById<View>(ctrlId) as? TextView\n            view?.text = value\n        }\n    }\n\n    private fun image(layoutId: Int, ctrlId: Int, resId: Int) {\n        if (mLayouts.containsKey(layoutId)) {\n            val view =\n                mLayouts[layoutId]?.findViewById<View>(ctrlId) as? ImageView\n            view?.setImageResource(resId)\n        }\n    }\n\n    companion object {\n        fun wrap(\n            activity: Activity\n        ): LoadingLayout {\n            return wrap(\n                (activity.findViewById<View>(android.R.id.content) as? ViewGroup)?.getChildAt(\n                    0\n                )\n            )\n        }\n\n        fun wrap(fragment: Fragment): LoadingLayout {\n            return wrap(fragment.view)\n        }\n\n        fun wrap(view: View?): LoadingLayout {\n            if (view == null) {\n                throw RuntimeException(\"content view can not be null\")\n            }\n            val parent = view.parent as? ViewGroup\n            val lp = view.layoutParams\n            val index = parent?.indexOfChild(view) ?: -1\n            parent?.removeView(view)\n            val layout = LoadingLayout(view.context)\n            parent?.addView(layout, index, lp)\n            layout.addView(view)\n            layout.setContentView(view)\n            return layout\n        }\n    }\n\n\n}\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580911037},"updatedAt":{"$$date":1598584048760},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"vClOF5DkMPF0GHYd"}
{"name":"HTML5 新的 Input 类型","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\nHTML5 新的 Input 类型\nHTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证。\n\n本章全面介绍这些新的输入类型：\n\ncolor\ndate\ndatetime\ndatetime-local\nemail\nmonth\nnumber\nrange\nsearch\ntel\ntime\nurl\nweek\n注意:并不是所有的主流浏览器都支持新的input类型，不过您已经可以在所有主流的浏览器中使用它们了。即使不被支持，仍然可以显示为常规的文本域。\n\nInput 类型: color\ncolor 类型用在input字段主要用于选取颜色，如下所示：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n从拾色器中选择一个颜色:\n\n选择你喜欢的颜色: <input type=\"color\" name=\"favcolor\">\n\n尝试一下 »\n\nInput 类型: date\ndate 类型允许你从一个日期选择器选择一个日期。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义一个时间控制器:\n\n生日: <input type=\"date\" name=\"bday\">\n\n尝试一下 »\n\nInput 类型: datetime\ndatetime 类型允许你选择一个日期（UTC 时间）。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义一个日期和时间控制器（本地时间）:\n\n生日 (日期和时间): <input type=\"datetime\" name=\"bdaytime\">\n\n尝试一下 »\n\nInput 类型: datetime-local\ndatetime-local 类型允许你选择一个日期和时间 (无时区).\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义一个日期和时间 (无时区):\n\n生日 (日期和时间): <input type=\"datetime-local\" name=\"bdaytime\">\n\n尝试一下 »\n\nInput 类型: email\nemail 类型用于应该包含 e-mail 地址的输入域。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n在提交表单时，会自动验证 email 域的值是否合法有效:\n\nE-mail: <input type=\"email\" name=\"email\">\n\n尝试一下 »\n提示: iPhone 中的 Safari 浏览器支持 email 输入类型，并通过改变触摸屏键盘来配合它（添加 @ 和 .com 选项）。\n\nInput 类型: month\nmonth 类型允许你选择一个月份。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义月与年 (无时区):\n\n生日 (月和年): <input type=\"month\" name=\"bdaymonth\">\n\n尝试一下 »\n\nInput 类型: number\nnumber 类型用于应该包含数值的输入域。\n\n您还能够设定对所接受的数字的限定：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义一个数值输入域(限定):\n\n数量 ( 1 到 5 之间 ): <input type=\"number\" name=\"quantity\" min=\"1\" max=\"5\">\n\n尝试一下 »\n使用下面的属性来规定对数字类型的限定：\n\n属性\t描述\ndisabled\t规定输入字段是禁用的\nmax\t规定允许的最大值\nmaxlength\t规定输入字段的最大字符长度\nmin\t规定允许的最小值\npattern\t规定用于验证输入字段的模式\nreadonly\t规定输入字段的值无法修改\nrequired\t规定输入字段的值是必需的\nsize\t规定输入字段中的可见字符数\nstep\t规定输入字段的合法数字间隔\nvalue\t规定输入字段的默认值\n尝试一下带有所有限定属性的例子 尝试一下\n\nInput 类型: range\nrange 类型用于应该包含一定范围内数字值的输入域。\n\nrange 类型显示为滑动条。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义一个不需要非常精确的数值（类似于滑块控制）:\n\n<input type=\"range\" name=\"points\" min=\"1\" max=\"10\">\n\n尝试一下 »\n请使用下面的属性来规定对数字类型的限定：\n\nmax - 规定允许的最大值\nmin - 规定允许的最小值\nstep - 规定合法的数字间隔\nvalue - 规定默认值\nInput 类型: search\nsearch 类型用于搜索域，比如站点搜索或 Google 搜索。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义一个搜索字段 (类似站点搜索或者Google搜索):\n\nSearch Google: <input type=\"search\" name=\"googlesearch\">\n\n尝试一下 »\n\nInput 类型: tel\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义输入电话号码字段:\n\n电话号码: <input type=\"tel\" name=\"usrtel\">\n\n尝试一下 »\n\nInput 类型: time\ntime 类型允许你选择一个时间。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义可输入时间控制器（无时区）：\n\n选择时间: <input type=\"time\" name=\"usr_time\">\n\n尝试一下 »\n\nInput 类型: url\nurl 类型用于应该包含 URL 地址的输入域。\n\n在提交表单时，会自动验证 url 域的值。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义输入URL字段:\n\n添加您的主页: <input type=\"url\" name=\"homepage\">\n\n尝试一下 »\n提示: iPhone 中的 Safari 浏览器支持 url 输入类型，并通过改变触摸屏键盘来配合它（添加 .com 选项）。\n\nInput 类型: week\nweek 类型允许你选择周和年。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n定义周和年 (无时区):\n\n选择周: <input type=\"week\" name=\"week_year\">\n\n尝试一下 »\n\nHTML5 <input> 标签\n标签\t描述\n<input>\t描述input输入器\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887688564},"updatedAt":{"$$date":1598887784259},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"vR8L3HKNHSgf4a1O"}
{"name":"ad-","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598539543738},"updatedAt":{"$$date":1598539543738},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"vSwBARoiVTpTqU5a"}
{"name":"HTML5 Web 存储","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n} else {\n    // 抱歉! 不支持 web 存储。\n}\n\nlocalStorage 对象\nlocalStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。\n\n实例\nlocalStorage.sitename=\"菜鸟教程\";\ndocument.getElementById(\"result\").innerHTML=\"网站名：\" + localStorage.sitename;\n\n尝试一下 »\n实例解析：\n\n使用 key=\"sitename\" 和 value=\"菜鸟教程\" 创建一个 localStorage 键/值对。\n检索键值为\"sitename\" 的值然后将数据插入 id=\"result\"的元素中。\n以上实例也可以这么写：\n\n// 存储\nlocalStorage.sitename = \"菜鸟教程\";\n// 查找\ndocument.getElementById(\"result\").innerHTML = localStorage.sitename;\n移除 localStorage 中的 \"sitename\" :\n\nlocalStorage.removeItem(\"sitename\");\n不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：\n\n保存数据：localStorage.setItem(key,value);\n读取数据：localStorage.getItem(key);\n删除单个数据：localStorage.removeItem(key);\n删除所有数据：localStorage.clear();\n得到某个索引的key：localStorage.key(index);\n提示: 键/值对通常以字符串存储，你可以按自己的需要转换该格式。\n\n下面的实例展示了用户点击按钮的次数。\n\n代码中的字符串值转换为数字类型:\n\n实例\nif (localStorage.clickcount)\n{\n    localStorage.clickcount=Number(localStorage.clickcount)+1;\n}\nelse\n{\n    localStorage.clickcount=1;\n}\ndocument.getElementById(\"result\").innerHTML=\" 你已经点击了按钮 \" + localStorage.clickcount + \" 次 \";\n\n尝试一下 »\n\nsessionStorage 对象\nsessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。\n\n如何创建并访问一个 sessionStorage：\n\n实例\nif (sessionStorage.clickcount)\n{\n    sessionStorage.clickcount=Number(sessionStorage.clickcount)+1;\n}\nelse\n{\n    sessionStorage.clickcount=1;\n}\ndocument.getElementById(\"result\").innerHTML=\"在这个会话中你已经点击了该按钮 \" + sessionStorage.clickcount + \" 次 \";\n\n尝试一下 »\nWeb Storage 开发一个简单的网站列表程序\n网站列表程序实现以下功能：\n\n可以输入网站名，网址，以网站名作为key存入localStorage；\n根据网站名，查找网址；\n列出当前已保存的所有网站；\n以下代码用于保存于查找数据：\n\nsave() 与 find() 方法\n//保存数据  \nfunction save(){  \n    var siteurl = document.getElementById(\"siteurl\").value;  \n    var sitename = document.getElementById(\"sitename\").value;  \n    localStorage.setItem(sitename, siteurl);\n    alert(\"添加成功\");\n}\n//查找数据  \nfunction find(){  \n    var search_site = document.getElementById(\"search_site\").value;  \n    var sitename = localStorage.getItem(search_site);  \n    var find_result = document.getElementById(\"find_result\");  \n    find_result.innerHTML = search_site + \"的网址是：\" + sitename;  \n}\n完整实例演示如下：\n\n实例\n<div style=\"border: 2px dashed #ccc;width:320px;text-align:center;\">     \n    <label for=\"sitename\">网站名(key)：</label>  \n    <input type=\"text\" id=\"sitename\" name=\"sitename\" class=\"text\"/>  \n    <br/>  \n    <label for=\"siteurl\">网 址(value)：</label>  \n    <input type=\"text\" id=\"siteurl\" name=\"siteurl\"/>  \n    <br/>  \n    <input type=\"button\" onclick=\"save()\" value=\"新增记录\"/>  \n    <hr/>  \n    <label for=\"search_site\">输入网站名：</label>  \n    <input type=\"text\" id=\"search_site\" name=\"search_site\"/>  \n    <input type=\"button\" onclick=\"find()\" value=\"查找网站\"/>  \n    <p id=\"find_result\"><br/></p>  \n</div>\n\n尝试一下 »\n实现效果截图：\n\n\n\n以上实例只是演示了简单的 localStorage 存储与查找，更多情况下我们存储的数据会更复杂。\n\n接下来我们将使用 JSON.stringify 来存储对象数据，JSON.stringify 可以将对象转换为字符串。\n\nvar site = new Object;\n...\nvar str = JSON.stringify(site); // 将对象转换为字符串\n之后我们使用 JSON.parse 方法将字符串转换为 JSON 对象：\n\nvar site = JSON.parse(str);\nJavaScript 实现代码：\n\nsave() 与 find() 方法\n//保存数据  \nfunction save(){  \n    var site = new Object;\n    site.keyname = document.getElementById(\"keyname\").value;\n    site.sitename = document.getElementById(\"sitename\").value;  \n    site.siteurl = document.getElementById(\"siteurl\").value;\n    var str = JSON.stringify(site); // 将对象转换为字符串\n    localStorage.setItem(site.keyname,str);  \n    alert(\"保存成功\");\n}  \n//查找数据  \nfunction find(){  \n    var search_site = document.getElementById(\"search_site\").value;  \n    var str = localStorage.getItem(search_site);  \n    var find_result = document.getElementById(\"find_result\");\n    var site = JSON.parse(str);  \n    find_result.innerHTML = search_site + \"的网站名是：\" + site.sitename + \"，网址是：\" + site.siteurl;  \n}\n完整实例如下：\n\n实例\n<div style=\"border: 2px dashed #ccc;width:320px;text-align:center;\">\n    <label for=\"keyname\">别名(key):</label>  \n    <input type=\"text\" id=\"keyname\" name=\"keyname\" class=\"text\"/>  \n    <br/>  \n    <label for=\"sitename\">网站名：</label>  \n    <input type=\"text\" id=\"sitename\" name=\"sitename\" class=\"text\"/>  \n    <br/>  \n    <label for=\"siteurl\">网 址：</label>  \n    <input type=\"text\" id=\"siteurl\" name=\"siteurl\"/>  \n    <br/>  \n    <input type=\"button\" onclick=\"save()\" value=\"新增记录\"/>  \n    <hr/>  \n    <label for=\"search_site\">输入别名(key)：</label>  \n    <input type=\"text\" id=\"search_site\" name=\"search_site\"/>  \n    <input type=\"button\" onclick=\"find()\" value=\"查找网站\"/>  \n    <p id=\"find_result\"><br/></p>  \n</div>\n\n尝试一下 »\n实例中的 loadAll 输出了所有存储的数据，你需要确保 localStorage 存储的数据都为 JSON 格式，否则 JSON.parse(str) 将会报错。\n\n输出结果演示：\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598887692921},"updatedAt":{"$$date":1598887947483},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"vT5FFf8kqkmdzKcI"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598525729085},"updatedAt":{"$$date":1598538089979},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"vTI1CUF0Vfdx45s7"}
{"name":"qk-ks_lib_ktx","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 103\n        versionName \"103\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n\n\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n    api deps.androidx.appcompat\n    api deps.kotlin.stdlib_jdk\n\n    api deps.kotlin.coroutines_core\n    api deps.kotlin.coroutines_android\n}\n\nrepositories {\n    mavenCentral()\n}\n\n//这句话一定要添加到文件末尾\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata class AppInfo(\n    val apkPath: String,\n    val packageName: String,\n    val versionName: String,\n    val versionCode: Long,\n    val appName: String,\n    val icon: Drawable\n)\n\n\n\n\n\n\n\n\n\n\nprivate const val ALL_MIME_TYPES = \"*/*\"\nval MIME_TYPES = HashMap<String, String>().apply {\n    put(\"323\", \"text/h323\")\n    put(\"3g2\", \"video/3gpp2\")\n    put(\"3gp\", \"video/3gpp\")\n    put(\"3gp2\", \"video/3gpp2\")\n    put(\"3gpp\", \"video/3gpp\")\n    put(\"7z\", \"application/x-7z-compressed\")\n    put(\"aa\", \"audio/audible\")\n    put(\"aac\", \"audio/aac\")\n    put(\"aaf\", \"application/octet-stream\")\n    put(\"aax\", \"audio/vnd.audible.aax\")\n    put(\"ac3\", \"audio/ac3\")\n    put(\"aca\", \"application/octet-stream\")\n    put(\"accda\", \"application/msaccess.addin\")\n    put(\"accdb\", \"application/msaccess\")\n    put(\"accdc\", \"application/msaccess.cab\")\n    put(\"accde\", \"application/msaccess\")\n    put(\"accdr\", \"application/msaccess.runtime\")\n    put(\"accdt\", \"application/msaccess\")\n    put(\"accdw\", \"application/msaccess.webapplication\")\n    put(\"accft\", \"application/msaccess.ftemplate\")\n    put(\"acx\", \"application/internet-property-stream\")\n    put(\"addin\", \"text/xml\")\n    put(\"ade\", \"application/msaccess\")\n    put(\"adobebridge\", \"application/x-bridge-url\")\n    put(\"adp\", \"application/msaccess\")\n    put(\"adt\", \"audio/vnd.dlna.adts\")\n    put(\"adts\", \"audio/aac\")\n    put(\"afm\", \"application/octet-stream\")\n    put(\"ai\", \"application/postscript\")\n    put(\"aif\", \"audio/aiff\")\n    put(\"aifc\", \"audio/aiff\")\n    put(\"aiff\", \"audio/aiff\")\n    put(\"air\", \"application/vnd.adobe.air-application-installer-package+zip\")\n    put(\"amc\", \"application/mpeg\")\n    put(\"anx\", \"application/annodex\")\n    put(\"apk\", \"application/vnd.android.package-archive\")\n    put(\"application\", \"application/x-ms-application\")\n    put(\"art\", \"image/x-jg\")\n    put(\"asa\", \"application/xml\")\n    put(\"asax\", \"application/xml\")\n    put(\"ascx\", \"application/xml\")\n    put(\"asd\", \"application/octet-stream\")\n    put(\"asf\", \"video/x-ms-asf\")\n    put(\"ashx\", \"application/xml\")\n    put(\"asi\", \"application/octet-stream\")\n    put(\"asm\", \"text/plain\")\n    put(\"asmx\", \"application/xml\")\n    put(\"aspx\", \"application/xml\")\n    put(\"asr\", \"video/x-ms-asf\")\n    put(\"asx\", \"video/x-ms-asf\")\n    put(\"atom\", \"application/atom+xml\")\n    put(\"au\", \"audio/basic\")\n    put(\"avi\", \"video/x-msvideo\")\n    put(\"axa\", \"audio/annodex\")\n    put(\"axs\", \"application/olescript\")\n    put(\"axv\", \"video/annodex\")\n    put(\"bas\", \"text/plain\")\n    put(\"bcpio\", \"application/x-bcpio\")\n    put(\"bin\", \"application/octet-stream\")\n    put(\"bmp\", \"image/bmp\")\n    put(\"c\", \"text/plain\")\n    put(\"cab\", \"application/octet-stream\")\n    put(\"caf\", \"audio/x-caf\")\n    put(\"calx\", \"application/vnd.ms-office.calx\")\n    put(\"cat\", \"application/vnd.ms-pki.seccat\")\n    put(\"cc\", \"text/plain\")\n    put(\"cd\", \"text/plain\")\n    put(\"cdda\", \"audio/aiff\")\n    put(\"cdf\", \"application/x-cdf\")\n    put(\"cer\", \"application/x-x509-ca-cert\")\n    put(\"cfg\", \"text/plain\")\n    put(\"chm\", \"application/octet-stream\")\n    put(\"class\", \"application/x-java-applet\")\n    put(\"clp\", \"application/x-msclip\")\n    put(\"cmd\", \"text/plain\")\n    put(\"cmx\", \"image/x-cmx\")\n    put(\"cnf\", \"text/plain\")\n    put(\"cod\", \"image/cis-cod\")\n    put(\"config\", \"application/xml\")\n    put(\"contact\", \"text/x-ms-contact\")\n    put(\"coverage\", \"application/xml\")\n    put(\"cpio\", \"application/x-cpio\")\n    put(\"cpp\", \"text/plain\")\n    put(\"crd\", \"application/x-mscardfile\")\n    put(\"crl\", \"application/pkix-crl\")\n    put(\"crt\", \"application/x-x509-ca-cert\")\n    put(\"cs\", \"text/plain\")\n    put(\"csdproj\", \"text/plain\")\n    put(\"csh\", \"application/x-csh\")\n    put(\"csproj\", \"text/plain\")\n    put(\"css\", \"text/css\")\n    put(\"csv\", \"text/csv\")\n    put(\"cur\", \"application/octet-stream\")\n    put(\"cxx\", \"text/plain\")\n    put(\"dat\", \"application/octet-stream\")\n    put(\"datasource\", \"application/xml\")\n    put(\"dbproj\", \"text/plain\")\n    put(\"dcr\", \"application/x-director\")\n    put(\"def\", \"text/plain\")\n    put(\"deploy\", \"application/octet-stream\")\n    put(\"der\", \"application/x-x509-ca-cert\")\n    put(\"dgml\", \"application/xml\")\n    put(\"dib\", \"image/bmp\")\n    put(\"dif\", \"video/x-dv\")\n    put(\"dir\", \"application/x-director\")\n    put(\"disco\", \"text/xml\")\n    put(\"divx\", \"video/divx\")\n    put(\"dll\", \"application/x-msdownload\")\n    put(\"dll.config\", \"text/xml\")\n    put(\"dlm\", \"text/dlm\")\n    put(\"dng\", \"image/x-adobe-dng\")\n    put(\"doc\", \"application/msword\")\n    put(\"docm\", \"application/vnd.ms-word.document.macroEnabled.12\")\n    put(\"docx\", \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\")\n    put(\"dot\", \"application/msword\")\n    put(\"dotm\", \"application/vnd.ms-word.template.macroEnabled.12\")\n    put(\"dotx\", \"application/vnd.openxmlformats-officedocument.wordprocessingml.template\")\n    put(\"dsp\", \"application/octet-stream\")\n    put(\"dsw\", \"text/plain\")\n    put(\"dtd\", \"text/xml\")\n    put(\"dtsconfig\", \"text/xml\")\n    put(\"dv\", \"video/x-dv\")\n    put(\"dvi\", \"application/x-dvi\")\n    put(\"dwf\", \"drawing/x-dwf\")\n    put(\"dwp\", \"application/octet-stream\")\n    put(\"dxr\", \"application/x-director\")\n    put(\"eml\", \"message/rfc822\")\n    put(\"emz\", \"application/octet-stream\")\n    put(\"eot\", \"application/vnd.ms-fontobject\")\n    put(\"eps\", \"application/postscript\")\n    put(\"etl\", \"application/etl\")\n    put(\"etx\", \"text/x-setext\")\n    put(\"evy\", \"application/envoy\")\n    put(\"exe\", \"application/octet-stream\")\n    put(\"exe.config\", \"text/xml\")\n    put(\"fdf\", \"application/vnd.fdf\")\n    put(\"fif\", \"application/fractals\")\n    put(\"filters\", \"application/xml\")\n    put(\"fla\", \"application/octet-stream\")\n    put(\"flac\", \"audio/flac\")\n    put(\"flr\", \"x-world/x-vrml\")\n    put(\"flv\", \"video/x-flv\")\n    put(\"fsscript\", \"application/fsharp-script\")\n    put(\"fsx\", \"application/fsharp-script\")\n    put(\"generictest\", \"application/xml\")\n    put(\"gif\", \"image/gif\")\n    put(\"group\", \"text/x-ms-group\")\n    put(\"gsm\", \"audio/x-gsm\")\n    put(\"gtar\", \"application/x-gtar\")\n    put(\"gz\", \"application/x-gzip\")\n    put(\"h\", \"text/plain\")\n    put(\"hdf\", \"application/x-hdf\")\n    put(\"hdml\", \"text/x-hdml\")\n    put(\"hhc\", \"application/x-oleobject\")\n    put(\"hhk\", \"application/octet-stream\")\n    put(\"hhp\", \"application/octet-stream\")\n    put(\"hlp\", \"application/winhlp\")\n    put(\"hpp\", \"text/plain\")\n    put(\"hqx\", \"application/mac-binhex40\")\n    put(\"hta\", \"application/hta\")\n    put(\"htc\", \"text/x-component\")\n    put(\"htm\", \"text/html\")\n    put(\"html\", \"text/html\")\n    put(\"htt\", \"text/webviewhtml\")\n    put(\"hxa\", \"application/xml\")\n    put(\"hxc\", \"application/xml\")\n    put(\"hxd\", \"application/octet-stream\")\n    put(\"hxe\", \"application/xml\")\n    put(\"hxf\", \"application/xml\")\n    put(\"hxh\", \"application/octet-stream\")\n    put(\"hxi\", \"application/octet-stream\")\n    put(\"hxk\", \"application/xml\")\n    put(\"hxq\", \"application/octet-stream\")\n    put(\"hxr\", \"application/octet-stream\")\n    put(\"hxs\", \"application/octet-stream\")\n    put(\"hxt\", \"text/html\")\n    put(\"hxv\", \"application/xml\")\n    put(\"hxw\", \"application/octet-stream\")\n    put(\"hxx\", \"text/plain\")\n    put(\"i\", \"text/plain\")\n    put(\"ico\", \"image/x-icon\")\n    put(\"ics\", \"text/calendar\")\n    put(\"idl\", \"text/plain\")\n    put(\"ief\", \"image/ief\")\n    put(\"iii\", \"application/x-iphone\")\n    put(\"inc\", \"text/plain\")\n    put(\"inf\", \"application/octet-stream\")\n    put(\"ini\", \"text/plain\")\n    put(\"inl\", \"text/plain\")\n    put(\"ins\", \"application/x-internet-signup\")\n    put(\"ipa\", \"application/x-itunes-ipa\")\n    put(\"ipg\", \"application/x-itunes-ipg\")\n    put(\"ipproj\", \"text/plain\")\n    put(\"ipsw\", \"application/x-itunes-ipsw\")\n    put(\"iqy\", \"text/x-ms-iqy\")\n    put(\"isp\", \"application/x-internet-signup\")\n    put(\"ite\", \"application/x-itunes-ite\")\n    put(\"itlp\", \"application/x-itunes-itlp\")\n    put(\"itms\", \"application/x-itunes-itms\")\n    put(\"itpc\", \"application/x-itunes-itpc\")\n    put(\"ivf\", \"video/x-ivf\")\n    put(\"jar\", \"application/java-archive\")\n    put(\"java\", \"application/octet-stream\")\n    put(\"jck\", \"application/liquidmotion\")\n    put(\"jcz\", \"application/liquidmotion\")\n    put(\"jfif\", \"image/pjpeg\")\n    put(\"jnlp\", \"application/x-java-jnlp-file\")\n    put(\"jpb\", \"application/octet-stream\")\n    put(\"jpe\", \"image/jpeg\")\n    put(\"jpeg\", \"image/jpeg\")\n    put(\"jpg\", \"image/jpeg\")\n    put(\"js\", \"application/javascript\")\n    put(\"json\", \"application/json\")\n    put(\"jsx\", \"text/jscript\")\n    put(\"jsxbin\", \"text/plain\")\n    put(\"latex\", \"application/x-latex\")\n    put(\"library-ms\", \"application/windows-library+xml\")\n    put(\"lit\", \"application/x-ms-reader\")\n    put(\"loadtest\", \"application/xml\")\n    put(\"lpk\", \"application/octet-stream\")\n    put(\"lsf\", \"video/x-la-asf\")\n    put(\"lst\", \"text/plain\")\n    put(\"lsx\", \"video/x-la-asf\")\n    put(\"lzh\", \"application/octet-stream\")\n    put(\"m13\", \"application/x-msmediaview\")\n    put(\"m14\", \"application/x-msmediaview\")\n    put(\"m1v\", \"video/mpeg\")\n    put(\"m2t\", \"video/vnd.dlna.mpeg-tts\")\n    put(\"m2ts\", \"video/vnd.dlna.mpeg-tts\")\n    put(\"m2v\", \"video/mpeg\")\n    put(\"m3u\", \"audio/x-mpegurl\")\n    put(\"m3u8\", \"audio/x-mpegurl\")\n    put(\"m4a\", \"audio/m4a\")\n    put(\"m4b\", \"audio/m4b\")\n    put(\"m4p\", \"audio/m4p\")\n    put(\"m4r\", \"audio/x-m4r\")\n    put(\"m4v\", \"video/x-m4v\")\n    put(\"mac\", \"image/x-macpaint\")\n    put(\"mak\", \"text/plain\")\n    put(\"man\", \"application/x-troff-man\")\n    put(\"manifest\", \"application/x-ms-manifest\")\n    put(\"map\", \"text/plain\")\n    put(\"master\", \"application/xml\")\n    put(\"mda\", \"application/msaccess\")\n    put(\"mdb\", \"application/x-msaccess\")\n    put(\"mde\", \"application/msaccess\")\n    put(\"mdp\", \"application/octet-stream\")\n    put(\"me\", \"application/x-troff-me\")\n    put(\"mfp\", \"application/x-shockwave-flash\")\n    put(\"mht\", \"message/rfc822\")\n    put(\"mhtml\", \"message/rfc822\")\n    put(\"mid\", \"audio/mid\")\n    put(\"midi\", \"audio/mid\")\n    put(\"mix\", \"application/octet-stream\")\n    put(\"mk\", \"text/plain\")\n    put(\"mkv\", \"video/x-matroska\")\n    put(\"mmf\", \"application/x-smaf\")\n    put(\"mno\", \"text/xml\")\n    put(\"mny\", \"application/x-msmoney\")\n    put(\"mod\", \"video/mpeg\")\n    put(\"mov\", \"video/quicktime\")\n    put(\"movie\", \"video/x-sgi-movie\")\n    put(\"mp2\", \"video/mpeg\")\n    put(\"mp2v\", \"video/mpeg\")\n    put(\"mp3\", \"audio/mpeg\")\n    put(\"mp4\", \"video/mp4\")\n    put(\"mp4v\", \"video/mp4\")\n    put(\"mpa\", \"video/mpeg\")\n    put(\"mpe\", \"video/mpeg\")\n    put(\"mpeg\", \"video/mpeg\")\n    put(\"mpf\", \"application/vnd.ms-mediapackage\")\n    put(\"mpg\", \"video/mpeg\")\n    put(\"mpp\", \"application/vnd.ms-project\")\n    put(\"mpv2\", \"video/mpeg\")\n    put(\"mqv\", \"video/quicktime\")\n    put(\"ms\", \"application/x-troff-ms\")\n    put(\"msi\", \"application/octet-stream\")\n    put(\"mso\", \"application/octet-stream\")\n    put(\"mts\", \"video/vnd.dlna.mpeg-tts\")\n    put(\"mtx\", \"application/xml\")\n    put(\"mvb\", \"application/x-msmediaview\")\n    put(\"mvc\", \"application/x-miva-compiled\")\n    put(\"mxp\", \"application/x-mmxp\")\n    put(\"nc\", \"application/x-netcdf\")\n    put(\"nsc\", \"video/x-ms-asf\")\n    put(\"nws\", \"message/rfc822\")\n    put(\"ocx\", \"application/octet-stream\")\n    put(\"oda\", \"application/oda\")\n    put(\"odb\", \"application/vnd.oasis.opendocument.database\")\n    put(\"odc\", \"application/vnd.oasis.opendocument.chart\")\n    put(\"odf\", \"application/vnd.oasis.opendocument.formula\")\n    put(\"odg\", \"application/vnd.oasis.opendocument.graphics\")\n    put(\"odh\", \"text/plain\")\n    put(\"odi\", \"application/vnd.oasis.opendocument.image\")\n    put(\"odl\", \"text/plain\")\n    put(\"odm\", \"application/vnd.oasis.opendocument.text-master\")\n    put(\"odp\", \"application/vnd.oasis.opendocument.presentation\")\n    put(\"ods\", \"application/vnd.oasis.opendocument.spreadsheet\")\n    put(\"odt\", \"application/vnd.oasis.opendocument.text\")\n    put(\"oga\", \"audio/ogg\")\n    put(\"ogg\", \"audio/ogg\")\n    put(\"ogv\", \"video/ogg\")\n    put(\"ogx\", \"application/ogg\")\n    put(\"one\", \"application/onenote\")\n    put(\"onea\", \"application/onenote\")\n    put(\"onepkg\", \"application/onenote\")\n    put(\"onetmp\", \"application/onenote\")\n    put(\"onetoc\", \"application/onenote\")\n    put(\"onetoc2\", \"application/onenote\")\n    put(\"opus\", \"audio/ogg\")\n    put(\"orderedtest\", \"application/xml\")\n    put(\"osdx\", \"application/opensearchdescription+xml\")\n    put(\"otf\", \"application/font-sfnt\")\n    put(\"otg\", \"application/vnd.oasis.opendocument.graphics-template\")\n    put(\"oth\", \"application/vnd.oasis.opendocument.text-web\")\n    put(\"otp\", \"application/vnd.oasis.opendocument.presentation-template\")\n    put(\"ots\", \"application/vnd.oasis.opendocument.spreadsheet-template\")\n    put(\"ott\", \"application/vnd.oasis.opendocument.text-template\")\n    put(\"oxt\", \"application/vnd.openofficeorg.extension\")\n    put(\"p10\", \"application/pkcs10\")\n    put(\"p12\", \"application/x-pkcs12\")\n    put(\"p7b\", \"application/x-pkcs7-certificates\")\n    put(\"p7c\", \"application/pkcs7-mime\")\n    put(\"p7m\", \"application/pkcs7-mime\")\n    put(\"p7r\", \"application/x-pkcs7-certreqresp\")\n    put(\"p7s\", \"application/pkcs7-signature\")\n    put(\"pbm\", \"image/x-portable-bitmap\")\n    put(\"pcast\", \"application/x-podcast\")\n    put(\"pct\", \"image/pict\")\n    put(\"pcx\", \"application/octet-stream\")\n    put(\"pcz\", \"application/octet-stream\")\n    put(\"pdf\", \"application/pdf\")\n    put(\"pfb\", \"application/octet-stream\")\n    put(\"pfm\", \"application/octet-stream\")\n    put(\"pfx\", \"application/x-pkcs12\")\n    put(\"pgm\", \"image/x-portable-graymap\")\n    put(\"php\", \"text/plain\")\n    put(\"pic\", \"image/pict\")\n    put(\"pict\", \"image/pict\")\n    put(\"pkgdef\", \"text/plain\")\n    put(\"pkgundef\", \"text/plain\")\n    put(\"pko\", \"application/vnd.ms-pki.pko\")\n    put(\"pls\", \"audio/scpls\")\n    put(\"pma\", \"application/x-perfmon\")\n    put(\"pmc\", \"application/x-perfmon\")\n    put(\"pml\", \"application/x-perfmon\")\n    put(\"pmr\", \"application/x-perfmon\")\n    put(\"pmw\", \"application/x-perfmon\")\n    put(\"png\", \"image/png\")\n    put(\"pnm\", \"image/x-portable-anymap\")\n    put(\"pnt\", \"image/x-macpaint\")\n    put(\"pntg\", \"image/x-macpaint\")\n    put(\"pnz\", \"image/png\")\n    put(\"pot\", \"application/vnd.ms-powerpoint\")\n    put(\"potm\", \"application/vnd.ms-powerpoint.template.macroEnabled.12\")\n    put(\"potx\", \"application/vnd.openxmlformats-officedocument.presentationml.template\")\n    put(\"ppa\", \"application/vnd.ms-powerpoint\")\n    put(\"ppam\", \"application/vnd.ms-powerpoint.addin.macroEnabled.12\")\n    put(\"ppm\", \"image/x-portable-pixmap\")\n    put(\"pps\", \"application/vnd.ms-powerpoint\")\n    put(\"ppsm\", \"application/vnd.ms-powerpoint.slideshow.macroEnabled.12\")\n    put(\"ppsx\", \"application/vnd.openxmlformats-officedocument.presentationml.slideshow\")\n    put(\"ppt\", \"application/vnd.ms-powerpoint\")\n    put(\"pptm\", \"application/vnd.ms-powerpoint.presentation.macroEnabled.12\")\n    put(\"pptx\", \"application/vnd.openxmlformats-officedocument.presentationml.presentation\")\n    put(\"prf\", \"application/pics-rules\")\n    put(\"prm\", \"application/octet-stream\")\n    put(\"prx\", \"application/octet-stream\")\n    put(\"ps\", \"application/postscript\")\n    put(\"psc1\", \"application/PowerShell\")\n    put(\"psd\", \"application/octet-stream\")\n    put(\"psess\", \"application/xml\")\n    put(\"psm\", \"application/octet-stream\")\n    put(\"psp\", \"application/octet-stream\")\n    put(\"pub\", \"application/x-mspublisher\")\n    put(\"pwz\", \"application/vnd.ms-powerpoint\")\n    put(\"py\", \"text/plain\")\n    put(\"qht\", \"text/x-html-insertion\")\n    put(\"qhtm\", \"text/x-html-insertion\")\n    put(\"qt\", \"video/quicktime\")\n    put(\"qti\", \"image/x-quicktime\")\n    put(\"qtif\", \"image/x-quicktime\")\n    put(\"qtl\", \"application/x-quicktimeplayer\")\n    put(\"qxd\", \"application/octet-stream\")\n    put(\"ra\", \"audio/x-pn-realaudio\")\n    put(\"ram\", \"audio/x-pn-realaudio\")\n    put(\"rar\", \"application/x-rar-compressed\")\n    put(\"ras\", \"image/x-cmu-raster\")\n    put(\"rat\", \"application/rat-file\")\n    put(\"rb\", \"text/plain\")\n    put(\"rc\", \"text/plain\")\n    put(\"rc2\", \"text/plain\")\n    put(\"rct\", \"text/plain\")\n    put(\"rdlc\", \"application/xml\")\n    put(\"reg\", \"text/plain\")\n    put(\"resx\", \"application/xml\")\n    put(\"rf\", \"image/vnd.rn-realflash\")\n    put(\"rgb\", \"image/x-rgb\")\n    put(\"rgs\", \"text/plain\")\n    put(\"rm\", \"application/vnd.rn-realmedia\")\n    put(\"rmi\", \"audio/mid\")\n    put(\"rmp\", \"application/vnd.rn-rn_music_package\")\n    put(\"roff\", \"application/x-troff\")\n    put(\"rpm\", \"audio/x-pn-realaudio-plugin\")\n    put(\"rqy\", \"text/x-ms-rqy\")\n    put(\"rtf\", \"application/rtf\")\n    put(\"rtx\", \"text/richtext\")\n    put(\"ruleset\", \"application/xml\")\n    put(\"s\", \"text/plain\")\n    put(\"safariextz\", \"application/x-safari-safariextz\")\n    put(\"scd\", \"application/x-msschedule\")\n    put(\"scr\", \"text/plain\")\n    put(\"sct\", \"text/scriptlet\")\n    put(\"sd2\", \"audio/x-sd2\")\n    put(\"sdp\", \"application/sdp\")\n    put(\"sea\", \"application/octet-stream\")\n    put(\"searchConnector-ms\", \"application/windows-search-connector+xml\")\n    put(\"setpay\", \"application/set-payment-initiation\")\n    put(\"setreg\", \"application/set-registration-initiation\")\n    put(\"settings\", \"application/xml\")\n    put(\"sgimb\", \"application/x-sgimb\")\n    put(\"sgml\", \"text/sgml\")\n    put(\"sh\", \"application/x-sh\")\n    put(\"shar\", \"application/x-shar\")\n    put(\"shtml\", \"text/html\")\n    put(\"sit\", \"application/x-stuffit\")\n    put(\"sitemap\", \"application/xml\")\n    put(\"skin\", \"application/xml\")\n    put(\"sldm\", \"application/vnd.ms-powerpoint.slide.macroEnabled.12\")\n    put(\"sldx\", \"application/vnd.openxmlformats-officedocument.presentationml.slide\")\n    put(\"slk\", \"application/vnd.ms-excel\")\n    put(\"sln\", \"text/plain\")\n    put(\"slupkg-ms\", \"application/x-ms-license\")\n    put(\"smd\", \"audio/x-smd\")\n    put(\"smi\", \"application/octet-stream\")\n    put(\"smx\", \"audio/x-smd\")\n    put(\"smz\", \"audio/x-smd\")\n    put(\"snd\", \"audio/basic\")\n    put(\"snippet\", \"application/xml\")\n    put(\"snp\", \"application/octet-stream\")\n    put(\"sol\", \"text/plain\")\n    put(\"sor\", \"text/plain\")\n    put(\"spc\", \"application/x-pkcs7-certificates\")\n    put(\"spl\", \"application/futuresplash\")\n    put(\"spx\", \"audio/ogg\")\n    put(\"src\", \"application/x-wais-source\")\n    put(\"srf\", \"text/plain\")\n    put(\"ssisdeploymentmanifest\", \"text/xml\")\n    put(\"ssm\", \"application/streamingmedia\")\n    put(\"sst\", \"application/vnd.ms-pki.certstore\")\n    put(\"stl\", \"application/vnd.ms-pki.stl\")\n    put(\"sv4cpio\", \"application/x-sv4cpio\")\n    put(\"sv4crc\", \"application/x-sv4crc\")\n    put(\"svc\", \"application/xml\")\n    put(\"svg\", \"image/svg+xml\")\n    put(\"swf\", \"application/x-shockwave-flash\")\n    put(\"t\", \"application/x-troff\")\n    put(\"tar\", \"application/x-tar\")\n    put(\"tcl\", \"application/x-tcl\")\n    put(\"testrunconfig\", \"application/xml\")\n    put(\"testsettings\", \"application/xml\")\n    put(\"tex\", \"application/x-tex\")\n    put(\"texi\", \"application/x-texinfo\")\n    put(\"texinfo\", \"application/x-texinfo\")\n    put(\"tgz\", \"application/x-compressed\")\n    put(\"thmx\", \"application/vnd.ms-officetheme\")\n    put(\"thn\", \"application/octet-stream\")\n    put(\"tif\", \"image/tiff\")\n    put(\"tiff\", \"image/tiff\")\n    put(\"tlh\", \"text/plain\")\n    put(\"tli\", \"text/plain\")\n    put(\"toc\", \"application/octet-stream\")\n    put(\"tr\", \"application/x-troff\")\n    put(\"trm\", \"application/x-msterminal\")\n    put(\"trx\", \"application/xml\")\n    put(\"ts\", \"video/vnd.dlna.mpeg-tts\")\n    put(\"tsv\", \"text/tab-separated-values\")\n    put(\"ttf\", \"application/font-sfnt\")\n    put(\"tts\", \"video/vnd.dlna.mpeg-tts\")\n    put(\"txt\", \"text/plain\")\n    put(\"u32\", \"application/octet-stream\")\n    put(\"uls\", \"text/iuls\")\n    put(\"user\", \"text/plain\")\n    put(\"ustar\", \"application/x-ustar\")\n    put(\"vb\", \"text/plain\")\n    put(\"vbdproj\", \"text/plain\")\n    put(\"vbk\", \"video/mpeg\")\n    put(\"vbproj\", \"text/plain\")\n    put(\"vbs\", \"text/vbscript\")\n    put(\"vcf\", \"text/x-vcard\")\n    put(\"vcproj\", \"application/xml\")\n    put(\"vcs\", \"text/plain\")\n    put(\"vcxproj\", \"application/xml\")\n    put(\"vddproj\", \"text/plain\")\n    put(\"vdp\", \"text/plain\")\n    put(\"vdproj\", \"text/plain\")\n    put(\"vdx\", \"application/vnd.ms-visio.viewer\")\n    put(\"vml\", \"text/xml\")\n    put(\"vscontent\", \"application/xml\")\n    put(\"vsct\", \"text/xml\")\n    put(\"vsd\", \"application/vnd.visio\")\n    put(\"vsi\", \"application/ms-vsi\")\n    put(\"vsix\", \"application/vsix\")\n    put(\"vsixlangpack\", \"text/xml\")\n    put(\"vsixmanifest\", \"text/xml\")\n    put(\"vsmdi\", \"application/xml\")\n    put(\"vspscc\", \"text/plain\")\n    put(\"vss\", \"application/vnd.visio\")\n    put(\"vsscc\", \"text/plain\")\n    put(\"vssettings\", \"text/xml\")\n    put(\"vssscc\", \"text/plain\")\n    put(\"vst\", \"application/vnd.visio\")\n    put(\"vstemplate\", \"text/xml\")\n    put(\"vsto\", \"application/x-ms-vsto\")\n    put(\"vsw\", \"application/vnd.visio\")\n    put(\"vsx\", \"application/vnd.visio\")\n    put(\"vtx\", \"application/vnd.visio\")\n    put(\"wav\", \"audio/wav\")\n    put(\"wave\", \"audio/wav\")\n    put(\"wax\", \"audio/x-ms-wax\")\n    put(\"wbk\", \"application/msword\")\n    put(\"wbmp\", \"image/vnd.wap.wbmp\")\n    put(\"wcm\", \"application/vnd.ms-works\")\n    put(\"wdb\", \"application/vnd.ms-works\")\n    put(\"wdp\", \"image/vnd.ms-photo\")\n    put(\"webarchive\", \"application/x-safari-webarchive\")\n    put(\"webm\", \"video/webm\")\n    put(\"webp\", \"image/webp\")\n    put(\"webtest\", \"application/xml\")\n    put(\"wiq\", \"application/xml\")\n    put(\"wiz\", \"application/msword\")\n    put(\"wks\", \"application/vnd.ms-works\")\n    put(\"wlmp\", \"application/wlmoviemaker\")\n    put(\"wlpginstall\", \"application/x-wlpg-detect\")\n    put(\"wlpginstall3\", \"application/x-wlpg3-detect\")\n    put(\"wm\", \"video/x-ms-wm\")\n    put(\"wma\", \"audio/x-ms-wma\")\n    put(\"wmd\", \"application/x-ms-wmd\")\n    put(\"wmf\", \"application/x-msmetafile\")\n    put(\"wml\", \"text/vnd.wap.wml\")\n    put(\"wmlc\", \"application/vnd.wap.wmlc\")\n    put(\"wmls\", \"text/vnd.wap.wmlscript\")\n    put(\"wmlsc\", \"application/vnd.wap.wmlscriptc\")\n    put(\"wmp\", \"video/x-ms-wmp\")\n    put(\"wmv\", \"video/x-ms-wmv\")\n    put(\"wmx\", \"video/x-ms-wmx\")\n    put(\"wmz\", \"application/x-ms-wmz\")\n    put(\"woff\", \"application/font-woff\")\n    put(\"wpl\", \"application/vnd.ms-wpl\")\n    put(\"wps\", \"application/vnd.ms-works\")\n    put(\"wri\", \"application/x-mswrite\")\n    put(\"wrl\", \"x-world/x-vrml\")\n    put(\"wrz\", \"x-world/x-vrml\")\n    put(\"wsc\", \"text/scriptlet\")\n    put(\"wsdl\", \"text/xml\")\n    put(\"wvx\", \"video/x-ms-wvx\")\n    put(\"x\", \"application/directx\")\n    put(\"xaf\", \"x-world/x-vrml\")\n    put(\"xaml\", \"application/xaml+xml\")\n    put(\"xap\", \"application/x-silverlight-app\")\n    put(\"xbap\", \"application/x-ms-xbap\")\n    put(\"xbm\", \"image/x-xbitmap\")\n    put(\"xdr\", \"text/plain\")\n    put(\"xht\", \"application/xhtml+xml\")\n    put(\"xhtml\", \"application/xhtml+xml\")\n    put(\"xla\", \"application/vnd.ms-excel\")\n    put(\"xlam\", \"application/vnd.ms-excel.addin.macroEnabled.12\")\n    put(\"xlc\", \"application/vnd.ms-excel\")\n    put(\"xld\", \"application/vnd.ms-excel\")\n    put(\"xlk\", \"application/vnd.ms-excel\")\n    put(\"xll\", \"application/vnd.ms-excel\")\n    put(\"xlm\", \"application/vnd.ms-excel\")\n    put(\"xls\", \"application/vnd.ms-excel\")\n    put(\"xlsb\", \"application/vnd.ms-excel.sheet.binary.macroEnabled.12\")\n    put(\"xlsm\", \"application/vnd.ms-excel.sheet.macroEnabled.12\")\n    put(\"xlsx\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")\n    put(\"xlt\", \"application/vnd.ms-excel\")\n    put(\"xltm\", \"application/vnd.ms-excel.template.macroEnabled.12\")\n    put(\"xltx\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.template\")\n    put(\"xlw\", \"application/vnd.ms-excel\")\n    put(\"xml\", \"text/xml\")\n    put(\"xmta\", \"application/xml\")\n    put(\"xof\", \"x-world/x-vrml\")\n    put(\"xoml\", \"text/plain\")\n    put(\"xpm\", \"image/x-xpixmap\")\n    put(\"xps\", \"application/vnd.ms-xpsdocument\")\n    put(\"xrm-ms\", \"text/xml\")\n    put(\"xsc\", \"application/xml\")\n    put(\"xsd\", \"text/xml\")\n    put(\"xsf\", \"text/xml\")\n    put(\"xsl\", \"text/xml\")\n    put(\"xslt\", \"text/xml\")\n    put(\"xsn\", \"application/octet-stream\")\n    put(\"xss\", \"application/xml\")\n    put(\"xspf\", \"application/xspf+xml\")\n    put(\"xtp\", \"application/octet-stream\")\n    put(\"xwd\", \"image/x-xwindowdump\")\n    put(\"z\", \"application/x-compress\")\n    put(\"zip\", \"application/zip\")\n}\n\nfun getMimeType(extension: String, isDirectory: Boolean): String {\n    if (isDirectory) {\n        return \"\"\n    }\n\n    var type: String? = ALL_MIME_TYPES\n\n    if (extension.isNotEmpty()) {\n        val extensionLowerCase = extension.toLowerCase(Locale\n            .getDefault())\n        val mime = MimeTypeMap.getSingleton()\n        type = mime.getMimeTypeFromExtension(extensionLowerCase)\n        if (type == null) {\n            type = MIME_TYPES[extensionLowerCase]\n        }\n    }\n    if (type == null) type = ALL_MIME_TYPES\n    return type\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAppInfo\next\nlistener\nSearchViewExt.kt\nSeekBarExt.kt\nTextWatcherExt.kt\nViewPagerExt.kt\npermission\nKtxPermissionFragment\nPermissionExt.kt\nPermissionRequest\nPermissionsCallback.kt\nPermissionsMap\nsharedpreferences\nSharedPreferencesExt.kt\nview\nTextViewExt.kt\nActivityExt.kt\nAesExt.kt\nAny.kt\nAppExt.kt\nContextExt.kt\nDrawableExt.kt\nHashExt.kt\nIntentExt.kt\nLogExt.kt\nOSVersionExt.kt\nShellExt.kt\nStatusBarExt.kt\nStringExt.kt\nSystemServiceExt.kt\nTelephonManagerExt.kt\nTimeStampExt.kt\nToastExt.kt\nTransformExt.kt\nTransformUtils\nViewExt.kt\nutil\nMimeType.kt\n\n\n\n\n\n\n\n\n\nfun View.dp2px(dp: Int): Int {\n    val scale = resources.displayMetrics.density\n    return (dp * scale + 0.5f).toInt()\n}\n\nfun View.dp2px(dp: Float): Float {\n    val scale = resources.displayMetrics.density\n    return (dp * scale + 0.5f)\n}\n\nfun View.px2dp(px: Int): Int {\n    return px2dp(px.toFloat()).toInt()\n}\n\nfun View.px2dp(px: Float): Float {\n    val scale = resources.displayMetrics.density\n    return (px / scale + 0.5f)\n}\n\n\n/**\n * Set view visible\n */\nfun View.visible() {\n    visibility = View.VISIBLE\n}\n\n/**\n * Set view invisible\n */\nfun View.invisible() {\n    visibility = View.INVISIBLE\n}\n\n/**\n * Set view gone\n */\nfun View.gone() {\n    visibility = View.GONE\n}\n\n/**\n * Reverse the view's visibility\n */\nfun View.reverseVisibility(needGone: Boolean = true) {\n    if (isVisible) {\n        if (needGone) gone() else invisible()\n    } else visible()\n}\n\nfun View.changeVisible(visible: Boolean, needGone: Boolean = true) {\n    when {\n        visible -> visible()\n        needGone -> gone()\n        else -> invisible()\n    }\n}\n\nvar View.isVisible: Boolean\n    get() = visibility == View.VISIBLE\n    set(value) = if (value) visible() else gone()\n\nvar View.isInvisible: Boolean\n    get() = visibility == View.INVISIBLE\n    set(value) = if (value) invisible() else visible()\n\nvar View.isGone: Boolean\n    get() = visibility == View.GONE\n    set(value) = if (value) gone() else visible()\n\n/**\n * Set padding\n * @param size top, bottom, left, right padding are same\n */\nfun View.setPadding(@Px size: Int) {\n    setPadding(size, size, size, size)\n}\n\n/**\n * Causes the Runnable which contains action() to be added to the message queue, to be run\n * after the specified amount of time elapses.\n * The runnable will be run on the user interface thread\n *\n * @param action Will be invoked in the Runnable\n * @param delayInMillis The delay (in milliseconds) until the action() will be invoked\n */\ninline fun View.postDelayed(delayInMillis: Long, crossinline action: () -> Unit): Runnable {\n    val runnable = Runnable { action() }\n    postDelayed(runnable, delayInMillis)\n    return runnable\n}\n\n@Deprecated(\"use View.drawToBitmap()\")\nfun View.toBitmap(scale: Float = 1f, config: Bitmap.Config = Bitmap.Config.ARGB_8888): Bitmap? {\n    if (this is ImageView) {\n        if (drawable is BitmapDrawable) return (drawable as BitmapDrawable).bitmap\n    }\n    this.clearFocus()\n    val bitmap = createBitmapSafely((width * scale).toInt(), (height * scale).toInt(), config, 1)\n    if (bitmap != null) {\n        Canvas().run {\n            setBitmap(bitmap)\n            save()\n            drawColor(Color.WHITE)\n            scale(scale, scale)\n            this@toBitmap.draw(this)\n            restore()\n            setBitmap(null)\n        }\n    }\n    return bitmap\n}\n\nfun createBitmapSafely(width: Int, height: Int, config: Bitmap.Config, retryCount: Int): Bitmap? {\n    try {\n        return Bitmap.createBitmap(width, height, config)\n    } catch (e: OutOfMemoryError) {\n        e.printStackTrace()\n        if (retryCount > 0) {\n            System.gc()\n            return createBitmapSafely(width, height, config, retryCount - 1)\n        }\n        return null\n    }\n\n}\n\n/**\n * Register a callback to be invoked when the global layout state or the visibility of views\n * within the view tree changes\n *\n * @param callback The callback() to be invoked\n */\ninline fun View.onGlobalLayout(crossinline callback: () -> Unit) = with(viewTreeObserver) {\n    addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {\n        @RequiresApi(Build.VERSION_CODES.JELLY_BEAN)\n        override fun onGlobalLayout() {\n            removeOnGlobalLayoutListener(this)\n            callback()\n        }\n    })\n}\n\n/**\n * Register a callback to be invoked after the view is measured\n *\n * @param callback The callback() to be invoked\n */\ninline fun View.afterMeasured(crossinline callback: View.() -> Unit) {\n    viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {\n        @RequiresApi(Build.VERSION_CODES.JELLY_BEAN)\n        override fun onGlobalLayout() {\n            if (measuredWidth > 0 && measuredHeight > 0) {\n                viewTreeObserver.removeOnGlobalLayoutListener(this)\n                callback()\n            }\n        }\n    })\n}\n\nvar clickCount = 0\nvar lastClickTime = 0L\n\n/**\n * Invoke the [action] after click [count] times.\n * The interval between two clicks is less than [interval] mills\n */\nfun View.clickN(count: Int = 1, interval: Long = 1000, action: () -> Unit) {\n\n    setOnClickListener {\n        val currentTime = System.currentTimeMillis()\n        if (lastClickTime != 0L && (currentTime - lastClickTime > interval)) {\n            clickCount = 1\n            lastClickTime = currentTime\n            return@setOnClickListener\n        }\n\n        ++clickCount\n        lastClickTime = currentTime\n\n        if (clickCount == count) {\n            clickCount = 0\n            lastClickTime = 0L\n            action()\n        }\n    }\n}\n\n\nobject ViewClickDelay {\n    var hash: Int = 0\n    var lastClickTime: Long = 0\n    var SPACE_TIME: Long = 1000\n}\n\n/**\n * 防止多次点击的方法\n * @receiver View\n * @param clickAction Function0<Unit>\n */\ninfix fun View.checkDoubleClick(clickAction: () -> Unit) {\n\n    this.setOnClickListener {\n        if (this.hashCode() != ViewClickDelay.hash) {\n            ViewClickDelay.hash = this.hashCode()\n            ViewClickDelay.lastClickTime = System.currentTimeMillis()\n            clickAction()\n        } else {\n            val currentTime = System.currentTimeMillis()\n            if (currentTime - ViewClickDelay.lastClickTime > ViewClickDelay.SPACE_TIME) {\n                ViewClickDelay.lastClickTime = System.currentTimeMillis()\n                clickAction()\n            }\n        }\n    }\n}\n\n/**\n * view的点击事件\n * @receiver View 当前点击的view\n * @param needBgMusic Boolean 点击是否需要背景音乐\n * @param action Function0<Unit> block\n */\nfun View.click(needBgMusic: Boolean = false, action: () -> Unit) {\n    if (needBgMusic) {\n\n    }\n    setOnClickListener {\n        action()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\nfun fromM() = fromSpecificVersion(Build.VERSION_CODES.M)\nfun beforeM() = beforeSpecificVersion(Build.VERSION_CODES.M)\nfun fromN() = fromSpecificVersion(Build.VERSION_CODES.N)\nfun beforeN() = beforeSpecificVersion(Build.VERSION_CODES.N)\nfun fromO() = fromSpecificVersion(Build.VERSION_CODES.O)\nfun beforeO() = beforeSpecificVersion(Build.VERSION_CODES.O)\nfun fromP() = fromSpecificVersion(Build.VERSION_CODES.P)\nfun beforeP() = beforeSpecificVersion(Build.VERSION_CODES.P)\nfun fromSpecificVersion(version: Int): Boolean = Build.VERSION.SDK_INT >= version\nfun beforeSpecificVersion(version: Int): Boolean = Build.VERSION.SDK_INT < version\n\n\n\n\n\n\n\n\n\n\n/**\n * 判断设备是否安装微信APP\n *\n * @return boolean\n */\nfun Context.isWeixinAvilible(): Boolean {\n    val pinfo = packageManager.getInstalledPackages(0)// 获取所有已安装程序的包信息\n    if (pinfo != null) {\n        for (i in pinfo.indices) {\n            val pn = pinfo[i].packageName\n            if (\"com.tencent.mm\" == pn) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n/**\n * 是否有网络连接\n * @receiver Context\n * @return Boolean\n */\n@SuppressLint(\"MissingPermission\")\nfun Context.isNetworkAvailable(): Boolean {\n    val mNetworkInfo = connectivityManager?.activeNetworkInfo\n    return mNetworkInfo != null && mNetworkInfo.isAvailable\n}\n\n/**\n * 检测网络是否是Mobile\n *\n * @return\n */\nfun Context.isMobile(): Boolean {\n    val mNetworkInfo = connectivityManager?.activeNetworkInfo\n    return mNetworkInfo != null\n            && mNetworkInfo.type == ConnectivityManager.TYPE_MOBILE\n            && mNetworkInfo.isConnected\n}\n\n/**\n * 判断wifi是否连接\n *\n * @return\n */\nfun Context.isWifiConnected(): Boolean {\n    val activeNetInfo = connectivityManager?.activeNetworkInfo\n    return activeNetInfo != null\n            && activeNetInfo.type == ConnectivityManager.TYPE_WIFI\n            && activeNetInfo.isConnected\n}\n\n\n/**\n * 是否有运行的服务\n * @receiver Context\n * @param className String\n * @return Boolean\n */\nfun Context.isServiceRunning(className: String): Boolean {\n    var isRunning = false\n    val serviceList = activityManager?.getRunningServices(Int.MAX_VALUE)\n    if (serviceList == null || serviceList.size <= 0) {\n        return false\n    }\n    for (i in serviceList.indices) {\n        if (serviceList[i] != null && serviceList[i].service != null) {\n            val cName = serviceList[i].service.className\n            if (cName.contains(className)) {\n                isRunning = true\n                break\n            }\n        }\n    }\n    return isRunning\n}\n\n\n/**\n * 包名判断是否为主进程\n *\n * @param context\n * @return\n */\nfun Context.isMainProcess(): Boolean {\n    return packageName == getProcessName()\n}\n\n/**\n * 获取进程名称\n *\n * @param context\n * @return\n */\nfun Context.getProcessName(): String? {\n    try {\n        val runningApps = activityManager?.runningAppProcesses ?: return null\n        for (proInfo in runningApps) {\n            if (proInfo.pid == Process.myPid()) {\n                if (proInfo.processName != null) {\n                    return proInfo.processName\n                }\n            }\n        }\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n    return null\n}\n\n/**\n * 判断当前app是否存活\n * @receiver Context\n * @param packageName String\n * @return Boolean\n */\nfun Context.isAppAlive(packageName: String): Boolean {\n    val processInfos = activityManager?.runningAppProcesses\n    if (processInfos != null) {\n        for (i in processInfos.indices) {\n            if (processInfos[i].processName == packageName) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n/**\n * 清楚当前所有的activity\n */\nfun Context.clearAllActivity() {\n    val allActivitys = getAllActivitys()\n    for (i in allActivitys.indices) {\n        allActivitys.get(i).finish()\n    }\n}\n\n/**\n * 获取当前所有的activity\n *\n * @return activity列表\n */\n@SuppressLint(\"PrivateApi\", \"DiscouragedPrivateApi\")\nfun Context.getAllActivitys(): List<Activity> {\n    val list = ArrayList<Activity>()\n    try {\n        val activityThread = Class.forName(\"android.app.ActivityThread\")\n        val currentActivityThread = activityThread.getDeclaredMethod(\"currentActivityThread\")\n        currentActivityThread.isAccessible = true\n        //获取主线程对象\n        val activityThreadObject = currentActivityThread.invoke(null)\n        val mActivitiesField = activityThread.getDeclaredField(\"mActivities\")\n        mActivitiesField.isAccessible = true\n        val mActivities = mActivitiesField.get(activityThreadObject) as Map<Any, Any>\n        for ((_, value) in mActivities) {\n            val activityClientRecordClass = value.javaClass\n            val activityField = activityClientRecordClass.getDeclaredField(\"activity\")\n            activityField.isAccessible = true\n            val o = activityField.get(value)\n            list.add(o as Activity)\n        }\n    } catch (e: Exception) {\n        e.printStackTrace()\n    }\n\n    return list\n}\n\n/**\n * 注意：不能先杀掉主进程，否则逻辑代码无法继续执行，需先杀掉相关进程最后杀掉主进程\n */\nfun Context.killAppProcess() {\n    val mList = activityManager?.runningAppProcesses\n    for (runningAppProcessInfo in mList!!) {\n        if (runningAppProcessInfo.pid != Process.myPid()) {\n            Process.killProcess(runningAppProcessInfo.pid)\n        }\n    }\n    Process.killProcess(Process.myPid())\n    exitProcess(0)\n}\n\n/**\n * 开启一个service之前需要判断是否开启\n * @receiver Context\n * @param className String\n * @param action Function0<Unit>\n */\nfun Context.onServiceNotRunning(className: String, action: () -> Unit) {\n    try {\n        if (isAppInForground()) {\n            val downloadPetServiceRunning: Boolean = isServiceRunning(className)\n            if (!downloadPetServiceRunning) {\n                action()\n            }\n        }\n    } catch (e: IllegalStateException) {\n        e.printStackTrace()\n    } catch (e: SecurityException) {\n        e.printStackTrace()\n    }\n}\n\n/**\n * 判断app是否在前台\n * @receiver Context\n * @return Boolean\n */\nfun Context.isAppInForground(): Boolean {\n    val processes = activityManager?.runningAppProcesses ?: return false\n    for (tmp in processes) {\n        if (tmp.processName == this.packageName) {\n            return tmp.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND\n        }\n    }\n    return false\n}\n\n\n/**\n * Sets the [text] on the clipboard\n */\nfun Context.copyToClipboard(text: String, label: String = \"KTX\") {\n    val clipData = ClipData.newPlainText(label, text)\n    clipboardManager?.primaryClip = clipData\n}\n\n/**\n * Check if the accessibility Service which name is [serviceName] is enabled\n */\nfun Context.checkAccessibilityServiceEnabled(serviceName: String): Boolean {\n    val settingValue =\n        Settings.Secure.getString(\n            applicationContext.contentResolver,\n            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES\n        )\n    return settingValue.notNull({\n        var result = false\n        val splitter = TextUtils.SimpleStringSplitter(':')\n        while (splitter.hasNext()) {\n            if (splitter.next().equals(serviceName, true)) {\n                result = true\n                break\n            }\n        }\n        result\n    }, { false })\n}\n\nfun Context.dp2px(dp: Int): Int = dp2px(dp.toFloat())\n\nfun Context.dp2px(dp: Float): Int {\n    val scale = resources.displayMetrics.density\n    return (dp * scale + 0.5f).toInt()\n}\n\nfun Context.px2dp(px: Int): Int = px2dp(px.toFloat()).toInt()\n\nfun Context.px2dp(px: Float): Float {\n    val scale = resources.displayMetrics.density\n    return (px / scale + 0.5f)\n}\n\n\n/**\n * Whether horizontal layout direction of this view is from Right to Left.\n */\nval Context.isRTLLayout: Boolean\n    @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)\n    get() = resources.configuration.layoutDirection == View.LAYOUT_DIRECTION_RTL\n\n/**\n * The absolute width of the available display size in pixels\n */\nval Context.screenWidth\n    get() = resources.displayMetrics.widthPixels\n\n/**\n * The absolute height of the available display size in pixels\n */\nval Context.screenHeight\n    get() = resources.displayMetrics.heightPixels\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598580912466},"updatedAt":{"$$date":1598584353408},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"vZwCQlAiTqK8HyvU"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598974376972},"updatedAt":{"$$date":1598974376972},"_id":"vk1j0Pjs4NVjBFjM"}
{"name":"kotlin-Android KTX","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\ndeveloper.android.google.cn /kotlin/ktx\nAndroid KTX  |  Android 开发者  |  Android Developers\n10-13 minutes\nAndroid KTX 是包含在 Android Jetpack 及其他 Android 库中的一组 Kotlin 扩展程序。KTX 扩展程序可以为 Jetpack、Android 平台及其他 API 提供简洁的惯用 Kotlin 代码。为此，这些扩展程序利用了多种 Kotlin 语言功能，其中包括：\n\n扩展函数\n扩展属性\nLambda\n命名参数\n参数默认值\n协程\n例如，使用 SharedPreferences 时，您必须先创建一个编辑器，然后才能对偏好设置数据进行修改。在完成修改后，您还必须应用或提交这些更改，如以下示例所示：\n\nsharedPreferences\n        .edit()  // create an Editor\n        .putBoolean(\"key\", value)\n        .apply() // write to disk asynchronously\nKotlin lambda 非常适合此用例。它们可让您采用一种更简洁的方法，即在创建编辑器后传递要执行的代码块，让代码执行，然后让 SharedPreferences API 以原子方式应用更改。\n\n下面是一个 Android KTX Core 函数 SharedPreferences.edit 的示例，在本例中向 SharedPreferences 添加了一个 edit 函数。此函数将可选的 boolean 标志作为第一个参数，指示是否要提交或应用更改。此外，它还以 lambda 的形式接收要在 SharedPreferences 编辑器上执行的操作。\n\n// SharedPreferences.edit extension function signature from Android KTX - Core\n// inline fun SharedPreferences.edit(\n//         commit: Boolean = false,\n//         action: SharedPreferences.Editor.() -> Unit)// Commit a new value asynchronously\nsharedPreferences.edit { putBoolean(\"key\", value) }// Commit a new value synchronously\nsharedPreferences.edit(commit = true) { putBoolean(\"key\", value) }\n调用方可以选择是否提交或应用更改。action lambda 本身是 SharedPreferences.Editor 上的一个匿名扩展函数，它返回 Unit，如其签名所指示。因此，在代码块内，可以直接在 SharedPreferences.Editor 上执行工作。\n\n最后，SharedPreferences.edit() 签名包含 inline 关键字。此关键字向 Kotlin 编译器表明，每次使用函数时，它都应该为函数复制并粘贴（或内嵌）编译的字节码。这样可避免每次调用此函数时都为每个 action 实例化一个新类所产生的开销。\n\n使用 lambda 传递代码、应用可以替换的合理默认值并使用 inline 扩展函数将这些行为添加到现有 API 中，这种模式是 Android KTX 库提供的典型增强功能。\n\n在项目中使用 Android KTX\n要开始使用 Android KTX，请将以下依赖项添加到项目的 build.gradle 文件中：\n\nrepositories {\n    google()\n}\nAndroidX 模块\nAndroid KTX 分为若干模块，每个模块包含一个或多个软件包。\n\n您必须在应用的 build.gradle 文件中为每个模块工件添加一个依赖项。请务必在工件后面附上版本号。可以在本主题中每个工件的相应部分找到最新版本号。\n\nAndroid KTX 包含一个核心模块，该模块可为通用框架 API 提供 Kotlin 扩展程序，而且还能提供一些领域专用的扩展程序。\n\n除了核心模块之外，所有 KTX 模块工件都会替换 build.gradle 文件中的底层 Java 依赖项。例如，您可以将 androidx.fragment:fragment 依赖项替换为 androidx.fragment:fragment-ktx。此语法有助于更好地管理版本控制，而不会增加额外的依赖项声明要求。\n\nCore KTX\nCore KTX 模块为属于 Android 框架的通用库提供扩展程序。这些库没有您需要添加到 build.gradle 的基于 Java 的依赖项。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\ndependencies {\n    implementation \"androidx.core:core-ktx:1.3.0\"\n}\n下面列出了 Core KTX 模块中包含的软件包：\n\nandroidx.core.animation\nandroidx.core.content\nandroidx.core.content.res\nandroidx.core.database\nandroidx.core.database.sqlite\nandroidx.core.graphics\nandroidx.core.graphics.drawable\nandroidx.core.location\nandroidx.core.net\nandroidx.core.os\nandroidx.core.text\nandroidx.core.transition\nandroidx.core.util\nandroidx.core.view\nandroidx.core.widget\nCollection KTX\nCollection 扩展程序包含在 Android 的节省内存的集合库中使用的效用函数，包括 ArrayMap、LongParseArray、LruCache 等等。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\n    dependencies {\n        implementation \"androidx.collection:collection-ktx:1.1.0\"\n    }\n    \nCollection 扩展程序利用 Kotlin 的运算符重载简化集合串联等操作，如以下示例所示：\n\n// Combine 2 ArraySets into 1.\nval combinedArraySet = arraySetOf(1, 2, 3) + arraySetOf(4, 5, 6)// Combine with numbers to create a new sets.\nval newArraySet = combinedArraySet + 7 + 8\nFragment KTX\nFragment KTX 模块提供了一系列扩展程序以简化 Fragment API。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\ndependencies {\n    implementation \"androidx.fragment:fragment-ktx:1.2.5\"\n}\n借助 Fragment KTX 模块，可以使用 lambda 来简化 Fragment 事务，例如：\n\nfragmentManager().commit {\n   addToBackStack(\"...\")\n   setCustomAnimations(\n           R.anim.enter_anim,\n           R.anim.exit_anim)\n   add(fragment, \"...\")\n}\n还可以使用 viewModels 和 activityViewModels 属性委托在一行中绑定到 ViewModel：\n\n// Get a reference to the ViewModel scoped to this Fragment\nval viewModel by viewModels<MyViewModel>()// Get a reference to the ViewModel scoped to its Activity\nval viewModel by activityViewModels<MyViewModel>()\nLifecycle KTX\nLifecycle KTX 为每个 Lifecycle 对象定义一个 LifecycleScope。在此范围内启动的协程会在 Lifecycle 被销毁时取消。您可以使用 lifecycle.coroutineScope 或 lifecycleOwner.lifecycleScope 属性访问 Lifecycle 的 CoroutineScope。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\n    dependencies {\n        implementation \"androidx.lifecycle:lifecycle-runtime-ktx:2.2.0\"\n    }\n    \n以下示例演示了如何使用 lifecycleOwner.lifecycleScope 异步创建预计算文本：\n\nclass MyFragment: Fragment() {\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        viewLifecycleOwner.lifecycleScope.launch {\n            val params = TextViewCompat.getTextMetricsParams(textView)\n            val precomputedText = withContext(Dispatchers.Default) {\n                PrecomputedTextCompat.create(longTextContent, params)\n            }\n            TextViewCompat.setPrecomputedText(textView, precomputedText)\n        }\n    }\n}\nLiveData KTX\n使用 LiveData 时，您可能需要异步计算值。例如，您可能需要检索用户的偏好设置并将其传送给界面。在这些情况下，LiveData KTX 可提供一个 liveData 构建器函数，该函数会调用 suspend 函数，并将结果作为 LiveData 对象传送。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\n    dependencies {\n        implementation \"androidx.lifecycle:lifecycle-livedata-ktx:2.2.0\"\n    }\n    \n在以下示例中，loadUser() 是在其他地方声明的 suspend 函数。 您可以使用 liveData 构建器函数异步调用 loadUser()，然后使用 emit() 来发出结果：\n\nval user: LiveData<User> = liveData {\n    val data = database.loadUser() // loadUser is a suspend function.\n    emit(data)\n}\n如需详细了解如何将协程与 LiveData 一起使用，请参阅将 Kotlin 协程与架构组件一起使用。\n\nNavigation KTX\nNavigation 库的每个组件都有自己的 KTX 版本，用于调整 API 以使其更简洁且更符合 Kotlin 的语言习惯。\n\n要添加这些模块，请将以下内容添加到应用的 build.gradle 文件中：\n\ndependencies {\n    implementation \"androidx.navigation:navigation-runtime-ktx:2.3.0-rc01\"\n    implementation \"androidx.navigation:navigation-fragment-ktx:2.3.0-rc01\"\n    implementation \"androidx.navigation:navigation-ui-ktx:2.3.0-rc01\"\n}\n您可以使用扩展函数和属性委托来访问目标参数并导航到目标，如以下示例所示：\n\nclass MyDestination : Fragment() {// Type-safe arguments are accessed from the bundle.\n    val args by navArgs<MyDestinationArgs>()...\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        view.findViewById<Button>(R.id.next)\n            .setOnClickListener {\n                // Fragment extension added to retrieve a NavController from\n                // any destination.\n                findNavController().navigate(R.id.action_to_next_destination)\n            }\n     }\n     ...}\nPalette KTX\nPalette KTX 模块为使用调色板提供惯用的 Kotlin 支持。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\n    dependencies {\n        implementation \"androidx.palette:palette-ktx:1.0.0\"\n    }\n    \n例如，使用 Palette 实例时，可以使用 get 运算符 ([ ]) 来检索给定 target 的 selected 色样：\n\nval palette = Palette.from(bitmap).generate()\nval swatch = palette[target]\nReactive Streams KTX\n利用 Reactive Streams KTX 模块可根据 ReactiveStreams 发布程序来创建可监测的 LiveData 流。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\n    dependencies {\n        implementation \"androidx.lifecycle:lifecycle-reactivestreams-ktx:2.2.0\"\n    }\n    \n例如，假设一个数据库只有很少的用户。在您的应用中，您将该数据库加载到内存中，然后在界面中显示用户数据。为此，您可以使用 RxJava。Room Jetpack 组件能以 Flowable 的形式检索用户列表。在这种情况下，您还必须在 Fragment 或 Activity 的整个生命周期内管理 Rx 发布程序订阅。\n\n不过，借助 LiveDataReactiveStreams，您既可以利用 RxJava 及其丰富的运算符和工作安排功能，又可以享受 LiveData 的简便性，如以下示例所示：\n\nval fun getUsersLiveData() : LiveData<List<User>> {\n    val users: Flowable<List<User>> = dao.findUsers()\n    return LiveDataReactiveStreams.fromPublisher(users)\n}\nRoom KTX\nRoom 扩展程序增加了对数据库事务的协程支持。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\n    dependencies {\n        implementation \"androidx.room:room-ktx:2.2.5\"\n    }\n    \n下面是 Room 现在使用协程的几个示例。第一个示例使用 suspend 函数返回 User 对象列表，而第二个示例利用 Kotlin 的 Flow 异步返回 User 列表。注意，使用 Flow 时，您还会收到有关您正在查询的表中任何更改的通知。\n\n@Query(\"SELECT * FROM Users\")\nsuspend fun getUsers(): List<User>@Query(\"SELECT * FROM Users\")\nfun getUsers(): Flow<List<User>>\nSQLite KTX\nSQLite 扩展程序将与 SQL 相关的代码封装在事务中，从而避免编写大量样板代码。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\n    dependencies {\n        implementation \"androidx.sqlite:sqlite-ktx:2.1.0\"\n    }\n    \n下面是一个使用 transaction 扩展程序执行数据库事务的示例：\n\ndb.transaction {\n    // insert data\n}\nViewModel KTX\nViewModel KTX 库提供了一个 viewModelScope() 函数，可让您更轻松地从 ViewModel 启动协程。CoroutineScope 绑定至 Dispatchers.Main，并且会在清除 ViewModel 后自动取消。您可以使用 viewModelScope()，而无需为每个 ViewModel 创建一个新范围。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\n    dependencies {\n        implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0\"\n    }\n    \n例如，以下 viewModelScope() 函数会启动一个协程，用于在后台线程中发出网络请求。该库会处理所有设置和相应的范围清除：\n\nclass MainViewModel : ViewModel() {\n    // Make a network request without blocking the UI thread\n    private fun makeNetworkRequest() {\n        // launch a coroutine in viewModelScope\n        viewModelScope.launch  {\n            remoteApi.slowFetch()\n            ...\n        }\n    }// No need to override onCleared()\n}\nWorkManager KTX\nWorkManager KTX 为协程提供一流的支持。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\n    dependencies {\n        implementation \"androidx.work:work-runtime-ktx:2.3.4\"\n    }\n    \n现在，您无需扩展 Worker，而可以扩展 CoroutineWorker，后者使用的 API 略有不同。例如，如果要构建一个简单的 CoroutineWorker 以执行某些网络操作，则需要执行以下操作：\n\nclass CoroutineDownloadWorker(context: Context, params: WorkerParameters)\n        : CoroutineWorker(context, params) {override suspend fun doWork(): Result = coroutineScope {\n        val jobs = (0 until 100).map {\n            async {\n                downloadSynchronously(\"https://www.google.com\")\n            }\n        }// awaitAll will throw an exception if a download fails, which\n        // CoroutineWorker will treat as a failure\n        jobs.awaitAll()\n        Result.success()\n    }\n}\n如需详细了解如何使用 CoroutineWorker，请参阅在 CoroutineWorker 中进行线程处理。\n\n此外，WorkManager KTX 还向 Operations 和 ListenableFutures 添加扩展函数以暂停当前协程。\n\n下面是暂停 enqueue() 返回的 Operation 的示例：\n\n// Inside of a coroutine...// Run async operation and suspend until completed.\nWorkManager.getInstance()\n        .beginWith(longWorkRequest)\n        .enqueue().await()// Resume after work completes...\n其他 KTX 模块\n您还可以添加存在于 AndroidX 之外的其他 KTX 模块。\n\nFirebase KTX\n部分适用于 Android 的 Firebase SDK 具有 Kotlin 扩展库，可让您在应用中使用 Firebase 时编写惯用 Kotlin 代码。如需了解详情，请参阅以下主题：\n\nFirebase Android SDK\nFirebase 常见 Kotlin 扩展\nGoogle Maps KTX\n有适用于主 Google Maps SDK for Android 的 KTX 扩展，也有适用于 Maps SDK for Android 实用程序库的 KTX 扩展。借助此 KTX 库，您能够利用多种 Kotlin 语言功能（例如扩展函数、命名参数和默认参数），解构声明和协程。\n\n如需了解详情，请参阅 Maps Android KTX 的 GitHub 页面。\n\nPlay Core KTX\nPlay Core KTX 通过向 Play Core 库中的 SplitInstallManager 和 AppUpdateManager 添加扩展函数，针对单发请求和用于监控状态更新的 Flow 添加了对 Kotlin 协程的支持。\n\n要使用此模块，请将以下内容添加到应用的 build.gradle 文件中：\n\ndependencies {\n    implementation \"com.google.android.play:core-ktx:1.8.0\"\n}\n以下是用于监控状态的 Flow 的示例：\n\n// Inside of a coroutine...// Request in-app update status updates.\nmanager.requestUpdateFlow().collect { updateResult ->\n    when (updateResult) {\n        is AppUpdateResult.Available -> TODO()\n        is AppUpdateResult.InProgress -> TODO()\n        is AppUpdateResult.Downloaded -> TODO()\n        AppUpdateResult.NotAvailable -> TODO()\n    }\n}\n更多信息\n要详细了解 Android KTX，请观看 DevBytes 视频。\n\n要报告问题或推荐功能，请使用 Android KTX 问题跟踪器。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597397422262},"updatedAt":{"$$date":1597399769280},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"vu0QfjJJaL0UzDr0"}
{"name":"py-数据类型转换","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n数据类型转换\nPython内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：\n\n>>> int('123')\n123\n>>> int(12.34)\n12\n>>> float('12.34')\n12.34\n>>> str(1.23)\n'1.23'\n>>> str(100)\n'100'\n>>> bool(1)\nTrue\n>>> bool('')\nFalse\n函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：\n\n>>> a = abs # 变量a指向abs函数\n>>> a(-1) # 所以也可以通过a调用abs函数\n1"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973944732},"updatedAt":{"$$date":1594977269087},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"w2Mk0Qh6yDfObMK1"}
{"name":"kotlin-嵌套类与内部类 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/nested-classes.html\n嵌套类与内部类 - Kotlin 语言中文站\n3-3 minutes\n改进翻译\n类可以嵌套在其他类中：\n\n标记为 inner 的嵌套类能够访问其外部类的成员。内部类会带有一个对外部类的对象的引用：\n\nclass Outer {\n    private val bar: Int = 1\n    inner class Inner {\n        fun foo() = bar\n    }\n}\n\nval demo = Outer().Inner().foo() // == 1\n参见限定的 this 表达式以了解内部类中的 this 的消歧义用法。\n\n使用对象表达式创建匿名内部类实例：\n\nwindow.addMouseListener(object : MouseAdapter() {\n\n    override fun mouseClicked(e: MouseEvent) { …… }\n\n    override fun mouseEntered(e: MouseEvent) { …… }\n})\n注：对于 JVM 平台, 如果对象是函数式 Java 接口（即具有单个抽象方法的 Java 接口）的实例， 你可以使用带接口类型前缀的lambda表达式创建它：\n\nval listener = ActionListener { println(\"clicked\") }"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307925492},"updatedAt":{"$$date":1597308079613},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"w2ijnfaFv4BaAG2K"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597404258454},"updatedAt":{"$$date":1597404258454},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"wE13iYR2XrlSRau1"}
{"name":"kotlin-枚举类 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/enum-classes.html\n枚举类 - Kotlin 语言中文站\n7-9 minutes\n改进翻译\n枚举类的最基本的用法是实现类型安全的枚举：\n\nenum class Direction {\n    NORTH, SOUTH, WEST, EAST\n}\n每个枚举常量都是一个对象。枚举常量用逗号分隔。\n\n因为每一个枚举都是枚举类的实例，所以他们可以是这样初始化过的：\n\nenum class Color(val rgb: Int) {\n        RED(0xFF0000),\n        GREEN(0x00FF00),\n        BLUE(0x0000FF)\n}\n枚举常量还可以声明其带有相应方法以及覆盖了基类方法的匿名类。\n\nenum class ProtocolState {\n    WAITING {\n        override fun signal() = TALKING\n    },\n\n    TALKING {\n        override fun signal() = WAITING\n    };\n\n    abstract fun signal(): ProtocolState\n}\n如果枚举类定义任何成员，那么使用分号将成员定义中的枚举常量定义分隔开。\n\n枚举条目不能包含内部类以外的嵌套类型（已在 Kotlin 1.2 中弃用）。\n\n一个枚举类可以实现接口（但不能从类继承），可以为所有条目提供统一的接口成员实现，也可以在相应匿名类中为每个条目提供各自的实现。只需将接口添加到枚举类声明中即可，如下所示：\n\nimport java.util.function.BinaryOperator\nimport java.util.function.IntBinaryOperator\n\n//sampleStart\nenum class IntArithmetics : BinaryOperator<Int>, IntBinaryOperator {\n    PLUS {\n        override fun apply(t: Int, u: Int): Int = t + u\n    },\n    TIMES {\n        override fun apply(t: Int, u: Int): Int = t * u\n    };\n    \n    override fun applyAsInt(t: Int, u: Int) = apply(t, u)\n}\n//sampleEnd\n\nfun main() {\n    val a = 13\n    val b = 31\n    for (f in IntArithmetics.values()) {\n        println(\"$f($a, $b) = ${f.apply(a, b)}\")\n    }\n}\nKotlin 中的枚举类也有合成方法允许列出定义的枚举常量以及通过名称获取枚举常量。这些方法的签名如下（假设枚举类的名称是 EnumClass）：\n\nEnumClass.valueOf(value: String): EnumClass\nEnumClass.values(): Array<EnumClass>\n如果指定的名称与类中定义的任何枚举常量均不匹配，valueOf() 方法将抛出 IllegalArgumentException 异常。\n\n自 Kotlin 1.1 起，可以使用 enumValues<T>() 与 enumValueOf<T>() 函数以泛型的方式访问枚举类中的常量 ：\n\nenum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n\nprintAllValues<RGB>() // 输出 RED, GREEN, BLUE\n每个枚举常量都具有在枚举类声明中获取其名称与位置的属性：\n\nval name: String\nval ordinal: Int\n枚举常量还实现了 Comparable 接口， 其中自然顺序是它们在枚举类中定义的顺序。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307926558},"updatedAt":{"$$date":1597308098756},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"wLTBHce1Wi9gB7k3"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1598974376016},"updatedAt":{"$$date":1598974376016},"_id":"wfr8ANFNSRwFKNYS"}
{"name":"kotlin-反射 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/reflection.html\n反射 - Kotlin 语言中文站\n17-21 minutes\n改进翻译\n反射是这样的一组语言和库功能，它允许在运行时自省你的程序的结构。 Kotlin 让语言中的函数和属性做为一等公民、并对其自省（即在运行时获悉一个名称或者一个属性或函数的类型）与简单地使用函数式或响应式风格紧密相关。\n\n在 Java 平台上，使用反射功能所需的运行时组件作为单独的 JAR 文件（kotlin-reflect.jar）分发。这样做是为了减少不使用反射功能的应用程序所需的运行时库的大小。如果你需要使用反射，请确保该 .jar文件添加到项目的 classpath 中。\n\n最基本的反射功能是获取 Kotlin 类的运行时引用。要获取对静态已知的 Kotlin 类的引用，可以使用 类字面值 语法：\n\n该引用是 KClass 类型的值。\n\n请注意，Kotlin 类引用与 Java 类引用不同。要获得 Java 类引用， 请在 KClass 实例上使用 .java 属性。\n\n通过使用对象作为接收者，可以用相同的 ::class 语法获取指定对象的类的引用：\n\nval widget: Widget = ……\nassert(widget is GoodWidget) { \"Bad widget: ${widget::class.qualifiedName}\" }\n你可以获取对象的精确类的引用，例如 GoodWidget 或 BadWidget，尽管接收者表达式的类型是 Widget。\n\n函数、属性以及构造函数的引用，除了作为自省程序结构外， 还可以用于调用或者用作函数类型的实例。\n\n所有可调用引用的公共超类型是 KCallable<out R>， 其中 R 是返回值类型，对于属性是属性类型，对于构造函数是所构造类型。\n\n当我们有一个具名函数声明如下：\n\nfun isOdd(x: Int) = x % 2 != 0\n我们可以很容易地直接调用它（isOdd(5)），但是我们也可以将其作为一个函数类型的值，例如将其传给另一个函数。为此，我们使用 :: 操作符：\n\nfun isOdd(x: Int) = x % 2 != 0\n\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3)\n    println(numbers.filter(::isOdd))\n//sampleEnd\n}\n这里 ::isOdd 是函数类型 (Int) -> Boolean 的一个值。\n\n函数引用属于 KFunction<out R> 的子类型之一，取决于参数个数，例如 KFunction3<T1, T2, T3, R>。\n\n当上下文中已知函数期望的类型时，:: 可以用于重载函数。 例如：\n\nfun main() {\n//sampleStart\n    fun isOdd(x: Int) = x % 2 != 0\n    fun isOdd(s: String) = s == \"brillig\" || s == \"slithy\" || s == \"tove\"\n    \n    val numbers = listOf(1, 2, 3)\n    println(numbers.filter(::isOdd)) // 引用到 isOdd(x: Int)\n//sampleEnd\n}\n或者，你可以通过将方法引用存储在具有显式指定类型的变量中来提供必要的上下文：\n\nval predicate: (String) -> Boolean = ::isOdd   // 引用到 isOdd(x: String)\n如果我们需要使用类的成员函数或扩展函数，它需要是限定的，例如 String::toCharArray。\n\n请注意，即使以扩展函数的引用初始化一个变量，其推断出的函数类型也会没有接收者（它会有一个接受接收者对象的额外参数）。如需改为带有接收者的函数类型，请明确指定其类型：\n\nval isEmptyStringList: List<String>.() -> Boolean = List<String>::isEmpty \n考虑以下函数：\n\nfun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {\n    return { x -> f(g(x)) }\n}\n它返回一个传给它的两个函数的组合：compose(f, g) = f(g(*))。 现在，你可以将其应用于可调用引用：\n\nfun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {\n    return { x -> f(g(x)) }\n}\n\nfun isOdd(x: Int) = x % 2 != 0\n\nfun main() {\n//sampleStart\n    fun length(s: String) = s.length\n    \n    val oddLength = compose(::isOdd, ::length)\n    val strings = listOf(\"a\", \"ab\", \"abc\")\n    \n    println(strings.filter(oddLength))\n//sampleEnd\n}\n要把属性作为 Kotlin中 的一等对象来访问，我们也可以使用 :: 运算符：\n\nval x = 1\n\nfun main() {\n    println(::x.get())\n    println(::x.name) \n}\n表达式 ::x 求值为 KProperty<Int> 类型的属性对象，它允许我们使用 get() 读取它的值，或者使用 name 属性来获取属性名。更多信息请参见关于 KProperty 类的文档。\n\n对于可变属性，例如 var y = 1，::y 返回 KMutableProperty<Int> 类型的一个值， 该类型有一个 set() 方法。\n\nvar y = 1\n\nfun main() {\n    ::y.set(2)\n    println(y)\n}\n属性引用可以用在预期具有单个泛型参数的函数的地方：\n\nfun main() {\n//sampleStart\n    val strs = listOf(\"a\", \"bc\", \"def\")\n    println(strs.map(String::length))\n//sampleEnd\n}\n要访问属于类的成员的属性，我们这样限定它：\n\nfun main() {\n//sampleStart\n    class A(val p: Int)\n    val prop = A::p\n    println(prop.get(A(1)))\n//sampleEnd\n}\n对于扩展属性：\n\nval String.lastChar: Char\n    get() = this[length - 1]\n\nfun main() {\n    println(String::lastChar.get(\"abc\"))\n}\n在Java平台上，标准库包含反射类的扩展，它提供了与 Java 反射对象之间映射（参见 kotlin.reflect.jvm 包）。 例如，要查找一个用作 Kotlin 属性 getter 的 幕后字段或 Java方法，可以这样写：\n\nimport kotlin.reflect.jvm.*\n\nclass A(val p: Int)\n\nfun main() {\n    println(A::p.javaGetter) // 输出 \"public final int A.getP()\"\n    println(A::p.javaField)  // 输出 \"private final int A.p\"\n}\n要获得对应于 Java 类的 Kotlin 类，请使用 .kotlin 扩展属性：\n\nfun getKClass(o: Any): KClass<Any> = o.javaClass.kotlin\n构造函数可以像方法和属性那样引用。他们可以用于期待这样的函数类型对象的任何地方：它与该构造函数接受相同参数并且返回相应类型的对象。 通过使用 :: 操作符并添加类名来引用构造函数。考虑下面的函数， 它期待一个无参并返回 Foo 类型的函数参数：\n\nclass Foo\n\nfun function(factory: () -> Foo) {\n    val x: Foo = factory()\n}\n使用 ::Foo，类 Foo 的零参数构造函数，我们可以这样简单地调用它：\n\n构造函数的可调用引用的类型也是 KFunction<out R> 的子类型之一 ，取决于其参数个数。\n\n你可以引用特定对象的实例方法：\n\nfun main() {\n//sampleStart\n    val numberRegex = \"\\\\d+\".toRegex()\n    println(numberRegex.matches(\"29\"))\n     \n    val isNumber = numberRegex::matches\n    println(isNumber(\"29\"))\n//sampleEnd\n}\n取代直接调用方法 matches 的是我们存储其引用。 这样的引用会绑定到其接收者上。 它可以直接调用（如上例所示）或者用于任何期待一个函数类型表达式的时候：\n\nfun main() {\n//sampleStart\n    val numberRegex = \"\\\\d+\".toRegex()\n    val strings = listOf(\"abc\", \"124\", \"a70\")\n    println(strings.filter(numberRegex::matches))\n//sampleEnd\n}\n比较绑定的类型和相应的未绑定类型的引用。 绑定的可调用引用有其接收者“附加”到其上，因此接收者的类型不再是参数：\n\nval isNumber: (CharSequence) -> Boolean = numberRegex::matches\n\nval matches: (Regex, CharSequence) -> Boolean = Regex::matches\n属性引用也可以绑定：\n\nfun main() {\n//sampleStart\n    val prop = \"abc\"::length\n    println(prop.get())\n//sampleEnd\n}\n自 Kotlin 1.2 起，无需显式指定 this 作为接收者：this::foo 与 ::foo 是等价的。\n\ninner 类的构造函数的绑定的可调用引用可通过提供外部类的实例来获得：\n\nclass Outer {\n    inner class Inner\n}\n\nval o = Outer()\nval boundInnerCtor = o::Inner"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386578104},"updatedAt":{"$$date":1597397206354},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"wqmc0l3faAlmCmKe"}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244749992},"updatedAt":{"$$date":1597244749992},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"x0fq7v9pwrjzldKL"}
{"name":"kotlin-Kotlin 继承 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-extend.html\nKotlin 继承 | 菜鸟教程\n3-4 minutes\nKotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：\n\nclass Example // 从 Any 隐式继承\nAny 默认提供了三个函数：\n\nequals()\n\nhashCode()\n\ntoString()\n注意：Any 不是 java.lang.Object。\n\n如果一个类要被继承，可以使用 open 关键字进行修饰。\n\nopen class Base(p: Int)           // 定义基类\n\nclass Derived(p: Int) : Base(p)\n构造函数\n子类有主构造函数\n如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。\n\nopen class Person(var name : String, var age : Int){// 基类\n\n}\n\nclass Student(name : String, age : Int, var no : String, var score : Int) : Person(name, age) {\n\n}\n\n// 测试\nfun main(args: Array<String>) {\n    val s =  Student(\"Runoob\", 18, \"S12346\", 89)\n    println(\"学生名： ${s.name}\")\n    println(\"年龄： ${s.age}\")\n    println(\"学生号： ${s.no}\")\n    println(\"成绩： ${s.score}\")\n}\n输出结果：\n\n学生名： Runoob\n年龄： 18\n学生号： S12346\n成绩： 89\n子类没有主构造函数\n如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。\n\nclass Student : Person {\n\n    constructor(ctx: Context) : super(ctx) {\n    } \n\n    constructor(ctx: Context, attrs: AttributeSet) : super(ctx,attrs) {\n    }\n}\n实例\n/**用户基类**/\nopen class Person(name:String){\n    /**次级构造函数**/\n    constructor(name:String,age:Int):this(name){\n        //初始化\n        println(\"-------基类次级构造函数---------\")\n    }\n}\n\n/**子类继承 Person 类**/\nclass Student:Person{\n\n    /**次级构造函数**/\n    constructor(name:String,age:Int,no:String,score:Int):super(name,age){\n        println(\"-------继承类次级构造函数---------\")\n        println(\"学生名： ${name}\")\n        println(\"年龄： ${age}\")\n        println(\"学生号： ${no}\")\n        println(\"成绩： ${score}\")\n    }\n}\n\nfun main(args: Array<String>) {\n    var s =  Student(\"Runoob\", 18, \"S12345\", 89)\n}\n输出结果：\n\n-------基类次级构造函数---------\n-------继承类次级构造函数---------\n学生名： Runoob\n年龄： 18\n学生号： S12345\n成绩： 89\n重写\n在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：\n\n/**用户基类**/\nopen class Person{\n    open fun study(){       // 允许子类重写\n        println(\"我毕业了\")\n    }\n}\n\n/**子类继承 Person 类**/\nclass Student : Person() {\n\n    override fun study(){    // 重写方法\n        println(\"我在读大学\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val s =  Student()\n    s.study();\n\n}\n输出结果为:\n\n我在读大学\n如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。\n\nopen class A {\n    open fun f () { print(\"A\") }\n    fun a() { print(\"a\") }\n}\n\ninterface B {\n    fun f() { print(\"B\") } //接口的成员变量默认是 open 的\n    fun b() { print(\"b\") }\n}\n\nclass C() : A() , B{\n    override fun f() {\n        super<A>.f()//调用 A.f()\n        super<B>.f()//调用 B.f()\n    }\n}\n\nfun main(args: Array<String>) {\n    val c =  C()\n    c.f();\n\n}\nC 继承自 a() 或 b(), C 不仅可以从 A 或则 B 中继承函数，而且 C 可以继承 A()、B() 中共有的函数。此时该函数在中只有一个实现，为了消除歧义，该函数必须调用A()和B()中该函数的实现，并提供自己的实现。\n\n输出结果为:\n\nAB\n属性重写\n属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写：\n\nopen class Foo {\n    open val x: Int get { …… }\n}\n\nclass Bar1 : Foo() {\n    override val x: Int = ……\n}\n你可以用一个var属性重写一个val属性，但是反过来不行。因为val属性本身定义了getter方法，重写为var属性会在衍生类中额外声明一个setter方法\n\n你可以在主构造函数中使用 override 关键字作为属性声明的一部分:\n\ninterface Foo {\n    val count: Int\n}\n\nclass Bar1(override val count: Int) : Foo\n\nclass Bar2 : Foo {\n    override var count: Int = 0\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303693203},"updatedAt":{"$$date":1597304084161},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xLI8nLZJLNfG7OV1"}
{"name":"kotlin-区间与数列 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/ranges.html\n区间与数列 - Kotlin 语言中文站\n9-11 minutes\n改进翻译\nKotlin 可通过调用 kotlin.ranges 包中的 rangeTo() 函数及其操作符形式的 .. 轻松地创建两个值的区间。 通常，rangeTo() 会辅以 in 或 !in 函数。\n\n整数类型区间（IntRange、LongRange、CharRange）还有一个拓展特性：可以对其进行迭代。 这些区间也是相应整数类型的等差数列。 这种区间通常用于 for 循环中的迭代。\n\nfun main() {\n//sampleStart\n    for (i in 1..4) print(i)\n//sampleEnd\n}\n\n要反向迭代数字，请使用 downTo 函数而不是 .. 。\n\nfun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n也可以通过任意步长（不一定为 1 ）迭代数字。 这是通过 step 函数完成的。\n\nfun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n    println()\n    for (i in 8 downTo 1 step 2) print(i)\n//sampleEnd\n}\n\n要迭代不包含其结束元素的数字区间，请使用 until 函数：\n\nfun main() {\n//sampleStart\n    for (i in 1 until 10) {       // i in [1, 10), 10被排除\n        print(i)\n    }\n//sampleEnd\n}\n\n区间从数学意义上定义了一个封闭的间隔：它由两个端点值定义，这两个端点值都包含在该区间内。 区间是为可比较类型定义的：具有顺序，可以定义任意实例是否在两个给定实例之间的区间内。 区间的主要操作是 contains，通常以 in 与 !in 操作符的形式使用。\n\n要为类创建一个区间，请在区间起始值上调用 rangeTo() 函数，并提供结束值作为参数。 rangeTo() 通常以操作符 .. 形式调用。\n\nclass Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        }\n        return this.minor - other.minor\n    }\n}\n\nfun main() {\n//sampleStart\n    val versionRange = Version(1, 11)..Version(1, 30)\n    println(Version(0, 9) in versionRange)\n    println(Version(1, 20) in versionRange)\n//sampleEnd\n}\n\n如上个示例所示，整数类型的区间（例如 Int、Long 与 Char）可视为等差数列。 在 Kotlin 中，这些数列由特殊类型定义：IntProgression、LongProgression 与 CharProgression。\n\n数列具有三个基本属性：first 元素、last 元素和一个非零的 step。 首个元素为 first，后续元素是前一个元素加上一个 step。 以确定的步长在数列上进行迭代等效于 Java/JavaScript 中基于索引的 for 循环。\n\nfor (int i = first; i <= last; i += step) {\n  // ……\n}\n通过迭代数列隐式创建区间时，此数列的 first 与 last 元素是区间的端点，step 为 1 。\n\nfun main() {\n//sampleStart\n    for (i in 1..10) print(i)\n//sampleEnd\n}\n\n要指定数列步长，请在区间上使用 step 函数。\n\nfun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n//sampleEnd\n}\n\n数列的 last 元素是这样计算的：\n\n对于正步长：不大于结束值且满足 (last - first) % step == 0 的最大值。\n对于负步长：不小于结束值且满足 (last - first) % step == 0 的最小值。\n因此，last 元素并非总与指定的结束值相同。\n\nfun main() {\n//sampleStart\n    for (i in 1..9 step 3) print(i) // 最后一个元素是 7\n//sampleEnd\n}\n\n要创建反向迭代的数列，请在定义其区间时使用 downTo 而不是 ..。\n\nfun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n数列实现 Iterable<N>，其中 N 分别是 Int、Long 或 Char，因此可以在各种集合函数（如 map、filter 与其他）中使用它们。\n\nfun main() {\n//sampleStart\n    println((1..10).filter { it % 2 == 0 })\n//sampleEnd\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308431957},"updatedAt":{"$$date":1597376998359},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xdzfG4zB8oiDTpBN"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977494373},"updatedAt":{"$$date":1594977494373},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xf9wLlmLfQfadLvf"}
{"name":"kotlin-Kotlin 对象表达式和对象声明 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-object-declarations.html\nKotlin 对象表达式和对象声明 | 菜鸟教程\n4-5 minutes\nKotlin 用对象表达式和对象声明来实现创建一个对某个类做了轻微改动的类的对象，且不需要去声明一个新的子类。\n\n对象表达式\n通过对象表达式实现一个匿名内部类的对象用于方法的参数中：\n\nwindow.addMouseListener(object : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) {\n        // ...\n    }\n    override fun mouseEntered(e: MouseEvent) {\n        // ...\n    }\n})\n对象可以继承于某个基类，或者实现其他接口:\n\nopen class A(x: Int) {\n    public open val y: Int = x\n}\n\ninterface B {……}\n\nval ab: A = object : A(1), B {\n    override val y = 15\n}\n如果超类型有一个构造函数，则必须传递参数给它。多个超类型和接口可以用逗号分隔。\n\n通过对象表达式可以越过类的定义直接得到一个对象：\n\nfun main(args: Array<String>) {\n    val site = object {\n        var name: String = \"菜鸟教程\"\n        var url: String = \"www.runoob.com\"\n    }\n    println(site.name)\n    println(site.url)\n}\n请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。\n\nclass C {\n    // 私有函数，所以其返回类型是匿名对象类型\n    private fun foo() = object {\n        val x: String = \"x\"\n    }\n\n    // 公有函数，所以其返回类型是 Any\n    fun publicFoo() = object {\n        val x: String = \"x\"\n    }\n\n    fun bar() {\n        val x1 = foo().x        // 没问题\n        val x2 = publicFoo().x  // 错误：未能解析的引用“x”\n    }\n}\n在对象表达中可以方便的访问到作用域中的其他变量:\n\nfun countClicks(window: JComponent) {\n    var clickCount = 0\n    var enterCount = 0\n\n    window.addMouseListener(object : MouseAdapter() {\n        override fun mouseClicked(e: MouseEvent) {\n            clickCount++\n        }\n\n        override fun mouseEntered(e: MouseEvent) {\n            enterCount++\n        }\n    })\n    // ……\n}\n对象声明\nKotlin 使用 object 关键字来声明一个对象。\n\nKotlin 中我们可以方便的通过对象声明来获得一个单例。\n\nobject DataProviderManager {\n    fun registerDataProvider(provider: DataProvider) {\n        // ……\n    }\n\n    val allDataProviders: Collection<DataProvider>\n        get() = // ……\n}\n引用该对象，我们直接使用其名称即可：\n\nDataProviderManager.registerDataProvider(……)\n当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个单例。\n\nvar data1 = DataProviderManager\nvar data2 = DataProviderManager\ndata1.name = \"test\"\nprint(\"data1 name = ${data2.name}\")  \n实例\n以下实例中，两个对象都输出了同一个 url 地址：\n\nobject Site {\n    var url:String = \"\"\n    val name: String = \"菜鸟教程\"\n}\nfun main(args: Array<String>) {\n    var s1 =  Site\n    var s2 = Site\n    s1.url = \"www.runoob.com\"\n    println(s1.url)\n    println(s2.url)\n}\n输出结果为:\n\nwww.runoob.com\nwww.runoob.com\n对象可以有超类型：\n\nobject DefaultListener : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) {\n        // ……\n    }\n\n    override fun mouseEntered(e: MouseEvent) {\n        // ……\n    }\n}\n与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。\n\nclass Site {\n    var name = \"菜鸟教程\"\n    object DeskTop{\n        var url = \"www.runoob.com\"\n        fun showName(){\n            print{\"desk legs $name\"} // 错误，不能访问到外部类的方法和变量\n        }\n    }\n}\nfun main(args: Array<String>) {\n    var site = Site()\n    site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象\n    Site.DeskTop.url // 正确\n}\n伴生对象\n类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。\n\nclass MyClass {\n    companion object Factory {\n        fun create(): MyClass = MyClass()\n    }\n}\n\nval instance = MyClass.create()   // 访问到对象的内部元素\n我们可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名：\n\nclass MyClass {\n    companion object {\n    }\n}\n\nval x = MyClass.Companion\n注意：一个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次。\n\n请伴生对象的成员看起来像其他语言的静态成员，但在运行时他们仍然是真实对象的实例成员。例如还可以实现接口：\n\ninterface Factory<T> {\n    fun create(): T\n}\n\n\nclass MyClass {\n    companion object : Factory<MyClass> {\n        override fun create(): MyClass = MyClass()\n    }\n}\n对象表达式和对象声明之间的语义差异\n对象表达式和对象声明之间有一个重要的语义差别：\n\n对象表达式是在使用他们的地方立即执行的\n\n对象声明是在第一次被访问到时延迟初始化的\n\n伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304151760},"updatedAt":{"$$date":1597305002861},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xfPUB9MMJmWc3vL8"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597404259436},"updatedAt":{"$$date":1597404259436},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xgRhV6HOVFvquPS3"}
{"name":"Untitled snippet","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598975707839},"updatedAt":{"$$date":1598975707839},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xjPgZoIS7ZyBJ6d1"}
{"name":"CSS3 用户界面","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 用户界面\nCSS3 用户界面\n在 CSS3 中, 增加了一些新的用户界面特性来调整元素尺寸，框尺寸和外边框。\n\n在本章中，您将了解以下的用户界面属性：\n\nresize\nbox-sizing\noutline-offset\n浏览器支持\n表格中的数字表示支持该属性的第一个浏览器版本号。\n\n紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号。\n\n属性\t\t\t\t\t\nresize\t4.0\t不兼容\t5.0\n4.0 -moz-\t4.0\t15.0\nbox-sizing\t10.0\n4.0 -webkit-\t8.0\t29.0\n2.0 -moz-\t5.1\n3.1 -webkit-\t9.5\noutline-offset\t4.0\t不兼容\t5.0\n4.0 -moz-\t4.0\t9.5\nCSS3 调整尺寸(Resizing)\nCSS3中，resize属性指定一个元素是否应该由用户去调整大小。\n\n这个 div 元素由用户调整大小。 (在 Firefox 4+, Chrome, 和 Safari中)\nCSS代码如下：\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n由用户指定一个div元素尺寸大小：\n\ndiv\n{\n    resize:both;\n    overflow:auto;\n}\n\n尝试一下 »\n\nCSS3 方框大小调整(Box Sizing)\nbox-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n规定两个并排的带边框方框：\n\ndiv\n{\n    box-sizing:border-box;\n    -moz-box-sizing:border-box; /* Firefox */\n    width:50%;\n    float:left;\n}\n\n尝试一下 »\n\nCSS3 外形修饰（outline-offset ）\noutline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。\n\n轮廓与边框有两点不同：\n\n轮廓不占用空间\n轮廓可能是非矩形\n这个 div 在边框之外 15 像素处有一个轮廓。\nCSS 代码如下:\n\nOperaSafariChromeFirefoxInternet Explorer\n实例\n规定边框边缘之外 15 像素处的轮廓：\n\ndiv\n{\n    border:2px solid black;\n    outline:2px solid red;\n    outline-offset:15px;\n}\n\n尝试一下 »\n\n新的用户界面特性\n属性\t说明\tCSS\nappearance\t允许您使一个元素的外观像一个标准的用户界面元素\t3\nbox-sizing\t允许你以适应区域而用某种方式定义某些元素\t3\nicon\t为创作者提供了将元素设置为图标等价物的能力。\t3\nnav-down\t指定在何处使用箭头向下导航键时进行导航\t3\nnav-index\t指定一个元素的Tab的顺序\t3\nnav-left\t指定在何处使用左侧的箭头导航键进行导航\t3\nnav-right\t指定在何处使用右侧的箭头导航键进行导航\t3\nnav-up\t指定在何处使用箭头向上导航键时进行导航\t3\noutline-offset\t外轮廓修饰并绘制超出边框的边缘\t3\nresize\t指定一个元素是否是由用户调整大小\t"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974623287},"updatedAt":{"$$date":1598975082554},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xlotaDTjcpYUOLIQ"}
{"name":"html-HTML 链接","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\nHTML 使用超级链接与网络上的另一个文档相连。几乎可以在所有的网页中找到链接。点击链接可以从一张页面跳转到另一张页面。\n\nExamples\n尝试一下 - 实例\nHTML 链接\n如何在HTML文档中创建链接。\n\n(可以在本页底端找到更多实例)\n\nHTML 超链接（链接）\nHTML使用标签 <a>来设置超文本链接。\n\n超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。\n\n当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。\n\n在标签<a> 中使用了href属性来描述链接的地址。\n\n默认情况下，链接将以以下形式出现在浏览器中：\n\n一个未访问过的链接显示为蓝色字体并带有下划线。\n访问过的链接显示为紫色并带有下划线。\n点击链接时，链接显示为红色并带有下划线。\n注意：如果为这些超链接设置了 CSS 样式，展示样式会根据 CSS 的设定而显示。\n\nHTML 链接语法\n链接的 HTML 代码很简单。它类似这样：\n\n<a href=\"url\">链接文本</a>\nhref 属性描述了链接的目标。.\n\n实例\n<a href=\"https://www.runoob.com/\">访问菜鸟教程</a>\n上面这行代码显示为：访问菜鸟教程\n\n点击这个超链接会把用户带到菜鸟教程的首页。\n\n提示: \"链接文本\" 不必一定是文本。图片或其他 HTML 元素都可以成为链接。\n\nHTML 链接 - target 属性\n使用 target 属性，你可以定义被链接的文档在何处显示。\n\n下面的这行会在新窗口打开文档：\n\n实例\n<a href=\"https://www.runoob.com/\" target=\"_blank\" rel=\"noopener noreferrer\">访问菜鸟教程!</a>\n\n尝试一下 »\n\nHTML 链接- id 属性\nid属性可用于创建在一个HTML文档书签标记。\n\n提示: 书签是不以任何特殊的方式显示，在HTML文档中是不显示的，所以对于读者来说是隐藏的。\n\n实例\n在HTML文档中插入ID:\n\n<a id=\"tips\">有用的提示部分</a>\n在HTML文档中创建一个链接到\"有用的提示部分(id=\"tips\"）\"：\n\n<a href=\"#tips\">访问有用的提示部分</a>\n或者，从另一个页面创建一个链接到\"有用的提示部分(id=\"tips\"）\"：\n\n<a href=\"https://www.runoob.com/html/html-links.html#tips\">\n访问有用的提示部分</a>\n\n基本的注意事项 - 有用的提示\n注释： 请始终将正斜杠添加到子文件夹。假如这样书写链接：href=\"https://www.runoob.com/html\"，就会向服务器产生两次 HTTP 请求。这是因为服务器会添加正斜杠到这个地址，然后创建一个新的请求，就像这样：href=\"https://www.runoob.com/html/\"。\n\nExamples\n更多实例\n图片链接\n如何使用图片链接。\n\n在当前页面链接到指定位置\n如何使用书签\n\n跳出框架\n本例演示如何跳出框架，假如你的页面被固定在框架之内。\n\n创建电子邮件链接\n本例演示如何链接到一个邮件。（本例在安装邮件客户端程序后才能工作。）\n\n创建电子邮件链接 2\n本例演示更加复杂的邮件链接。\n\nHTML 链接标签\n标签\t描述\n<a>\t定义一个超级链接\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598885700898},"updatedAt":{"$$date":1598886156676},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xoOCP61uTk4YpJ34"}
{"name":"CSS3 多列","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"CSS3 多列\nCSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例:\n\n菜鸟教程 - 学的不仅是技术，更是梦想！菜鸟教程(www.runoob.com)提供了最全的编程技术基础教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识。 同时本站中也提供了大量的在线实例，通过实例，您可以更好的学习编程。\n\n浏览器支持\n表格中的数字表示支持该方法的第一个浏览器的版本号。\n\n紧跟在数字后面的 -webkit- 或 -moz- 为指定浏览器的前缀。\n\n属性\t\t\t\t\t\ncolumn-count\t4.0 -webkit-\t10.0\t2.0 -moz-\t3.1 -webkit-\t15.0 -webkit-\n11.1\ncolumn-gap\t4.0 -webkit-\t10.0\t2.0 -moz-\t3.1 -webkit-\t15.0 -webkit-\n11.1\ncolumn-rule\t4.0 -webkit-\t10.0\t2.0 -moz-\t3.1 -webkit-\t15.0 -webkit-\n11.1\ncolumn-rule-color\t4.0 -webkit-\t10.0\t2.0 -moz-\t3.1 -webkit-\t15.0 -webkit\n11.1\ncolumn-rule-style\t4.0 -webkit-\t10.0\t2.0 -moz-\t3.1 -webkit-\t15.0 -webkit\n11.1\ncolumn-rule-width\t4.0 -webkit-\t10.0\t2.0 -moz-\t3.1 -webkit-\t15.0 -webkit\n11.1\ncolumn-width\t4.0 -webkit-\t10.0\t2.0 -moz-\t3.1 -webkit-\t15.0 -webkit\n11.1\nCSS3 多列属性\n本章节我们将学习以下几个 CSS3 的多列属性:\n\ncolumn-count\ncolumn-gap\ncolumn-rule-style\ncolumn-rule-width\ncolumn-rule-color\ncolumn-rule\ncolumn-span\ncolumn-width\nCSS3 创建多列\ncolumn-count 属性指定了需要分割的列数。\n\n以下实例将 <div> 元素中的文本分为 3 列：\n\n实例\ndiv {\n    -webkit-column-count: 3; /* Chrome, Safari, Opera */\n    -moz-column-count: 3; /* Firefox */\n    column-count: 3;\n}\n\n尝试一下 »\nCSS3 多列中列与列间的间隙\ncolumn-gap 属性指定了列与列间的间隙。\n\n以下实例指定了列与列间的间隙为 40 像素：\n\n实例\ndiv {\n    -webkit-column-gap: 40px; /* Chrome, Safari, Opera */\n    -moz-column-gap: 40px; /* Firefox */\n    column-gap: 40px;\n}\n\n尝试一下 »\nCSS3 列边框\ncolumn-rule-style 属性指定了列与列间的边框样式：\n\n实例\ndiv {\n    -webkit-column-rule-style: solid; /* Chrome, Safari, Opera */\n    -moz-column-rule-style: solid; /* Firefox */\n    column-rule-style: solid;\n}\n\n尝试一下 »\ncolumn-rule-width 属性指定了两列的边框厚度:\n\n实例\ndiv {\n    -webkit-column-rule-width: 1px; /* Chrome, Safari, Opera */\n    -moz-column-rule-width: 1px; /* Firefox */\n    column-rule-width: 1px;\n}\n\n尝试一下 »\ncolumn-rule-color 属性指定了两列的边框颜色：\n\n实例\ndiv {\n    -webkit-column-rule-color: lightblue; /* Chrome, Safari, Opera */\n    -moz-column-rule-color: lightblue; /* Firefox */\n    column-rule-color: lightblue;\n}\n\n尝试一下 »\ncolumn-rule 属性是 column-rule-* 所有属性的简写。\n\n以下实例设置了列直接的边框的厚度，样式及颜色：\n\n实例\ndiv {\n    -webkit-column-rule: 1px solid lightblue; /* Chrome, Safari, Opera */\n    -moz-column-rule: 1px solid lightblue; /* Firefox */\n    column-rule: 1px solid lightblue;\n}\n\n尝试一下 »\n指定元素跨越多少列\n以下实例指定 <h2> 元素跨越所有列：\n\n实例\nh2 {\n    -webkit-column-span: all; /* Chrome, Safari, Opera */\n    column-span: all;\n}\n\n尝试一下 »\n指定列的宽度\ncolumn-width 属性指定了列的宽度。\n\n实例\ndiv {\n    -webkit-column-width: 100px; /* Chrome, Safari, Opera */\n    column-width: 100px;\n}\n\n尝试一下 »\nCSS3 多列属性\n下表列出了所有 CSS3 的多列属性：\n\n属性\t描述\ncolumn-count\t指定元素应该被分割的列数。\ncolumn-fill\t指定如何填充列\ncolumn-gap\t指定列与列之间的间隙\ncolumn-rule\t所有 column-rule-* 属性的简写\ncolumn-rule-color\t指定两列间边框的颜色\ncolumn-rule-style\t指定两列间边框的样式\ncolumn-rule-width\t指定两列间边框的厚度\ncolumn-span\t指定元素要跨越多少列\ncolumn-width\t指定列的宽度\ncolumns\tcolumn-width 与 column-count 的简写属性。\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598974621995},"updatedAt":{"$$date":1598975064926},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xsfnx5ubydT046ar"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973264611},"updatedAt":{"$$date":1594973264611},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xwlWtJcH1itE8Pil"}
{"name":"java-使用CompletableFuture","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。\n\n从Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。\n\n我们以获取股票价格为例，看看如何使用CompletableFuture：\n\n// CompletableFuture\nimport java.util.concurrent.CompletableFuture;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 创建异步执行任务:\n        CompletableFuture<Double> cf = CompletableFuture.supplyAsync(Main::fetchPrice);\n        // 如果执行成功:\n        cf.thenAccept((result) -> {\n            System.out.println(\"price: \" + result);\n        });\n        // 如果执行异常:\n        cf.exceptionally((e) -> {\n            e.printStackTrace();\n            return null;\n        });\n        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:\n        Thread.sleep(200);\n    }\n\n    static Double fetchPrice() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        if (Math.random() < 0.3) {\n            throw new RuntimeException(\"fetch price failed!\");\n        }\n        return 5 + Math.random() * 20;\n    }\n}\n\n Run\n创建一个CompletableFuture是通过CompletableFuture.supplyAsync()实现的，它需要一个实现了Supplier接口的对象：\n\npublic interface Supplier<T> {\n    T get();\n}\n这里我们用lambda语法简化了一下，直接传入Main::fetchPrice，因为Main.fetchPrice()静态方法的签名符合Supplier接口的定义（除了方法名外）。\n\n紧接着，CompletableFuture已经被提交给默认的线程池执行了，我们需要定义的是CompletableFuture完成时和异常时需要回调的实例。完成时，CompletableFuture会调用Consumer对象：\n\npublic interface Consumer<T> {\n    void accept(T t);\n}\n异常时，CompletableFuture会调用Function对象：\n\npublic interface Function<T, R> {\n    R apply(T t);\n}\n这里我们都用lambda语法简化了代码。\n\n可见CompletableFuture的优点是：\n\n异步任务结束时，会自动回调某个对象的方法；\n异步任务出错时，会自动回调某个对象的方法；\n主线程设置好回调后，不再关心异步任务的执行。\n如果只是实现了异步回调机制，我们还看不出CompletableFuture相比Future的优势。CompletableFuture更强大的功能是，多个CompletableFuture可以串行执行，例如，定义两个CompletableFuture，第一个CompletableFuture根据证券名称查询证券代码，第二个CompletableFuture根据证券代码查询证券价格，这两个CompletableFuture实现串行操作如下：\n\n// CompletableFuture\nimport java.util.concurrent.CompletableFuture;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 第一个任务:\n        CompletableFuture<String> cfQuery = CompletableFuture.supplyAsync(() -> {\n            return queryCode(\"中国石油\");\n        });\n        // cfQuery成功后继续执行下一个任务:\n        CompletableFuture<Double> cfFetch = cfQuery.thenApplyAsync((code) -> {\n            return fetchPrice(code);\n        });\n        // cfFetch成功后打印结果:\n        cfFetch.thenAccept((result) -> {\n            System.out.println(\"price: \" + result);\n        });\n        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:\n        Thread.sleep(2000);\n    }\n\n    static String queryCode(String name) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        return \"601857\";\n    }\n\n    static Double fetchPrice(String code) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        return 5 + Math.random() * 20;\n    }\n}\n\n Run\n除了串行执行外，多个CompletableFuture还可以并行执行。例如，我们考虑这样的场景：\n\n同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：\n\n// CompletableFuture\nimport java.util.concurrent.CompletableFuture;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 两个CompletableFuture执行异步查询:\n        CompletableFuture<String> cfQueryFromSina = CompletableFuture.supplyAsync(() -> {\n            return queryCode(\"中国石油\", \"https://finance.sina.com.cn/code/\");\n        });\n        CompletableFuture<String> cfQueryFrom163 = CompletableFuture.supplyAsync(() -> {\n            return queryCode(\"中国石油\", \"https://money.163.com/code/\");\n        });\n\n        // 用anyOf合并为一个新的CompletableFuture:\n        CompletableFuture<Object> cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);\n\n        // 两个CompletableFuture执行异步查询:\n        CompletableFuture<Double> cfFetchFromSina = cfQuery.thenApplyAsync((code) -> {\n            return fetchPrice((String) code, \"https://finance.sina.com.cn/price/\");\n        });\n        CompletableFuture<Double> cfFetchFrom163 = cfQuery.thenApplyAsync((code) -> {\n            return fetchPrice((String) code, \"https://money.163.com/price/\");\n        });\n\n        // 用anyOf合并为一个新的CompletableFuture:\n        CompletableFuture<Object> cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);\n\n        // 最终结果:\n        cfFetch.thenAccept((result) -> {\n            System.out.println(\"price: \" + result);\n        });\n        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:\n        Thread.sleep(200);\n    }\n\n    static String queryCode(String name, String url) {\n        System.out.println(\"query code from \" + url + \"...\");\n        try {\n            Thread.sleep((long) (Math.random() * 100));\n        } catch (InterruptedException e) {\n        }\n        return \"601857\";\n    }\n\n    static Double fetchPrice(String code, String url) {\n        System.out.println(\"query price from \" + url + \"...\");\n        try {\n            Thread.sleep((long) (Math.random() * 100));\n        } catch (InterruptedException e) {\n        }\n        return 5 + Math.random() * 20;\n    }\n}\n\n Run\n上述逻辑实现的异步查询规则实际上是：\n\n┌─────────────┐ ┌─────────────┐\n│ Query Code  │ │ Query Code  │\n│  from sina  │ │  from 163   │\n└─────────────┘ └─────────────┘\n       │               │\n       └───────┬───────┘\n               ▼\n        ┌─────────────┐\n        │    anyOf    │\n        └─────────────┘\n               │\n       ┌───────┴────────┐\n       ▼                ▼\n┌─────────────┐  ┌─────────────┐\n│ Query Price │  │ Query Price │\n│  from sina  │  │  from 163   │\n└─────────────┘  └─────────────┘\n       │                │\n       └────────┬───────┘\n                ▼\n         ┌─────────────┐\n         │    anyOf    │\n         └─────────────┘\n                │\n                ▼\n         ┌─────────────┐\n         │Display Price│\n         └─────────────┘\n除了anyOf()可以实现“任意个CompletableFuture只要一个成功”，allOf()可以实现“所有CompletableFuture都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。\n\n最后我们注意CompletableFuture的命名规则：\n\nxxx()：表示该方法将继续在已有的线程中执行；\nxxxAsync()：表示将异步在线程池中执行。\n练习\n从下载练习：使用CompletableFuture （推荐使用IDE练习插件快速下载）\n\n小结\nCompletableFuture可以指定异步处理流程：\n\nthenAccept()处理正常结果；\nexceptional()处理异常结果；\nthenApplyAsync()用于串行化另一个CompletableFuture；\nanyOf()和allOf()用于并行化多个CompletableFuture。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973284814},"updatedAt":{"$$date":1594973370741},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"y6PWECdpdNWzibw1"}
{"name":"kotlin-异步流 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/coroutines/flow.html\n异步流 - Kotlin 语言中文站\n106-133 minutes\n改进翻译\n目录\n\n异步流\n表示多个值\n序列\n挂起函数\n流\n流是冷的\n流取消基础\n流构建器\n过渡流操作符\n转换操作符\n限长操作符\n末端流操作符\n流是连续的\n流上下文\nwithContext 发出错误\nflowOn 操作符\n缓冲\n合并\n处理最新值\n组合多个流\nZip\nCombine\n展平流\nflatMapConcat\nflatMapMerge\nflatMapLatest\n流异常\n收集器 try 与 catch\n一切都已捕获\n异常透明性\n透明捕获\n声明式捕获\n流完成\n命令式 finally 块\n声明式处理\n成功完成\n命令式还是声明式\n启动流\nFlow cancellation checks\nMaking busy flow cancellable\n流（Flow）与响应式流（Reactive Streams）\n挂起函数可以异步的返回单个值，但是该如何异步返回多个计算好的值呢？这正是 Kotlin 流（Flow）的用武之地。\n\n在 Kotlin 中可以使用集合来表示多个值。 比如说，我们有一个 simple 函数，它返回一个包含三个数字的 List， 然后使用 forEach 打印它们：\n\nfun simple(): List<Int> = listOf(1, 2, 3)\n \nfun main() {\n    simple().forEach { value -> println(value) } \n}\n可以在这里获取完整代码。\n\n这段代码输出如下：\n\n1\n2\n3\n如果使用一些消耗 CPU 资源的阻塞代码计算数字（每次计算需要 100 毫秒）那么我们可以使用 Sequence 来表示数字：\n\nfun simple(): Sequence<Int> = sequence { // 序列构建器\n    for (i in 1..3) {\n        Thread.sleep(100) // 假装我们正在计算\n        yield(i) // 产生下一个值\n    }\n}\n\nfun main() {\n    simple().forEach { value -> println(value) } \n}\n可以在这里获取完整代码。\n\n这段代码输出相同的数字，但在打印每个数字之前等待 100 毫秒。\n\n然而，计算过程阻塞运行该代码的主线程。 当这些值由异步代码计算时，我们可以使用 suspend 修饰符标记函数 simple， 这样它就可以在不阻塞的情况下执行其工作并将结果作为列表返回：\n\nimport kotlinx.coroutines.*                 \n                           \n//sampleStart\nsuspend fun simple(): List<Int> {\n    delay(1000) // 假装我们在这里做了一些异步的事情\n    return listOf(1, 2, 3)\n}\n\nfun main() = runBlocking<Unit> {\n    simple().forEach { value -> println(value) } \n}\n//sampleEnd\n可以在这里获取完整代码。\n\n这段代码将会在等待一秒之后打印数字。\n\n使用 List 结果类型，意味着我们只能一次返回所有值。 为了表示异步计算的值流（stream），我们可以使用 Flow 类型（正如同步计算值会使用 Sequence 类型）：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart               \nfun simple(): Flow<Int> = flow { // 流构建器\n    for (i in 1..3) {\n        delay(100) // 假装我们在这里做了一些有用的事情\n        emit(i) // 发送下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // 启动并发的协程以验证主线程并未阻塞\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // 收集这个流\n    simple().collect { value -> println(value) } \n}\n//sampleEnd\n可以在这里获取完整代码。\n\n这段代码在不阻塞主线程的情况下每等待 100 毫秒打印一个数字。在主线程中运行一个单独的协程每 100 毫秒打印一次 “I'm not blocked” 已经经过了验证。\n\nI'm not blocked 1\n1\nI'm not blocked 2\n2\nI'm not blocked 3\n3\n注意使用 Flow 的代码与先前示例的下述区别：\n\n名为 flow 的 Flow 类型构建器函数。\nflow { ... } 构建块中的代码可以挂起。\n函数 simple 不再标有 suspend 修饰符。\n流使用 emit 函数 发射 值。\n流使用 collect 函数 收集 值。\n我们可以在 simple 的 flow { ... } 函数体内使用 delay 代替 Thread.sleep 以观察主线程在本案例中被阻塞了。\n\nFlow 是一种类似于序列的冷流 — 这段 flow 构建器中的代码直到流被收集的时候才运行。这在以下的示例中非常明显：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart      \nfun simple(): Flow<Int> = flow { \n    println(\"Flow started\")\n    for (i in 1..3) {\n        delay(100)\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    println(\"Calling simple function...\")\n    val flow = simple()\n    println(\"Calling collect...\")\n    flow.collect { value -> println(value) } \n    println(\"Calling collect again...\")\n    flow.collect { value -> println(value) } \n}\n//sampleEnd\n可以在这里获取完整代码。\n\n打印如下：\n\nCalling simple function...\nCalling collect...\nFlow started\n1\n2\n3\nCalling collect again...\nFlow started\n1\n2\n3\n这是返回一个流的 simple 函数没有标记 suspend 修饰符的主要原因。 通过它自己，simple() 调用会尽快返回且不会进行任何等待。该流在每次收集的时候启动， 这就是为什么当我们再次调用 collect 时我们会看到“Flow started”。\n\n流采用与协程同样的协作取消。像往常一样，流的收集可以在当流在一个可取消的挂起函数（例如 delay）中挂起的时候取消。 以下示例展示了当 withTimeoutOrNull 块中代码在运行的时候流是如何在超时的情况下取消并停止执行其代码的：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nfun simple(): Flow<Int> = flow { \n    for (i in 1..3) {\n        delay(100)          \n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    withTimeoutOrNull(250) { // 在 250 毫秒后超时\n        simple().collect { value -> println(value) } \n    }\n    println(\"Done\")\n}\n//sampleEnd\n可以在这里获取完整代码。\n\n注意，在 simple 函数中流仅发射两个数字，产生以下输出：\n\nEmitting 1\n1\nEmitting 2\n2\nDone\nSee Flow cancellation checks section for more details.\n\n先前示例中的 flow { ... } 构建器是最基础的一个。还有其他构建器使流的声明更简单：\n\nflowOf 构建器定义了一个发射固定值集的流。\n使用 .asFlow() 扩展函数，可以将各种集合与序列转换为流。\n因此，从流中打印从 1 到 3 的数字的示例可以写成：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    // 将一个整数区间转化为流\n    (1..3).asFlow().collect { value -> println(value) }\n//sampleEnd \n}\n可以在这里获取完整代码。\n\n可以使用操作符转换流，就像使用集合与序列一样。 过渡操作符应用于上游流，并返回下游流。 这些操作符也是冷操作符，就像流一样。这类操作符本身不是挂起函数。它运行的速度很快，返回新的转换流的定义。\n\n基础的操作符拥有相似的名字，比如 map 与 filter。 流与序列的主要区别在于这些操作符中的代码可以调用挂起函数。\n\n举例来说，一个请求中的流可以使用 map 操作符映射出结果，即使执行一个长时间的请求操作也可以使用挂起函数来实现：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nsuspend fun performRequest(request: Int): String {\n    delay(1000) // 模仿长时间运行的异步工作\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n    (1..3).asFlow() // 一个请求流\n        .map { request -> performRequest(request) }\n        .collect { response -> println(response) }\n}\n//sampleEnd\n可以在这里获取完整代码。\n\n它产生以下三行，每一行每秒出现一次：\n\nresponse 1\nresponse 2\nresponse 3\n在流转换操作符中，最通用的一种称为 transform。它可以用来模仿简单的转换，例如 map 与 filter，以及实施更复杂的转换。 使用 transform 操作符，我们可以 发射 任意值任意次。\n\n比如说，使用 transform 我们可以在执行长时间运行的异步请求之前发射一个字符串并跟踪这个响应：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nsuspend fun performRequest(request: Int): String {\n    delay(1000) // 模仿长时间运行的异步任务\n    return \"response $request\"\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    (1..3).asFlow() // 一个请求流\n        .transform { request ->\n            emit(\"Making request $request\") \n            emit(performRequest(request)) \n        }\n        .collect { response -> println(response) }\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n这段代码的输出如下：\n\nMaking request 1\nresponse 1\nMaking request 2\nresponse 2\nMaking request 3\nresponse 3\n限长过渡操作符（例如 take）在流触及相应限制的时候会将它的执行取消。协程中的取消操作总是通过抛出异常来执行，这样所有的资源管理函数（如 try {...} finally {...} 块）会在取消的情况下正常运行：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun numbers(): Flow<Int> = flow {\n    try {                          \n        emit(1)\n        emit(2) \n        println(\"This line will not execute\")\n        emit(3)    \n    } finally {\n        println(\"Finally in numbers\")\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    numbers() \n        .take(2) // 只获取前两个\n        .collect { value -> println(value) }\n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n这段代码的输出清楚地表明，numbers() 函数中对 flow {...} 函数体的执行在发射出第二个数字后停止：\n\n1\n2\nFinally in numbers\n末端操作符是在流上用于启动流收集的挂起函数。 collect 是最基础的末端操作符，但是还有另外一些更方便使用的末端操作符：\n\n转化为各种集合，例如 toList 与 toSet。\n获取第一个（first）值与确保流发射单个（single）值的操作符。\n使用 reduce 与 fold 将流规约到单个值。\n举例来说：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart         \n    val sum = (1..5).asFlow()\n        .map { it * it } // 数字 1 至 5 的平方                        \n        .reduce { a, b -> a + b } // 求和（末端操作符）\n    println(sum)\n//sampleEnd     \n}\n可以在这里获取完整代码。\n\n打印单个数字：\n\n55\n流的每次单独收集都是按顺序执行的，除非进行特殊操作的操作符使用多个流。该收集过程直接在协程中运行，该协程调用末端操作符。 默认情况下不启动新协程。 从上游到下游每个过渡操作符都会处理每个发射出的值然后再交给末端操作符。\n\n请参见以下示例，该示例过滤偶数并将其映射到字符串：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> {\n//sampleStart         \n    (1..5).asFlow()\n        .filter {\n            println(\"Filter $it\")\n            it % 2 == 0              \n        }              \n        .map { \n            println(\"Map $it\")\n            \"string $it\"\n        }.collect { \n            println(\"Collect $it\")\n        }    \n//sampleEnd                  \n}\n可以在这里获取完整代码。\n\n执行：\n\nFilter 1\nFilter 2\nMap 2\nCollect string 2\nFilter 3\nFilter 4\nMap 4\nCollect string 4\nFilter 5\n流的收集总是在调用协程的上下文中发生。例如，如果有一个流 simple，然后以下代码在它的编写者指定的上下文中运行，而无论流 simple 的实现细节如何：\n\nwithContext(context) {\n    simple().collect { value ->\n        println(value) // 运行在指定上下文中\n    }\n}\n流的该属性称为 上下文保存 。\n\n所以默认的，flow { ... } 构建器中的代码运行在相应流的收集器提供的上下文中。举例来说，考虑打印线程的一个 simple 函数的实现， 它被调用并发射三个数字：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \n//sampleStart\nfun simple(): Flow<Int> = flow {\n    log(\"Started simple flow\")\n    for (i in 1..3) {\n        emit(i)\n    }\n}  \n\nfun main() = runBlocking<Unit> {\n    simple().collect { value -> log(\"Collected $value\") } \n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n运行这段代码：\n\n[main @coroutine#1] Started simple flow\n[main @coroutine#1] Collected 1\n[main @coroutine#1] Collected 2\n[main @coroutine#1] Collected 3\n由于 simple().collect 是在主线程调用的，则 simple 的流主体也是在主线程调用的。 这是快速运行或异步代码的理想默认形式，它不关心执行的上下文并且不会阻塞调用者。\n\n然而，长时间运行的消耗 CPU 的代码也许需要在 Dispatchers.Default 上下文中执行，并且更新 UI 的代码也许需要在 Dispatchers.Main 中执行。通常，withContext 用于在 Kotlin 协程中改变代码的上下文，但是 flow {...} 构建器中的代码必须遵循上下文保存属性，并且不允许从其他上下文中发射（emit）。\n\n尝试运行下面的代码：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n                      \n//sampleStart\nfun simple(): Flow<Int> = flow {\n    // 在流构建器中更改消耗 CPU 代码的上下文的错误方式\n    kotlinx.coroutines.withContext(Dispatchers.Default) {\n        for (i in 1..3) {\n            Thread.sleep(100) // 假装我们以消耗 CPU 的方式进行计算\n            emit(i) // 发射下一个值\n        }\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    simple().collect { value -> println(value) } \n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n这段代码产生如下的异常：\n\nException in thread \"main\" java.lang.IllegalStateException: Flow invariant is violated:\n        Flow was collected in [CoroutineId(1), \"coroutine#1\":BlockingCoroutine{Active}@5511c7f8, BlockingEventLoop@2eac3323],\n        but emission happened in [CoroutineId(1), \"coroutine#1\":DispatchedCoroutine{Active}@2dae0000, Dispatchers.Default].\n        Please refer to 'flow' documentation or use 'flowOn' instead\n    at ...\n例外的是 flowOn 函数，该函数用于更改流发射的上下文。 以下示例展示了更改流上下文的正确方法，该示例还通过打印相应线程的名字以展示它们的工作方式：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \n//sampleStart\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        Thread.sleep(100) // 假装我们以消耗 CPU 的方式进行计算\n        log(\"Emitting $i\")\n        emit(i) // 发射下一个值\n    }\n}.flowOn(Dispatchers.Default) // 在流构建器中改变消耗 CPU 代码上下文的正确方式\n\nfun main() = runBlocking<Unit> {\n    simple().collect { value ->\n        log(\"Collected $value\") \n    } \n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n注意，当收集发生在主线程中，flow { ... } 是如何在后台线程中工作的：\n\n这里要观察的另一件事是 flowOn 操作符已改变流的默认顺序性。 现在收集发生在一个协程中（“coroutine#1”）而发射发生在运行于另一个线程中与收集协程并发运行的另一个协程（“coroutine#2”）中。当上游流必须改变其上下文中的 CoroutineDispatcher 的时候，flowOn 操作符创建了另一个协程。\n\n从收集流所花费的时间来看，将流的不同部分运行在不同的协程中将会很有帮助，特别是当涉及到长时间运行的异步操作时。例如，考虑一种情况， 一个 simple 流的发射很慢，它每花费 100 毫秒才产生一个元素；而收集器也非常慢， 需要花费 300 毫秒来处理元素。让我们看看从该流收集三个数字要花费多长时间：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\n//sampleStart\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple().collect { value -> \n            delay(300) // 假装我们花费 300 毫秒来处理它\n            println(value) \n        } \n    }   \n    println(\"Collected in $time ms\")\n}\n//sampleEnd\n可以在这里获取完整代码。\n\n它会产生这样的结果，整个收集过程大约需要 1200 毫秒（3 个数字，每个花费 400 毫秒）：\n\n1\n2\n3\nCollected in 1220 ms\n我们可以在流上使用 buffer 操作符来并发运行这个 simple 流中发射元素的代码以及收集的代码， 而不是顺序运行它们：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        simple()\n            .buffer() // 缓冲发射项，无需等待\n            .collect { value -> \n                delay(300) // 假装我们花费 300 毫秒来处理它\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n它产生了相同的数字，只是更快了，由于我们高效地创建了处理流水线， 仅仅需要等待第一个数字产生的 100 毫秒以及处理每个数字各需花费的 300 毫秒。这种方式大约花费了 1000 毫秒来运行：\n\n1\n2\n3\nCollected in 1071 ms\n注意，当必须更改 CoroutineDispatcher 时，flowOn 操作符使用了相同的缓冲机制， 但是我们在这里显式地请求缓冲而不改变执行上下文。\n\n当流代表部分操作结果或操作状态更新时，可能没有必要处理每个值，而是只处理最新的那个。在本示例中，当收集器处理它们太慢的时候， conflate 操作符可以用于跳过中间值。构建前面的示例：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        simple()\n            .conflate() // 合并发射项，不对每个值进行处理\n            .collect { value -> \n                delay(300) // 假装我们花费 300 毫秒来处理它\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n我们看到，虽然第一个数字仍在处理中，但第二个和第三个数字已经产生，因此第二个是 conflated ，只有最新的（第三个）被交付给收集器：\n\n1\n3\nCollected in 758 ms\n当发射器和收集器都很慢的时候，合并是加快处理速度的一种方式。它通过删除发射值来实现。 另一种方式是取消缓慢的收集器，并在每次发射新值的时候重新启动它。有一组与 xxx 操作符执行相同基本逻辑的 xxxLatest 操作符，但是在新值产生的时候取消执行其块中的代码。让我们在先前的示例中尝试更换 conflate 为 collectLatest：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val time = measureTimeMillis {\n        simple()\n            .collectLatest { value -> // 取消并重新发射最后一个值\n                println(\"Collecting $value\") \n                delay(300) // 假装我们花费 300 毫秒来处理它\n                println(\"Done $value\") \n            } \n    }   \n    println(\"Collected in $time ms\")\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n由于 collectLatest 的函数体需要花费 300 毫秒，但是新值每 100 秒发射一次，我们看到该代码块对每个值运行，但是只收集最后一个值：\n\nCollecting 1\nCollecting 2\nCollecting 3\nDone 3\nCollected in 741 ms\n组合多个流有很多种方式。\n\n就像 Kotlin 标准库中的 Sequence.zip 扩展函数一样， 流拥有一个 zip 操作符用于组合两个流中的相关值：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow() // 数字 1..3\n    val strs = flowOf(\"one\", \"two\", \"three\") // 字符串\n    nums.zip(strs) { a, b -> \"$a -> $b\" } // 组合单个字符串\n        .collect { println(it) } // 收集并打印\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n示例打印如下：\n\n1 -> one\n2 -> two\n3 -> three\n当流表示一个变量或操作的最新值时（请参阅相关小节 conflation），可能需要执行计算，这依赖于相应流的最新值，并且每当上游流产生值的时候都需要重新计算。这种相应的操作符家族称为 combine。\n\n例如，先前示例中的数字如果每 300 毫秒更新一次，但字符串每 400 毫秒更新一次， 然后使用 zip 操作符合并它们，但仍会产生相同的结果， 尽管每 400 毫秒打印一次结果：\n\n我们在本示例中使用 onEach 过渡操作符来延时每次元素发射并使该流更具说明性以及更简洁。\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow().onEach { delay(300) } // 发射数字 1..3，间隔 300 毫秒\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // 每 400 毫秒发射一次字符串\n    val startTime = System.currentTimeMillis() // 记录开始的时间\n    nums.zip(strs) { a, b -> \"$a -> $b\" } // 使用“zip”组合单个字符串\n        .collect { value -> // 收集并打印\n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n可以在这里获取完整代码。\n\n然而，当在这里使用 combine 操作符来替换 zip：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking<Unit> { \n//sampleStart                                                                           \n    val nums = (1..3).asFlow().onEach { delay(300) } // 发射数字 1..3，间隔 300 毫秒\n    val strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // 每 400 毫秒发射一次字符串\n    val startTime = System.currentTimeMillis() // 记录开始的时间\n    nums.combine(strs) { a, b -> \"$a -> $b\" } // 使用“combine”组合单个字符串\n        .collect { value -> // 收集并打印\n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n可以在这里获取完整代码。\n\n我们得到了完全不同的输出，其中，nums 或 strs 流中的每次发射都会打印一行：\n\n1 -> one at 452 ms from start\n2 -> one at 651 ms from start\n2 -> two at 854 ms from start\n3 -> two at 952 ms from start\n3 -> three at 1256 ms from start\n流表示异步接收的值序列，所以很容易遇到这样的情况： 每个值都会触发对另一个值序列的请求。比如说，我们可以拥有下面这样一个返回间隔 500 毫秒的两个字符串流的函数：\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // 等待 500 毫秒\n    emit(\"$i: Second\")    \n}\n现在，如果我们有一个包含三个整数的流，并为每个整数调用 requestFlow，如下所示：\n\n(1..3).asFlow().map { requestFlow(it) }\n然后我们得到了一个包含流的流（Flow<Flow<String>>），需要将其进行展平为单个流以进行下一步处理。集合与序列都拥有 flatten 与 flatMap 操作符来做这件事。然而，由于流具有异步的性质，因此需要不同的展平模式， 为此，存在一系列的流展平操作符。\n\n连接模式由 flatMapConcat 与 flattenConcat 操作符实现。它们是相应序列操作符最相近的类似物。它们在等待内部流完成之前开始收集下一个值，如下面的示例所示：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // 等待 500 毫秒\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // 记录开始时间\n    (1..3).asFlow().onEach { delay(100) } // 每 100 毫秒发射一个数字 \n        .flatMapConcat { requestFlow(it) }                                                                           \n        .collect { value -> // 收集并打印\n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n可以在这里获取完整代码。\n\n在输出中可以清楚地看到 flatMapConcat 的顺序性质：\n\n1: First at 121 ms from start\n1: Second at 622 ms from start\n2: First at 727 ms from start\n2: Second at 1227 ms from start\n3: First at 1328 ms from start\n3: Second at 1829 ms from start\n另一种展平模式是并发收集所有传入的流，并将它们的值合并到一个单独的流，以便尽快的发射值。 它由 flatMapMerge 与 flattenMerge 操作符实现。他们都接收可选的用于限制并发收集的流的个数的 concurrency 参数（默认情况下，它等于 DEFAULT_CONCURRENCY）。\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // 等待 500 毫秒\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // 记录开始时间\n    (1..3).asFlow().onEach { delay(100) } // 每 100 毫秒发射一个数字 \n        .flatMapMerge { requestFlow(it) }                                                                           \n        .collect { value -> // 收集并打印\n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n可以在这里获取完整代码。\n\nflatMapMerge 的并发性质很明显：\n\n1: First at 136 ms from start\n2: First at 231 ms from start\n3: First at 333 ms from start\n1: Second at 639 ms from start\n2: Second at 732 ms from start\n3: Second at 833 ms from start\n注意，flatMapMerge 会顺序调用代码块（本示例中的 { requestFlow(it) }），但是并发收集结果流，相当于执行顺序是首先执行 map { requestFlow(it) } 然后在其返回结果上调用 flattenMerge。\n\n与 collectLatest 操作符类似（在\"处理最新值\" 小节中已经讨论过），也有相对应的“最新”展平模式，在发出新流后立即取消先前流的收集。 这由 flatMapLatest 操作符来实现。\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // 等待 500 毫秒\n    emit(\"$i: Second\")    \n}\n\nfun main() = runBlocking<Unit> { \n//sampleStart\n    val startTime = System.currentTimeMillis() // 记录开始时间\n    (1..3).asFlow().onEach { delay(100) } // 每 100 毫秒发射一个数字 \n        .flatMapLatest { requestFlow(it) }                                                                           \n        .collect { value -> // 收集并打印\n            println(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n        } \n//sampleEnd\n}\n可以在这里获取完整代码。\n\n该示例的输出很好的展示了 flatMapLatest 的工作方式：\n\n1: First at 142 ms from start\n2: First at 322 ms from start\n3: First at 425 ms from start\n3: Second at 931 ms from start\n注意，flatMapLatest 在一个新值到来时取消了块中的所有代码 (本示例中的 { requestFlow(it) }）。 这在该特定示例中不会有什么区别，由于调用 requestFlow 自身的速度是很快的，不会发生挂起， 所以不会被取消。然而，如果我们要在块中调用诸如 delay 之类的挂起函数，这将会被表现出来。\n\n当运算符中的发射器或代码抛出异常时，流收集可以带有异常的完成。 有几种处理异常的方法。\n\n收集者可以使用 Kotlin 的 try/catch 块来处理异常：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i) // 发射下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    try {\n        simple().collect { value ->         \n            println(value)\n            check(value <= 1) { \"Collected $value\" }\n        }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n这段代码成功的在末端操作符 collect 中捕获了异常，并且， 如我们所见，在这之后不再发出任何值：\n\nEmitting 1\n1\nEmitting 2\n2\nCaught java.lang.IllegalStateException: Collected 2\n前面的示例实际上捕获了在发射器或任何过渡或末端操作符中发生的任何异常。 例如，让我们修改代码以便将发出的值映射为字符串， 但是相应的代码会产生一个异常：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun simple(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // 发射下一个值\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n    try {\n        simple().collect { value -> println(value) }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    } \n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n仍然会捕获该异常并停止收集：\n\nEmitting 1\nstring 1\nEmitting 2\nCaught java.lang.IllegalStateException: Crashed on 2\n但是，发射器的代码如何封装其异常处理行为？\n\n流必须对异常透明，即在 flow { ... } 构建器内部的 try/catch 块中发射值是违反异常透明性的。这样可以保证收集器抛出的一个异常能被像先前示例中那样的 try/catch 块捕获。\n\n发射器可以使用 catch 操作符来保留此异常的透明性并允许封装它的异常处理。catch 操作符的代码块可以分析异常并根据捕获到的异常以不同的方式对其做出反应：\n\n可以使用 throw 重新抛出异常。\n可以使用 catch 代码块中的 emit 将异常转换为值发射出去。\n可以将异常忽略，或用日志打印，或使用一些其他代码处理它。\n例如，让我们在捕获异常的时候发射文本：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            println(\"Emitting $i\")\n            emit(i) // 发射下一个值\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }\n        \"string $value\"\n    }\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    simple()\n        .catch { e -> emit(\"Caught $e\") } // 发射一个异常\n        .collect { value -> println(value) }\n//sampleEnd\n}            \n可以在这里获取完整代码。\n\n即使我们不再在代码的外层使用 try/catch，示例的输出也是相同的。\n\ncatch 过渡操作符遵循异常透明性，仅捕获上游异常（catch 操作符上游的异常，但是它下面的不是）。 如果 collect { ... } 块（位于 catch 之下）抛出一个异常，那么异常会逃逸：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .catch { e -> println(\"Caught $e\") } // 不会捕获下游异常\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n尽管有 catch 操作符，但不会打印“Caught …”消息：\n\n我们可以将 catch 操作符的声明性与处理所有异常的期望相结合，将 collect 操作符的代码块移动到 onEach 中，并将其放到 catch 操作符之前。收集该流必须由调用无参的 collect() 来触发：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        println(\"Emitting $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    simple()\n        .onEach { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n        .catch { e -> println(\"Caught $e\") }\n        .collect()\n//sampleEnd\n}            \n可以在这里获取完整代码。\n\n现在我们可以看到已经打印了“Caught …”消息，并且我们可以在没有显式使用 try/catch 块的情况下捕获所有异常：\n\n当流收集完成时（普通情况或异常情况），它可能需要执行一个动作。 你可能已经注意到，它可以通过两种方式完成：命令式或声明式。\n\n除了 try/catch 之外，收集器还能使用 finally 块在 collect 完成时执行一个动作。\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun simple(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    try {\n        simple().collect { value -> println(value) }\n    } finally {\n        println(\"Done\")\n    }\n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n这段代码打印出 simple 流产生的三个数字，后面跟一个“Done”字符串：\n\n1\n2\n3\nDone\n对于声明式，流拥有 onCompletion 过渡操作符，它在流完全收集时调用。\n\n可以使用 onCompletion 操作符重写前面的示例，并产生相同的输出：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun simple(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n//sampleStart\n    simple()\n        .onCompletion { println(\"Done\") }\n        .collect { value -> println(value) }\n//sampleEnd\n}            \n可以在这里获取完整代码。\n\nonCompletion 的主要优点是其 lambda 表达式的可空参数 Throwable 可以用于确定流收集是正常完成还是有异常发生。在下面的示例中 simple 流在发射数字 1 之后抛出了一个异常：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun simple(): Flow<Int> = flow {\n    emit(1)\n    throw RuntimeException()\n}\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .onCompletion { cause -> if (cause != null) println(\"Flow completed exceptionally\") }\n        .catch { cause -> println(\"Caught exception\") }\n        .collect { value -> println(value) }\n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n如你所期望的，它打印了：\n\n1\nFlow completed exceptionally\nCaught exception\nonCompletion 操作符与 catch 不同，它不处理异常。我们可以看到前面的示例代码，异常仍然流向下游。它将被提供给后面的 onCompletion 操作符，并可以由 catch 操作符处理。\n\n与 catch 操作符的另一个不同点是 onCompletion 能观察到所有异常并且仅在上游流成功完成（没有取消或失败）的情况下接收一个 null 异常。\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\nfun simple(): Flow<Int> = (1..3).asFlow()\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .onCompletion { cause -> println(\"Flow completed with $cause\") }\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            println(value) \n        }\n}\n//sampleEnd\n可以在这里获取完整代码。\n\n我们可以看到完成时 cause 不为空，因为流由于下游异常而中止：\n\n1\nFlow completed with java.lang.IllegalStateException: Collected 2\nException in thread \"main\" java.lang.IllegalStateException: Collected 2\n现在我们知道如何收集流，并以命令式与声明式的方式处理其完成及异常情况。 这里有一个很自然的问题是，哪种方式应该是首选的？为什么？ 作为一个库，我们不主张采用任何特定的方式，并且相信这两种选择都是有效的， 应该根据自己的喜好与代码风格进行选择。\n\n使用流表示来自一些源的异步事件是很简单的。 在这个案例中，我们需要一个类似 addEventListener 的函数，该函数注册一段响应的代码处理即将到来的事件，并继续进行进一步的处理。onEach 操作符可以担任该角色。 然而，onEach 是一个过渡操作符。我们也需要一个末端操作符来收集流。 否则仅调用 onEach 是无效的。\n\n如果我们在 onEach 之后使用 collect 末端操作符，那么后面的代码会一直等待直至流被收集：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart\n// 模仿事件流\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .collect() // <--- 等待流收集\n    println(\"Done\")\n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n你可以看到它的输出：\n\nEvent: 1\nEvent: 2\nEvent: 3\nDone\nlaunchIn 末端操作符可以在这里派上用场。使用 launchIn 替换 collect 我们可以在单独的协程中启动流的收集，这样就可以立即继续进一步执行代码：\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n// 模仿事件流\nfun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n\n//sampleStart\nfun main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> println(\"Event: $event\") }\n        .launchIn(this) // <--- 在单独的协程中执行流\n    println(\"Done\")\n}            \n//sampleEnd\n可以在这里获取完整代码。\n\n它打印了：\n\nDone\nEvent: 1\nEvent: 2\nEvent: 3\nlaunchIn 必要的参数 CoroutineScope 指定了用哪一个协程来启动流的收集。在先前的示例中这个作用域来自 runBlocking 协程构建器，在这个流运行的时候，runBlocking 作用域等待它的子协程执行完毕并防止 main 函数返回并终止此示例。\n\n在实际的应用中，作用域来自于一个寿命有限的实体。在该实体的寿命终止后，相应的作用域就会被取消，即取消相应流的收集。这种成对的 onEach { ... }.launchIn(scope) 工作方式就像 addEventListener 一样。而且，这不需要相应的 removeEventListener 函数， 因为取消与结构化并发可以达成这个目的。\n\n注意，launchIn 也会返回一个 Job，可以在不取消整个作用域的情况下仅取消相应的流收集或对其进行 join。\n\nFor convenience, the flow builder performs additional ensureActive checks for cancellation on each emitted value. It means that a busy loop emitting from a flow { ... } is cancellable:\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nfun foo(): Flow<Int> = flow { \n    for (i in 1..5) {\n        println(\"Emitting $i\") \n        emit(i) \n    }\n}\n\nfun main() = runBlocking<Unit> {\n    foo().collect { value -> \n        if (value == 3) cancel()  \n        println(value)\n    } \n}\n//sampleEnd\nYou can get the full code from here.\n\nWe get only numbers up to 3 and a CancellationException after trying to emit number 4:\n\nEmitting 1\n1\nEmitting 2\n2\nEmitting 3\n3\nEmitting 4\nException in thread \"main\" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=\"coroutine#1\":BlockingCoroutine{Cancelled}@6d7b4f4c\nHowever, most other flow operators do not do additional cancellation checks on their own for performance reasons. For example, if you use IntRange.asFlow extension to write the same busy loop and don't suspend anywhere, then there are no checks for cancellation:\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nfun main() = runBlocking<Unit> {\n    (1..5).asFlow().collect { value -> \n        if (value == 3) cancel()  \n        println(value)\n    } \n}\n//sampleEnd\nYou can get the full code from here.\n\nAll numbers from 1 to 5 are collected and cancellation gets detected only before return from runBlocking:\n\n1\n2\n3\n4\n5\nException in thread \"main\" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=\"coroutine#1\":BlockingCoroutine{Cancelled}@3327bd23\nIn the case where you have a busy loop with coroutines you must explicitly check for cancellation. You can add .onEach { currentCoroutineContext().ensureActive() }, but there is a ready-to-use cancellable operator provided to do that:\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n//sampleStart           \nfun main() = runBlocking<Unit> {\n    (1..5).asFlow().cancellable().collect { value -> \n        if (value == 3) cancel()  \n        println(value)\n    } \n}\n//sampleEnd\nYou can get the full code from here.\n\nWith the cancellable operator only the numbers from 1 to 3 are collected:\n\n1\n2\n3\nException in thread \"main\" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=\"coroutine#1\":BlockingCoroutine{Cancelled}@5ec0a365\n流（Flow）与响应式流（Reactive Streams）\n对于熟悉响应式流（Reactive Streams）或诸如 RxJava 与 Project Reactor 这样的响应式框架的人来说， Flow 的设计也许看起来会非常熟悉。\n\n确实，其设计灵感来源于响应式流以及其各种实现。但是 Flow 的主要目标是拥有尽可能简单的设计， 对 Kotlin 以及挂起友好且遵从结构化并发。没有响应式的先驱及他们大量的工作，就不可能实现这一目标。你可以阅读 Reactive Streams and Kotlin Flows 这篇文章来了解完成 Flow 的故事。\n\n虽然有所不同，但从概念上讲，Flow 依然是响应式流，并且可以将它转换为响应式（规范及符合 TCK）的发布者（Publisher），反之亦然。 这些开箱即用的转换器可以在 kotlinx.coroutines 提供的相关响应式模块（kotlinx-coroutines-reactive 用于 Reactive Streams，kotlinx-coroutines-reactor 用于 Project Reactor，以及 kotlinx-coroutines-rx2/kotlinx-coroutines-rx3 用于 RxJava2/RxJava3）中找到。 集成模块包含 Flow 与其他实现之间的转换，与 Reactor 的 Context 集成以及与一系列响应式实体配合使用的挂起友好的使用方式。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386566872},"updatedAt":{"$$date":1597388572255},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"y6VOxodbzwTS0M3G"}
{"name":"html-HTML5 Canvas","folderId":"oMt48o0iD","content":[{"label":"Fragment 1","language":"html","value":"\n\n\n\n\n<canvas> 标签定义图形，比如图表和其他图像，您必须使用脚本来绘制图形。\n\n在画布上（Canvas）画一个红色矩形，渐变矩形，彩色矩形，和一些彩色的文字。\n\n\n什么是 canvas?\nHTML5 <canvas> 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.\n\n<canvas> 标签只是图形容器，您必须使用脚本来绘制图形。\n\n你可以通过多种方法使用 canvas 绘制路径,盒、圆、字符以及添加图像。\n\n浏览器支持\n表格中的数字表示支持 <canvas> 元素的第一个浏览器版本号。\n\n元素\t\t\t\t\t\n<canvas>\t4.0\t9.0\t2.0\t3.1\t9.0\n创建一个画布（Canvas）\n一个画布在网页中是一个矩形框，通过 <canvas> 元素来绘制.\n\n注意: 默认情况下 <canvas> 元素没有边框和内容。\n\n<canvas>简单实例如下:\n\n<canvas id=\"myCanvas\" width=\"200\" height=\"100\"></canvas>\n注意: 标签通常需要指定一个id属性 (脚本中经常引用), width 和 height 属性定义的画布的大小.\n\n提示:你可以在HTML页面中使用多个 <canvas> 元素.\n\n使用 style 属性来添加边框:\n\n实例\n<canvas id=\"myCanvas\" width=\"200\" height=\"100\"\nstyle=\"border:1px solid #000000;\">\n</canvas>\n\n尝试一下 »\n\n使用 JavaScript 来绘制图像\ncanvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：\n\n实例\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\nctx.fillStyle=\"#FF0000\";\nctx.fillRect(0,0,150,75);\n\n尝试一下 »\n实例解析:\n\n首先，找到 <canvas> 元素:\n\nvar c=document.getElementById(\"myCanvas\");\n然后，创建 context 对象：\n\nvar ctx=c.getContext(\"2d\");\ngetContext(\"2d\") 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n\n下面的两行代码绘制一个红色的矩形：\n\nctx.fillStyle=\"#FF0000\";\nctx.fillRect(0,0,150,75);\n设置fillStyle属性可以是CSS颜色，渐变，或图案。fillStyle 默认设置是#000000（黑色）。\n\nfillRect(x,y,width,height) 方法定义了矩形当前的填充方式。\n\nCanvas 坐标\ncanvas 是一个二维网格。\n\ncanvas 的左上角坐标为 (0,0)\n\n上面的 fillRect 方法拥有参数 (0,0,150,75)。\n\n意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。\n\n坐标实例\n\n如下图所示，画布的 X 和 Y 坐标用于在画布上对绘画进行定位。鼠标移动的矩形框上，显示定位坐标。\n\nX\nY\nCanvas - 路径\n在Canvas上画线，我们将使用以下两种方法：\n\nmoveTo(x,y) 定义线条开始坐标\nlineTo(x,y) 定义线条结束坐标\n绘制线条我们必须使用到 \"ink\" 的方法，就像stroke().\n\n实例\n定义开始坐标(0,0), 和结束坐标 (200,100)。然后使用 stroke() 方法来绘制线条:\n\nJavaScript:\n\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\nctx.moveTo(0,0);\nctx.lineTo(200,100);\nctx.stroke();\n\n尝试一下 »\n在canvas中绘制圆形, 我们将使用以下方法:\n\narc(x,y,r,start,stop)\n实际上我们在绘制圆形时使用了 \"ink\" 的方法, 比如 stroke() 或者 fill().\n\n实例\n使用 arc() 方法 绘制一个圆:\n\nJavaScript:\n\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\nctx.beginPath();\nctx.arc(95,50,40,0,2*Math.PI);\nctx.stroke();\n\n尝试一下 »\n\nCanvas - 文本\n使用 canvas 绘制文本，重要的属性和方法如下：\n\nfont - 定义字体\nfillText(text,x,y) - 在 canvas 上绘制实心的文本\nstrokeText(text,x,y) - 在 canvas 上绘制空心的文本\n使用 fillText():\n\n实例\n使用 \"Arial\" 字体在画布上绘制一个高 30px 的文字（实心）：\n\nJavaScript:\n\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\nctx.font=\"30px Arial\";\nctx.fillText(\"Hello World\",10,50);\n\n尝试一下 »\n使用 strokeText():\n\n实例\n使用 \"Arial\" 字体在画布上绘制一个高 30px 的文字（空心）：\n\nJavaScript:\n\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\nctx.font=\"30px Arial\";\nctx.strokeText(\"Hello World\",10,50);\n\n尝试一下 »\n\nCanvas - 渐变\n渐变可以填充在矩形, 圆形, 线条, 文本等等, 各种形状可以自己定义不同的颜色。\n\n以下有两种不同的方式来设置Canvas渐变：\n\ncreateLinearGradient(x,y,x1,y1) - 创建线条渐变\ncreateRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变\n当我们使用渐变对象，必须使用两种或两种以上的停止颜色。\n\naddColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1.\n\n使用渐变，设置fillStyle或strokeStyle的值为 渐变，然后绘制形状，如矩形，文本，或一条线。\n\n使用 createLinearGradient():\n\n实例\n创建一个线性渐变。使用渐变填充矩形:\n\nJavaScript:\n\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\n \n// 创建渐变\nvar grd=ctx.createLinearGradient(0,0,200,0);\ngrd.addColorStop(0,\"red\");\ngrd.addColorStop(1,\"white\");\n \n// 填充渐变\nctx.fillStyle=grd;\nctx.fillRect(10,10,150,80);\n\n尝试一下 »\n使用 createRadialGradient():\n\n实例\n创建一个径向/圆渐变。使用渐变填充矩形：\n\nJavaScript:\n\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\n \n// 创建渐变\nvar grd=ctx.createRadialGradient(75,50,5,90,60,100);\ngrd.addColorStop(0,\"red\");\ngrd.addColorStop(1,\"white\");\n \n// 填充渐变\nctx.fillStyle=grd;\nctx.fillRect(10,10,150,80);\n\n尝试一下 »\n\nCanvas - 图像\n把一幅图像放置到画布上, 使用以下方法:\n\ndrawImage(image,x,y)\n使用图像:\nThe Scream\n\n实例\n把一幅图像放置到画布上:\n\nJavaScript:\n\nvar c=document.getElementById(\"myCanvas\");\nvar ctx=c.getContext(\"2d\");\nvar img=document.getElementById(\"scream\");\nctx.drawImage(img,10,10);\n\n尝试一下 »\n\nHTML Canvas 参考手册\n标签的完整属性可以参考Canvas 参考手册.\n\nHTML <canvas> 标签\nTag\t描述\n<canvas>\tHTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。\n更多内容可参考：学习 HTML5 Canvas 这一篇文章就够了\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598886956106},"updatedAt":{"$$date":1598887360577},"folder":{"id":"oMt48o0iD","name":"html","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yEPU8YrtgcumNwRJ"}
{"name":"ad-ks_imageload_glide","folderId":"Ai3gX3u8U","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\napply plugin: 'com.android.library'\n// 上传插件\napply from: rootProject.file(\"./gradle/upload_local_maven.gradle\")\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        minSdkVersion 16\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n    //implementation project(path: ':ks_imageload_core')\n    api 'com.ks.frame:imageload-core:0.0.1.1-SNAPSHOT'\n    //glide\n    implementation 'com.github.bumptech.glide:glide:4.11.0'\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'\n    implementation \"com.github.bumptech.glide:okhttp3-integration:4.11.0\"\n\n}\n\n\n\n"}],"tags":["qtPYV4ZiUOHbJ5WL"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598539542753},"updatedAt":{"$$date":1598539828613},"folder":{"id":"Ai3gX3u8U","name":"ksframe","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"android","_id":"qtPYV4ZiUOHbJ5WL","text":"android"}],"_id":"yEhA5dmNm2IJFtv5"}
{"name":"kotlin-类型检测与类型转换：“is”与“as” - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/typecasts.html\n类型检测与类型转换：“is”与“as” - Kotlin 语言中文站\n14-18 minutes\n改进翻译\n我们可以在运行时通过使用 is 操作符或其否定形式 !is 来检测对象是否符合给定类型：\n\nif (obj is String) {\n    print(obj.length)\n}\n\nif (obj !is String) { // 与 !(obj is String) 相同\n    print(\"Not a String\")\n}\nelse {\n    print(obj.length)\n}\n在许多情况下，不需要在 Kotlin 中使用显式转换操作符，因为编译器跟踪不可变值的 is-检测以及显式转换，并在需要时自动插入（安全的）转换：\n\nfun demo(x: Any) {\n    if (x is String) {\n        print(x.length) // x 自动转换为字符串\n    }\n}\n编译器足够聪明，能够知道如果反向检测导致返回那么该转换是安全的：\n\nif (x !is String) return\n\nprint(x.length) // x 自动转换为字符串\n或者在 && 和 || 的右侧：\n\n// `||` 右侧的 x 自动转换为字符串\nif (x !is String || x.length == 0) return\n\n// `&&` 右侧的 x 自动转换为字符串\nif (x is String && x.length > 0) {\n    print(x.length) // x 自动转换为字符串\n}\n这些 智能转换 用于 when-表达式 和 while-循环 也一样：\n\nwhen (x) {\n    is Int -> print(x + 1)\n    is String -> print(x.length + 1)\n    is IntArray -> print(x.sum())\n}\n请注意，当编译器不能保证变量在检测和使用之间不可改变时，智能转换不能用。 更具体地，智能转换能否适用根据以下规则：\n\nval 局部变量——总是可以，局部委托属性除外；\nval 属性——如果属性是 private 或 internal，或者该检测在声明属性的同一模块中执行。智能转换不适用于 open 的属性或者具有自定义 getter 的属性；\nvar 局部变量——如果变量在检测和使用之间没有修改、没有在会修改它的 lambda 中捕获、并且不是局部委托属性；\nvar 属性——决不可能（因为该变量可以随时被其他代码修改）。\n通常，如果转换是不可能的，转换操作符会抛出一个异常。因此，我们称之为不安全的。 Kotlin 中的不安全转换由中缀操作符 as（参见operator precedence）完成：\n\nval x: String = y as String\n请注意，null 不能转换为 String 因该类型不是可空的， 即如果 y 为空，上面的代码会抛出一个异常。 为了让这样的代码用于可空值，请在类型转换的右侧使用可空类型：\n\nval x: String? = y as String?\n为了避免抛出异常，可以使用安全转换操作符 as?，它可以在失败时返回 null：\n\nval x: String? = y as? String\n请注意，尽管事实上 as? 的右边是一个非空类型的 String，但是其转换的结果是可空的。\n\nKotlin 在编译时确保涉及泛型操作的类型安全性， 而在运行时，泛型类型的实例并未带有关于它们实际类型参数的信息。例如， List<Foo> 会被擦除为 List<*>。通常，在运行时无法检测一个实例是否属于带有某个类型参数的泛型类型。\n\n为此，编译器会禁止由于类型擦除而无法执行的 is 检测，例如 ints is List<Int> 或者 list is T（类型参数）。当然，你可以对一个实例检测星投影的类型：\n\nif (something is List<*>) {\n    something.forEach { println(it) } // 这些项的类型都是 `Any?`\n}\n类似地，当已经让一个实例的类型参数（在编译期）静态检测， 就可以对涉及非泛型部分做 is 检测或者类型转换。请注意， 在这种情况下，会省略尖括号：\n\nfun handleStrings(list: List<String>) {\n    if (list is ArrayList) {\n        // `list` 会智能转换为 `ArrayList<String>`\n    }\n}\n省略类型参数的这种语法可用于不考虑类型参数的类型转换：list as ArrayList。\n\n带有具体化的类型参数的内联函数使其类型实参在每个调用处内联，这就能够对类型参数进行 arg is T 检测，但是如果 arg 自身是一个泛型实例，其类型参数还是会被擦除。例如：\n\n//sampleStart\ninline fun <reified A, reified B> Pair<*, *>.asPairOf(): Pair<A, B>? {\n    if (first !is A || second !is B) return null\n    return first as A to second as B\n}\n\nval somePair: Pair<Any?, Any?> = \"items\" to listOf(1, 2, 3)\n\nval stringToSomething = somePair.asPairOf<String, Any>()\nval stringToInt = somePair.asPairOf<String, Int>()\nval stringToList = somePair.asPairOf<String, List<*>>()\nval stringToStringList = somePair.asPairOf<String, List<String>>() // 破坏类型安全！\n//sampleEnd\n\nfun main() {\n    println(\"stringToSomething = \" + stringToSomething)\n    println(\"stringToInt = \" + stringToInt)\n    println(\"stringToList = \" + stringToList)\n    println(\"stringToStringList = \" + stringToStringList)\n}\n如上所述，类型擦除使运行时不可能对泛型类型实例的类型实参进行检测，并且代码中的泛型可能相互连接不够紧密，以致于编译器无法确保类型安全。\n\n即便如此，有时候我们有高级的程序逻辑来暗示类型安全。例如：\n\nfun readDictionary(file: File): Map<String, *> = file.inputStream().use { \n    TODO(\"Read a mapping of strings to arbitrary elements.\")\n}\n\n// 我们已将存有一些 `Int` 的映射保存到该文件\nval intsFile = File(\"ints.dictionary\")\n\n// Warning: Unchecked cast: `Map<String, *>` to `Map<String, Int>`\nval intsDictionary: Map<String, Int> = readDictionary(intsFile) as Map<String, Int>\n编译器会对最后一行的类型转换产生一个警告。该类型转换不能在运行时完全检测，并且不能保证映射中的值是“Int”。\n\n为避免未受检类型转换，可以重新设计程序结构：在上例中，可以使用具有类型安全实现的不同接口 DictionaryReader<T> 与 DictionaryWriter<T>。 可以引入合理的抽象，将未受检的类型转换从调用代码移动到实现细节中。 正确使用泛型型变也有帮助。\n\n对于泛型函数，使用具体化的类型参数可以使诸如 arg as T 这样的类型转换受检，除非 arg 对应类型的自身类型参数已被擦除。\n\n可以通过在产生警告的语句或声明上用注解 @Suppress(\"UNCHECKED_CAST\") 标注来禁止未受检类型转换警告：\n\ninline fun <reified T> List<*>.asListOfType(): List<T>? =\n    if (all { it is T })\n        @Suppress(\"UNCHECKED_CAST\")\n        this as List<T> else\n        null\n在 JVM 平台中，数组类型（Array<Foo>）会保留关于其元素被擦除类型的信息，并且类型转换为一个数组类型可以部分受检： 元素类型的可空性与类型实参仍然会被擦除。例如， 如果 foo 是一个保存了任何 List<*>（无论可不可空）的数组的话，类型转换 foo as Array<List<String>?> 都会成功。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386569165},"updatedAt":{"$$date":1597396740406},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yGyKHm3oOK7Nzi0j"}
{"name":"ad-ks-lib-ktx-support","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName version\n\n//        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n//        consumerProguardFiles 'consumer-rules.pro'\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n\n    lintOptions {\n        abortOnError false\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    kotlinOptions {\n        jvmTarget = JavaVersion.VERSION_1_8\n    }\n\n    androidExtensions {\n        experimental = true\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n    testImplementation deps.androidx.junit\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n\n    implementation deps.androidx.app_compat\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    implementation deps.kotlin.kotlin_reflect\n\n    api deps.kotlin.coroutines_core\n    api deps.kotlin.coroutines_android\n\n    api deps.lifecycle.extensions\n    api deps.lifecycle.viewmodel\n    api deps.lifecycle.livedata\n    api deps.lifecycle.runtime\n}\n\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\nview\nTextViewExt.kt\nActivityExt.kt\nAesExt.kt\nAppExt.kt\nCommonExt.kt\nDrawableExt.kt\nHashExt.kt\nIntentExt.kt\nLogExt.kt\nShellExt.kt\nStatusBarExt.kt\nStringExt.kt\nSystemServiceExt.kt\nTelephonManagerExt.kt\nTimeStampExt.kt\nToastExt.kt\nTransformExt.kt\nTransformUtils\nViewExt.kt\nviewmodel\nBaseAndroidViewModel\nBaseAndroidViewModelKTX.kt\nBaseViewModel\nBaseViewModelKTX.kt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class BaseAndroidViewModel extends AndroidViewModel {\n    // Can't use ConcurrentHashMap, because it can lose values on old apis (see b/37042460)\n\n    private final Map<String, Object> mBagOfTags = new HashMap<>();\n    private volatile boolean mCleared = false;\n\n    public BaseAndroidViewModel( Application application) {\n        super(application);\n    }\n\n    @MainThread\n    final void clear() {\n        mCleared = true;\n        // Since clear() is final, this method is still called on mock objects\n        // and in those cases, mBagOfTags is null. It'll always be empty though\n        // because setTagIfAbsent and getTag are not final so we can skip\n        // clearing it\n        if (mBagOfTags != null) {\n            synchronized (mBagOfTags) {\n                for (Object value : mBagOfTags.values()) {\n                    // see comment for the similar call in setTagIfAbsent\n                    closeWithRuntimeException(value);\n                }\n            }\n        }\n        onCleared();\n    }\n\n    /**\n     * Sets a tag associated with this viewmodel and a key.\n     * If the given {@code newValue} is {@link Closeable},\n     * it will be closed once {@link #clear()}.\n     * <p>\n     * If a value was already set for the given key, this calls do nothing and\n     * returns currently associated value, the given {@code newValue} would be ignored\n     * <p>\n     * If the ViewModel was already cleared then close() would be called on the returned object if\n     * it implements {@link Closeable}. The same object may receive multiple close calls, so method\n     * should be idempotent.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T setTagIfAbsent(String key, T newValue) {\n        T previous;\n        synchronized (mBagOfTags) {\n            previous = (T) mBagOfTags.get(key);\n            if (previous == null) {\n                mBagOfTags.put(key, newValue);\n            }\n        }\n        T result = previous == null ? newValue : previous;\n        if (mCleared) {\n            // It is possible that we'll call close() multiple times on the same object, but\n            // Closeable interface requires close method to be idempotent:\n            // \"if the stream is already closed then invoking this method has no effect.\" (c)\n            closeWithRuntimeException(result);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the tag associated with this viewmodel and the specified key.\n     */\n    @SuppressWarnings({\"TypeParameterUnusedInFormals\", \"unchecked\"})\n    public <T> T getTag(String key) {\n        if (mBagOfTags == null) {\n            return null;\n        }\n        synchronized (mBagOfTags) {\n            return (T) mBagOfTags.get(key);\n        }\n    }\n\n    private static void closeWithRuntimeException(Object obj) {\n        if (obj instanceof Closeable) {\n            try {\n                ((Closeable) obj).close();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nprivate const val JOB_KEY = \"androidx.lifecycle.ViewModelCoroutineScope.JOB_KEY\"\n\n/**\n * [CoroutineScope] tied to this [ViewModel].\n * This scope will be canceled when ViewModel will be cleared, i.e [ViewModel.onCleared] is called\n *\n * This scope is bound to\n * [Dispatchers.Main.immediate][kotlinx.coroutines.MainCoroutineDispatcher.immediate]\n */\nval BaseAndroidViewModel.viewModelScope: CoroutineScope\n    get() {\n        val scope: CoroutineScope? = this.getTag(JOB_KEY)\n        if (scope != null) {\n            return scope\n        }\n        return setTagIfAbsent(JOB_KEY,\n                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))\n    }\n\n//internal class CloseableCoroutineScope(context: CoroutineContext) : Closeable, CoroutineScope {\n//    override val coroutineContext: CoroutineContext = context\n//\n//    override fun close() {\n//        coroutineContext.cancel()\n//    }\n//}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class BaseViewModel extends ViewModel {\n    // Can't use ConcurrentHashMap, because it can lose values on old apis (see b/37042460)\n\n    private final Map<String, Object> mBagOfTags = new HashMap<>();\n    private volatile boolean mCleared = false;\n\n    @MainThread\n    final void clear() {\n        mCleared = true;\n        // Since clear() is final, this method is still called on mock objects\n        // and in those cases, mBagOfTags is null. It'll always be empty though\n        // because setTagIfAbsent and getTag are not final so we can skip\n        // clearing it\n        if (mBagOfTags != null) {\n            synchronized (mBagOfTags) {\n                for (Object value : mBagOfTags.values()) {\n                    // see comment for the similar call in setTagIfAbsent\n                    closeWithRuntimeException(value);\n                }\n            }\n        }\n        onCleared();\n    }\n\n    /**\n     * Sets a tag associated with this viewmodel and a key.\n     * If the given {@code newValue} is {@link Closeable},\n     * it will be closed once {@link #clear()}.\n     * <p>\n     * If a value was already set for the given key, this calls do nothing and\n     * returns currently associated value, the given {@code newValue} would be ignored\n     * <p>\n     * If the ViewModel was already cleared then close() would be called on the returned object if\n     * it implements {@link Closeable}. The same object may receive multiple close calls, so method\n     * should be idempotent.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T setTagIfAbsent(String key, T newValue) {\n        T previous;\n        synchronized (mBagOfTags) {\n            previous = (T) mBagOfTags.get(key);\n            if (previous == null) {\n                mBagOfTags.put(key, newValue);\n            }\n        }\n        T result = previous == null ? newValue : previous;\n        if (mCleared) {\n            // It is possible that we'll call close() multiple times on the same object, but\n            // Closeable interface requires close method to be idempotent:\n            // \"if the stream is already closed then invoking this method has no effect.\" (c)\n            closeWithRuntimeException(result);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the tag associated with this viewmodel and the specified key.\n     */\n    @SuppressWarnings({\"TypeParameterUnusedInFormals\", \"unchecked\"})\n    public <T> T getTag(String key) {\n        if (mBagOfTags == null) {\n            return null;\n        }\n        synchronized (mBagOfTags) {\n            return (T) mBagOfTags.get(key);\n        }\n    }\n\n    private static void closeWithRuntimeException(Object obj) {\n        if (obj instanceof Closeable) {\n            try {\n                ((Closeable) obj).close();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n}\n\n\n\n\n\n\n\n\nval BaseViewModel.viewModelScope: CoroutineScope\n    get() {\n        val scope: CoroutineScope? = this.getTag(JOB_KEY)\n        if (scope != null) {\n            return scope\n        }\n        return setTagIfAbsent(JOB_KEY,\n                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))\n    }\n\ninternal class CloseableCoroutineScope(context: CoroutineContext) : Closeable, CoroutineScope {\n    override val coroutineContext: CoroutineContext = context\n\n    override fun close() {\n        coroutineContext.cancel()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Created by luyao\n * on 2019/7/9 9:45\n */\n\n/**\n * Set view visible\n */\nfun View.visible() {\n    visibility = View.VISIBLE\n}\n\n/**\n * Set view invisible\n */\nfun View.invisible() {\n    visibility = View.INVISIBLE\n}\n\n/**\n * Set view gone\n */\nfun View.gone() {\n    visibility = View.GONE\n}\n\n/**\n * Reverse the view's visibility\n */\nfun View.reverseVisibility(needGone: Boolean = true) {\n    if (isVisible) {\n        if (needGone) gone() else invisible()\n    } else visible()\n}\n\nfun View.changeVisible(visible: Boolean, needGone: Boolean = true) {\n    when {\n        visible -> visible()\n        needGone -> gone()\n        else -> invisible()\n    }\n}\n\nvar View.isVisible: Boolean\n    get() = visibility == View.VISIBLE\n    set(value) = if (value) visible() else gone()\n\nvar View.isInvisible: Boolean\n    get() = visibility == View.INVISIBLE\n    set(value) = if (value) invisible() else visible()\n\nvar View.isGone: Boolean\n    get() = visibility == View.GONE\n    set(value) = if (value) gone() else visible()\n\n/**\n * Set padding\n * @param size top, bottom, left, right padding are same\n */\nfun View.setPadding(@Px size: Int) {\n    setPadding(size, size, size, size)\n}\n\n/**\n * Causes the Runnable which contains action() to be added to the message queue, to be run\n * after the specified amount of time elapses.\n * The runnable will be run on the user interface thread\n *\n * @param action Will be invoked in the Runnable\n * @param delayInMillis The delay (in milliseconds) until the action() will be invoked\n */\ninline fun View.postDelayed(delayInMillis: Long, crossinline action: () -> Unit): Runnable {\n    val runnable = Runnable { action() }\n    postDelayed(runnable, delayInMillis)\n    return runnable\n}\n\n@Deprecated(\"use View.drawToBitmap()\")\nfun View.toBitmap(scale: Float = 1f, config: Bitmap.Config = Bitmap.Config.ARGB_8888): Bitmap? {\n    if (this is ImageView) {\n        if (drawable is BitmapDrawable) return (drawable as BitmapDrawable).bitmap\n    }\n    this.clearFocus()\n    val bitmap = createBitmapSafely((width * scale).toInt(), (height * scale).toInt(), config, 1)\n    if (bitmap != null) {\n        Canvas().run {\n            setBitmap(bitmap)\n            save()\n            drawColor(Color.WHITE)\n            scale(scale, scale)\n            this@toBitmap.draw(this)\n            restore()\n            setBitmap(null)\n        }\n    }\n    return bitmap\n}\n\nfun createBitmapSafely(width: Int, height: Int, config: Bitmap.Config, retryCount: Int): Bitmap? {\n    try {\n        return Bitmap.createBitmap(width, height, config)\n    } catch (e: OutOfMemoryError) {\n        e.printStackTrace()\n        if (retryCount > 0) {\n            System.gc()\n            return createBitmapSafely(width, height, config, retryCount - 1)\n        }\n        return null\n    }\n\n}\n\n/**\n * Register a callback to be invoked when the global layout state or the visibility of views\n * within the view tree changes\n *\n * @param callback The callback() to be invoked\n */\ninline fun View.onGlobalLayout(crossinline callback: () -> Unit) = with(viewTreeObserver) {\n    addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {\n        @RequiresApi(Build.VERSION_CODES.JELLY_BEAN)\n        override fun onGlobalLayout() {\n            removeOnGlobalLayoutListener(this)\n            callback()\n        }\n    })\n}\n\n/**\n * Register a callback to be invoked after the view is measured\n *\n * @param callback The callback() to be invoked\n */\ninline fun View.afterMeasured(crossinline callback: View.() -> Unit) {\n    viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {\n        @RequiresApi(Build.VERSION_CODES.JELLY_BEAN)\n        override fun onGlobalLayout() {\n            if (measuredWidth > 0 && measuredHeight > 0) {\n                viewTreeObserver.removeOnGlobalLayoutListener(this)\n                callback()\n            }\n        }\n    })\n}\n\nvar clickCount = 0\nvar lastClickTime = 0L\n\n/**\n * Invoke the [action] after click [count] times.\n * The interval between two clicks is less than [interval] mills\n */\nfun View.clickN(count: Int = 1, interval: Long = 1000, action: () -> Unit) {\n\n    setOnClickListener {\n        val currentTime = System.currentTimeMillis()\n        if (lastClickTime != 0L && (currentTime - lastClickTime > interval)) {\n            clickCount = 1\n            lastClickTime = currentTime\n            return@setOnClickListener\n        }\n\n        ++clickCount\n        lastClickTime = currentTime\n\n        if (clickCount == count) {\n            clickCount = 0\n            lastClickTime = 0L\n            action()\n        }\n    }\n}\n\n\nobject ViewClickDelay {\n    var hash: Int = 0\n    var lastClickTime: Long = 0\n    var SPACE_TIME: Long = 1000\n}\n\n/**\n * 防止多次点击的方法\n * @receiver View\n * @param clickAction Function0<Unit>\n */\ninfix fun View.checkDoubleClick(clickAction: () -> Unit) {\n\n    this.setOnClickListener {\n        if (this.hashCode() != ViewClickDelay.hash) {\n            ViewClickDelay.hash = this.hashCode()\n            ViewClickDelay.lastClickTime = System.currentTimeMillis()\n            clickAction()\n        } else {\n            val currentTime = System.currentTimeMillis()\n            if (currentTime - ViewClickDelay.lastClickTime > ViewClickDelay.SPACE_TIME) {\n                ViewClickDelay.lastClickTime = System.currentTimeMillis()\n                clickAction()\n            }\n        }\n    }\n}\n\n/**\n * view的点击事件\n * @receiver View 当前点击的view\n * @param needBgMusic Boolean 点击是否需要背景音乐\n * @param action Function0<Unit> block\n */\nfun View.click(needBgMusic: Boolean = false, action: () -> Unit) {\n    if (needBgMusic) {\n\n    }\n    setOnClickListener {\n        action()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nfun Context.toast(content: String, duration: Int = Toast.LENGTH_SHORT) {\n    Toast.makeText(this, content, duration).apply {\n        show()\n    }\n}\n\nfun Context.toast(content: String) {\n    Toast.makeText(this, content, Toast.LENGTH_SHORT).apply {\n        show()\n    }\n}\n\nfun Context.toast(@StringRes id: Int, duration: Int = Toast.LENGTH_SHORT) {\n    toast(getString(id), duration)\n}\n\nfun Context.longToast(content: String) {\n    toast(content, Toast.LENGTH_LONG)\n}\n\nfun Context.longToast(@StringRes id: Int) {\n    toast(id, Toast.LENGTH_LONG)\n}\n\nfun Any.toast(context: Context, content: String, duration: Int = Toast.LENGTH_SHORT) {\n    context.toast(content, duration)\n}\n\nfun Any.toast(context: Context, @StringRes id: Int, duration: Int=Toast.LENGTH_SHORT) {\n    context.toast(id, duration)\n}\n\nfun Any.longToast(context: Context, content: String) {\n    context.longToast(content)\n}\n\nfun Any.longToast(context: Context, @StringRes id: Int) {\n    context.longToast(id)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 获取格式化String\n * @param pattern PATTERN\n */\nfun Long.format(pattern: TimePattern): String {\n\n    val formatter = SimpleDateFormat(pattern.str)\n    return formatter.format(Date(this))\n}\n\n/**\n * 自定义pattern （需要做多语言适配的时候用）\n * @receiver Long\n * @param pattern String\n */\nfun Long.format(pattern: String): String {\n\n    val formatter = SimpleDateFormat(pattern)\n    return formatter.format(Date(this))\n}\n\nenum class TimePattern(val str: String){\n    P_yyyyMMdd_HHmmSS(\"yyyy-MM-dd HH:mm:SS\"),\n    P_yyyyMMdd_HHmm(\"yyyy-MM-dd HH:mm\"),\n    P_yyyyMMdd(\"yyyy-MM-dd\"),\n    P_HHmm(\"HH:mm\"),\n    P_MMdd_HHmm(\"MM-dd HH:mm\");\n}\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Return system service which type is [T]\n */\ninline fun <reified T> Context.getSystemService(): T? =\n    ContextCompat.getSystemService(this, T::class.java)\n\nval Context.windowManager get() = getSystemService<WindowManager>()\nval Context.clipboardManager get() = getSystemService<ClipboardManager>()\nval Context.layoutInflater get() = getSystemService<LayoutInflater>()\nval Context.activityManager get() = getSystemService<ActivityManager>()\nval Context.powerManager get() = getSystemService<PowerManager>()\nval Context.alarmManager get() = getSystemService<AlarmManager>()\nval Context.notificationManager get() = getSystemService<NotificationManager>()\nval Context.keyguardManager get() = getSystemService<KeyguardManager>()\nval Context.locationManager get() = getSystemService<LocationManager>()\nval Context.searchManager get() = getSystemService<SearchManager>()\nval Context.storageManager get() = getSystemService<StorageManager>()\nval Context.vibrator get() = getSystemService<Vibrator>()\nval Context.connectivityManager get() = getSystemService<ConnectivityManager>()\nval Context.wifiManager get() = getSystemService<WifiManager>()\nval Context.audioManager get() = getSystemService<AudioManager>()\nval Context.mediaRouter get() = getSystemService<MediaRouter>()\nval Context.telephonyManager get() = getSystemService<TelephonyManager>()\nval Context.sensorManager get() = getSystemService<SensorManager>()\nval Context.subscriptionManager get() = getSystemService<SubscriptionManager>()\nval Context.carrierConfigManager get() = getSystemService<CarrierConfigManager>()\nval Context.inputMethodManager get() = getSystemService<InputMethodManager>()\nval Context.uiModeManager get() = getSystemService<UiModeManager>()\nval Context.downloadManager get() = getSystemService<DownloadManager>()\nval Context.batteryManager get() = getSystemService<BatteryManager>()\nval Context.jobScheduler get() = getSystemService<JobScheduler>()\nval Context.accessibilityManager get() = getSystemService<AccessibilityManager>()\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522806494},"updatedAt":{"$$date":1598528209210},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yNguoBPmYu9LTPL5"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980166135},"updatedAt":{"$$date":1594980166135},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yXP4hKbqlHKLe0EB"}
{"name":"css-CSS 下拉菜单","folderId":"u_Qk844gP","content":[{"label":"Fragment 1","language":"css","value":"使用 CSS 创建一个鼠标移动上去后显示下拉菜单的效果。\n\n下拉菜单实例\n实例演示 1\n文本下拉菜单\n实例演示 2\n下拉菜单\n实例演示 3\nTrolltunga Norway\n基本下拉菜单\n当鼠标移动到指定元素上时，会出现下拉菜单。\n\n实例\n<style>\n.dropdown {\n    position: relative;\n    display: inline-block;\n}\n\n.dropdown-content {\n    display: none;\n    position: absolute;\n    background-color: #f9f9f9;\n    min-width: 160px;\n    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);\n    padding: 12px 16px;\n    z-index: 1;\n}\n\n.dropdown:hover .dropdown-content {\n    display: block;\n}\n</style>\n\n<div class=\"dropdown\">\n  <span>Mouse over me</span>\n  <div class=\"dropdown-content\">\n    <p>Hello World!</p>\n  </div>\n</div>\n\n尝试一下 »\n实例解析\nHTML 部分：\n\n我们可以使用任何的 HTML 元素来打开下拉菜单，如：<span>, 或 a <button> 元素。\n\n使用容器元素 (如： <div>) 来创建下拉菜单的内容，并放在任何你想放的位置上。\n\n使用 <div> 元素来包裹这些元素，并使用 CSS 来设置下拉内容的样式。\n\nCSS 部分：\n\n.dropdown 类使用 position:relative, 这将设置下拉菜单的内容放置在下拉按钮 (使用 position:absolute) 的右下角位置。\n\n.dropdown-content 类中是实际的下拉菜单。默认是隐藏的，在鼠标移动到指定元素后会显示。 注意 min-width 的值设置为 160px。你可以随意修改它。 注意: 如果你想设置下拉内容与下拉按钮的宽度一致，可设置 width 为 100% ( overflow:auto 设置可以在小尺寸屏幕上滚动)。\n\n我们使用 box-shadow 属性让下拉菜单看起来像一个\"卡片\"。\n\n:hover 选择器用于在用户将鼠标移动到下拉按钮上时显示下拉菜单。\n\n下拉菜单\n创建下拉菜单，并允许用户选取列表中的某一项：\n\n下拉菜单\n这个实例类似前面的实例，当我们在下拉列表中添加了链接，并设置了样式：\n\n实例\n<style>\n/* 下拉按钮样式 */\n.dropbtn {\n    background-color: #4CAF50;\n    color: white;\n    padding: 16px;\n    font-size: 16px;\n    border: none;\n    cursor: pointer;\n}\n\n/* 容器 <div> - 需要定位下拉内容 */\n.dropdown {\n    position: relative;\n    display: inline-block;\n}\n\n/* 下拉内容 (默认隐藏) */\n.dropdown-content {\n    display: none;\n    position: absolute;\n    background-color: #f9f9f9;\n    min-width: 160px;\n    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);\n}\n\n/* 下拉菜单的链接 */\n.dropdown-content a {\n    color: black;\n    padding: 12px 16px;\n    text-decoration: none;\n    display: block;\n}\n\n/* 鼠标移上去后修改下拉菜单链接颜色 */\n.dropdown-content a:hover {background-color: #f1f1f1}\n\n/* 在鼠标移上去后显示下拉菜单 */\n.dropdown:hover .dropdown-content {\n    display: block;\n}\n\n/* 当下拉内容显示后修改下拉按钮的背景颜色 */\n.dropdown:hover .dropbtn {\n    background-color: #3e8e41;\n}\n</style>\n\n<div class=\"dropdown\">\n  <button class=\"dropbtn\">下拉菜单</button>\n  <div class=\"dropdown-content\">\n    <a href=\"#\">菜鸟教程 1</a>\n    <a href=\"#\">菜鸟教程 2</a>\n    <a href=\"#\">菜鸟教程 3</a>\n  </div>\n</div>\n\n尝试一下 »\n下拉内容对齐方式\nfloat:left;\n左\nfloat:right;\n右\n如果你想设置右浮动的下拉菜单内容方向是从右到左，而不是从左到右，可以添加以下代码 right: 0;\n\n实例\n.dropdown-content {\n    right: 0;\n}\n尝试一下 »\n更多实例\n图片下拉\n该实例演示了如何如何在下拉菜单中添加图片。\n\n导航条下拉\n该实例演示了如何在导航条上添加下拉菜单。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598973616211},"updatedAt":{"$$date":1598974138361},"folder":{"id":"u_Qk844gP","name":"CSS","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yiK3iwb62J3hblH9"}
{"name":"andr-使用生命周期感知型组件处理生命周期","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/architecture/lifecycle\n使用生命周期感知型组件处理生命周期  |  Android 开发者  |  Android Developers\n12-15 minutes\n生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您写出更有条理且往往更精简的代码，这样的代码更易于维护。\n\n一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。\n\nandroidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。\n\n在 Android 框架中定义的大多数应用组件都存在生命周期。生命周期由操作系统或进程中运行的框架代码管理。它们是 Android 运作方式的核心，应用必须遵循它们。如果不这样做，可能会引发内存泄露甚至应用崩溃。\n\n假设我们有一个在屏幕上显示设备位置的 Activity。常见的实现可能如下所示：\n\n    internal class MyLocationListener(\n            private val context: Context,\n            private val callback: (Location) -> Unit\n    ) {fun start() {\n            // connect to system location service\n        }fun stop() {\n            // disconnect from system location service\n        }\n    }class MyActivity : AppCompatActivity() {\n        private lateinit var myLocationListener: MyLocationListeneroverride fun onCreate(...) {\n            myLocationListener = MyLocationListener(this) { location ->\n                // update UI\n            }\n        }public override fun onStart() {\n            super.onStart()\n            myLocationListener.start()\n            // manage other components that need to respond\n            // to the activity lifecycle\n        }public override fun onStop() {\n            super.onStop()\n            myLocationListener.stop()\n            // manage other components that need to respond\n            // to the activity lifecycle\n        }\n    }\n    \n    class MyLocationListener {\n        public MyLocationListener(Context context, Callback callback) {\n            // ...\n        }void start() {\n            // connect to system location service\n        }void stop() {\n            // disconnect from system location service\n        }\n    }class MyActivity extends AppCompatActivity {\n        private MyLocationListener myLocationListener;@Override\n        public void onCreate(...) {\n            myLocationListener = new MyLocationListener(this, (location) -> {\n                // update UI\n            });\n        }@Override\n        public void onStart() {\n            super.onStart();\n            myLocationListener.start();\n            // manage other components that need to respond\n            // to the activity lifecycle\n        }@Override\n        public void onStop() {\n            super.onStop();\n            myLocationListener.stop();\n            // manage other components that need to respond\n            // to the activity lifecycle\n        }\n    }\n    \n虽然此示例看起来没问题，但在真实的应用中，最终会有太多管理界面和其他组件的调用，以响应生命周期的当前状态。管理多个组件会在生命周期方法（如 onStart() 和 onStop()）中放置大量的代码，这使得它们难以维护。\n\n此外，无法保证组件会在 Activity 或 Fragment 停止之前启动。在我们需要执行长时间运行的操作（如 onStart() 中的某种配置检查）时尤其如此。这可能会导致出现一种竞争条件，在这种条件下，onStop() 方法会在 onStart() 之前结束，这使得组件留存的时间比所需的时间要长。\n\n    class MyActivity : AppCompatActivity() {\n        private lateinit var myLocationListener: MyLocationListeneroverride fun onCreate(...) {\n            myLocationListener = MyLocationListener(this) { location ->\n                // update UI\n            }\n        }public override fun onStart() {\n            super.onStart()\n            Util.checkUserStatus { result ->\n                // what if this callback is invoked AFTER activity is stopped?\n                if (result) {\n                    myLocationListener.start()\n                }\n            }\n        }public override fun onStop() {\n            super.onStop()\n            myLocationListener.stop()\n        }}\n    \n    class MyActivity extends AppCompatActivity {\n        private MyLocationListener myLocationListener;public void onCreate(...) {\n            myLocationListener = new MyLocationListener(this, location -> {\n                // update UI\n            });\n        }@Override\n        public void onStart() {\n            super.onStart();\n            Util.checkUserStatus(result -> {\n                // what if this callback is invoked AFTER activity is stopped?\n                if (result) {\n                    myLocationListener.start();\n                }\n            });\n        }@Override\n        public void onStop() {\n            super.onStop();\n            myLocationListener.stop();\n        }\n    }\n    \nandroidx.lifecycle 软件包提供的类和接口可帮助您以弹性和隔离的方式解决这些问题。\n\n生命周期\nLifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。\n\nLifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：\n\n事件\n从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。\n状态\n由 Lifecycle 对象跟踪的组件的当前状态。\n生命周期状态示意图\n图 1. 构成 Android Activity 生命周期的状态和事件\n您可以将状态看作图中的节点，将事件看作这些节点之间的边。\n\n类可以通过向其方法添加注解来监控组件的生命周期状态。然后，您可以通过调用 Lifecycle 类的 addObserver() 方法并传递观察者的实例来添加观察者，如以下示例中所示：\n\n    class MyObserver : LifecycleObserver {@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n        fun connectListener() {\n            ...\n        }@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n        fun disconnectListener() {\n            ...\n        }\n    }\n    myLifecycleOwner\n\n.getLifecycle().addObserver(MyObserver())\n    \n    public class MyObserver implements LifecycleObserver {\n        @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n        public void connectListener() {\n            ...\n        }@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n        public void disconnectListener() {\n            ...\n        }\n    }\n    myLifecycleOwner\n\n.getLifecycle().addObserver(new MyObserver());\n    \n在上面的示例中，myLifecycleOwner 对象实现了 LifecycleOwner 接口，我们将在接下来的部分中对该接口进行说明。\n\nLifecycleOwner\nLifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。\n\n此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。\n\n实现 LifecycleObserver 的组件可与实现 LifecycleOwner 的组件无缝协同工作，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。\n\n对于位置跟踪示例，我们可以让 MyLocationListener 类实现 LifecycleObserver，然后在 onCreate() 方法中使用 Activity 的 Lifecycle 对其进行初始化。这样，MyLocationListener 类便可以“自给自足”，这意味着，对生命周期状态的变化做出响应的逻辑会在 MyLocationListener（而不是在 Activity）中进行声明。让各个组件存储自己的逻辑，可使 Activity 和 Fragment 逻辑更易于管理。\n\n    class MyActivity : AppCompatActivity() {\n        private lateinit var myLocationListener: MyLocationListeneroverride fun onCreate(...) {\n            myLocationListener = MyLocationListener(this, lifecycle) { location ->\n                // update UI\n            }\n            Util.checkUserStatus { result ->\n                if (result) {\n                    myLocationListener.enable()\n                }\n            }\n        }\n    }\n    \n    class MyActivity extends AppCompatActivity {\n        private MyLocationListener myLocationListener;public void onCreate(...) {\n            myLocationListener = new MyLocationListener(this, getLifecycle(), location -> {\n                // update UI\n            });\n            Util.checkUserStatus(result -> {\n                if (result) {\n                    myLocationListener.enable();\n                }\n            });\n      }\n    }\n    \n一个常见的用例是，如果 Lifecycle 现在未处于良好的状态，则应避免调用某些回调。例如，如果回调在 Activity 状态保存后运行 Fragment 事务，就会引发崩溃，因此我们绝不能调用该回调。\n\n为简化此用例，Lifecycle 类允许其他对象查询当前状态。\n\n    internal class MyLocationListener(\n            private val context: Context,\n            private val lifecycle: Lifecycle,\n            private val callback: (Location) -> Unit\n    ) {private var enabled = false@OnLifecycleEvent(Lifecycle.Event.ON_START)\n        fun start() {\n            if (enabled) {\n                // connect\n            }\n        }fun enable() {\n            enabled = true\n            if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) {\n                // connect if not connected\n            }\n        }@OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n        fun stop() {\n            // disconnect if connected\n        }\n    }\n    \n    class MyLocationListener implements LifecycleObserver {\n        private boolean enabled = false;\n        public MyLocationListener(Context context, Lifecycle lifecycle, Callback callback) {\n           ...\n        }@OnLifecycleEvent(Lifecycle.Event.ON_START)\n        void start() {\n            if (enabled) {\n               // connect\n            }\n        }public void enable() {\n            enabled = true;\n            if (lifecycle.getCurrentState().isAtLeast(STARTED)) {\n                // connect if not connected\n            }\n        }@OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n        void stop() {\n            // disconnect if connected\n        }\n    }\n    \n对于此实现，LocationListener 类可以完全感知生命周期。如果我们需要从另一个 Activity 或 Fragment 使用 LocationListener，只需对其进行初始化。所有设置和拆解操作都由类本身管理。\n\n如果库提供了需要使用 Android 生命周期的类，我们建议您使用生命周期感知型组件。库客户端可以轻松集成这些组件，而无需在客户端进行手动生命周期管理。\n\n实现自定义 LifecycleOwner\nSupport Library 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 LifecycleOwner 接口。\n\n如果您有一个自定义类并希望使其成为 LifecycleOwner，您可以使用 LifecycleRegistry 类，但需要将事件转发到该类，如以下代码示例中所示：\n\n    class MyActivity : Activity(), LifecycleOwner {private lateinit var lifecycleRegistry: LifecycleRegistryoverride fun onCreate(savedInstanceState: Bundle?) {\n            super.onCreate(savedInstanceState)\n            lifecycleRegistry \n\n= LifecycleRegistry(this)\n            lifecycleRegistry.markState(Lifecycle.State.CREATED)\n        }public override fun onStart() {\n            super.onStart()\n            lifecycleRegistry.markState(Lifecycle.State.STARTED)\n        }override fun getLifecycle(): Lifecycle {\n            return lifecycleRegistry\n        }\n    }\n    \n    public class MyActivity extends Activity implements LifecycleOwner {\n        private LifecycleRegistry lifecycleRegistry;@Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            lifecycleRegistry \n\n= new LifecycleRegistry(this);\n            lifecycleRegistry.markState(Lifecycle.State.CREATED);\n        }@Override\n        public void onStart() {\n            super.onStart();\n            lifecycleRegistry.markState(Lifecycle.State.STARTED);\n        }@NonNull\n        @Override\n        public Lifecycle getLifecycle() {\n            return lifecycleRegistry;\n        }\n    }\n    \n生命周期感知型组件的最佳做法\n使界面控制器（Activity 和 Fragment）尽可能保持精简。它们不应试图获取自己的数据，而应使用 ViewModel 执行此操作，并观察 LiveData 对象以将更改体现到视图中。\n设法编写数据驱动型界面，对于此类界面，界面控制器的责任是随着数据更改而更新视图，或者将用户操作通知给 ViewModel。\n将数据逻辑放在 ViewModel 类中。ViewModel 应充当界面控制器与应用其余部分之间的连接器。不过要注意，ViewModel 不负责获取数据（例如，从网络获取）。ViewModel 应调用相应的组件来获取数据，然后将结果提供给界面控制器。\n使用 Data Binding 在视图与界面控制器之间维持干净的接口。这样一来，您可以使视图更具声明性，并尽量减少需要在 Activity 和 Fragment 中编写的更新代码。如果您更愿意使用 Java 编程语言执行此操作，请使用诸如 Butter Knife 之类的库，以避免样板代码并实现更好的抽象化。\n如果界面很复杂，不妨考虑创建 presenter 类来处理界面的修改。这可能是一项艰巨的任务，但这样做可使界面组件更易于测试。\n避免在 ViewModel 中引用 View 或 Activity 上下文。如果 ViewModel 存在的时间比 Activity 更长（在配置更改的情况下），Activity 将泄露并且不会由垃圾回收器妥善处置。\n使用 Kotlin 协程管理长时间运行的任务和其他可以异步运行的操作。\n生命周期感知型组件的用例\n生命周期感知型组件可使您在各种情况下更轻松地管理生命周期。下面列举几个例子：\n\n在粗粒度和细粒度位置更新之间切换。使用生命周期感知型组件可在位置应用可见时启用细粒度位置更新，并在应用位于后台时切换到粗粒度更新。借助生命周期感知型组件 LiveData，应用可以在用户使用位置发生变化时自动更新界面。\n停止和开始视频缓冲。使用生命周期感知型组件可尽快开始视频缓冲，但会推迟播放，直到应用完全启动。此外，应用销毁后，您还可以使用生命周期感知型组件终止缓冲。\n开始和停止网络连接。借助生命周期感知型组件，可在应用位于前台时启用网络数据的实时更新（流式传输），并在应用进入后台时自动暂停。\n暂停和恢复动画可绘制资源。借助生命周期感知型组件，可在应用位于后台时暂停动画可绘制资源，并在应用位于前台后恢复可绘制资源。\n处理 ON_STOP 事件\n如果 Lifecycle 属于 AppCompatActivity 或 Fragment，那么调用 AppCompatActivity 或 Fragment 的 onSaveInstanceState() 时，Lifecycle 的状态会更改为 CREATED 并且会分派 ON_STOP 事件。\n\n通过 onSaveInstanceState() 保存 Fragment 或 AppCompatActivity 的状态后，其界面被视为不可变，直到调用 ON_START。如果在保存状态后尝试修改界面，很可能会导致应用的导航状态不一致，因此应用在保存状态后运行 FragmentTransaction 时，FragmentManager 会抛出异常。如需了解详情，请参阅 commit()。\n\nLiveData 本身可防止出现这种极端情况，方法是在其观察者的关联 Lifecycle 还没有至少处于 STARTED 状态时避免调用其观察者。在后台，它会在决定调用其观察者之前调用 isAtLeast()。\n\n遗憾的是，AppCompatActivity 的 onStop() 方法会在 onSaveInstanceState() 之后调用，这样就会留下一个缺口，即不允许界面状态发生变化，但 Lifecycle 尚未移至 CREATED 状态。\n\n为防止出现这个问题，beta2 及更低版本中的 Lifecycle 类会将状态标记为 CREATED 而不分派事件，这样一来，即使未分派事件（直到系统调用 onStop()），检查当前状态的任何代码也会获得实际值。\n\n遗憾的是，此解决方案有两个主要问题：\n\n在 API 23 及更低级别，Android 系统实际上会保存 Activity 的状态，即使它的一部分被另一个 Activity 覆盖。换句话说，Android 系统会调用 onSaveInstanceState()，但不一定会调用 onStop()。这样可能会产生很长的时间间隔，在此时间间隔内，观察者仍认为生命周期处于活动状态，虽然无法修改其界面状态。\n要向 LiveData 类公开类似行为的任何类都必须实现由 Lifecycle 版本 beta 2 及更低版本提供的解决方案。\n其他资源\n要详细了解如何使用生命周期感知型组件处理生命周期，请参阅下面列出的其他资源：\n\n示例\nAndroid 架构组件基本示例\nSunflower，这是一个演示应用，演示架构组件的最佳做法\nCodelab\nAndroid 生命周期感知型组件\n博客\nAndroid Sunflower 简介"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243905343},"updatedAt":{"$$date":1597244236715},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yjgwCjJu6lyzbGB3"}
{"name":"qk-","folderId":"xOmqk8Xwn","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598586261148},"updatedAt":{"$$date":1598586261148},"folder":{"id":"xOmqk8Xwn","name":"qingke","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yxoaxjL4IEIA7pX0"}
{"name":"ad-Android Studio依赖添加方式小结","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n在开发过程中，我们会需要引用一些第三方的 jar库，aar库，so库或者一些远程库。那么怎样方便快捷的添加使用这些第三方库呢？下面就来一一介绍依赖添加库的方法。\n\n\n\n添加依赖图\n\nAS不同于Eclipse的配置 Build Path，AS既可以通过图形界面 Project Structure 来配置 Dependencies，还可以通过 gradle.build 脚本来配置。\n\nAS中常用的几种依赖添加方式有：\n\nLib库依赖（Library dependency）\nJar依赖（Jar dependency）\nModule依赖（Module dependency）\nSo文件依赖（So File dependency）\n一. 文件依赖\n1. 文件依赖（so文件导入）\n导入so文件\n(1) 在app/src/main的目录下新建名为 jniLibs 文件夹(app/src/main/jniLibs)；\n(2) 再将so文件复制、粘贴到 jniLibs 目录内；\n(3) 在项目gradle.properties文件中加上以下代码，表示我们要使用NDK进行开发：\n\nandroid.useDeprecatedNdk = true\n(4) 在项目local.properties中配置ndk和sdk的路径：\n\nndk.dir=D\\:\\\\NDK\\\\android-ndk-bundle   \nsdk.dir=D\\:\\\\SDK\\\\android-sdk-bundle  \n(5) 在app下的build.gradle里添加配置:\n\nandroid {\n    compileSdkVersion 25\n    buildToolsVersion \"25.0.2\"\n\n    defaultConfig {\n        applicationId \"com.example.activitytest\"\n        minSdkVersion 14\n        targetSdkVersion 22\n        versionCode 10\n        versionName \"1.0\"        \n    }\n    \n    ndk {\n      moduleName\"myNativeLib\" \n      ldLibs \"log\", \"z\", \"m\"\n      abiFilters \"armeabi\", \"armeabi-v7a\", \"x86\" \n    }\n    \n     buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    \n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n        }\n    }\n}\n导入aar文件\n(1) 将aar文件复制、粘贴到app/libs目录中\n(2) 修改app下的build.gradle配置文件\nAS 3.0之前：\n    ...\n    dependencies {\n        compile fileTree(include: ['*.jar'], dir: 'libs')\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:25.0.0'\n        compile(name:'pullrefreshlibrary', ext:'aar') \n        ...  \n    }  \n    repositories {\n       flatDir {\n          dirs 'libs'\n       }\n    }\nAS 3.0之后：\n\n   ...\n    dependencies {\n        implementation fileTree(include: ['*.jar'], dir: 'libs')\n        testImplementation 'junit:junit:4.12'\n        implementation 'com.android.support:appcompat-v7:25.0.0'\n        implementation(name:'pullrefreshlibrary', ext:'aar') \n        ...  \n    }  \n  ...\n(3) 同步更新Gradle (Sync now)\n\n2. 库依赖（library导入）\n(1) 项目根目录下的build.gradle里repositories节点下添加仓库地址\nAS 3.0之前：\n\nbuildscript {\n    repositories {   \n        \n        jcenter()\n    }\n    dependencies {        \n        \n        classpath 'com.android.tools.build:gradle:2.3.3'\n    }\n}\n\nallprojects {\n    repositories {    \n        jcenter()\n        \n        maven { url \"https://jitpack.io\" }\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\nAS 3.0之后：\n\nbuildscript {\n    repositories {\n        google()\n        \n        jcenter()\n    }\n    dependencies {        \n        \n        classpath 'com.android.tools.build:gradle:3.0.1'\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n        \n        maven { url \"https://jitpack.io\" }\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n(2) 在app下的build.gradle里dependencies节点下添加引用\nAS 3.0之前：\n\n    ...\n    dependencies {\n        compile fileTree(include: ['*.jar'], dir: 'libs')\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:25.0.0'\n        compile 'com.google.code.gson:gson:2.8' \n        ...  \n    }\nAS 3.0之后：\n\n   ...\n    dependencies {\n        implementation fileTree(include: ['*.jar'], dir: 'libs')\n        testImplementation 'junit:junit:4.12'\n        implementation 'com.android.support:appcompat-v7:25.0.0'\n        implementation 'com.google.code.gson:gson:2.8' \n        ...  \n    }\n(3) 同步更新Gradle (Sync now)\n\n3. Jar依赖（jar包导入）\n方法一：\n(1) 将jar文件复制、粘贴到app/libs目录中\n(2) 右键点击jar文件，并点击弹出菜单中的 Add As Library，将jar文件作为类库添加到项目中\n\n方法二：\n(1) 将jar文件复制、粘贴到app/libs目录中\n(2) 在app下的 build.gradle里的dependencies节点下添加引用\nAS 3.0之前：\n\n    ...\n    dependencies {\n        compile fileTree(include: ['*.jar'], dir: 'libs')\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:25.0.0'\n        compile files('libs/gson-2.8.jar')\n        ...\n    } \nAS 3.0之后：\n\n  ...\n    dependencies {\n        implementation fileTree(include: ['*.jar'], dir: 'libs')\n        testImplementation 'junit:junit:4.12'\n        implementation 'com.android.support:appcompat-v7:25.0.0'\n        implementation files('libs/gson-2.8.jar')\n        ...\n    } \n(3) 同步更新Gradle (Sync now)\n\n4. Module依赖（module导入）\n(1) 项目根目录下settigs.gradle里添加第三方库名（例如：testlibrary）\n\n:include ':app',':testlibrary'\n(2) 在app下的build.gradle里dependencies节点下添加引用\nAS 3.0之前：\n\n    ...\n    dependencies {\n        compile fileTree(include: ['*.jar'], dir: 'libs')\n        testCompile 'junit:junit:4.12'\n        compile 'com.android.support:appcompat-v7:25.0.0'\n        compile project(':library')\n        ...  \n    }\nAS 3.0之后：\n\n  ...\n    dependencies {\n        implementation fileTree(include: ['*.jar'], dir: 'libs')\n        testImplementation 'junit:junit:4.12'\n        implementation 'com.android.support:appcompat-v7:25.0.0'\n        implementation project(':library')\n        ...  \n    }\n(3) 同步更新Gradle (Sync now)\n\n二. 文件打包\n详细方法请移驾 —— 《Android Studio打包文件配置方法》\n\n禁止转载，如需转载请通过简信或评论联系作者。\n\n\"如果觉得我的文章对你有帮助，请随意赞赏。您的支持将鼓励我继续创作！\"\n\n还没有人赞赏，支持一下\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241225995},"updatedAt":{"$$date":1598516126578},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"zBSTXFEEpiXzrXmX"}
{"name":"py-变量","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。\n\n变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：\n\na = 1\n变量a是一个整数。\n\nt_007 = 'T007'\n变量t_007是一个字符串。\n\nAnswer = True\n变量Answer是一个布尔值True。\n\n在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：\n\n# -*- coding: utf-8 -*-\na = 123 # a是整数\nprint(a)\na = 'ABC' # a变为字符串\nprint(a)\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973928011},"updatedAt":{"$$date":1594974272529},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"zHNZcljbPaFidrDm"}
{"name":"ad-ks_media_core","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n    buildToolsVersion build_versions.tool_version\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n\n\n    //这个是解决lint报错的代码\n    lintOptions {\n        abortOnError false\n    }\n\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    testImplementation deps.androidx.junit\n    androidTestImplementation deps.androidx.test_runner\n    androidTestImplementation deps.androidx.spresso_core\n\n    implementation deps.androidx.app_compat\n    implementation deps.kotlin.kotlin_stdlib_jdk\n    implementation deps.kotlin.kotlin_reflect\n\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n\n\n\n\n\nmedia\nbean\nMediaData\ncode\ndialog\nLoadingDialog\nlistener\nDialogCallback\nload\nIPicLoader\nPicLoader\nPicLoadListener\nCompressCallback\nIMediaCenter\nIMediaCodeIntercept\nMediaCallback\nMediaConstants\nMediaEvenDigist\nMediaHodle\nPreviewType\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598522803859},"updatedAt":{"$$date":1598524734908},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"zYvvlkY0kNSzVq11"}
{"name":"andr-权限","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/permissions/overview\n权限概览  |  Android 开发者  |  Android Developers\n8-10 minutes\n权限的作用是保护 Android 用户的隐私。Android 应用必须请求权限才能访问敏感的用户数据（例如联系人和短信）以及某些系统功能（例如相机和互联网）。系统可能会自动授予权限，也可能会提示用户批准请求，具体取决于访问的功能。\n\nAndroid 安全架构的设计主旨是：在默认情况下，任何应用都没有权限执行会对其他应用、操作系统或用户带来不利影响的任何操作。这包括读取或写入用户的私有数据（例如联系人或电子邮件）、读取或写入其他应用的文件、执行网络访问、使设备保持唤醒状态等。\n\n本页概述了 Android 权限的工作原理，包括：如何向用户提供权限、安装时权限请求和运行时权限请求之间的区别、如何强制执行权限，以及权限类型和权限组。如果您只需要关于如何使用应用权限的方法指南，请参阅请求应用权限。\n\n权限审批\n应用必须通过在应用清单中添加 <uses-permission> 标记来公开所需的权限。例如，需要发送短信的应用会在清单中添加以下代码行：\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n          package=\"com.example.snazzyapp\"><uses-permission android:name=\"android.permission.SEND_SMS\"/><application ...>\n        ...\n    </application>\n</manifest>\n如果您的应用在清单中列出普通权限（即不会给用户隐私或设备操作带来太大风险的权限），系统会自动将这些权限授予应用。\n\n如果您的应用在清单中列出危险权限（即可能影响用户隐私或设备正常操作的权限），如上面的 SEND_SMS 权限，必须由用户明确同意授予这些权限。\n\n如需详细了解普通权限和危险权限，请参阅保护级别。\n\n危险权限的请求提示\n仅危险权限需要用户同意。Android 请求用户授予危险权限的方式取决于用户设备上搭载的 Android 版本和应用的目标系统版本。\n\n运行时请求（Android 6.0 及更高版本）\n如果设备搭载的是 Android 6.0（API 级别 23）或更高版本，并且应用的 targetSdkVersion 是 23 或更高版本，用户在安装时不会收到任何应用权限的通知。您的应用必须在运行时请求用户授予危险权限。当应用请求权限时，用户会看到一个系统对话框（如图 1 左图所示），告知用户应用正在尝试访问的权限组。该对话框包括拒绝和允许按钮。\n\n如果用户拒绝权限请求，当应用下次请求该权限时，该对话框将包含一个复选框，选中它即表示用户不想再收到权限提示（请参阅图 1 右图）。\n\n\n\n图 1. 初始权限对话框（左）和包含关闭进一步请求的选项的二次权限请求（右）\n\n如果用户选中不再询问复选框并点按拒绝，当您以后尝试请求相同权限时，系统不会再提示用户。\n\n即使用户授予应用所请求的权限，您也不能指望始终拥有该权限。用户也可以选择在系统设置中逐一启用和停用权限。您应始终在运行时检查并请求权限，以防发生运行时错误 (SecurityException)。\n\n如需详细了解如何处理运行时权限请求，请参阅请求应用权限。\n\n安装时请求（Android 5.1.1 及更低版本）\n如果设备搭载的是 Android 5.1.1（API 级别 22）或更低版本，或者应用在任何版本的 Android 上运行时其 targetSdkVersion 是 22 或更低版本，系统将在安装时自动请求用户向应用授予所有危险权限（请参见图 2）。\n\n\n\n图 2. 安装时权限对话框\n\n如果用户点击接受，系统将授予应用请求的所有权限。如果用户拒绝权限请求，系统将取消安装应用。\n\n如果应用更新包括额外权限需求，系统会在更新应用之前提示用户接受这些新权限。\n\n有关请求权限的建议用户体验模式概览，请参阅应用权限最佳做法。\n\n如需了解如何检查并向用户请求权限，请参阅请求应用权限。\n\n访问敏感用户信息的请求提示\n有些应用依赖于访问与通话记录和短信有关的敏感用户信息。如果您想请求特定于通话记录和短信的权限，并将应用发布到 Play 商店，您必须在请求这些运行时权限之前，提示用户将应用设置为核心系统功能的默认处理程序。\n\n如需详细了解默认处理程序，包括有关如何向用户显示默认处理程序提示的指南，请参阅有关仅在默认处理程序中使用的权限的指南。\n\n可选硬件功能的权限\n访问某些硬件功能（如蓝牙或相机）需要应用权限。但是，实际上并非所有 Android 设备都具备这些硬件功能。因此，如果您的应用请求 CAMERA 权限，请务必还要在清单中添加 <uses-feature> 标记，用于声明是否确实需要此功能。例如：\n\n<uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n如果您对该功能声明 android:required=\"false\"，那么 Google Play 就会允许将您的应用安装在没有该功能的设备上。然后，您必须在运行时通过调用 PackageManager.hasSystemFeature() 检查当前设备是否具备该功能，并在没有该功能的情况下将其妥善停用。\n\n如果您未提供 <uses-feature> 标记，那么当 Google Play 发现您的应用请求相应权限时，就会假定您的应用需要此功能。因此，它会从没有该功能的设备中过滤掉您的应用，就像您在 <uses-feature> 标记中声明了 android:required=\"true\" 一样。\n\n如需了解详情，请参阅 Google Play 和根据功能进行过滤\n\n权限强制执行\n权限不仅仅用于请求系统功能。应用提供的服务可强制执行自定义权限以限制谁能使用它们。如需详细了解如何声明自定义权限，请参阅定义自定义应用权限。\n\nActivity 权限强制执行\n使用 android:permission 属性应用于清单中 <activity> 标记的权限可限制谁能启动该 Activity。系统会在 Context.startActivity() 和 Activity.startActivityForResult() 期间检查权限。如果调用方没有所需的权限，则调用会抛出 SecurityException。\n\n服务权限强制执行\n使用 android:permission 属性应用于清单中 <service> 标记的权限可限制谁能启动或绑定到关联的 Service。系统会在 Context.startService()、Context.stopService() 和 Context.bindService() 期间检查权限。如果调用方没有所需的权限，则调用会抛出 SecurityException。\n\n广播权限强制执行\n使用 android:permission 属性应用于 <receiver> 标记的权限可限制谁能向关联的 BroadcastReceiver 发送广播。系统会在 Context.sendBroadcast() 返回后检查权限，因为系统会尝试将提交的广播传递到指定的接收器。因此，权限失效不会导致向调用方抛回异常；只是不会传递该 Intent。\n\n同样，可以向 Context.registerReceiver() 提供权限，用于控制谁能向以编程方式注册的接收器发送广播。另一方面，可以在调用 Context.sendBroadcast() 时提供权限来限制允许哪些广播接收器接收广播。\n\n请注意，接收器和广播者可能都需要权限。发生这种情况时，两项权限检查都必须通过后方可将 intent 传递到关联的目标。如需了解详情，请参阅通过权限限制广播。\n\n内容提供程序权限强制执行\n使用 android:permission 属性应用于 <provider> 标记的权限可限制谁能访问 ContentProvider 中的数据。（内容提供程序有重要的附加安全工具可供其使用，称为 URI 权限，将在后面介绍。）与其他组件不同，您可以设置两个单独的权限属性：android:readPermission 限制谁可以读取提供程序，android:writePermission 限制谁可以写入提供程序。请注意，如果提供程序有读取和写入权限保护，仅拥有写入权限并不表示您可以读取提供程序。\n\n第一次检索提供程序时将会检查权限（如果没有任何权限，将会抛出 SecurityException），对提供程序执行操作时也会检查权限。使用 ContentResolver.query() 需要拥有读取权限；使用 ContentResolver.insert()、ContentResolver.update()、ContentResolver.delete() 需要写入权限。在所有这些情况下，没有所需的权限将导致调用抛出 SecurityException。\n\nURI 权限\n内容提供程序仅仅使用到目前为止介绍的标准权限系统往往是不够的。内容提供程序可能需要通过读取和写入权限保护自己，而其直接客户端也需要将特定 URI 传给其他应用以便于它们运行。\n\n电子邮件应用中的附件就是一个典型的示例。对电子邮件的访问应通过权限加以保护，因为这是敏感的用户数据。但是，如果将图像附件的 URI 提供给图像查看器，该图像查看器就不再有打开附件的权限，因为它没有理由拥有访问所有电子邮件的权限。\n\n此问题的解决方法是采用按 URI 的权限机制：在启动 Activity 或返回结果给 Activity 时，调用方可以设置 Intent.FLAG_GRANT_READ_URI_PERMISSION 和/或 Intent.FLAG_GRANT_WRITE_URI_PERMISSION。这将向接收 Activity 授予访问 intent 中特定数据 URI 的权限，而不管它是否具有任何权限可访问 intent 对应的内容提供程序中的数据。\n\n此机制支持常见的能力式模型，其中用户互动（如打开附件、从列表中选择联系人等）推动临时授予细化的权限。这是一项关键功能，可将应用所需的权限缩小至只与其行为直接相关的权限。\n\n如需构建最安全的实现，使其他应用对其在您的应用中的操作负责，您应该以这种方式使用细化的权限，并使用 android:grantUriPermissions 属性或 <grant-uri-permissions> 标记声明您的应用对它的支持。\n\n如需了解详情，请参阅 Context.grantUriPermission()、Context.revokeUriPermission() 和 Context.checkUriPermission() 方法。\n\n其他权限强制执行\n您可对任何服务调用强制执行任意细化的权限。这可通过 Context.checkCallingPermission() 方法完成。使用所需的权限字符串调用，它将返回一个整数，表示是否已向当前的调用进程授予权限。请注意，仅在执行从另一个进程传入的调用（通常是通过从服务发布的 IDL 接口或者指定给另一进程的某种其他方式完成）时才可使用此方法。\n\n检查权限还有许多其他有用的方法。如果您有另一个进程的进程 ID (PID)，您可以使用 Context.checkPermission() 方法检查针对该 PID 的权限。如果您有另一个应用的软件包名称，您可以使用 PackageManager.checkPermission() 方法了解是否已为该软件包授予特定权限。\n\n自动权限调整\n随着时间的推移，平台中可能会加入新的限制，以致您的应用为了使用特定 API，必须请求之前不需要的权限。因为现有应用假设可随意获取这些 API 的访问权限，所以 Android 可能会将新的权限请求应用到应用清单，以免在新平台版本上中断应用（从而将应用包括在“祖父豁免原则”中以获取权限）。Android 将根据为 targetSdkVersion 属性提供的值决定应用是否需要权限。如果该值低于在其中添加权限的版本，Android 就会添加该权限。\n\n例如，READ_EXTERNAL_STORAGE 权限从 API 级别 19 开始强制执行，用于限制对共享存储空间的访问。如果您的 targetSdkVersion 为 18 或更低版本，系统就会向更高版本的 Android 中运行的应用添加此权限。\n\n警告：如果某权限自动添加到应用，即使您的应用可能实际并不需要这些附加权限，Google Play 上的应用详情也会列出它们。为避免这种情况并移除您不需要的默认权限，请始终将 targetSdkVersion 尽可能更新至最高版本。您可在 Build.VERSION_CODES 文档中查看各版本添加的权限。\n\n保护级别\n权限分为几个保护级别。保护级别影响着是否需要运行时权限请求。\n\n有三种保护级别会影响第三方应用：普通、签名和危险权限。如需查看特定权限所拥有的保护级别，请访问权限 API 参考页面。\n\n普通权限\n普通权限涵盖以下情况：应用需要访问其沙盒外部的数据或资源，但对用户隐私或其他应用的操作带来的风险很小。例如，设置时区的权限就是普通权限。\n\n如果应用在清单中声明需要普通权限，系统会在安装时自动向应用授予该权限。系统不会提示用户授予普通权限，用户也无法撤消这些权限。\n\n签名权限\n系统在安装时授予这些应用权限，但仅会在尝试使用某权限的应用签名证书为定义该权限的同一证书时才会授予。\n\n危险权限\n危险权限涵盖以下情况：应用需要的数据或资源涉及用户隐私信息，或者可能对用户存储的数据或其他应用的操作产生影响。例如，能够读取用户的联系人属于危险权限。如果应用声明其需要危险权限，必须由用户向应用明确授予该权限。在用户批准该权限之前，应用无法提供依赖于该权限的功能。\n\n为了使用危险权限，应用必须在运行时提示用户授予权限。如需详细了解如何提示用户，请参阅危险权限的请求提示。\n\n特殊权限\n有几项权限的行为与普通权限及危险权限都不同。SYSTEM_ALERT_WINDOW 和 WRITE_SETTINGS 特别敏感，因此大多数应用不应该使用它们。如果应用需要其中一种权限，必须在清单中声明该权限，并发送请求用户授权的 intent。系统将向用户显示详细管理屏幕，以响应该 intent。\n\n如需详细了解如何请求这些权限，请参阅 SYSTEM_ALERT_WINDOW 和 WRITE_SETTINGS 参考条目。\n\n如需了解 Android 系统提供的所有权限，请参阅 Manifest.permission。\n\n权限组\n权限根据设备的功能或特性分为多个组。在这一体系中，权限请求在组级别进行处理，一个权限组对应于应用清单中的多个权限声明。例如，短信组同时包括 READ_SMS 和 RECEIVE_SMS 声明。通过这种方式对权限分组，用户就能做出更有意义和明智的选择，而不会对复杂和技术性权限请求感到无所适从。\n\n\n\n所有危险的 Android 权限都属于权限组。任何权限都可以属于某个权限组，不管保护级别如何。但是，权限组仅当权限危险时才影响用户体验。\n\n如果设备搭载的是 Android 6.0（API 级别 23），并且应用的 targetSdkVersion 是 23 或更高版本，系统会在应用请求危险权限时发生以下行为：\n\n如果应用当前在权限组中没有任何权限，系统会向用户显示权限请求对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只会说明应用需要访问设备的联系人。如果用户批准，系统只会向应用授予其请求的权限。\n如果应用已在相同权限组中被授予另一危险权限，系统将立即授予该权限，不会与用户进行任何互动。例如，如果某应用之前已请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限，不向用户显示权限对话框。\n注意：将来版本的 Android SDK 可能可以将特定权限从一个组移到另一个组。因此，不要根据这些权限组的结构设置应用的逻辑。\n\n例如，自 Android 8.1（API 级别 27）起，READ_CONTACTS 位于与 WRITE_CONTACTS 相同的权限组中。如果您的应用请求 READ_CONTACTS 权限，然后请求 WRITE_CONTACTS 权限，不要假定系统可以自动授予 WRITE_CONTACTS 权限。\n\n如果设备搭载的是 Android 5.1（API 级别 22）或更低版本，或者应用的 targetSdkVersion 是 22 或更低版本，系统会在安装时要求用户授予权限。再次强调，系统只会向用户告知应用需要的权限组，而不告知具体权限。例如，当应用请求 READ_CONTACTS 时，安装对话框会列出“联系人”组。当用户接受后，系统仅向应用授予 READ_CONTACTS 权限。\n\n注意：您的应用仍需要明确请求其需要的每项权限，即使用户已授予同一组中的其他权限。此外，权限分组在将来的 Android 版本中可能会发生变化。代码的逻辑不应依赖于同一组中的一组特定权限。\n\n查看应用的权限\n您可以使用“设置”应用和 shell 命令 adb shell pm list permissions 查看系统中当前定义的所有权限。如需使用“设置”应用，请依次转至设置 > 应用。选择一个应用并向下滚动查看该应用使用的权限。对于开发者，adb '-s' 选项以类似于用户所见内容的形式显示权限：\n\n$ adb shell pm list permissions -s\nAll Permissions:\n\nNetwork communication: view Wi-Fi state, create Bluetooth connections, full\ninternet access, view network state\n\nYour location: access extra location provider commands, fine (GPS) location,\nmock location sources for testing, coarse (network-based) location\n\nServices that cost you money: send SMS messages, directly call phone numbers\n\n...\n在模拟器中或测试设备上安装应用时，您也可以使用 adb -g 选项自动授予所有权限：\n\n$ adb shell install -g MyApp.apk\n其他资源\n请求应用权限：有关请求应用权限的方法指南。\n隐含功能要求的权限：介绍请求某些权限如何隐式将您的应用限制于包含相应硬件或软件功能的设备。\n<uses-permission>：声明应用所需权限的清单标记的 API 参考文档。\n设备兼容性：介绍 Android 如何在不同类型的设备上工作，以及如何针对各种设备优化您的应用，或如何限制您的应用在不同设备上的可用性。\nAndroid 安全性概览：详细介绍 Android 平台的安全模型。\n“妈妈，我可以吗？”请求权限：2015 年 Android 开发者峰会上的这个视频介绍了请求权限的最佳做法。\nAndroid M 权限：2015 年 Google I/O 大会上的这个视频说明了 Android 6.0 中对权限模型进行的更改。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242655321},"updatedAt":{"$$date":1597243183631},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ziPrZqte7Kqasfcw"}
{"name":"kqapp-dialog activity","folderId":"_lKjE_epO","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n\n\n\n\nclass CoursePetSourceDownloadActivity : BaseActivity() {\n\n    private var intExtra: ArrayList<PetSourceBean> = arrayListOf()\n\n    override fun setLayoutView() {\n        setContentView(R.layout.course_activity_pet_resource_download)\n    }\n\n    override fun initView() {\n        setStatusBarColor(Color.parseColor(\"#99000000\"))\n    }\n\n    override fun initData() {\n        val navHostFragment = pet_nav_host_fragment as NavHostFragment\n        val inflater = navHostFragment.navController.navInflater\n        val graph = inflater.inflate(R.navigation.course_pet_source_download)\n        if (isMobile()) {\n            graph.startDestination = R.id.course_pet_source_download_mobile\n        } else if (isWifiConnected()) {\n            graph.startDestination = R.id.course_pet_source_download_wifi\n        }\n\n        intExtra = intent.getParcelableArrayListExtra(CourseConstants.PET_SOURCE_DATA_LIST)\n        intExtra?.let {\n            val argument = NavArgument.Builder().setDefaultValue(intExtra).build()\n            graph.addArgument(CourseConstants.PET_SOURCE_DATA_LIST, argument)\n        }\n        var downloadType = intent.getIntExtra(CourseConstants.PET_SOURCE_DOWNLOAD_TYPE, CourseConstants.ALL_PET_DOWNLOAD)\n        val argument = NavArgument.Builder().setDefaultValue(downloadType).build()\n        graph.addArgument(CourseConstants.PET_SOURCE_DOWNLOAD_TYPE, argument)\n\n        navHostFragment.navController.graph = graph\n    }\n\n    override fun finish() {\n        super.finish()\n        overridePendingTransition(R.anim.activity_bottom_enter, R.anim.activity_bottom_exit)\n    }\n\n    override fun onSupportNavigateUp() = findNavController(this, R.id.pet_nav_host_fragment).navigateUp()\n}\n\n\n\n\n\n  <activity\n            android:name=\".ui.activity.pet.CoursePetSourceDownloadActivity\"\n            android:configChanges=\"keyboardHidden|orientation\"\n            android:theme=\"@style/DialogActivityTheme\" />\n\n            \n\n\n    <style name=\"DialogActivityTheme\" parent=\"@style/Theme.AppCompat.Light.NoActionBar\">\n        <item name=\"android:windowBackground\">@android:color/transparent</item>\n        <item name=\"android:windowFullscreen\">false</item>\n        <item name=\"android:backgroundDimEnabled\">true</item>\n        <item name=\"android:backgroundDimAmount\">0.2</item>\n        <item name=\"android:windowIsTranslucent\">true</item>\n        <item name=\"android:layout_width\">match_parent</item>\n        <item name=\"android:layout_height\">match_parent</item>\n        <item name=\"android:windowAnimationStyle\">@android:style/Animation.Activity</item> <!--Activity切换动画效果-->\n    </style>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598593270861},"updatedAt":{"$$date":1598600331215},"folder":{"id":"_lKjE_epO","name":"qingke-app","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"zuGBGCOAGLw0whSP"}
{"name":"ad-ksutils-gradle","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\napply plugin: 'com.android.library'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion build_versions.compile_sdk\n\n    defaultConfig {\n        minSdkVersion build_versions.min_sdk\n        targetSdkVersion build_versions.target_sdk\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n}\n\ndependencies {\n    api fileTree(dir: 'libs', include: ['*.jar'])\n    implementation deps.androidx.app_compat\n    implementation deps.kotlin.kotlin_stdlib_jdk\n}\n\napply from: rootProject.file(\"./gradle/upload.gradle\")\n\n\n\n\n\n\n有如下类：\n\n\nActivityStackManager\nio\nIOUtils\nkeyboard\nCmKeyboardUtil\nKeyboardHeightObserver\nKeyboardHeightProvider\nUtils\noptimize\nTraceUtils\nthread\nHandlerManager\ntimer\nCountdownTask\nDateConstant\nTimerTask\nTimerTaskBase\nAppUtil\nDpUtils\nFastClickChecker\nFileUtils\nKeyboardUtils\nKsUtils\nListUtils\nLogUtils\nUtils\n\n\n\n\n\n\n\n\n\n\n/**\n * @author yangjilai\n * @func 日志类\n */\npublic class LogUtils {\n\n    private LogUtils() {\n    }\n\n    private static boolean IS_DEBUG = true;\n\n    private static final String TAG = \"ksutils\";\n\n    public static void e(String tag, String msg) {\n        if (IS_DEBUG) Log.e(tag, msg);\n    }\n\n    public static void i(String tag, String msg) {\n        if (IS_DEBUG) Log.i(tag, msg);\n    }\n\n    public static void d(String tag, String msg) {\n        if (IS_DEBUG) Log.d(tag, msg);\n    }\n\n    public static void v(String tag, String msg) {\n        if (IS_DEBUG) Log.v(tag, msg);\n    }\n\n    public static void w(String tag, String msg) {\n        if (IS_DEBUG) Log.w(tag, msg);\n    }\n\n    public static void e(String msg) {\n        if (IS_DEBUG) Log.e(TAG, msg);\n    }\n\n    public static void i(String msg) {\n        i(TAG, msg);\n    }\n\n    public static void d(String msg) {\n        d(TAG, msg);\n    }\n\n    public static void v(String msg) {\n        v(TAG, msg);\n    }\n\n    public static void w(String msg) {\n        w(TAG, msg);\n    }\n\n    public static void i(String tag, Throwable e) {\n        if (IS_DEBUG) {\n            Writer info = new StringWriter();\n            PrintWriter printWriter = new PrintWriter(info);\n            e.printStackTrace(printWriter);\n\n            Throwable cause = e.getCause();\n            while (cause != null) {\n                cause.printStackTrace(printWriter);\n                cause = cause.getCause();\n            }\n            i(tag, info.toString());\n        }\n    }\n\n    public static void i(Throwable e) {\n        i(TAG, e);\n    }\n\n}\n\n\n\n\n\n\n\n\n\npublic class ListUtils {\n\n    private ListUtils() {\n        throw new AssertionError();\n    }\n\n    public static <V> int getSize(List<V> sourceList) {\n        return sourceList == null ? 0 : sourceList.size();\n    }\n\n    public static <V> boolean isEmpty(List<V> sourceList) {\n        return sourceList == null || sourceList.size() == 0;\n    }\n\n    public static String join(List<String> list) {\n        return join(list, \",\");\n    }\n\n    public static String join(List<String> list, char separator) {\n        return join(list, new String(new char[]{separator}));\n    }\n\n    public static String join(List<String> list, String separator) {\n        return list == null ? \"\" : TextUtils.join(separator, list);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class KeyboardUtils {\n\n    /**\n     * 显示软键盘\n     */\n    public static void showKeyboard(Activity activity) {\n        if (activity == null) {\n            return;\n        }\n        if (activity.getWindow().getAttributes().softInputMode\n                != WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE) {\n\n            if (activity.getCurrentFocus() != null) {\n                ((InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE))\n                        .toggleSoftInput(0, InputMethodManager.SHOW_FORCED);\n            }\n        }\n    }\n\n\n    /**\n     * 隐藏软键盘\n     */\n    public static void hideKeyboard(Activity activity) {\n        if (activity == null) {\n            return;\n        }\n        if (activity.getWindow().getAttributes().softInputMode\n                != WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN) {\n\n            if (activity.getCurrentFocus() != null) {\n                ((InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE))\n                        .hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(),\n                                InputMethodManager.HIDE_NOT_ALWAYS);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @date 创建时间：2019-08-19\n * @auther yangjilai\n * @Description 当前文件获取的工具类\n */\npublic class FileUtils {\n    /**\n     * 通过 assets 文件获取json 文件数据\n     *\n     * @param fileName\n     * @return\n     */\n    public static String getJsonFromAssets(String fileName) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try {\n            AssetManager assetManager = KsUtils.getContext().getAssets();\n            BufferedReader bf = new BufferedReader(new InputStreamReader(assetManager.open(fileName)));\n            String line;\n            while ((line = bf.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @author yangjilai\n * @func 快速点击的方法\n */\npublic class FastClickChecker {\n\n    private Map<View, Long> viewTimeHashMap;\n    public Map<Integer, Long> idTimeHashMap;\n\n    public FastClickChecker() {\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {\n            viewTimeHashMap = new ArrayMap<>();\n            idTimeHashMap = new ArrayMap<Integer, Long>();\n        } else {\n            viewTimeHashMap = new HashMap<>();\n            idTimeHashMap = new HashMap<Integer, Long>();\n        }\n    }\n\n    public void ksClearCheckView(){\n        if(null!=idTimeHashMap){\n            idTimeHashMap.clear();\n            idTimeHashMap=null;\n        }\n        if (null!=viewTimeHashMap){\n            viewTimeHashMap.clear();\n            viewTimeHashMap=null;\n        }\n    }\n\n    private int timeSpan = 1000;\n\n    //设置需要监听的id\n    public void setView(int... viewIds) {\n        for (int id : viewIds) {\n            idTimeHashMap.put(id, 0L);\n        }\n    }\n\n    //设置需要监听的view\n    public void setView(View... views) {\n        for (View v : views) {\n            viewTimeHashMap.put(v, 0L);\n        }\n    }\n\n    //检查是否是快速点击\n    public boolean isFastClick(View view) {\n        if (viewTimeHashMap.containsKey(view)) {\n            Long lastClickTime = viewTimeHashMap.get(view);\n            long time = System.currentTimeMillis();\n            long span = time - lastClickTime;\n            if (0 < span && span < timeSpan) {\n                return true;\n            }\n            viewTimeHashMap.put(view, time);\n        }\n        return false;\n    }\n\n    /**\n     * 检查是否是快速点击\n     */\n    public boolean isFastClick(int viewId) {\n        if (idTimeHashMap.containsKey(viewId)) {\n            Long lastClickTime = idTimeHashMap.get(viewId);\n            long time = System.currentTimeMillis();\n            long span = time - lastClickTime;\n            if (0 < span && span < timeSpan) {\n                return true;\n            }\n            idTimeHashMap.put(viewId, time);\n        }\n        return false;\n    }\n\n    /**\n     * 设置认定为快速点击的时间间隔\n     */\n    public void setTimeSpan(int span) {\n        this.timeSpan = span;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @author yangjilai\n * @function dp->px px->dp sp->px ps->sp 像素转换工具类\n */\npublic class DpUtils {\n\n    private DpUtils() {\n        /* cannot be instantiated */\n        throw new UnsupportedOperationException(\"cannot be instantiated\");\n    }\n\n    /**\n     * dp转px\n     *\n     * @param dpVal\n     * @return\n     */\n    public static int dp2px( float dpVal) {\n        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,\n                dpVal, KsUtils.getContext().getResources().getDisplayMetrics());\n    }\n\n    /**\n     * sp转px\n     *\n     * @param spVal\n     * @return\n     */\n    public static int sp2px( float spVal) {\n        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,\n                spVal, KsUtils.getContext().getResources().getDisplayMetrics());\n    }\n\n    /**\n     * px转dp\n     *\n     * @param pxVal\n     * @return\n     */\n    public static float px2dp( float pxVal) {\n        final float scale = KsUtils.getContext().getResources().getDisplayMetrics().density;\n        return (pxVal / scale);\n    }\n\n    /**\n     * px转sp\n     *\n     * @param pxVal\n     * @return\n     */\n    public static float px2sp( float pxVal) {\n        return (pxVal / KsUtils.getContext().getResources().getDisplayMetrics().scaledDensity);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobject AppUtil {\n\n    private val TAG = \"AppUtil\"\n    /**\n     * @return 版本名字 ，默认\"\"\n     */\n    @JvmStatic\n    fun getVersionName(): String? =\n            KsUtils.getContext()?.run {\n                return try {\n                    packageManager?.getPackageInfo(packageName, 0)?.versionName\n                } catch (var4: PackageManager.NameNotFoundException) {\n                    var4.printStackTrace()\n                    \"\"\n                }\n\n            }\n\n    /**\n     * @return\n     * 版本号 , 错误：-1\n     */\n    @JvmStatic\n    fun getVersionCode(): Int? =\n            KsUtils.getContext()?.run {\n\n                return try {\n                    packageManager?.getPackageInfo(packageName, 0)?.versionCode\n                } catch (var3: Exception) {\n                    LogUtils.e(var3.toString())\n                    -1\n                }\n            }\n\n    /**\n     * 拿到 指定路径apk 包名\n     * @return apk包名\n     */\n    @JvmStatic\n    fun getAPKPackageName(archiveFilePath: String): String? = KsUtils.getContext()?.run {\n        return try{\n            packageManager?.getPackageArchiveInfo(archiveFilePath, 1)?.packageName\n        }catch(ex:Exception){\n            \"\"\n        }\n    }\n\n    /**\n     * 判断应用是否在前台\n     *\n     * @return true 是前台  ，false后台\n     */\n    @JvmStatic\n    fun isForeground(context: Context): Boolean {\n        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager?\n        if (activityManager != null) {\n            val appProcesses = activityManager.runningAppProcesses\n            for (appProcess in appProcesses) {\n                /* BACKGROUND=400 EMPTY=500 FOREGROUND=100 GONE=1000 PERCEPTIBLE=130 SERVICE=300 ISIBLE=200 */\n                if (appProcess.processName == context.getPackageName()) {\n                    return appProcess.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND\n                }\n            }\n        }\n\n        return false\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class HandlerManager {\n    private static HandlerManager manager;\n    public static HandlerManager getInstance() {\n        if (manager == null) {\n            synchronized (HandlerManager.class) {\n                if (manager == null)\n                    manager = new HandlerManager();\n            }\n        }\n        return manager;\n    }\n\n    private Handler mainHandle,\n    //子线程Handler\n    synHandler;\n\n    private HandlerManager() {\n        mainHandle = new Handler(Looper.getMainLooper());\n    }\n\n    private volatile HandlerThread synThread;\n\n    private void initSynThread() {\n            synchronized (HandlerManager.class) {\n                if (synThread == null || !synThread.isAlive()) {\n                    synThread = new HandlerThread(\"syn_handler_thread\");\n                    synThread.start();\n                    synHandler = new Handler(synThread.getLooper());\n                }\n            }\n    }\n\n    /**\n     * 获取异步 Looper\n     * @return\n     */\n    public Looper getSynLooper() {\n        if (synThread == null || !synThread.isAlive()) {\n            initSynThread();\n            return synThread.getLooper();\n        } else {\n            return synThread.getLooper();\n        }\n    }\n\n    /**\n     * 获取主线程Handler\n     * @return\n     */\n    public Handler getMainHandler() {\n        return mainHandle;\n    }\n\n    /**\n     * 获取异步线程Handler\n     * @return\n     */\n    public Handler getSynHandler() {\n        checkSynThread();\n        return synHandler;\n    }\n\n    /**\n     * 移除主线程Handler任务\n     * @param runnable\n     */\n    public void removeUiTask(Runnable runnable) {\n        mainHandle.removeCallbacks(runnable);\n    }\n\n    /**\n     * 在主线程执行任务\n     * @param runnable\n     */\n    public void runOnUi(Runnable runnable) {\n        mainHandle.post(runnable);\n    }\n\n    /**\n     * 异步线程执行任务\n     * @param runnable\n     */\n    public void runOnSyn(Runnable runnable) {\n        checkSynThread();\n        synHandler.post(runnable);\n    }\n\n    /**\n     * 指定某个时间执行任务\n     * @param runnable\n     * @param time 执行任务时间点\n     */\n    public void runOnSynAtTime(Runnable runnable,long time) {\n        checkSynThread();\n        synHandler.postAtTime(runnable,time);\n    }\n\n    /**\n     * 指定某个时间执行任务\n     * @param runnable\n     * @param token\n     * @param time\n     */\n    public void runOnSynAtTime(Runnable runnable,Object token , long time){\n        checkSynThread();\n        synHandler.postAtTime(runnable,token,time);\n    }\n\n    /**\n     * 执行主线程延时任务 （注意此方法 导致的内存泄露问题）\n     * @param r\n     * @param time\n     */\n    public void runOnUiDelay(Runnable r, long time) {\n        mainHandle.postDelayed(r, time);\n    }\n\n\n    private void checkSynThread() {\n        if (synThread == null || !synThread.isAlive()) {\n            initSynThread();\n        }\n    }\n\n    /**\n     * 异步Handler中是否有消息\n     * @param what\n     * @return\n     */\n    public boolean hasSynMessage(int what){\n        if(synHandler  != null){\n            return synHandler.hasMessages(what);\n        }\n        return false;\n    }\n\n    /**\n     * 任务放置最前面执行\n     * @param runnable\n     */\n    public void runSynFront(Runnable runnable) {\n        checkSynThread();\n        synHandler.postAtFrontOfQueue(runnable);\n    }\n\n    /**\n     * 消息提前执行\n     * @param msg\n     */\n    public void sendSynFront(Message msg){\n        checkSynThread();\n        synHandler.sendMessageAtFrontOfQueue(msg);\n    }\n\n    /**\n     * 销毁异步线程\n     */\n    public void destory() {\n        mainHandle.removeCallbacksAndMessages(null);\n        if (synHandler != null)\n            synHandler.removeCallbacksAndMessages(null);\n\n        synchronized (HandlerManager.class) {\n            if (synThread != null && synThread.isAlive()) {\n                synThread.quit();\n\n            }\n        }\n        synThread = null;\n        synHandler = null;\n        mainHandle = null;\n        manager = null;\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @date 创建时间：2019-10-31\n * @auther yangjilai\n * @Description 监测耗时工具类\n */\npublic class TraceUtils {\n\n    public static final int SDK_INT = Build.VERSION.SDK_INT;\n\n    private TraceUtils() {\n    }\n\n    public static void beginSection(String sectionName) {\n        if (SDK_INT >= 18) {\n            beginSectionV18(sectionName);\n        }\n    }\n\n    public static void endSection() {\n        if (SDK_INT >= 18) {\n            endSectionV18();\n        }\n    }\n\n    @TargetApi(18)\n    private static void beginSectionV18(String sectionName) {\n        android.os.Trace.beginSection(sectionName);\n    }\n\n    @TargetApi(18)\n    private static void endSectionV18() {\n        android.os.Trace.endSection();\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @date 创建时间：2020-01-10\n * @auther cangming\n * @Description\n */\nclass Utils {\n\n    /**\n     * Return the application's height of screen, in pixel.\n     *\n     * @return the application's height of screen, in pixel\n     */\n    public static int getAppScreenHeight(Activity activity) {\n        WindowManager wm = (WindowManager) activity.getSystemService(Context.WINDOW_SERVICE);\n        if (wm == null) return -1;\n        Point point = new Point();\n        wm.getDefaultDisplay().getSize(point);\n        return point.y;\n    }\n\n\n    /**\n     * Hide the soft input.\n     *\n     * @param activity The activity.\n     */\n    public static void hideSoftInput(final Activity activity) {\n        View view = activity.getCurrentFocus();\n        if (view == null) {\n            view = new View(activity);\n        }\n        hideSoftInput(view, activity);\n    }\n\n    /**\n     * Hide the soft input.\n     *\n     * @param view The view.\n     */\n     static void hideSoftInput(final View view, final Activity activity) {\n        InputMethodManager imm =\n                (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n        if (imm == null) return;\n        imm.hideSoftInputFromWindow(view.getWindowToken(), 0, new ResultReceiver(new Handler()) {\n            @Override\n            protected void onReceiveResult(int resultCode, Bundle resultData) {\n                if (resultCode == InputMethodManager.RESULT_UNCHANGED_SHOWN\n                        || resultCode == InputMethodManager.RESULT_SHOWN) {\n                    toggleSoftInput(activity);\n                }\n            }\n        });\n    }\n\n    /**\n     * Toggle the soft input display or not.\n     */\n     static void toggleSoftInput(final Activity activity) {\n        InputMethodManager imm =\n                (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n        //noinspection ConstantConditions\n        imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Github https://github.com/siebeprojects/samples-keyboardheight\n * The keyboard height provider, this class uses a PopupWindow\n * to calculate the window height when the floating keyboard is opened and closed.\n */\npublic class KeyboardHeightProvider extends PopupWindow {\n\n    /**\n     * The tag for logging purposes\n     */\n    private final static String TAG = \"sample_KeyboardHeightProvider\";\n\n    /**\n     * The keyboard height observer\n     */\n    private KeyboardHeightObserver observer;\n\n    /**\n     * The cached landscape height of the keyboard\n     */\n    private int keyboardLandscapeHeight;\n\n    /**\n     * The cached portrait height of the keyboard\n     */\n    private int keyboardPortraitHeight;\n\n    /**\n     * The view that is used to calculate the keyboard height\n     */\n    private View popupView;\n\n    /**\n     * The parent view\n     */\n    private View parentView;\n\n    /**\n     * The root activity that uses this KeyboardHeightProvider\n     */\n    private Activity activity;\n\n\n    private int lasTimekeyboardHeight = 0;\n\n    /**\n     * Construct a new KeyboardHeightProvider\n     *\n     * @param activity The parent activity\n     */\n    public KeyboardHeightProvider(Activity activity) {\n        super(activity);\n        this.activity = activity;\n\n        LayoutInflater inflator = (LayoutInflater) activity.getSystemService(Activity.LAYOUT_INFLATER_SERVICE);\n        this.popupView = inflator.inflate(R.layout.popupwindow, null, false);\n        setContentView(popupView);\n\n        setSoftInputMode(LayoutParams.SOFT_INPUT_ADJUST_RESIZE | LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);\n        setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);\n\n        parentView = activity.findViewById(android.R.id.content);\n        setWidth(0);//  这样既能测量高度，又不会导致界面不能点击\n//        setWidth(LayoutParams.MATCH_PARENT);\n        setHeight(LayoutParams.MATCH_PARENT);\n\n        popupView.getViewTreeObserver().addOnGlobalLayoutListener(mOnGlobalLayoutListener);\n    }\n\n    OnGlobalLayoutListener mOnGlobalLayoutListener = new OnGlobalLayoutListener() {\n\n        @Override\n        public void onGlobalLayout() {\n            if (popupView != null) {\n                handleOnGlobalLayout();\n            }\n        }\n    };\n\n    /**\n     * Start the KeyboardHeightProvider, this must be called after the onResume of the Activity.\n     * PopupWindows are not allowed to be registered before the onResume has finished\n     * of the Activity.\n     */\n    public void start() {\n\n        if (!isShowing() && parentView.getWindowToken() != null) {\n            setBackgroundDrawable(new ColorDrawable(0));\n            showAtLocation(parentView, Gravity.NO_GRAVITY, 0, 0);\n        }\n    }\n\n    /**\n     * Close the keyboard height provider,\n     * this provider will not be used anymore.\n     */\n    public void close() {\n        this.observer = null;\n        dismiss();\n    }\n\n    /**\n     * Set the keyboard height observer to this provider. The\n     * observer will be notified when the keyboard height has changed.\n     * For example when the keyboard is opened or closed.\n     *\n     * @param observer The observer to be added to this provider.\n     */\n    public void setKeyboardHeightObserver(KeyboardHeightObserver observer) {\n        this.observer = observer;\n    }\n\n    /**\n     * Get the screen orientation\n     *\n     * @return the screen orientation\n     */\n    private int getScreenOrientation() {\n        return activity.getResources().getConfiguration().orientation;\n    }\n\n    /**\n     * Popup window itself is as big as the window of the Activity.\n     * The keyboard can then be calculated by extracting the popup view bottom\n     * from the activity window height.\n     */\n    private void handleOnGlobalLayout() {\n\n        Point screenSize = new Point();\n        activity.getWindowManager().getDefaultDisplay().getSize(screenSize);\n\n        Rect rect = new Rect();\n        popupView.getWindowVisibleDisplayFrame(rect);\n\n        // REMIND, you may like to change this using the fullscreen size of the phone\n        // and also using the status bar and navigation bar heights of the phone to calculate\n        // the keyboard height. But this worked fine on a Nexus.\n        int orientation = getScreenOrientation();\n        int keyboardHeight = screenSize.y - rect.bottom;\n\n        if (lasTimekeyboardHeight == keyboardHeight) {\n            return;\n        } else {\n            lasTimekeyboardHeight = keyboardHeight;\n        }\n\n        if (keyboardHeight == 0) {\n            notifyKeyboardHeightChanged(0, orientation);\n        } else if (orientation == Configuration.ORIENTATION_PORTRAIT) {\n            this.keyboardPortraitHeight = keyboardHeight;\n            notifyKeyboardHeightChanged(keyboardPortraitHeight, orientation);\n        } else {\n            this.keyboardLandscapeHeight = keyboardHeight;\n            notifyKeyboardHeightChanged(keyboardLandscapeHeight, orientation);\n        }\n    }\n\n    /**\n     *\n     */\n    private void notifyKeyboardHeightChanged(int height, int orientation) {\n        if (observer != null) {\n            observer.onKeyboardHeightChanged(height, orientation);\n        }\n    }\n\n    public void recycle() {\n        dismiss();\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n            popupView.getViewTreeObserver().removeOnGlobalLayoutListener(mOnGlobalLayoutListener);\n        }\n        observer = null;\n        activity = null;\n        parentView = null;\n        popupView = null;\n    }\n\n}\n\n\n\npublic interface KeyboardHeightObserver {\n\n    /**\n     * Called when the keyboard height has changed, 0 means keyboard is closed,\n     * >= 1 means keyboard is opened.\n     *\n     * @param height        The height of the keyboard in pixels\n     * @param orientation   The orientation either: Configuration.ORIENTATION_PORTRAIT or\n     *                      Configuration.ORIENTATION_LANDSCAPE\n     */\n    void onKeyboardHeightChanged(int height, int orientation);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @date 创建时间：2020-01-10\n * @auther cangming\n * @Description\n */\npublic class CmKeyboardUtil {\n\n    static CmKeyboardUtil cmKeyboardUtil;\n    static Activity mActivity;\n    static View mBtnView;\n    static ViewGroup rootView;\n    static boolean isMove;\n    static int marginBottom = 0;\n    static KeyboardHeightProvider keyboardHeightProvider;\n    int keyBoardHeight = 0;\n    int btnViewY = 0;\n    boolean isRegister = false;\n    AnimatorSet animSet = new AnimatorSet();\n\n    public static CmKeyboardUtil getInstance(Activity activity) {\n        if (cmKeyboardUtil == null) {\n            cmKeyboardUtil = new CmKeyboardUtil();\n        }\n\n        initData(activity);\n\n        return cmKeyboardUtil;\n    }\n\n    private static void initData(Activity activity) {\n        mActivity = activity;\n        mActivity.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING);\n        rootView = (ViewGroup) ((ViewGroup) mActivity.findViewById(android.R.id.content)).getChildAt(0);\n        isMove = false;\n        marginBottom = 0;\n        if (keyboardHeightProvider != null) {\n            keyboardHeightProvider.recycle();\n            keyboardHeightProvider = null;\n        }\n        keyboardHeightProvider = new KeyboardHeightProvider(mActivity);\n    }\n\n    public CmKeyboardUtil setBtnView(View btnView) {\n        mBtnView = btnView;\n        return cmKeyboardUtil;\n    }\n\n\n    Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            startAnim(msg.arg1);\n        }\n    };\n\n    void startAnim(int transY) {\n        float curTranslationY = rootView.getTranslationY();\n        ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(rootView, \"translationY\", curTranslationY, transY);\n        animSet.play(objectAnimator);\n        animSet.setDuration(200);\n        animSet.start();\n    }\n\n    public void register() {\n\n        isRegister = true;\n\n        keyboardHeightProvider.setKeyboardHeightObserver(new KeyboardHeightObserver() {\n            @Override\n            public void onKeyboardHeightChanged(int height, int orientation) {\n                if (orientation == Configuration.ORIENTATION_LANDSCAPE) {\n                    return;\n                }\n                if (!isRegister) {\n                    return;\n                }\n\n                if (keyBoardHeight == height) {\n                    return;\n                } else {\n                    keyBoardHeight = height;\n                }\n\n                if (keyBoardHeight <= 0) {//键盘收起\n                    if (isMove) {\n\n                        sendHandlerMsg(0);\n\n                        isMove = true;\n                    }\n                } else {//键盘打开\n\n                    int keyBorardTopY = Utils.getAppScreenHeight(mActivity) - keyBoardHeight;\n                    if (keyBorardTopY > (btnViewY + mBtnView.getHeight())) {\n                        return;\n                    }\n                    int margin = keyBorardTopY - (btnViewY + mBtnView.getHeight());\n                    Log.i(\"tag\", \"margin:\" + margin);\n                    sendHandlerMsg(margin);\n\n                    isMove = true;\n                }\n\n            }\n        });\n\n        mBtnView.post(new Runnable() {\n            @Override\n            public void run() {\n                btnViewY = getViewLocationYInScreen(mBtnView);\n                if (keyboardHeightProvider != null) {\n                    keyboardHeightProvider.start();\n                }\n            }\n        });\n\n    }\n\n    public void unRegister() {\n        isRegister = false;\n        Utils.hideSoftInput(mActivity);\n        keyBoardHeight = 0;\n        sendHandlerMsg(0);\n\n        if (keyboardHeightProvider != null) {\n            keyboardHeightProvider.setKeyboardHeightObserver(null);\n            keyboardHeightProvider.close();\n        }\n    }\n\n    public static void recycle() {\n        mActivity = null;\n        if (keyboardHeightProvider != null) {\n            keyboardHeightProvider.recycle();\n            keyboardHeightProvider = null;\n        }\n\n    }\n\n    private void sendHandlerMsg(int i) {\n        Message message = new Message();\n        message.arg1 = i;\n        mHandler.sendMessage(message);\n    }\n\n    private int getViewLocationYInScreen(View view) {\n        int[] location = new int[2];\n        view.getLocationOnScreen(location);\n        return location[1];\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * <pre>\n *    author : Senh Linsh\n *    github : https://github.com/SenhLinsh\n *    date   : 2017/11/10\n *    desc   : 工具类: IO 流对象相关\n *             API  : 关闭流对象 等\n * </pre>\n */\npublic class IOUtils {\n\n    private IOUtils() {\n    }\n\n    /**\n     * 关闭流对象\n     * <p>API 将会对流对象进行判空, 并在关闭流对象时抓捕异常, 防止崩溃</p>\n     *\n     * @param stream 流对象\n     */\n    public static void close(Closeable stream) {\n        if (stream != null) {\n            try {\n                stream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * 关闭指针\n     *\n     * @param cursor 指针对象\n     */\n    public static void close(Cursor cursor) {\n        if (cursor != null) {\n            cursor.close();\n        }\n    }\n\n    /**\n     * 关闭多个流对象\n     * <p>API 将会对流对象进行判空, 并在关闭流对象时抓捕异常, 防止崩溃</p>\n     *\n     * @param streams 多个流对象\n     */\n    public static void close(Closeable... streams) {\n        for (Closeable stream : streams) {\n            close(stream);\n        }\n    }\n\n    /**\n     * 关闭流对象, 不打印关闭时抛出的异常\n     * <p>API 将会对流对象进行判空, 并在关闭流对象时抓捕异常, 防止崩溃</p>\n     *\n     * @param stream 流对象\n     */\n    public static void closeQuietly(Closeable stream) {\n        if (stream != null) {\n            try {\n                stream.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    /**\n     * 关闭多个流对象, 不打印关闭时抛出的异常\n     * <p>API 将会对流对象进行判空, 并在关闭流对象时抓捕异常, 防止崩溃</p>\n     *\n     * @param streams 多个流对象\n     */\n    public static void closeQuietly(Closeable... streams) {\n        for (Closeable stream : streams) {\n            close(stream);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * **************************************\n * 项目名称: kaishustory\n *\n * @Author yangjilai\n * 邮箱：yangjilai@ksjgs.com\n * 创建时间: 2019-09-17     16:46\n * 用途： （1）应用程序Activity管理 （2）用于Activity管理和应用程序退出\n * **************************************\n */\npublic class ActivityStackManager {\n\n    private static Stack<String> activityNameStack;\n    private Stack<Activity> activityStack;\n    private ActivityStackManager() {\n        activityStack = new Stack<>();\n    }\n\n\n    /**\n     * 单一实例\n     */\n    public static ActivityStackManager getInstance() {\n        return Holder.INSTANCE;\n    }\n\n\n    static class Holder {\n        public static ActivityStackManager INSTANCE = new ActivityStackManager();\n    }\n\n    /**\n     * 压栈\n     * @param activity\n     */\n    public  void push(Activity activity){\n        if(activityStack==null){\n            activityStack = new Stack<>();\n        }\n        activityStack.push(activity);\n    }\n    /**\n     * 移除Activity\n     * @param activity\n     */\n    public void remove(Activity activity){\n        if(activityStack!=null){\n            activityStack.remove(activity);\n        }\n    }\n\n    /**\n     * 获取栈顶activity\n     * @return\n     */\n    public Activity getTopActivity(){\n        if(activityStack==null || activityStack.isEmpty()){\n            return null;\n        }\n        return activityStack.peek();\n    }\n\n    /**\n     * 获取所有的Activity\n     * @return\n     */\n    public Stack<Activity> getActivitys(){\n        if(activityStack==null||activityStack.isEmpty()){\n            return new Stack<>();\n        }\n        return (Stack)activityStack.clone();\n    }\n\n\n    /**\n     * 通过名字从栈中获取\n     * @param activityName\n     * @return\n     */\n    public Activity getActivityByName(String activityName){\n        if(activityName == null || activityStack==null || activityStack.isEmpty()){\n            return null;\n        }\n        for(Activity a:activityStack){\n            if(activityName.equals(a.getClass().getName())||activityName.equals(a.getClass().getSimpleName())){\n                return a;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * 通过class获取Activity\n     * @param clazz\n     * @return\n     */\n    public Activity getActivityByClass(Class clazz){\n\n        if(clazz == null || activityStack==null || activityStack.isEmpty()){\n            return null;\n        }\n        for(Activity a:activityStack){\n            if(clazz.equals(a.getClass())){\n                return a;\n            }\n        }\n        return null;\n    }\n\n\n\n\n    /**\n     * 添加Activity到堆栈\n     */\n    public void addActivity(String activityName) {\n        if (activityNameStack == null) {\n            activityNameStack = new Stack<String>();\n        }\n        activityNameStack.add(activityName);\n    }\n\n    /**\n     * 获取当前Activity（堆栈中最后三个压入的类）\n     *\n     * @return null 栈为空  activity的集合\n     */\n    public List<String> getTopThreeActivity() {\n        return getTopActivityByNumber(3);\n    }\n\n    /**\n     * 获取当前Activity（堆栈中最后 N 个压入的类）\n     *\n     * @param activityNumber 获取最近的播放器\n     * @return\n     */\n    public List<String> getTopActivityByNumber(int activityNumber) {\n        if (activityNameStack == null) {\n            return null;\n        }\n        Stack<String> tmpActivityStack = (Stack<String>) activityNameStack.clone();\n        ArrayList<String> activityList = new ArrayList<>();\n\n        while (tmpActivityStack.size() > 0) {\n            try {\n                String activity = tmpActivityStack.pop();\n                activityList.add(activity);\n                if (activityList.size() >= activityNumber) {\n                    break;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return activityList;\n    }\n\n    /**\n     * 获取当前Activity（堆栈中最后一个压入的）\n     */\n    public String currentActivity() {\n        if (activityNameStack == null || activityNameStack.size() == 0) {\n            return null;\n        }\n        return activityNameStack.peek();\n    }\n\n    /**\n     * 结束当前Activity（堆栈中最后一个压入的）\n     */\n    public void removeLatestActivity(String activityName) {\n        if (activityNameStack == null || activityNameStack.size() == 0) {\n            return;\n        }\n        try {\n            Iterator<String> iterator = activityNameStack.iterator();\n            while (iterator.hasNext()) {\n                String next = iterator.next();\n                if (next.equals(activityName)) {\n                    activityNameStack.remove(activityName);\n                    break;\n                }\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public int getSize() {\n        if (activityNameStack == null) {\n            return -1;\n        }\n        return activityNameStack.size();\n    }\n\n    /**\n     * 获取 . 后边的名字\n     *\n     * @param activity\n     * @return\n     */\n    public static String getShortName(Activity activity) {\n        String result = \"NoneActivity\";\n        String shortClassName = activity.getComponentName().getShortClassName();\n        if (shortClassName.contains(\".\")) {\n            try {\n                result = shortClassName.substring(shortClassName.lastIndexOf('.') + 1);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return result;\n    }\n\n\n\n\n    /**\n     * 已启动的activity 是否包含某个activity\n     *\n     * @param activity\n     * @return\n     */\n    public static boolean isActivityStackExistActivity(Context context, Class<?> activity) {\n        Intent intent = new Intent(context, activity);\n        ComponentName cmpName = intent.resolveActivity(context.getPackageManager());\n        boolean flag = false;\n        if (cmpName != null) {\n            android.app.ActivityManager am = (android.app.ActivityManager) context.getSystemService(ACTIVITY_SERVICE);\n            List<android.app.ActivityManager.RunningTaskInfo> taskInfoList = am.getRunningTasks(10);//获取从栈顶开始往下查找的10个activity\n            if(taskInfoList!=null) {\n                for (android.app.ActivityManager.RunningTaskInfo taskInfo : taskInfoList) {\n                    if (taskInfo.baseActivity.equals(cmpName)) {\n                        flag = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return flag;\n    }\n\n    /**\n     *\n     * 关闭所有\n     *\n     */\n    public synchronized  void finishAll(){\n        if(activityStack!=null){\n            while (!activityStack.isEmpty()){\n                activityStack.pop().finish();\n            }\n        }\n\n    }\n}\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1598515785307},"updatedAt":{"$$date":1598518112054},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"zzdDd4XVKeo79lAd"}
{"name":"mac 杀掉占用某个端口的进程/Linux 查看某个端口的进程","folderId":"6eW4X4NDu","content":[{"label":"Fragment 1","language":"text","value":"mac OS：\n\n两个小命令:\n\nlsof -i :端口\nkill -9 进程ID\n\nlinux ：\n\n查看端口：\n\n\nnetstat -an | grep 23"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1599053365659},"updatedAt":{"$$date":1599053392214},"_id":"mATYTqfTuO0QICW6","folder":{"id":"6eW4X4NDu","name":"jiqiao","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}

{"name":"kotlin-kotlin 委托 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-delegated.html\nkotlin 委托 | 菜鸟教程\n7-8 minutes\n委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。\n\nKotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。\n\n类委托\n类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。\n\n以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。\n\n// 创建接口\ninterface Base {   \n    fun print()\n}\n\n// 实现此接口的被委托的类\nclass BaseImpl(val x: Int) : Base {\n    override fun print() { print(x) }\n}\n\n// 通过关键字 by 建立委托类\nclass Derived(b: Base) : Base by b\n\nfun main(args: Array<String>) {\n    val b = BaseImpl(10)\n    Derived(b).print() // 输出 10\n}\n在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。\n\n属性委托\n属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。\n\n属性委托语法格式：\n\nval/var <属性名>: <类型> by <表达式>\nvar/val：属性类型(可变/只读)\n属性名：属性名称\n类型：属性的数据类型\n表达式：委托代理类\nby 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。\n\n定义一个被委托的类\n该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，prop 为进行委托的属性的对象。\n\nimport kotlin.reflect.KProperty\n// 定义包含属性委托的类\nclass Example {\n    var p: String by Delegate()\n}\n\n// 委托的类\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, 这里委托了 ${property.name} 属性\"\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$thisRef 的 ${property.name} 属性赋值为 $value\")\n    }\n}\nfun main(args: Array<String>) {\n    val e = Example()\n    println(e.p)     // 访问该属性，调用 getValue() 函数\n\n    e.p = \"Runoob\"   // 调用 setValue() 函数\n    println(e.p)\n}\n输出结果为：\n\nExample@433c675d, 这里委托了 p 属性\nExample@433c675d 的 p 属性赋值为 Runoob\nExample@433c675d, 这里委托了 p 属性\n标准委托\nKotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。\n\n延迟属性 Lazy\nlazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy <T> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。\n\nval lazyValue: String by lazy {\n    println(\"computed!\")     // 第一次调用输出，第二次调用不执行\n    \"Hello\"\n}\n\nfun main(args: Array<String>) {\n    println(lazyValue)   // 第一次执行，执行两次输出表达式\n    println(lazyValue)   // 第二次执行，只输出返回值\n}\n执行输出结果：\n\ncomputed!\nHello\nHello\n可观察属性 Observable\nobservable 可以用于实现观察者模式。\n\nDelegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。\n\n在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值：\n\nimport kotlin.properties.Delegates\n\nclass User {\n    var name: String by Delegates.observable(\"初始值\") {\n        prop, old, new ->\n        println(\"旧值：$old -> 新值：$new\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val user = User()\n    user.name = \"第一次赋值\"\n    user.name = \"第二次赋值\"\n}\n执行输出结果：\n\n旧值：初始值 -> 新值：第一次赋值\n旧值：第一次赋值 -> 新值：第二次赋值\n把属性储存在映射中\n一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他\"动态\"事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。\n\nclass Site(val map: Map<String, Any?>) {\n    val name: String by map\n    val url: String  by map\n}\n\nfun main(args: Array<String>) {\n    // 构造函数接受一个映射参数\n    val site = Site(mapOf(\n        \"name\" to \"菜鸟教程\",\n        \"url\"  to \"www.runoob.com\"\n    ))\n    \n    // 读取映射值\n    println(site.name)\n    println(site.url)\n}\n执行输出结果：\n\n菜鸟教程\nwww.runoob.com\n如果使用 var 属性，需要把 Map 换成 MutableMap：\n\nclass Site(val map: MutableMap<String, Any?>) {\n    val name: String by map\n    val url: String by map\n}\n\nfun main(args: Array<String>) {\n\n    var map:MutableMap<String, Any?> = mutableMapOf(\n            \"name\" to \"菜鸟教程\",\n            \"url\" to \"www.runoob.com\"\n    )\n\n    val site = Site(map)\n\n    println(site.name)\n    println(site.url)\n\n    println(\"--------------\")\n    map.put(\"name\", \"Google\")\n    map.put(\"url\", \"www.google.com\")\n\n    println(site.name)\n    println(site.url)\n\n}\n执行输出结果：\n\n菜鸟教程\nwww.runoob.com\n--------------\nGoogle\nwww.google.com\nNot Null\nnotNull 适用于那些无法在初始化阶段就确定属性值的场合。\n\nclass Foo {\n    var notNullBar: String by Delegates.notNull<String>()\n}\n\nfoo.notNullBar = \"bar\"\nprintln(foo.notNullBar)\n需要注意，如果属性在赋值前就被访问的话则会抛出异常。\n\n局部委托属性\n你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：\n\nfun example(computeFoo: () -> Foo) {\n    val memoizedFoo by lazy(computeFoo)\n\n    if (someCondition && memoizedFoo.isValid()) {\n        memoizedFoo.doSomething()\n    }\n}\nmemoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。\n\n属性委托要求\n对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数：\n\nthisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型\nproperty —— 必须是类型 KProperty<*> 或其超类型\n这个函数必须返回与属性相同的类型（或其子类型）。\n\n对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数:\n\nproperty —— 必须是类型 KProperty<*> 或其超类型\nnew value —— 必须和属性同类型或者是它的超类型。\n翻译规则\n在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性：\n\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// 这段是由编译器生成的相应代码：\nclass C {\n    private val prop$delegate = MyDelegate()\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\nKotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。\n\n提供委托\n通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。\n\nprovideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。\n\n例如，如果要在绑定之前检查属性名称，可以这样写：\n\nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(\n            thisRef: MyUI,\n            prop: KProperty<*>\n    ): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        // 创建委托\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { …… }\n}\n\nfun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { …… }\n\nclass MyUI {\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\nprovideDelegate 的参数与 getValue 相同：\n\nthisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型\nproperty —— 必须是类型 KProperty<*> 或其超类型。\n在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。\n\n如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：\n\n// 检查属性名称而不使用“provideDelegate”功能\nclass MyUI {\n    val image by bindResource(ResourceID.image_id, \"image\")\n    val text by bindResource(ResourceID.text_id, \"text\")\n}\n\nfun <T> MyUI.bindResource(\n        id: ResourceID<T>,\n        propertyName: String\n): ReadOnlyProperty<MyUI, T> {\n   checkProperty(this, propertyName)\n   // 创建委托\n}\n在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：\n\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// 这段代码是当“provideDelegate”功能可用时\n// 由编译器生成的代码：\nclass C {\n    // 调用“provideDelegate”来创建额外的“delegate”属性\n    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)\n    val prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n}\n请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304152917},"updatedAt":{"$$date":1597305135650},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0SBq9za4zC6ZmCKB"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977488664},"updatedAt":{"$$date":1594977488664},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"1Dr1XzINvSxOuA6u"}
{"name":"ad- View.post()","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n更新 UI 操作\n\n获取 View 的实际宽高\n\n\n\n在 Activity 中，View 绘制流程的开始时机是在 ActivityThread 的 handleResumeActivity 方法，\n在该方法首先完成 Activity 生命周期 onResume 方法回调，然后开始 View 绘制任务。\n\n\n\n\n\n\n\n\n\n注意这里不考虑使用 ViewTreeObserver 或更长延迟的 postDelayed()。\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594980139005},"updatedAt":{"$$date":1594980202597},"_id":"1a1lrWW2FLFJKnPY","folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241223941},"updatedAt":{"$$date":1597241223941},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"1yqbZQiCzl7mkFgZ"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241210789},"updatedAt":{"$$date":1597241210789},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2Ld6PvrG6BGuinmT"}
{"name":"kotlin-构造集合 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/constructing-collections.html\n构造集合 - Kotlin 语言中文站\n11-14 minutes\n改进翻译\n创建集合的最常用方法是使用标准库函数 listOf<T>()、setOf<T>()、mutableListOf<T>()、mutableSetOf<T>()。 如果以逗号分隔的集合元素列表作为参数，编译器会自动检测元素类型。创建空集合时，须明确指定类型。\n\n同样的，Map 也有这样的函数 mapOf() 与 mutableMapOf()。映射的键和值作为 Pair 对象传递（通常使用中缀函数 to 创建）。\n\nval numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n注意，to 符号创建了一个短时存活的 Pair 对象，因此建议仅在性能不重要时才使用它。 为避免过多的内存使用，请使用其他方法。例如，可以创建可写 Map 并使用写入操作填充它。 apply() 函数可以帮助保持初始化流畅。\n\nval numbersMap = mutableMapOf<String, String>().apply { this[\"one\"] = \"1\"; this[\"two\"] = \"2\" }\n还有用于创建没有任何元素的集合的函数：emptyList()、emptySet() 与 emptyMap()。 创建空集合时，应指定集合将包含的元素类型。\n\nval empty = emptyList<String>()\n对于 List，有一个接受 List 的大小与初始化函数的构造函数，该初始化函数根据索引定义元素的值。\n\nfun main() {\n//sampleStart\n    val doubled = List(3, { it * 2 })  // 如果你想操作这个集合，应使用 MutableList\n    println(doubled)\n//sampleEnd\n}\n要创建具体类型的集合，例如 ArrayList 或 LinkedList，可以使用这些类型的构造函数。 类似的构造函数对于 Set 与 Map 的各实现中均有提供。\n\nval linkedList = LinkedList<String>(listOf(\"one\", \"two\", \"three\"))\nval presizedSet = HashSet<Int>(32)\n要创建与现有集合具有相同元素的集合，可以使用复制操作。标准库中的集合复制操作创建了具有相同元素引用的 浅 复制集合。 因此，对集合元素所做的更改会反映在其所有副本中。\n\n在特定时刻通过集合复制函数，例如toList()、toMutableList()、toSet() 等等。创建了集合的快照。 结果是创建了一个具有相同元素的新集合 如果在源集合中添加或删除元素，则不会影响副本。副本也可以独立于源集合进行更改。\n\nfun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val copyList = sourceList.toMutableList()\n    val readOnlyCopyList = sourceList.toList()\n    sourceList.add(4)\n    println(\"Copy size: ${copyList.size}\")   \n    \n    //readOnlyCopyList.add(4)             // 编译异常\n    println(\"Read-only copy size: ${readOnlyCopyList.size}\")\n//sampleEnd\n}\n这些函数还可用于将集合转换为其他类型，例如根据 List 构建 Set，反之亦然。\n\nfun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)    \n    val copySet = sourceList.toMutableSet()\n    copySet.add(3)\n    copySet.add(4)    \n    println(copySet)\n//sampleEnd\n}\n或者，可以创建对同一集合实例的新引用。使用现有集合初始化集合变量时，将创建新引用。 因此，当通过引用更改集合实例时，更改将反映在其所有引用中。\n\nfun main() {\n//sampleStart\n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList = sourceList\n    referenceList.add(4)\n    println(\"Source size: ${sourceList.size}\")\n//sampleEnd\n}\n集合的初始化可用于限制其可变性。例如，如果构建了一个 MutableList 的 List 引用，当你试图通过此引用修改集合的时候，编译器会抛出错误。\n\nfun main() {\n//sampleStart \n    val sourceList = mutableListOf(1, 2, 3)\n    val referenceList: List<Int> = sourceList\n    //referenceList.add(4)            // 编译错误\n    sourceList.add(4)\n    println(referenceList) // 显示 sourceList 当前状态\n//sampleEnd\n}\n可以通过其他集合各种操作的结果来创建集合。例如，过滤列表会创建与过滤器匹配的新元素列表：\n\nfun main() {\n//sampleStart \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n//sampleEnd\n}\n映射生成转换结果列表：\n\nfun main() {\n//sampleStart \n    val numbers = setOf(1, 2, 3)\n    println(numbers.map { it * 3 })\n    println(numbers.mapIndexed { idx, value -> value * idx })\n//sampleEnd\n}\n关联生成 Map:\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n有关 Kotlin 中集合操作的更多信息，参见集合操作概述."}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308429761},"updatedAt":{"$$date":1597313895931},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"2d5vRVNfdNs5MyyU"}
{"name":"py-数据类型检查可以用内置函数isinstance()实现：","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：\n\ndef my_abs(x):\n    if not isinstance(x, (int, float)):\n        raise TypeError('bad operand type')\n    if x >= 0:\n        return x\n    else:\n        return -x\n添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：\n\n>>> my_abs('A')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 3, in my_abs\nTypeError: bad operand type\n错误和异常处理将在后续讲到。\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973948153},"updatedAt":{"$$date":1594977429216},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"30Dx01Ahdu4KWYBs"}
{"name":"Untitled snippet","folderId":null,"content":[{"label":"Fragment 1","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594709014765},"updatedAt":{"$$date":1594709014765},"_id":"3BzA1TGqEP2PBtcZ"}
{"name":"Map 集合的默认值","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"dart","value":"val map = mapOf(\n        \"java\" to 1,\n        \"kotlin\" to 2,\n        \"python\" to 3\n).withDefault { \"?\" }\n\nprintln(map.getValue(\"java\")) // 1\nprintln(map.getValue(\"kotlin\")) // 2\nprintln(map.getValue(\"c++\")) // ?\n\n作者：HiDhl\n链接：https://juejin.im/post/5edfd7c9e51d45789a7f206d\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}],"tags":["aZ7LswF9qbcVtQZT"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594728228648},"updatedAt":{"$$date":1594728387772},"_id":"3xW0ORj8fA0dYEDm","folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"kotlin","_id":"aZ7LswF9qbcVtQZT","text":"kotlin"}]}
{"name":"py-默认参数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：\n\n>>> power(5)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: power() missing 1 required positional argument: 'n'\nPython的错误信息很明确：调用函数power()缺少了一个位置参数n。\n\n这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：\n\ndef power(x, n=2):\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n这样，当我们调用power(5)时，相当于调用power(5, 2)：\n\n>>> power(5)\n25\n>>> power(5, 2)\n25\n而对于n > 2的其他情况，就必须明确地传入n，比如power(5, 3)。\n\n从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：\n\n一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；\n\n二是如何设置默认参数。\n\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n\n使用默认参数有什么好处？最大的好处是能降低调用函数的难度。\n\n举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：\n\ndef enroll(name, gender):\n    print('name:', name)\n    print('gender:', gender)\n这样，调用enroll()函数只需要传入两个参数：\n\n>>> enroll('Sarah', 'F')\nname: Sarah\ngender: F\n如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。\n\n我们可以把年龄和城市设为默认参数：\n\ndef enroll(name, gender, age=6, city='Beijing'):\n    print('name:', name)\n    print('gender:', gender)\n    print('age:', age)\n    print('city:', city)\n这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：\n\n>>> enroll('Sarah', 'F')\nname: Sarah\ngender: F\nage: 6\ncity: Beijing\n只有与默认参数不符的学生才需要提供额外的信息：\n\nenroll('Bob', 'M', 7)\nenroll('Adam', 'M', city='Tianjin')\n可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。\n\n有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。\n\n也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。\n\n默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：\n\n先定义一个函数，传入一个list，添加一个END再返回：\n\ndef add_end(L=[]):\n    L.append('END')\n    return L\n当你正常调用时，结果似乎不错：\n\n>>> add_end([1, 2, 3])\n[1, 2, 3, 'END']\n>>> add_end(['x', 'y', 'z'])\n['x', 'y', 'z', 'END']\n当你使用默认参数调用时，一开始结果也是对的：\n\n>>> add_end()\n['END']\n但是，再次调用add_end()时，结果就不对了：\n\n>>> add_end()\n['END', 'END']\n>>> add_end()\n['END', 'END', 'END']\n很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。\n\n原因解释如下：\n\nPython函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。\n\n 定义默认参数要牢记一点：默认参数必须指向不变对象！\n要修改上面的例子，我们可以用None这个不变对象来实现：\n\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n现在，无论调用多少次，都不会有问题：\n\n>>> add_end()\n['END']\n>>> add_end()\n['END']\n为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973950809},"updatedAt":{"$$date":1594977537350},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"58crdKwfbpxQQPeD"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977493221},"updatedAt":{"$$date":1594977493221},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5BMyTbMqsTXyvdAl"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973274642},"updatedAt":{"$$date":1594973274642},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5C70cNT3wii5VvPv"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973280314},"updatedAt":{"$$date":1594973280314},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5EWJzywYU0NXERDq"}
{"name":"kotlin-使用 Kotlin 进行 Android 开发","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"www.kotlincn.net /docs/reference/android-overview.html\nKotlin 用于 Android 开发 - Kotlin 语言中文站\n4-4 minutes\n改进翻译\n自 2019 年 Google I/O 以来，Kotlin 就成为了 Android 移动开发的首选。\n\n使用 Kotlin 进行 Android 开发，可以受益于：\n\n代码更少、可读性更强。花更少的时间来编写代码与理解他人的代码。\n成熟的语言与环境。自 2011 年创建以来，Kotlin 不仅通过语言而且通过强大的工具在整个生态系统中不断发展。 现在，它已无缝集成到 Android Studio 中， 并被许多公司积极用于开发 Android 应用程序。\nAndroid Jetpack 与其他库中的 Kotlin 支持。KTX 扩展 为现有的 Android 库添加了 Kotlin 语言特性，如协程、扩展函数、lambdas 与命名参数。\n与 Java 的互操作性。可以在应用程序中将 Kotlin 与 Java 编程语言一起使用， 而无需将所有代码迁移到 Kotlin。\n支持多平台开发。不仅可以使用 Kotlin 开发 Android，还可以开发 iOS、后端与 Web 应用程序。 享受在平台之间共享公共代码的好处。\n代码安全。更少的代码与更好的可读性导致更少的错误。Kotlin 编译器检测这些剩余的错误，从而使代码安全。\n易学易用。Kotlin 非常易于学习，尤其是对于 Java 开发人员而言。\n大社区。Kotlin 得到了社区的大力支持与许多贡献，该社区在全世界范围内都在增长。 根据 Google 的说法，Play 商店前 1000 个应用中有 60％ 以上使用 Kotlin。\n许多初创公司与财富 500 强公司已经使用 Kotlin 开发了 Android 应用程序——详情请见面向 Kotlin 开发者的谷歌网站。\n\n如果想开始使用 Kotlin 进行 Android 开发，请参阅在 Android 开发中开始使用 Kotlin。\n\n如果是 Android 的新手，并且想学习使用 Kotlin 创建应用程序，请查看这门 Udacity 课程。\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304156407},"updatedAt":{"$$date":1597305702236},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"5GQuwtnCFQFHlbnw"}
{"name":"java-使用StampedLock","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"前面介绍的ReadWriteLock可以解决多线程同时读，但只有一个线程能写的问题。\n\n如果我们深入分析ReadWriteLock，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。\n\n要进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。\n\nStampedLock和ReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。\n\n乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。\n\n我们来看例子：\n\npublic class Point {\n    private final StampedLock stampedLock = new StampedLock();\n\n    private double x;\n    private double y;\n\n    public void move(double deltaX, double deltaY) {\n        long stamp = stampedLock.writeLock(); // 获取写锁\n        try {\n            x += deltaX;\n            y += deltaY;\n        } finally {\n            stampedLock.unlockWrite(stamp); // 释放写锁\n        }\n    }\n\n    public double distanceFromOrigin() {\n        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁\n        // 注意下面两行代码不是原子操作\n        // 假设x,y = (100,200)\n        double currentX = x;\n        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)\n        double currentY = y;\n        // 此处已读取到y，如果没有写入，读取是正确的(100,200)\n        // 如果有写入，读取是错误的(100,400)\n        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生\n            stamp = stampedLock.readLock(); // 获取一个悲观读锁\n            try {\n                currentX = x;\n                currentY = y;\n            } finally {\n                stampedLock.unlockRead(stamp); // 释放悲观读锁\n            }\n        }\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}\n和ReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过tryOptimisticRead()获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过validate()去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。\n\n可见，StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。\n\nStampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。\n\n小结\nStampedLock提供了乐观读锁，可取代ReadWriteLock以进一步提升并发性能；\n\nStampedLock是不可重入锁。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826927346},"updatedAt":{"$$date":1594967852779},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"6G7ILb19mwcKVpuR"}
{"name":"js-","folderId":"WKqaKGQVd","content":[{"label":"Fragment 1","language":"javascript","value":"\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973740085},"updatedAt":{"$$date":1594973761483},"_id":"6RF35DpChYyIO0ti","folder":{"id":"WKqaKGQVd","name":"javascript","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244757625},"updatedAt":{"$$date":1597244757625},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"6nqJ2gwgo3hlt6tI"}
{"name":"kotlin-Inline classes - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/inline-classes.html\nInline classes - Kotlin 语言中文站\n14-17 minutes\n改进翻译\n内联类仅在 Kotlin 1.3 之后版本可用，目前还是实验性的。关于详情请参见下文\n\n有时候，业务逻辑需要围绕某种类型创建包装器。然而，由于额外的堆内存分配问题，它会引入运行时的性能开销。此外，如果被包装的类型是原生类型，性能的损失是很糟糕的，因为原生类型通常在运行时就进行了大量优化，然而他们的包装器却没有得到任何特殊的处理。\n\n为了解决这类问题，Kotlin 引入了一种被称为 内联类 的特殊类，它通过在类的前面定义一个 inline 修饰符来声明：\n\n内联类必须含有唯一的一个属性在主构造函数中初始化。在运行时，将使用这个唯一属性来表示内联类的实例（关于运行时的内部表达请参阅下文）：\n\n// 不存在 'Password' 类的真实实例对象\n// 在运行时，'securePassword' 仅仅包含 'String'\nval securePassword = Password(\"Don't try this in production\") \n这就是内联类的主要特性，它灵感来源于 “inline” 这个名称：类的数据被 “内联”到该类使用的地方（类似于内联函数中的代码被内联到该函数调用的地方）。\n\n内联类支持普通类中的一些功能。特别是，内联类可以声明属性与函数：\n\ninline class Name(val s: String) {\n    val length: Int\n        get() = s.length\n\n    fun greet() {\n        println(\"Hello, $s\")\n    }\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    name.greet() // `greet` 方法会作为一个静态方法被调用\n    println(name.length) // 属性的 get 方法会作为一个静态方法被调用\n}\n然而，内联类的成员也有一些限制：\n\n内联类不能含有 init 代码块\n内联类不能含有幕后字段\n因此，内联类只能含有简单的计算属性（不能含有延迟初始化/委托属性）\n内联类允许去继承接口\n\ninterface Printable {\n    fun prettyPrint(): String\n}\n\ninline class Name(val s: String) : Printable {\n    override fun prettyPrint(): String = \"Let's $s!\"\n}    \n\nfun main() {\n    val name = Name(\"Kotlin\")\n    println(name.prettyPrint()) // 仍然会作为一个静态方法被调用\n}\n禁止内联类参与到类的继承关系结构中。这就意味着内联类不能继承其他的类而且必须是 final。\n\n在生成的代码中，Kotlin 编译器为每个内联类保留一个包装器。内联类的实例可以在运行时表示为包装器或者基础类型。这就类似于 Int 可以表示为原生类型 int 或者包装器 Integer。\n\n为了生成性能最优的代码，Kotlin 编译更倾向于使用基础类型而不是包装器。 然而，有时候使用包装器是必要的。一般来说，只要将内联类用作另一种类型，它们就会被装箱。\n\ninterface I\n\ninline class Foo(val i: Int) : I\n\nfun asInline(f: Foo) {}\nfun <T> asGeneric(x: T) {}\nfun asInterface(i: I) {}\nfun asNullable(i: Foo?) {}\n\nfun <T> id(x: T): T = x\n\nfun main() {\n    val f = Foo(42) \n    \n    asInline(f)    // 拆箱操作: 用作 Foo 本身\n    asGeneric(f)   // 装箱操作: 用作泛型类型 T\n    asInterface(f) // 装箱操作: 用作类型 I\n    asNullable(f)  // 装箱操作: 用作不同于 Foo 的可空类型 Foo?\n    \n    // 在下面这里例子中，'f' 首先会被装箱（当它作为参数传递给 'id' 函数时）然后又被拆箱（当它从'id'函数中被返回时）\n    // 最后， 'c' 中就包含了被拆箱后的内部表达(也就是 '42')， 和 'f' 一样\n    val c = id(f)  \n}\n因为内联类既可以表示为基础类型有可以表示为包装器，引用相等对于内联类而言毫无意义，因此这也是被禁止的。\n\n由于内联类被编译为其基础类型，因此可能会导致各种模糊的错误，例如意想不到的平台签名冲突：\n\ninline class UInt(val x: Int)\n\n// 在 JVM 平台上被表示为'public final void compute(int x)'\nfun compute(x: Int) { }\n\n// 同理，在 JVM 平台上也被表示为'public final void compute(int x)'！\nfun compute(x: UInt) { }\n为了缓解这种问题，一般会通过在函数名后面拼接一些稳定的哈希码来重命名函数。 因此，fun compute(x: UInt) 将会被表示为 public final void compute-<hashcode>(int x)，以此来解决冲突的问题。\n\n请注意在 Java 中 - 是一个 无效的 符号，也就是说在 Java 中不能调用使用内联类作为形参的函数。\n\n初看起来，内联类似乎与类型别名非常相似。实际上，两者似乎都引入了一种新的类型，并且都在运行时表示为基础类型。\n\n然而，关键的区别在于类型别名与其基础类型(以及具有相同基础类型的其他类型别名)是 赋值兼容 的，而内联类却不是这样。\n\n换句话说，内联类引入了一个真实的新类型，与类型别名正好相反，类型别名仅仅是为现有的类型取了个新的替代名称(别名)：\n\ntypealias NameTypeAlias = String\ninline class NameInlineClass(val s: String)\n\nfun acceptString(s: String) {}\nfun acceptNameTypeAlias(n: NameTypeAlias) {}\nfun acceptNameInlineClass(p: NameInlineClass) {}\n\nfun main() {\n    val nameAlias: NameTypeAlias = \"\"\n    val nameInlineClass: NameInlineClass = NameInlineClass(\"\")\n    val string: String = \"\"\n\n    acceptString(nameAlias) // 正确: 传递别名类型的实参替代函数中基础类型的形参\n    acceptString(nameInlineClass) // 错误: 不能传递内联类的实参替代函数中基础类型的形参\n\n    // And vice versa:\n    acceptNameTypeAlias(string) // 正确: 传递基础类型的实参替代函数中别名类型的形参\n    acceptNameInlineClass(string) // 错误: 不能传递基础类型的实参替代函数中内联类类型的形参\n}\n内联类的设计目前是实验性的，这就是说此特性是正在 快速变化的，并且不保证其兼容性。在 Kotlin 1.3+ 中使用内联类时，将会得到一个警告，来表明此特性还是实验性的。\n\n如需移除警告，必须通过指定编译器参数 -Xinline-classes 来选择使用这项实验性的特性。\n\nGroovyKotlin\n\ncompileKotlin {\n    kotlinOptions.freeCompilerArgs += [\"-Xinline-classes\"]\n}\ntasks.withType<KotlinCompile> {\n    kotlinOptions.freeCompilerArgs += \"-Xinline-classes\"\n}\n关于详细信息，请参见编译器选项。关于多平台项目的设置，请参见使用 Gradle 构建多平台项目章节。\n\n<configuration>\n    <args>\n        <arg>-Xinline-classes</arg> \n    </args>\n</configuration>\n关于详细信息，请参见指定编译器选项。\n\n关于其他技术详细信息和讨论，请参见内联类的语言提议"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307929968},"updatedAt":{"$$date":1597308315206},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"7STj5TYmD3hk5nEw"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977485771},"updatedAt":{"$$date":1594977485771},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"89ltA1CzbcuyjwQi"}
{"name":"andr-请求应用权限","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/permissions/requesting\n请求应用权限  |  Android 开发者  |  Android Developers\n10-13 minutes\n每款 Android 应用都在访问受限的沙盒中运行。如果应用需要使用自己的沙盒外的资源或信息，就必须请求相应权限。您可以通过以下方式声明应用需要某项权限：在应用清单中列出该权限，然后在运行时请求用户批准每项权限（适用于 Android 6.0 及更高版本）。\n\n\n\n基本原则如下：\n\n视情况在用户开始与需要相关权限的功能进行互动时请求权限。\n不要阻止用户使用应用。始终提供选项供用户取消与权限相关的指导界面流程。\n如果用户拒绝或撤消某项功能所需的权限，请适当降级您的应用以便让用户可以继续使用您的应用（可能通过停用需要该权限的功能来实现）。\n不要假设任何系统行为。\n本页面详细介绍向应用添加权限以及在运行时根据需要请求这些权限的分步流程。\n\n向清单添加权限\n对于所有 Android 版本，如需声明应用需要某项权限，请在应用清单中添加 <uses-permission> 元素，作为顶级 <manifest> 元素的子级。\n\n例如，需要访问互联网的应用会在清单中添加以下代码行：\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        package=\"com.example.snazzyapp\"><uses-permission android:name=\"android.permission.INTERNET\"/>\n    <!-- other permissions go here --><application ...>\n        ...\n    </application>\n</manifest>\n系统在您声明权限之后的行为取决于权限的敏感程度。有些权限被视为“普通”权限，因此系统会在安装应用后立即授予这些权限。还有些权限则被视为“危险”权限，因此必须由用户向应用明确授予相应访问权限。如需详细了解不同类型的权限，请参阅保护级别。\n\n检查权限\n如果应用需要一项危险权限，那么每次执行需要该权限的操作时，您都必须检查是否具有该权限。在 Android 6.0（API 级别 23）及更高版本中，用户可以随时从任何应用撤消危险权限。\n\n确定应用是否已获得权限\n如需检查用户是否已向您的应用授予特定权限，请将该权限传入 ContextCompat.checkSelfPermission() 方法。根据您的应用是否具有相应权限，此方法会返回 PERMISSION_GRANTED 或 PERMISSION_DENIED。\n\n说明您的应用为何需要获取权限\n如果 ContextCompat.checkSelfPermission() 方法返回 PERMISSION_DENIED，请调用 shouldShowRequestPermissionRationale()。如果此方法返回 true，请向用户显示指导界面。请在此界面中说明用户希望启用的功能为何需要特定权限。\n\n请求权限\n用户查看指导界面后或者 shouldShowRequestPermissionRationale() 的返回值表明您这次不需要显示指导界面后，您可以请求权限。用户会看到系统权限对话框，并可在其中选择是否向您的应用授予特定权限。\n\n按照历来的做法，您可以在权限请求过程中自行管理请求代码，并将此请求代码包含在您的权限回调逻辑中。另一种选择是使用 AndroidX 库中包含的 RequestPermission 协定类，您可在其中允许系统代为管理权限请求代码。由于使用 RequestPermission 协定类可简化逻辑，因此，建议您尽可能使用该方法。\n\n允许系统管理权限请求代码\n如需允许系统管理与权限请求相关联的请求代码，请在您模块的 build.gradle 文件中添加 androidx.activity 库的依赖项。请使用该库的 1.2.0 版或更高版本。\n\n然后，您可以使用以下某个类：\n\n如需请求一项权限，请使用 RequestPermission。\n如需同时请求多项权限，请使用 RequestMultiplePermissions。\n以下步骤显示了如何使用 RequestPermission 协定类。使用 RequestMultiplePermissions 协定类的流程几乎与此相同。\n\n在 Activity 或 Fragment 的初始化逻辑中，将 ActivityResultCallback 的实现传入对 registerForActivityResult() 的调用。ActivityResultCallback 定义应用如何处理用户对权限请求的响应。\n\n保留对 registerForActivityResult()（类型为 ActivityResultLauncher）的返回值的引用。\n\n如需在必要时显示系统权限对话框，请对您在上一步中保存的 ActivityResultLauncher 实例调用 launch() 方法。\n\n调用 launch() 之后，系统会显示系统权限对话框。当用户做出选择后，系统会异步调用您在上一步中定义的 ActivityResultCallback 实现。\n\n注意：应用无法自定义调用 launch() 时显示的对话框。如需为用户提供更多信息或上下文，请更改应用的界面，以便让用户更容易了解应用中的功能为何需要特定权限。例如，您可以更改用于启用该功能的按钮中的文本。\n\n此外，系统权限对话框中的文本会提及与您请求的权限关联的权限组。此权限分组是为了让系统易于使用，您的应用不应依赖于特定权限组之内或之外的权限。\n\n以下代码段展示了如何处理权限响应：\n\n// Register the permissions callback, which handles the user's response to the\n// system permissions dialog. Save the return value, an instance of\n// ActivityResultLauncher. You can use either a val, as shown in this snippet,\n// or a lateinit var in your onAttach() or onCreate() method.\nval requestPermissionLauncher =\n    registerForActivityResult(RequestPermission()\n    ) { isGranted: Boolean ->\n        if (isGranted) {\n            // Permission is granted. Continue the action or workflow in your\n            // app.\n        } else {\n            // Explain to the user that the feature is unavailable because the\n            // features requires a permission that the user has denied. At the\n            // same time, respect the user's decision. Don't link to system\n            // settings in an effort to convince the user to change their\n            // decision.\n        }\n    }\n// Register the permissions callback, which handles the user's response to the\n// system permissions dialog. Save the return value, an instance of\n// ActivityResultLauncher, as an instance variable.\nprivate ActivityResultLauncher<String> requestPermissionLauncher =\n    registerForActivityResult(new RequestPermission(), isGranted -> {\n        if (isGranted) {\n            // Permission is granted. Continue the action or workflow in your\n            // app.\n        } else {\n            // Explain to the user that the feature is unavailable because the\n            // features requires a permission that the user has denied. At the\n            // same time, respect the user's decision. Don't link to system\n            // settings in an effort to convince the user to change their\n            // decision.\n        }\n    });\n以下代码段演示了检查权限并根据需要向用户请求权限的建议流程：\n\nwhen {\n    ContextCompat.checkSelfPermission(\n            CONTEXT,\n            Manifest.permission.REQUESTED_PERMISSION\n            ) == PackageManager.PERMISSION_GRANTED -> {\n        // You can use the API that requires the permission.\n    }\n    shouldShowRequestPermissionRationale(...) -> {\n        // In an educational UI, explain to the user why your app requires this\n        // permission for a specific feature to behave as expected. In this UI,\n        // include a \"cancel\" or \"no thanks\" button that allows the user to\n        // continue using your app without granting the permission.\n        showInContextUI(...)\n    }\n    else -> {\n        // You can directly ask for the permission.\n        // The registered ActivityResultCallback gets the result of this request.\n        requestPermissionLauncher.launch(\n                Manifest.permission.REQUESTED_PERMISSION)\n    }\n}\nif (ContextCompat.checkSelfPermission(\n        CONTEXT, Manifest.permission.REQUESTED_PERMISSION) ==\n        PackageManager.PERMISSION_GRANTED) {\n    // You can use the API that requires the permission.\n    performAction(...);\n} else if (shouldShowRequestPermissionRationale(...)) {\n    // In an educational UI, explain to the user why your app requires this\n    // permission for a specific feature to behave as expected. In this UI,\n    // include a \"cancel\" or \"no thanks\" button that allows the user to\n    // continue using your app without granting the permission.\n    showInContextUI(...);\n} else {\n    // You can directly ask for the permission.\n    // The registered ActivityResultCallback gets the result of this request.\n    requestPermissionLauncher.launch(\n            Manifest.permission.REQUESTED_PERMISSION);\n}\n自行管理权限请求代码\n作为允许系统管理权限请求代码的替代方法，您可以自行管理权限请求代码。为此，请在对 requestPermissions() 的调用中添加请求代码。\n\n以下代码段演示了如何使用请求代码来请求权限：\n\nwhen {\n    ContextCompat.checkSelfPermission(\n            CONTEXT,\n            Manifest.permission.REQUESTED_PERMISSION\n            ) == PackageManager.PERMISSION_GRANTED -> {\n        // You can use the API that requires the permission.\n        performAction(...)\n    }\n    shouldShowRequestPermissionRationale(...) -> {\n        // In an educational UI, explain to the user why your app requires this\n        // permission for a specific feature to behave as expected. In this UI,\n        // include a \"cancel\" or \"no thanks\" button that allows the user to\n        // continue using your app without granting the permission.\n        showInContextUI(...)\n    }\n    else -> {\n        // You can directly ask for the permission.\n        requestPermissions(CONTEXT,\n                arrayOf(Manifest.permission.REQUESTED_PERMISSION),\n                REQUEST_CODE)\n    }\n}\nif (ContextCompat.checkSelfPermission(\n        CONTEXT, Manifest.permission.REQUESTED_PERMISSION) ==\n        PackageManager.PERMISSION_GRANTED) {\n    // You can use the API that requires the permission.\n    performAction(...);\n} else if (shouldShowRequestPermissionRationale(...)) {\n    // In an educational UI, explain to the user why your app requires this\n    // permission for a specific feature to behave as expected. In this UI,\n    // include a \"cancel\" or \"no thanks\" button that allows the user to\n    // continue using your app without granting the permission.\n    showInContextUI(...);\n} else {\n    // You can directly ask for the permission.\n    requestPermissions(CONTEXT,\n            new String[] { Manifest.permission.REQUESTED_PERMISSION },\n            REQUEST_CODE);\n}\n当用户响应系统权限对话框后，系统就会调用应用的 onRequestPermissionsResult() 实现。系统会传入用户对权限对话框的响应以及您定义的请求代码，如以下代码段所示：\n\noverride fun onRequestPermissionsResult(requestCode: Int,\n        permissions: Array<String>, grantResults: IntArray) {\n    when (requestCode) {\n        PERMISSION_REQUEST_CODE -> {\n            // If request is cancelled, the result arrays are empty.\n            if ((grantResults.isNotEmpty() &&\n                    grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n                // Permission is granted. Continue the action or workflow\n                // in your app.\n            } else {\n                // Explain to the user that the feature is unavailable because\n                // the features requires a permission that the user has denied.\n                // At the same time, respect the user's decision. Don't link to\n                // system settings in an effort to convince the user to change\n                // their decision.\n            }\n            return\n        }// Add other 'when' lines to check for other\n        // permissions this app might request.\n        else -> {\n            // Ignore all other requests.\n        }\n    }\n}\n@Override\npublic void onRequestPermissionsResults(int requestCode, String[] permissions,\n        int[] grantResults) {\n    switch (requestCode) {\n        case PERMISSION_REQUEST_CODE:\n            // If request is cancelled, the result arrays are empty.\n            if (grantResults.length > 0 &&\n                    grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                // Permission is granted. Continue the action or workflow\n                // in your app.\n            }  else {\n                // Explain to the user that the feature is unavailable because\n                // the features requires a permission that the user has denied.\n                // At the same time, respect the user's decision. Don't link to\n                // system settings in an effort to convince the user to change\n                // their decision.\n            }\n            return;\n        }\n        // Other 'case' lines to check for other\n        // permissions this app might request.\n    }\n}\n处理权限请求遭拒情况\n如果用户拒绝了权限请求，应用应该帮助用户了解拒绝授予权限的影响。具体而言，应用应该让用户知道因缺少权限而无法使用的功能。在处理这种情况时，请牢记以下最佳做法：\n\n引导用户的注意力。在应用界面中突出显示因为应用没有必要的权限而受限的功能所在的具体部分。以下列举了几个例子说明您可以采取的做法：\n\n在该功能的结果或数据会出现的位置显示一条消息。\n显示一个包含错误图标并带有相应错误颜色的不同按钮。\n内容要具体。显示的消息不要空泛；而要指出因为应用没有必要的权限而无法使用的具体功能。\n\n不要阻止界面显示。换言之，不要显示全屏警告消息，让用户根本无法继续使用您的应用。\n\n在某些情况下，系统可能会自动拒绝权限，而无需用户执行任何操作。（同样，系统也可能会自动授予权限。）请千万不要对系统的自动行为做出任何假设。每当应用需要使用的功能需要权限时，您都应该检查应用是否仍被授予该权限。\n\n如需在请求应用权限时提供最佳用户体验，另请参阅应用权限最佳做法。\n\n在必要时请求成为默认处理程序\n有些应用依赖于访问与通话记录和短信有关的敏感用户信息。如果您想请求特定于通话记录和短信的权限，并将应用发布到 Play 商店，您必须在请求这些运行时权限之前，提示用户将应用设置为核心系统功能的默认处理程序。\n\n如需详细了解默认处理程序，包括有关如何向用户显示默认处理程序提示的指南，请参阅有关仅在默认处理程序中使用的权限的指南。\n\n按 API 级别声明权限\n如需仅在支持运行时权限的设备（即，搭载 Android 6.0（API 级别 23）或更高版本的设备）上声明某项权限，请添加 uses-permission-sdk-23 标记，而不是 uses-permission 标记。\n\n使用这些标记中的任意一个时，您都可以设置 maxSdkVersion 属性，用于指定在搭载更高版本的设备上不需要特定权限。\n\n其他资源\n如需详细了解权限，请阅读以下文章：\n\n权限概览\n应用权限最佳做法\n如需详细了解如何请求权限，请下载以下示例应用：\n\nAndroid RuntimePermissionsBasic 示例 Java | Kotlin"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242656436},"updatedAt":{"$$date":1597243254146},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"8Rd8aj5LdsFbd3ap"}
{"name":"andr-样式","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/style-resource\n样式资源  |  Android 开发者  |  Android Developers\n2-3 minutes\n样式资源定义界面的格式和外观。样式可应用于单个 View（从布局文件中）或应用于整个 Activity 或应用（从清单文件中）。\n\n如需详细了解如何创建和应用样式，请参阅样式和主题。\n\n注意：样式是使用 name 属性中提供的值（不是 XML 文件的名称）引用的简单资源。因此，您可以在一个 XML 文件中将样式资源与其他简单资源合并到一个 <resources> 元素下。\n\n文件位置：\nres/values/filename.xml\n该文件名可以任意设置。元素的 name 将用作资源 ID。\n资源引用：\n在 XML 中：@[package:]style/style_name\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <resources>\n        <style\n            name=\"style_name\"\n            parent=\"@[package:]style/style_to_inherit\">\n            <item\n                name=\"[package:]style_property_name\"\n                >style_value</item>\n        </style>\n    </resources>\n    \n元素：\n<resources>\n必需。该元素必须是根节点。\n没有属性。\n\n<style>\n定义单个样式。包含 <item> 元素。\n属性：\n\nname\n字符串。必需。样式的名称，用作将样式应用于 View、Activity 或应用的资源 ID。\nparent\n样式资源。对此样式应从中继承样式属性的样式的引用。\n<item>\n定义样式的单个属性。必须是 <style> 元素的子元素。\n属性：\n\nname\n属性资源。必需。要定义的样式属性的名称，必要时带有包前缀（例如 android:textColor）。\n示例：\n样式的 XML 文件（保存在 res/values/ 中）：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <resources>\n        <style name=\"CustomText\" parent=\"@style/Text\">\n            <item name=\"android:textSize\">20sp</item>\n            <item name=\"android:textColor\">#008</item>\n        </style>\n    </resources>\n    \n将样式应用于 TextView 的 XML 文件（保存在 res/layout/ 中）：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <EditText\n        style=\"@style/CustomText\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello, World!\" />\n    "}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242644630},"updatedAt":{"$$date":1597242925167},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"8RduqLTGpTlb7MoN"}
{"name":"py-dict","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\nPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n\n举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：\n\nnames = ['Michael', 'Bob', 'Tracy']\nscores = [95, 75, 85]\n给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。\n\n如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：\n\n>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\n>>> d['Michael']\n95\n为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。\n\n第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。\n\ndict就是第二种实现方式，给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。\n\n你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。\n\n把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：\n\n>>> d['Adam'] = 67\n>>> d['Adam']\n67\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\n\n>>> d['Jack'] = 90\n>>> d['Jack']\n90\n>>> d['Jack'] = 88\n>>> d['Jack']\n88\n如果key不存在，dict就会报错：\n\n>>> d['Thomas']\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'Thomas'\n要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：\n\n>>> 'Thomas' in d\nFalse\n二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：\n\n>>> d.get('Thomas')\n>>> d.get('Thomas', -1)\n-1\n注意：返回None的时候Python的交互环境不显示结果。\n\n要删除一个key，用pop(key)方法，对应的value也会从dict中删除：\n\n>>> d.pop('Bob')\n75\n>>> d\n{'Michael': 95, 'Tracy': 85}\n请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。\n\n和list比较，dict有以下几个特点：\n\n查找和插入的速度极快，不会随着key的增加而变慢；\n需要占用大量的内存，内存浪费多。\n而list相反：\n\n查找和插入的时间随着元素的增加而增加；\n占用空间小，浪费内存很少。\n所以，dict是用空间来换取时间的一种方法。\n\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n\n这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：\n\n>>> key = [1, 2, 3]\n>>> d[key] = 'a list'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unhashable type: 'list'"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973940470},"updatedAt":{"$$date":1594977047548},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"8SUnHPRXFtkBs512"}
{"name":"andr-颜色状态列表资源","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/color-list-resource\n颜色状态列表资源  |  Android 开发者  |  Android Developers\n4-4 minutes\nColorStateList 是一个您可以在 XML 中定义的对象，您可以将其作为颜色来应用，但它实际上会更改颜色，具体取决于其应用到的 View 对象的状态。例如，Button 微件可以处于多种不同状态中的一种（按下、聚焦或既不按下也不聚焦），而使用颜色状态列表，您可以为每种状态提供不同的颜色。\n\n您可以在 XML 文件中描述状态列表。每种颜色都在单个 <selector> 元素内的 <item> 元素中定义。每个 <item> 使用不同的属性描述其应在什么状态下使用。\n\n在每次状态更改期间，系统将从上到下遍历状态列表，并且将使用与当前状态匹配的第一项。系统的选择并非基于“最佳匹配”，而仅仅是基于符合状态的最低标准的第一项。\n\n注意：如果要提供静态颜色资源，请使用简单的颜色值。\n\n文件位置：\nres/color/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 ColorStateList 的资源指针。\n资源引用：\n在 Java 中：R.color.filename\n在 XML 中：@[package:]color/filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <selector xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n        <item\n            android:color=\"hex_color\"\n            android:state_pressed=[\"true\" | \"false\"]\n            android:state_focused=[\"true\" | \"false\"]\n            android:state_selected=[\"true\" | \"false\"]\n            android:state_checkable=[\"true\" | \"false\"]\n            android:state_checked=[\"true\" | \"false\"]\n            android:state_enabled=[\"true\" | \"false\"]\n            android:state_window_focused=[\"true\" | \"false\"] />\n    </selector>\n    \n元素：\n<selector>\n必需。该元素必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必需。定义 XML 命名空间，该命名空间必须为 \"http://schemas.android.com/apk/res/android\"。\n<item>\n定义在某些状态下使用的颜色，状态通过其属性来描述。必须是 <selector> 元素的子元素。\n属性：\n\nandroid:color\n十六进制颜色。必需。颜色通过 RGB 值和可选的 Alpha 通道指定。\n该值始终以井号 (#) 字符开头，后跟以下某种格式的“透明度、红、绿、蓝”(Alpha-Red-Green-Blue) 信息：\n\n#RGB\n#ARGB\n#RRGGBB\n#AARRGGBB\nandroid:state_pressed\n布尔值。如果此项应在按下对象时（例如轻触/点按了按钮时）使用，则为“true”；如果此项应在默认的非按下状态下使用，则为“false”。\nandroid:state_focused\n布尔值。如果此项应在聚焦对象时（例如使用轨迹球/方向键突出显示按钮时）使用，则为“true”；如果此项应在默认的非聚焦状态下使用，则为“false”。\nandroid:state_selected\n布尔值。如果此项应在选择对象时（例如打开标签页时）使用，则为“true”；如果此项应在未选择对象时使用，则为“false”。\nandroid:state_checkable\n布尔值。如果此项应在对象可勾选时使用，则为“true”；如果此项应在对象不可勾选时使用，则为“false”。（仅适用于对象可在可勾选和不可勾选的微件之间转换的情况。）\nandroid:state_checked\n布尔值。如果此项应在勾选对象时使用，则为“true”；如果应在取消勾选对象时使用，则为“false”。\nandroid:state_enabled\n布尔值。如果此项应在启用对象（能够接收轻触/点按事件）时使用，则为“true”；如果应在停用对象时使用，则为“false”。\nandroid:state_window_focused\n布尔值。如果此项应在应用窗口具有焦点（应用位于前台）时使用，则为“true”；如果此项应在应用窗口没有焦点时（例如通知栏下拉或出现一个对话框时）使用，则为“false”。\n注意：请注意，系统将应用状态列表中与对象的当前状态匹配的第一项。因此，如果列表中的第一项不包含上述任何状态属性，则每次都会应用该项，因此默认值应始终为最后一项，如以下示例所示。\n\n示例：\n保存于 res/color/button_text.xml 的 XML 文件：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n        <item android:state_pressed=\"true\"\n              android:color=\"#ffff0000\"/> <!-- pressed -->\n        <item android:state_focused=\"true\"\n              android:color=\"#ff0000ff\"/> <!-- focused -->\n        <item android:color=\"#ff000000\"/> <!-- default -->\n    </selector>\n    \n此布局 XML 会将颜色列表应用到 View：\n\n    <Button\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"@string/button_text\"\n        android:textColor=\"@color/button_text\" />\n    \n另请参阅：\n颜色（简单值）\nColorStateList\n状态列表可绘制对象"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242356080},"updatedAt":{"$$date":1597242563574},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9CcNS7Ui55ziBJzu"}
{"name":"kotlin-Kotlin 泛型 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-generics.html\nKotlin 泛型 | 菜鸟教程\n4-4 minutes\n泛型，即 \"参数化类型\"，将类型参数化，可以用在类，接口，方法上。\n\n与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。\n\n声明一个泛型类:\n\nclass Box<T>(t: T) {\n    var value = t\n}\n创建类的实例时我们需要指定类型参数:\n\nval box: Box<Int> = Box<Int>(1)\n// 或者\nval box = Box(1) // 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box<Int>。\n以下实例向泛型类 Box 传入整型数据和字符串：\n\nclass Box<T>(t : T) {\n    var value = t\n}\n\nfun main(args: Array<String>) {\n    var boxInt = Box<Int>(10)\n    var boxString = Box<String>(\"Runoob\")\n\n    println(boxInt.value)\n    println(boxString.value)\n}\n输出结果为：\n\n10\nRunoob\n定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。\n\nKotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：\n\nfun <T> boxIn(value: T) = Box(value)\n\n// 以下都是合法语句\nval box4 = boxIn<Int>(1)\nval box5 = boxIn(1)     // 编译器会进行类型推断\n在调用泛型函数时，如果可以推断出类型参数，可以省略泛型参数。\n\n以下实例创建了泛型函数 doPrintln，函数根据传入的不同类型做相应处理：\n\nfun main(args: Array<String>) {\n    val age = 23\n    val name = \"runoob\"\n    val bool = true\n\n    doPrintln(age)    // 整型\n    doPrintln(name)   // 字符串\n    doPrintln(bool)   // 布尔型\n}\n\nfun <T> doPrintln(content: T) {\n\n    when (content) {\n        is Int -> println(\"整型数字为 $content\")\n        is String -> println(\"字符串转换为大写：${content.toUpperCase()}\")\n        else -> println(\"T 不是整型，也不是字符串\")\n    }\n}\n输出结果为：\n\n整型数字为 23\n字符串转换为大写：RUNOOB\nT 不是整型，也不是字符串\n泛型约束\n我们可以使用泛型约束来设定一个给定参数允许使用的类型。\n\nKotlin 中使用 : 对泛型的类型上限进行约束。\n\n最常见的约束是上界(upper bound)：\n\nfun <T : Comparable<T>> sort(list: List<T>) {\n    // ……\n}\nComparable 的子类型可以替代 T。 例如:\n\nsort(listOf(1, 2, 3)) // OK。Int 是 Comparable<Int> 的子类型\nsort(listOf(HashMap<Int, String>())) // 错误：HashMap<Int, String> 不是 Comparable<HashMap<Int, String>> 的子类型\n默认的上界是 Any?。\n\n对于多个上界约束条件，可以用 where 子句：\n\nfun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>\n    where T : CharSequence,\n          T : Comparable<T> {\n    return list.filter { it > threshold }.map { it.toString() }\n}\n型变\nKotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。\n\n声明处型变\n声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。\n\n使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：\n\n// 定义一个支持协变的类\nclass Runoob<out A>(val a: A) {\n    fun foo(): A {\n        return a\n    }\n}\n\nfun main(args: Array<String>) {\n    var strCo: Runoob<String> = Runoob(\"a\")\n    var anyCo: Runoob<Any> = Runoob<Any>(\"b\")\n    anyCo = strCo\n    println(anyCo.foo())   // 输出 a\n}\nin 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：\n\n// 定义一个支持逆变的类\nclass Runoob<in A>(a: A) {\n    fun foo(a: A) {\n    }\n}\n\nfun main(args: Array<String>) {\n    var strDCo = Runoob(\"a\")\n    var anyDCo = Runoob<Any>(\"b\")\n    strDCo = anyDCo\n}\n星号投射\n有些时候, 你可能想表示你并不知道类型参数的任何信息, 但是仍然希望能够安全地使用它. 这里所谓\"安全地使用\"是指, 对泛型类型定义一个类型投射, 要求这个泛型类型的所有的实体实例, 都是这个投射的子类型。\n\n对于这个问题, Kotlin 提供了一种语法, 称为 星号投射(star-projection):\n\n假如类型定义为 Foo<out T> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper ,Foo<> 等价于 Foo<out TUpper> . 它表示, 当 T 未知时, 你可以安全地从 Foo<> 中 读取TUpper 类型的值.\n假如类型定义为 Foo<in T> , 其中 T 是一个反向协变的类型参数, Foo<> 等价于 Foo<inNothing> . 它表示, 当 T 未知时, 你不能安全地向 Foo<> 写入 任何东西.\n假如类型定义为 Foo<T> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper , 对于读取值的场合, Foo<*> 等价于 Foo<out TUpper> , 对于写入值的场合, 等价于 Foo<in Nothing> .\n如果一个泛型类型中存在多个类型参数, 那么每个类型参数都可以单独的投射. 比如, 如果类型定义为interface Function<in T, out U> , 那么可以出现以下几种星号投射:\n\nFunction<*, String> , 代表 Function<in Nothing, String> ;\nFunction<Int, *> , 代表 Function<Int, out Any?> ;\nFunction<, > , 代表 Function<in Nothing, out Any?> .\n注意: 星号投射与 Java 的原生类型(raw type)非常类似, 但可以安全使用"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304148711},"updatedAt":{"$$date":1597304297171},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9MZXOe8JlHPA5715"}
{"name":"py-max","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n而max函数max()可以接收任意多个参数，并返回最大的那个：\n\n>>> max(1, 2)\n2\n>>> max(2, 3, 1, -5)\n3\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973942744},"updatedAt":{"$$date":1594977252280},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9xJkNCQNKsPvdW6g"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382140847},"updatedAt":{"$$date":1597382140847},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9zC8KjRNRbTjr529"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973282995},"updatedAt":{"$$date":1594973282995},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"A9c3Q3zNiJikoHg3"}
{"name":"java-方法引用","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"使用Lambda表达式，我们就可以不必编写FunctionalInterface接口的实现类，从而简化代码：\n\nArrays.sort(array, (s1, s2) -> {\n    return s1.compareTo(s2);\n});\n实际上，除了Lambda表达式，我们还可以直接传入方法引用。例如：\n\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, Main::cmp);\n        System.out.println(String.join(\", \", array));\n    }\n\n    static int cmp(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n}\n\n Run\n上述代码在Arrays.sort()中直接传入了静态方法cmp的引用，用Main::cmp表示。\n\n因此，所谓方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用。\n\n因为Comparator<String>接口定义的方法是int compare(String, String)，和静态方法int cmp(String, String)相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入：\n\nArrays.sort(array, Main::cmp);\n注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系。\n\n我们再看看如何引用实例方法。如果我们把代码改写如下：\n\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, String::compareTo);\n        System.out.println(String.join(\", \", array));\n    }\n}\n\n Run\n不但可以编译通过，而且运行结果也是一样的，这说明String.compareTo()方法也符合Lambda定义。\n\n观察String.compareTo()的方法定义：\n\npublic final class String {\n    public int compareTo(String o) {\n        ...\n    }\n}\n这个方法的签名只有一个参数，为什么和int Comparator<String>.compare(String, String)能匹配呢？\n\n因为实例方法有一个隐含的this参数，String类的compareTo()方法在实际调用的时候，第一个隐含参数总是传入this，相当于静态方法：\n\npublic static int compareTo(this, String o);\n所以，String.compareTo()方法也可作为方法引用传入。\n\n构造方法引用\n除了可以引用静态方法和实例方法，我们还可以引用构造方法。\n\n我们来看一个例子：如果要把一个List<String>转换为List<Person>，应该怎么办？\n\nclass Person {\n    String name;\n    public Person(String name) {\n        this.name = name;\n    }\n}\n\nList<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\nList<Person> persons = ???\n传统的做法是先定义一个ArrayList<Person>，然后用for循环填充这个List：\n\nList<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\nList<Person> persons = new ArrayList<>();\nfor (String name : names) {\n    persons.add(new Person(name));\n}\n要更简单地实现String到Person的转换，我们可以引用Person的构造方法：\n\n// 引用构造方法\nimport java.util.*;\nimport java.util.stream.*;\npublic class Main {\n    public static void main(String[] args) {\n        List<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\n        List<Person> persons = names.stream().map(Person::new).collect(Collectors.toList());\n        System.out.println(persons);\n    }\n}\n\nclass Person {\n    String name;\n    public Person(String name) {\n        this.name = name;\n    }\n    public String toString() {\n        return \"Person:\" + this.name;\n    }\n}\n\n Run\n后面我们会讲到Stream的map()方法。现在我们看到，这里的map()需要传入的FunctionalInterface的定义是：\n\n@FunctionalInterface\npublic interface Function<T, R> {\n    R apply(T t);\n}\n把泛型对应上就是方法签名Person apply(String)，即传入参数String，返回类型Person。而Person类的构造方法恰好满足这个条件，因为构造方法的参数是String，而构造方法虽然没有return语句，但它会隐式地返回this实例，类型就是Person，因此，此处可以引用构造方法。构造方法的引用写法是类名::new，因此，此处传入Person::new。\n\n练习\n从下载练习：使用方法引用实现忽略大小写排序 （推荐使用IDE练习插件快速下载）\n\n小结\nFunctionalInterface允许传入：\n\n接口的实现类（传统写法，代码较繁琐）；\nLambda表达式（只需列出参数名，由编译器推断类型）；\n符合方法签名的静态方法；\n符合方法签名的实例方法（实例类型被看做第一个参数类型）；\n符合方法签名的构造方法（实例类型被看做返回类型）。\nFunctionalInterface不强制继承关系，不需要方法名称相同，只要求方法参数（类型和数量）与方法返回类型相同，即认为方法签名相同。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973255909},"updatedAt":{"$$date":1594973664981},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AYTXD4TFlneEEBfu"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241220144},"updatedAt":{"$$date":1597241220144},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AaHhbmGoxhVF4FDH"}
{"name":"andr-片段   ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/components/fragments\n片段  |  Android 开发者  |  Android Developers\n27-34 minutes\nFragment 表示 FragmentActivity 中的行为或界面的一部分。您可以在一个 Activity 中组合多个片段，从而构建多窗格界面，并在多个 Activity 中重复使用某个片段。您可以将片段视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除片段（这有点像可以在不同 Activity 中重复使用的“子 Activity”）。\n\n片段必须始终托管在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。例如，当 Activity 暂停时，Activity 的所有片段也会暂停；当 Activity 被销毁时，所有片段也会被销毁。不过，当 Activity 正在运行（处于已恢复生命周期状态）时，您可以独立操纵每个片段，如添加或移除片段。当执行此类片段事务时，您也可将其添加到由 Activity 管理的返回栈 — Activity 中的每个返回栈条目都是一条已发生片段事务的记录。借助返回栈，用户可以通过按返回按钮撤消片段事务（后退）。\n\n当您将片段作为 Activity 布局的一部分添加时，其位于 Activity 视图层次结构的某个 ViewGroup 中，并且片段会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明片段，将其作为 <fragment> 元素插入您的 Activity 布局，或者通过将其添加到某个现有的 ViewGroup，利用应用代码将其插入布局。\n\n本文介绍如何在开发应用时使用片段，包括如何在将片段添加到 Activity 返回栈时保持其状态、如何与 Activity 及 Activity 中的其他片段共享事件、如何为 Activity 的应用栏发挥作用等等。\n\n如需了解有关处理生命周期的信息（包括最佳实践的相关指导），请参阅以下资源：\n\n使用具有生命周期感知能力的组件处理生命周期\n应用架构指南\n支持平板电脑和手机\n设计原理\nAndroid 在 Android 3.0（API 级别 11）中引入了片段，主要目的是为大屏幕（如平板电脑）上更加动态和灵活的界面设计提供支持。由于平板电脑的屏幕尺寸远胜于手机屏幕尺寸，因而有更多空间可供您组合和交换界面组件。利用片段实现此类设计时，您无需管理对视图层次结构做出的复杂更改。通过将 Activity 布局分成各个片段，您可以在运行时修改 Activity 的外观，并在由 Activity 管理的返回栈中保留这些更改。现在，您可以通过片段支持库获取大量片段。\n\n例如，新闻应用可以使用一个片段在左侧显示文章列表，使用另一个片段在右侧显示文章 — 两个片段并排显示在一个 Activity 中，每个片段都拥有自己的一套生命周期回调方法，并各自处理自己的用户输入事件。因此，用户无需使用一个 Activity 来选择文章，然后使用另一个 Activity 来阅读文章，而是可以在同一个 Activity 内选择文章并进行阅读，如图 1 中的平板电脑布局所示。\n\n您应将每个片段都设计为可重复使用的模块化 Activity 组件。换言之，由于每个片段都会通过各自的生命周期回调来定义自己的布局和行为，您可以将一个片段加入多个 Activity，因此，您应采用可复用式设计，避免直接通过某个片段操纵另一个片段。这一点颇为重要，因为模块化片段允许您更改片段的组合方式，从而适应不同的屏幕尺寸。在设计可同时支持平板电脑和手机的应用时，您可以在不同的布局配置中重复使用您的片段，以根据可用的屏幕空间优化用户体验。例如，在手机上，如果不能在同一 Activity 内储存多个片段，则可能必须利用单独的片段来实现单窗格界面。\n\n\n\n图 1. 由片段定义的两个界面模块如何适应不同设计的示例：通过组合成一个 Activity 来适应平板电脑设计，通过单独片段来适应手机设计。\n\n例如（仍以新闻应用为例），在平板电脑尺寸的设备上运行时，该应用可以在 Activity A 中嵌入两个片段。不过，手机尺寸的屏幕没有足够的空间来存储两个片段，因此 Activity A 只包含用于显示文章列表的片段，并且当用户选择文章时，它会启动 Activity B，其包含用于阅读文章的第二个片段。因此，应用可通过重复使用不同组合的片段来同时支持平板电脑和手机（如图 1 所示）。\n\n如需详细了解在设计应用时利用不同片段组合来适应不同屏幕配置，请参阅屏幕兼容性概览。\n\n创建片段\n\n\n图 2. 片段的生命周期（当其 Activity 运行时）。\n\n如要创建片段，您必须创建 Fragment 的子类（或已有其子类）。Fragment 类的代码与 Activity 非常相似。它包含与 Activity 类似的回调方法，如 onCreate()、onStart()、onPause() 和 onStop()。实际上，如果您要将现有 Android 应用转换为使用片段，可能只需将代码从 Activity 的回调方法移入片段相应的回调方法中。\n\n通常，您至少应实现以下生命周期方法：\n\nonCreate()\n系统会在创建片段时调用此方法。当片段经历暂停或停止状态继而恢复后，如果您希望保留此片段的基本组件，则应在您的实现中将其初始化。\nonCreateView()\n系统会在片段首次绘制其界面时调用此方法。如要为您的片段绘制界面，您从此方法中返回的 View 必须是片段布局的根视图。如果片段未提供界面，您可以返回 null。\nonPause()\n系统会将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。通常，您应在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。\n大多数应用至少应为每个片段实现这三个方法，但您还应使用几种其他回调方法来处理片段生命周期的各个阶段。处理片段生命周期部分对所有生命周期回调方法做了更详尽的阐述。\n\n请注意，用于实现依赖组件生命周期的代码应放在组件本身内，而非直接放在片段回调实现中。请参阅使用具有生命周期感知能力的组件处理生命周期，了解如何让您的依赖组件获得生命周期感知能力。\n\n您可能还想扩展几个子类，而非 Fragment 基类：\n\nDialogFragment\n显示浮动对话框。使用此类创建对话框可有效代替使用 Activity 类中的对话框辅助方法，因为您可以将片段对话框纳入由 Activity 管理的片段返回栈，从而使用户能够返回清除的片段。\nListFragment\n显示由适配器（如 SimpleCursorAdapter）管理的一系列项目，类似于 ListActivity。该类提供几种管理列表视图的方法，如用于处理点击事件的 onListItemClick() 回调。（请注意，显示列表的首选方法是使用 RecyclerView，而非 ListView。在此情况下，您需在列表布局中创建包含 RecyclerView 的片段。如需了解具体操作方法，请参阅使用 RecyclerView 创建列表）\nPreferenceFragmentCompat\n以列表形式显示 Preference 对象的层次结构。此类用于为您的应用创建设置屏幕。\n添加界面\n片段通常用作 Activity 界面的一部分，并且会将其自己的布局融入 Activity。\n\n如要为片段提供布局，您必须实现 onCreateView() 回调方法，Android 系统会在片段需要绘制其布局时调用该方法。此方法的实现所返回的 View 必须是片段布局的根视图。\n\n注意：如果您的片段是 ListFragment 的子类，则默认实现会从 onCreateView() 返回一个 ListView，因此您无需实现它。\n\n如要从 onCreateView() 返回布局，您可以通过 XML 中定义的布局资源来扩展布局。为帮助您执行此操作，onCreateView() 提供了一个 LayoutInflater 对象。\n\n例如，以下 Fragment 子类从 example_fragment.xml 文件加载布局：\n\nclass ExampleFragment : Fragment() {override fun onCreateView(\n            inflater: LayoutInflater,\n            container: ViewGroup?,\n            savedInstanceState: Bundle?\n    ): View {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.example_fragment, container, false)\n    }\n}\npublic static class ExampleFragment extends Fragment {\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.example_fragment, container, false);\n    }\n}\n注意：在上例中，R.layout.example_fragment 是对应用资源中保存的布局资源 example_fragment.xml 的引用。如需了解有关如何在 XML 中创建布局的信息，请参阅界面文档。\n\n传递至 onCreateView() 的 container 参数是您的片段布局将插入到的父级 ViewGroup（来自 Activity 的布局）。savedInstanceState 参数是在恢复片段时，提供上一片段实例相关数据的 Bundle（处理片段生命周期部分对恢复状态做了详细阐述）。\n\ninflate() 方法带有三个参数：\n\n您想要扩展的布局的资源 ID。\n将作为扩展布局父项的 ViewGroup。传递 container 对系统向扩展布局的根视图（由其所属的父视图指定）应用布局参数具有重要意义。\n指示是否应在扩展期间将扩展布局附加至 ViewGroup（第二个参数）的布尔值。（在本例中，此值为 false，因为系统已将扩展布局插入 container，而传递 true 值会在最终布局中创建一个多余的视图组。）\n现在，您已了解如何创建提供布局的片段。接下来，您需将该片段添加到您的 Activity 中。\n\n向 Activity 添加片段\n通常，片段会向宿主 Activity 贡献一部分界面，作为 Activity 整体视图层次结构的一部分嵌入到 Activity 中。可以通过两种方式向 Activity 布局添加片段：\n\n在 Activity 的布局文件内声明片段。\n在本例中，您可以将片段当作视图来为其指定布局属性。例如，以下是拥有两个片段的 Activity 的布局文件：\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <fragment android:name=\"com.example.news.ArticleListFragment\"\n            android:id=\"@+id/list\"\n            android:layout_weight=\"1\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\" />\n    <fragment android:name=\"com.example.news.ArticleReaderFragment\"\n            android:id=\"@+id/viewer\"\n            android:layout_weight=\"2\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\" />\n</LinearLayout>\n<fragment> 中的 android:name 属性指定要在布局中进行实例化的 Fragment 类。\n\n创建此 Activity 布局时，系统会将布局中指定的每个片段实例化，并为每个片段调用 onCreateView() 方法，以检索每个片段的布局。系统会直接插入片段返回的 View，从而代替 <fragment> 元素。\n\n注意：每个片段都需要唯一标识符，重启 Activity 时，系统可使用该标识符来恢复片段（您也可以使用该标识符来捕获片段，从而执行某些事务，如将其移除）。可以通过两种方式为片段提供 ID：\n\n为 android:id 属性提供唯一 ID。\n为 android:tag 属性提供唯一字符串。\n或者，通过编程方式将片段添加到某个现有 ViewGroup。\n在 Activity 运行期间，您可以随时将片段添加到 Activity 布局中。您只需指定要将片段放入哪个 ViewGroup。\n\n如要在您的 Activity 中执行片段事务（如添加、移除或替换片段），则必须使用 FragmentTransaction 中的 API。如下所示，您可以从 FragmentActivity 获取一个 FragmentTransaction 实例：\n\nval fragmentManager = supportFragmentManager\nval fragmentTransaction = fragmentManager.beginTransaction()\nFragmentManager fragmentManager = getSupportFragmentManager();\nFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n然后，您可以使用 add() 方法添加一个片段，指定要添加的片段以及将其插入哪个视图。例如：\n\nval fragment = ExampleFragment()\nfragmentTransaction.add(R.id.fragment_container, fragment)\nfragmentTransaction.commit()\nExampleFragment fragment = new ExampleFragment();\nfragmentTransaction.add(R.id.fragment_container, fragment);\nfragmentTransaction.commit();\n传递到 add() 的第一个参数是 ViewGroup，即应放置片段的位置，由资源 ID 指定，第二个参数是要添加的片段。\n\n一旦您通过 FragmentTransaction 做出了更改，就必须调用 commit() 以使更改生效。\n\n管理片段\n如要管理 Activity 中的片段，您需使用 FragmentManager。如要获取它，请从您的 Activity 调用 getSupportFragmentManager()。\n\n可使用 FragmentManager 执行的操作包括：\n\n通过 findFragmentById()（针对在 Activity 布局中提供界面的片段）或 findFragmentByTag()（针对提供或不提供界面的片段）获取 Activity 中存在的片段。\n通过 popBackStack()（模拟用户发出的返回命令）使片段从返回栈中弹出。\n通过 addOnBackStackChangedListener() 注册侦听返回栈变化的侦听器。\n如需了解有关这些方法以及其他方法的详细信息，请参阅 FragmentManager 类文档。\n\n如上文所述，您也可使用 FragmentManager 打开一个 FragmentTransaction，通过它来执行某些事务，如添加和移除片段。\n\n执行片段事务\n在 Activity 中使用片段的一大优点是，您可以通过片段执行添加、移除、替换以及其他操作，从而响应用户交互。提交给 Activity 的每组更改均称为事务，并且您可使用 FragmentTransaction 中的 API 来执行一项事务。您也可将每个事务保存到由 Activity 管理的返回栈内，从而让用户能够回退片段更改（类似于回退 Activity）。\n\n如下所示，您可以从 FragmentManager 获取一个 FragmentTransaction 实例：\n\nval fragmentManager = supportFragmentManager\nval fragmentTransaction = fragmentManager.beginTransaction()\nFragmentManager fragmentManager = getSupportFragmentManager();\nFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n每个事务都是您想要同时执行的一组更改。您可以使用 add()、remove() 和 replace() 等方法，为给定事务设置您想要执行的所有更改。然后，如要将事务应用到 Activity，您必须调用 commit()。\n\n不过，在调用 commit() 之前，您可能希望调用 addToBackStack()，以将事务添加到片段事务返回栈。该返回栈由 Activity 管理，允许用户通过按返回按钮返回上一片段状态。\n\n例如，以下示例说明如何将一个片段替换为另一个片段，以及如何在返回栈中保留先前的状态：\n\nval newFragment = ExampleFragment()\nval transaction = supportFragmentManager.beginTransaction()\ntransaction.replace(R.id.fragment_container, newFragment)\ntransaction.addToBackStack(null)\ntransaction.commit()\n// Create new fragment and transaction\nFragment newFragment = new ExampleFragment();\nFragmentTransaction transaction = getSupportFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,\n// and add the transaction to the back stack\ntransaction.replace(R.id.fragment_container, newFragment);\ntransaction.addToBackStack(null);// Commit the transaction\ntransaction.commit();\n在本例中，newFragment 会替换目前在 R.id.fragment_container ID 所标识的布局容器中的任何片段（如有）。通过调用 addToBackStack()，您可以将替换事务保存到返回栈，以便用户能够通过按返回按钮撤消事务并回退到上一片段。\n\n然后，FragmentActivity 会自动通过 onBackPressed() 从返回栈检索片段。\n\n如果您向事务添加多个更改（如又一个 add() 或 remove()），并调用 addToBackStack()，则调用 commit() 前应用的所有更改都将作为单一事务添加到返回栈，并且返回按钮会将它们一并撤消。\n\n向 FragmentTransaction 添加更改的顺序无关紧要，不过：\n\n您必须最后调用 commit()。\n如果您要向同一容器添加多个片段，则您添加片段的顺序将决定它们在视图层次结构中出现的顺序。\n如果您没有在执行删除片段的事务时调用 addToBackStack()，则事务提交时该片段会被销毁，用户将无法回退到该片段。不过，如果您在删除片段时调用 addToBackStack()，则系统会停止该片段，并随后在用户回退时将其恢复。\n\n提示：对于每个片段事务，您都可通过在提交前调用 setTransition() 来应用过渡动画。\n\n调用 commit() 不会立即执行事务，而是在 Activity 的界面线程（“主”线程）可执行该操作时，再安排该事务在线程上运行。不过，如有必要，您也可以从界面线程调用 executePendingTransactions()，以立即执行 commit() 提交的事务。通常不必这样做，除非其他线程中的作业依赖该事务。\n\n注意：您只能在 Activity 保存其状态（当用户离开 Activity）之前使用 commit() 提交事务。如果您试图在该时间点后提交，则会引发异常。这是因为如需恢复 Activity，则提交后的状态可能会丢失。对于丢失提交无关紧要的情况，请使用 commitAllowingStateLoss()。\n\n与 Activity 通信\n尽管 Fragment 作为独立于 FragmentActivity 的对象实现，并且可在多个 Activity 内使用，但片段的给定实例会直接绑定到托管该片段的 Activity。\n\n具体而言，片段可通过 getActivity() 访问 FragmentActivity 实例，并轻松执行在 Activity 布局中查找视图等任务：\n\n同样，您的 Activity 也可使用 findFragmentById() 或 findFragmentByTag()，通过从 FragmentManager 获取对 Fragment 的引用来调用片段中的方法。例如：\n\nval fragment = supportFragmentManager.findFragmentById(R.id.example_fragment) as ExampleFragment\nExampleFragment fragment = (ExampleFragment) getSupportFragmentManager().findFragmentById(R.id.example_fragment);\n创建 Activity 的事件回调\n在某些情况下，您可能需使用片段来与 Activity 和/或 Activity 托管的其他片段共享事件或数据。如要共享数据，请依照 ViewModel 指南中“在片段之间共享数据”部分所述，创建共享的 ViewModel。如需传播无法使用 ViewModel 处理的事件，则可改为在片段内定义回调接口，并要求宿主 Activity 实现此接口。当 Activity 通过该接口收到回调时，可根据需要与布局中的其他片段共享这些信息。\n\n例如，如果某个新闻应用的 Activity 有两个片段，其中一个用于显示文章列表（片段 A），另一个用于显示文章（片段 B），则片段 A 必须在列表项被选定后告知 Activity，以便它告知片段 B 显示该文章。在本例中，OnArticleSelectedListener 接口在片段 A 内进行声明：\n\npublic class FragmentA : ListFragment() {\n    ...\n    // Container Activity must implement this interface\n    interface OnArticleSelectedListener {\n        fun onArticleSelected(articleUri: Uri)\n    }\n    ...\n}\npublic static class FragmentA extends ListFragment {\n    ...\n    // Container Activity must implement this interface\n    public interface OnArticleSelectedListener {\n        public void onArticleSelected(Uri articleUri);\n    }\n    ...\n}\n然后，该片段的宿主 Activity 会实现 OnArticleSelectedListener 接口并重写 onArticleSelected()，将来自片段 A 的事件通知片段 B。为确保宿主 Activity 实现此接口，片段 A 的 onAttach() 回调方法（系统在向 Activity 添加片段时调用的方法）会通过转换传递到 onAttach() 中的 Activity 来实例化 OnArticleSelectedListener 的实例：\n\npublic class FragmentA : ListFragment() {var listener: OnArticleSelectedListener? = null\n    ...\n    override fun onAttach(context: Context) {\n        super.onAttach(context)\n        listener = context as? OnArticleSelectedListener\n        if (listener == null) {\n            throw ClassCastException(\"$context must implement OnArticleSelectedListener\")\n        }}\n    ...\n}\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener listener;\n    ...\n    @Override\n    public void onAttach(Context context) {\n        super.onAttach(context);\n        try {\n            listener = (OnArticleSelectedListener) context;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(context.toString() + \" must implement OnArticleSelectedListener\");\n        }\n    }\n    ...\n}\n如果 Activity 未实现接口，则片段会抛出 ClassCastException。若实现成功，mListener 成员会保留对 Activity 的 OnArticleSelectedListener 实现的引用，以便片段 A 可通过调用 OnArticleSelectedListener 接口定义的方法与 Activity 共享事件。例如，如果片段 A 是 ListFragment 的一个扩展，则用户每次点击列表项时，系统都会调用片段中的 onListItemClick()，然后该方法会通过调用 onArticleSelected() 与 Activity 共享事件：\n\npublic class FragmentA : ListFragment() {var listener: OnArticleSelectedListener? = null\n    ...\n    override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) {\n        // Append the clicked item's row ID with the content provider Uri\n        val noteUri: Uri = ContentUris.\nwithAppendedId\n(ArticleColumns.CONTENT_URI, id)\n        // Send the event and Uri to the host activity\n        listener?.onArticleSelected(noteUri)\n    }\n    ...\n}\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener listener;\n    ...\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Append the clicked item's row ID with the content provider Uri\n        Uri noteUri = ContentUris.\nwithAppendedId\n(ArticleColumns.CONTENT_URI, id);\n        // Send the event and Uri to the host activity\n        listener.onArticleSelected(noteUri);\n    }\n    ...\n}\n传递到 onListItemClick() 的 id 参数是被点击项的行 ID，即 Activity（或其他片段）用来从应用的 ContentProvider 获取文章的 ID。\n\n如需了解关于使用内容提供程序的详细信息，请参阅内容提供程序文档。\n\n向应用栏添加项目\n您的片段可通过实现 onCreateOptionsMenu() 向 Activity 的选项菜单（并因此向应用栏）贡献菜单项。不过，为使此方法能够收到调用，您必须在 onCreate() 期间调用 setHasOptionsMenu()，以指示片段想要向选项菜单添加菜单项。否则，片段不会收到对 onCreateOptionsMenu() 的调用。\n\n您之后从片段添加到选项菜单的任何菜单项都将追加到现有菜单项之后。选定菜单项时，片段还会收到对 onOptionsItemSelected() 的回调。\n\n您还可通过调用 registerForContextMenu()，在片段布局中注册一个视图来提供上下文菜单。当用户打开上下文菜单时，片段会收到对 onCreateContextMenu() 的调用。当用户选择某个菜单项时，片段会收到对 onContextItemSelected() 的调用。\n\n注意：尽管您的片段会收到与其添加的每个菜单项对应的 on-item-selected 回调，但当用户选择菜单项时，Activity 会首先收到相应的回调。如果 Activity 对 on-item-selected 回调的实现不处理选定的菜单项，则系统会将事件传递至片段的回调。这适用于选项菜单和上下文菜单。\n\n如需了解有关菜单的详细信息，请参阅菜单开发者指南和应用栏培训课程。\n\n处理片段生命周期\n\n\n图 3. Activity 生命周期对片段生命周期的影响。\n\n管理片段生命周期与管理 Activity 生命周期很相似。和 Activity 一样，片段也以三种状态存在：\n\n已恢复\n片段在运行中的 Activity 中可见。\n已暂停\n另一个 Activity 位于前台并具有焦点，但此片段所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。\n已停止\n片段不可见。宿主 Activity 已停止，或片段已从 Activity 中移除，但已添加到返回栈。已停止的片段仍处于活动状态（系统会保留所有状态和成员信息）。不过，它对用户不再可见，并随 Activity 的终止而终止。\n与 Activity 一样，您也可使用 onSaveInstanceState(Bundle)、ViewModel 和持久化本地存储的组合，在配置变更和进程终止后保留片段的界面状态。如要了解保留界面状态的更多信息，请参阅保存界面状态。\n\n对于 Activity 生命周期与片段生命周期而言，二者最显著的差异是在其各自返回栈中的存储方式。默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈中（以便用户通过返回按钮回退到 Activity，详细介绍请参阅任务和返回栈）。不过，只有当您在移除片段的事务执行期间通过调用 addToBackStack() 显式请求保存实例时，系统才会将片段放入由宿主 Activity 管理的返回栈。\n\n在其他方面，管理片段生命周期与管理 Activity 生命周期非常相似；对此，您可采取相同的做法。请参阅 Activity 生命周期指南和使用具有生命周期感知能力的组件处理生命周期，了解有关 Activity 生命周期及其管理措施的详情。\n\n注意：如果您的 Fragment 中需要 Context 对象，则可以调用 getContext()。但请注意，只有在该片段附加到 Activity 时才需调用 getContext()。如果尚未附加该片段，或者其在生命周期结束期间已分离，则 getContext() 返回 null。\n\n与 Activity 生命周期协调一致\n片段所在 Activity 的生命周期会直接影响片段的生命周期，其表现为，Activity 的每次生命周期回调都会引发每个片段的类似回调。例如，当 Activity 收到 onPause() 时，Activity 中的每个片段也会收到 onPause()。\n\n不过，片段还有几个额外的生命周期回调，用于处理与 Activity 的唯一交互，从而执行构建和销毁片段界面等操作。这些额外的回调方法是：\n\nonAttach()\n在片段已与 Activity 关联时进行调用（Activity 传递到此方法内）。\nonCreateView()\n调用它可创建与片段关联的视图层次结构。\nonActivityCreated()\n当 Activity 的 onCreate() 方法已返回时进行调用。\nonDestroyView()\n在移除与片段关联的视图层次结构时进行调用。\nonDetach()\n在取消片段与 Activity 的关联时进行调用。\n图 3 所示为受宿主 Activity 影响的片段生命周期流。在该图中，您可以看到 Activity 的每个连续状态如何确定片段可收到的回调方法。例如，当 Activity 收到其 onCreate() 回调时，Activity 中的片段只会收到 onActivityCreated() 回调。\n\n一旦 Activity 达到已恢复状态，您便可随意向 Activity 添加片段和移除其中的片段。因此，只有当 Activity 处于已恢复状态时，片段的生命周期才能独立变化。\n\n不过，当 Activity 离开已恢复状态时，片段会在 Activity 的推动下再次经历其生命周期。\n\n示例\n为将本文阐述的所有内容融会贯通，以下提供了一个示例，其中的 Activity 使用两个片段来创建一个双窗格布局。下面的 Activity 包括两个片段：一个用于显示莎士比亚戏剧标题列表，另一个用于在从列表中选定戏剧时显示其摘要。此外，它还展示了如何根据屏幕配置提供不同的片段配置。\n\n注意：有关此 Activity 的完整源代码，请参见示例应用，该应用展示了示例 FragmentLayout 类的用法。\n\n主 Activity 在 onCreate() 期间以常规方式应用布局：\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView\n\n(R.layout.fragment_layout)\n}\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView\n\n(R.layout.fragment_layout);\n}\n应用的布局为 fragment_layout.xml：\n\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"><fragment class=\"com.example.android.apis.app.FragmentLayout$TitlesFragment\"\n            android:id=\"@+id/titles\" android:layout_weight=\"1\"\n            android:layout_width=\"0px\" android:layout_height=\"match_parent\" /><FrameLayout android:id=\"@+id/details\" android:layout_weight=\"1\"\n            android:layout_width=\"0px\" android:layout_height=\"match_parent\"\n            android:background=\"?android:attr/detailsElementBackground\" /></LinearLayout>\n通过使用此布局，系统会在 Activity 加载布局时立即实例化 TitlesFragment（其列出了戏剧标题），而 FrameLayout（用于显示戏剧摘要的片段所在位置）则会占用屏幕右侧的空间，但最初处于空白状态。如下文所示，只有当用户从列表中选择某个项目后，系统才会将片段放入 FrameLayout。\n\n不过，并非所有屏幕配置都具有足够的宽度，可以一同显示戏剧列表和摘要。因此，以上布局仅用于横向屏幕配置（布局保存在 res/layout-land/fragment_layout.xml 中）。\n\n因此，当屏幕纵向显示时，系统会应用以下布局（保存在 res/layout/fragment_layout.xml 中）：\n\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\">\n    <fragment class=\"com.example.android.apis.app.FragmentLayout$TitlesFragment\"\n            android:id=\"@+id/titles\"\n            android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" />\n</FrameLayout>\n此布局仅包括 TitlesFragment。这意味着，当设备纵向显示时，用户只能看到戏剧标题列表。因此，当用户在此配置中点击某个列表项时，应用会启动一个新 Activity 来显示摘要，而非加载另一个片段。\n\n接下来，您将了解如何在片段类中实现此目的。第一个片段是 TitlesFragment，用于显示莎士比亚戏剧标题列表。该片段扩展了 ListFragment，并依靠它来处理大多数列表视图工作。\n\n当您检查此代码时，请注意，用户点击列表项时可能会出现两种行为：系统可能会创建并显示一个新片段，从而在同一 Activity 中显示详细信息（将片段添加到 FrameLayout），也可能会启动一个新 Activity（在该 Activity 中可显示片段），具体取决于这两个布局中哪一个处于活动状态。\n\nclass TitlesFragment : ListFragment() {private var dualPane: Boolean = false\n    private var curCheckPosition = 0override fun onActivityCreated(savedInstanceState: Bundle?) {\n        super.onActivityCreated(savedInstanceState)// Populate list with our static array of titles.\n        listAdapter = ArrayAdapter<String>(\n                activity,\n                android.R.layout.simple_list_item_activated_1,\n                Shakespeare.TITLES\n        )// Check to see if we have a frame in which to embed the details\n        // fragment directly in the containing UI.\n        val detailsFrame: View? = activity?.findViewById(R.id.details)\n        dualPane = detailsFrame?.visibility == View.VISIBLE\n        curCheckPosition \n\n= savedInstanceState?.getInt(\"curChoice\", 0) ?: 0if (dualPane) {\n            // In dual-pane mode, the list view highlights the selected item.\n            listView.choiceMode = ListView.CHOICE_MODE_SINGLE\n            // Make sure our UI is in the correct state.\n            showDetails(curCheckPosition)\n        }\n    }override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        outState.putInt(\"curChoice\", curCheckPosition)\n    }override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) {\n        showDetails(position)\n    }/**\n     * Helper function to show the details of a selected item, either by\n     * displaying a fragment in-place in the current UI, or starting a\n     * whole new activity in which it is displayed.\n     */\n    private fun showDetails(index: Int) {\n        curCheckPosition = indexif (dualPane) {\n            // We can display everything in-place with fragments, so update\n            // the list to highlight the selected item and show the data.\n            listView.setItemChecked(index, true)// Check what fragment is currently shown, replace if needed.\n            var details = fragmentManager?.findFragmentById(R.id.details) as? DetailsFragment\n            if (details?.shownIndex != index) {\n                // Make new fragment to show this selection.\n                details = DetailsFragment.newInstance(index)// Execute a transaction, replacing any existing fragment\n                // with this one inside the frame.\n                fragmentManager?.beginTransaction()?.apply {\n                    if (index == 0) {\n                        replace(R.id.details, details)\n                    } else {\n                        replace(R.id.a_item, details)\n                    }\n                    setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)\n                    commit()\n                }\n            }} else {\n            // Otherwise we need to launch a new activity to display\n            // the dialog fragment with selected text.\n            val intent = Intent().apply {\n                setClass(activity, DetailsActivity::class.java)\n                putExtra(\"index\", index)\n            }\n            startActivity(intent)\n        }\n    }\n}\npublic static class TitlesFragment extends ListFragment {\n    boolean dualPane;\n    int curCheckPosition = 0;@Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);// Populate list with our static array of titles.\n        setListAdapter(new ArrayAdapter<String>(getActivity(),\n                android.R.layout.simple_list_item_activated_1, Shakespeare.TITLES));// Check to see if we have a frame in which to embed the details\n        // fragment directly in the containing UI.\n        View detailsFrame = getActivity().findViewById(R.id.details);\n        dualPane = detailsFrame != null && detailsFrame.getVisibility() == View.VISIBLE;if (savedInstanceState != null) {\n            // Restore last state for checked position.\n            curCheckPosition = savedInstanceState.getInt(\"curChoice\", 0);\n        }if (dualPane) {\n            // In dual-pane mode, the list view highlights the selected item.\n            getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);\n            // Make sure our UI is in the correct state.\n            showDetails(curCheckPosition);\n        }\n    }@Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(\"curChoice\", curCheckPosition);\n    }@Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        showDetails(position);\n    }/**\n     * Helper function to show the details of a selected item, either by\n     * displaying a fragment in-place in the current UI, or starting a\n     * whole new activity in which it is displayed.\n     */\n    void showDetails(int index) {\n        curCheckPosition = index;if (dualPane) {\n            // We can display everything in-place with fragments, so update\n            // the list to highlight the selected item and show the data.\n            getListView().setItemChecked(index, true);// Check what fragment is currently shown, replace if needed.\n            DetailsFragment details = (DetailsFragment)\n                    getSupportFragmentManager().findFragmentById(R.id.details);\n            if (details == null || details.getShownIndex() != index) {\n                // Make new fragment to show this selection.\n                details = DetailsFragment.newInstance(index);// Execute a transaction, replacing any existing fragment\n                // with this one inside the frame.\n                FragmentTransaction ft = getSupportFragmentManager().beginTransaction();\n                if (index == 0) {\n                    ft.replace(R.id.details, details);\n                } else {\n                    ft.replace(R.id.a_item, details);\n                }\n                ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);\n                ft.commit();\n            }} else {\n            // Otherwise we need to launch a new activity to display\n            // the dialog fragment with selected text.\n            Intent intent = new Intent();\n            intent.setClass(getActivity(), DetailsActivity.class);\n            intent.putExtra(\"index\", index);\n            startActivity(intent);\n        }\n    }\n}\n第二个片段 DetailsFragment 显示从 TitlesFragment 的列表中选择的项目的戏剧摘要：\n\n    class DetailsFragment : Fragment() {val shownIndex: Int by lazy {\n            arguments?.getInt(\"index\", 0) ?: 0\n        }override fun onCreateView(\n                inflater: LayoutInflater,\n                container: ViewGroup?,\n                savedInstanceState: Bundle?\n        ): View? {\n            if (container == null) {\n                // We have different layouts, and in one of them this\n                // fragment's containing frame doesn't exist. The fragment\n                // may still be created from its saved state, but there is\n                // no reason to try to create its view hierarchy because it\n                // isn't displayed. Note this isn't needed -- we could just\n                // run the code below, where we would create and return the\n                // view hierarchy; it would just never be used.\n                return null\n            }val text = TextView(activity).apply {\n                val padding: Int = TypedValue.applyDimension(\n                        TypedValue.COMPLEX_UNIT_DIP,\n                        4f,\n                        activity?.resources?.displayMetrics\n                ).toInt()\n                setPadding(padding, padding, padding, padding)\n                text = Shakespeare.DIALOGUE[shownIndex]\n            }\n            return ScrollView(activity).apply {\n                addView(text)\n            }\n        }companion object {\n            /**\n             * Create a new instance of DetailsFragment, initialized to\n             * show the text at 'index'.\n             */\n            fun newInstance(index: Int): DetailsFragment {\n                val f = DetailsFragment()// Supply index input as an argument.\n                val args = Bundle()\n                args.putInt(\"index\", index)\n                f.arguments = argsreturn f\n            }\n        }\n    }\n}\npublic static class DetailsFragment extends Fragment {\n    /**\n     * Create a new instance of DetailsFragment, initialized to\n     * show the text at 'index'.\n     */\n    public static DetailsFragment newInstance(int index) {\n        DetailsFragment f = new DetailsFragment();// Supply index input as an argument.\n        Bundle args = new Bundle();\n        args.putInt(\"index\", index);\n        f.setArguments(args);return f;\n    }public int getShownIndex() {\n        return getArguments().getInt(\"index\", 0);\n    }@Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n        if (container == null) {\n            // We have different layouts, and in one of them this\n            // fragment's containing frame doesn't exist. The fragment\n            // may still be created from its saved state, but there is\n            // no reason to try to create its view hierarchy because it\n            // isn't displayed. Note this isn't needed -- we could just\n            // run the code below, where we would create and return the\n            // view hierarchy; it would just never be used.\n            return null;\n        }ScrollView scroller = new ScrollView(getActivity());\n        TextView text = new TextView(getActivity());\n        int padding = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,\n                4, getActivity().getResources().getDisplayMetrics());\n        text.setPadding(padding, padding, padding, padding);\n        scroller.addView(text);\n        text.setText(Shakespeare.DIALOGUE[getShownIndex()]);\n        return scroller;\n    }\n}\n从 TitlesFragment 类中重新调用，如果用户点击某个列表项，且当前布局不包括 R.id.details 视图（即 DetailsFragment 所属视图），则应用会启动 DetailsActivity Activity 以显示该项目的内容。\n\n以下是 DetailsActivity，它通过简单嵌入 DetailsFragment，在屏幕为纵向时显示所选的戏剧摘要：\n\nclass DetailsActivity : FragmentActivity() {override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {\n            // If the screen is now in landscape mode, we can show the\n            // dialog in-line with the list so we don't need this activity.\n            finish()\n            return\n        }if (savedInstanceState == null) {\n            // During initial setup, plug in the details fragment.\n            val details = DetailsFragment().apply {\n                arguments = intent.extras\n            }\n            supportFragmentManager.beginTransaction()\n                    .add(android.R.id.content, details)\n                    .commit()\n        }\n    }\n}\npublic static class DetailsActivity extends FragmentActivity {@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);if (getResources().getConfiguration().orientation\n                == Configuration.ORIENTATION_LANDSCAPE) {\n            // If the screen is now in landscape mode, we can show the\n            // dialog in-line with the list so we don't need this activity.\n            finish();\n            return;\n        }if (savedInstanceState == null) {\n            // During initial setup, plug in the details fragment.\n            DetailsFragment details = new DetailsFragment();\n            details.setArguments(getIntent().getExtras());\n            getSupportFragmentManager().beginTransaction().add(android.R.id.content, details).commit();\n        }\n    }\n}\n请注意，如果配置为横向，则此 Activity 会自行完成，这样主 Activity 便可接受并显示 TitlesFragment 和 DetailsFragment。如果用户在纵向模式下启动 DetailsActivity，但随后将设备旋转为横向（这会重启当前 Activity），则可能会出现这种情况。\n\n其他资源\nSunflower 演示应用中使用了 Fragment。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243442162},"updatedAt":{"$$date":1597243806669},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Ar9evxKFEuNkeo8j"}
{"name":"andr-可绘制对象","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"developer.android.google.cn /guide/topics/resources/drawable-resource\n可绘制对象资源 | Android 开发者 | Android Developers\n27-34 minutes\n可绘制对象资源是图形的一般概念，是指可在屏幕上绘制的图形，以及可使用 getDrawable(int) 等 API 检索，或应用到拥有 android:drawable 和 android:icon 等属性的其他 XML 资源的图形。可绘制对象包含以下多种类型：\n\n位图文件\n位图图形文件（.png、.jpg 或 .gif）。创建 BitmapDrawable。\n九宫格文件\n具有可伸缩区域的 PNG 文件，支持根据内容调整图像大小 (.9.png)。创建 NinePatchDrawable。\n图层列表\n管理其他可绘制对象阵列的可绘制对象。这些可绘制对象按阵列顺序绘制，因此索引最大的元素绘制于顶部。创建 LayerDrawable。\n状态列表\n此 XML 文件用于为不同状态引用不同位图图形（例如，按下按钮时使用不同图像）。创建 StateListDrawable。\n级别列表\n此 XML 文件用于定义管理大量备选可绘制对象的可绘制对象，每个可绘制对象都配有最大备选数量。创建 LevelListDrawable。\n转换可绘制对象\n此 XML 文件用于定义可在两种可绘制对象资源之间交错淡出的可绘制对象。创建 TransitionDrawable。\n插入可绘制对象\n此 XML 文件用于定义以指定距离插入其他可绘制对象的可绘制对象。当视图需要小于视图实际边界的背景可绘制对象时，此类可绘制对象非常有用。\n裁剪可绘制对象\n此 XML 文件用于定义对其他可绘制对象进行裁剪（根据其当前级别值）的可绘制对象。创建 ClipDrawable。\n缩放可绘制对象\n此 XML 文件用于定义更改其他可绘制对象大小（根据其当前级别值）的可绘制对象。创建 ScaleDrawable\n形状可绘制对象\n此 XML 文件用于定义几何形状（包括颜色和渐变）。创建 GradientDrawable。\n另请参阅动画资源文档，了解如何创建 AnimationDrawable。\n\n请注意：颜色资源也可用作 XML 中的可绘制对象。例如，在创建状态列表可绘制对象时，可以引用 android:drawable 属性的颜色资源 (android:drawable=\"@color/green\")。\n\n位图\n位图图像。Android 支持以下三种格式的位图文件：.png（首选）、.jpg（可接受）、.gif（不建议）。\n\n您可以使用文件名作为资源 ID 直接引用位图文件，也可以在 XML 中创建别名资源 ID。\n\n注：在构建过程中，可通过 aapt 工具自动优化位图文件，对图像进行无损压缩。例如，不需要超过 256 色的真彩色 PNG 可通过调色板转换为 8 位 PNG。这样产生的图像质量相同，但所需内存更少。因此请注意，此目录中的图像二进制文件在构建时可能会发生变化。如果您打算以比特流的形式读取图像，进而将其转换为位图，请改为将图像放在 res/raw/ 文件夹中，避免系统对其进行优化。\n\n位图文件\n位图文件是 .png、.jpg 或 .gif 文件。当您将任一位图文件保存到 res/drawable/ 目录中时，Android 会为其创建 Drawable 资源。\n\n文件位置：\nres/drawable/filename.png（.png、.jpg 或 .gif）\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 BitmapDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n示例：\n当图像保存为 res/drawable/myimage.png 后，此布局 XML 会将该图像应用至视图：\n<ImageView\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:src=\"@drawable/myimage\" />\n以下应用代码将图像作为 Drawable 进行检索：\n\nval drawable: Drawable? = ResourcesCompat.\ngetDrawable\n(resources, R.drawable.myimage, null)\nResources res = \ngetResources()\n;\nDrawable drawable = ResourcesCompat.\ngetDrawable\n(res, R.drawable.myimage, null);\n另请参阅：\n2D 图形\nBitmapDrawable\nXML 位图\nXML 位图是在 XML 文件中定义的资源，指向位图文件。实际上是原始位图文件的别名。XML 可以指定位图的其他属性，例如抖动和层叠。\n\n注：您可以将 <bitmap> 元素用作 <item> 元素的子项。例如，在创建状态列表或图层列表时，可以将 android:drawable 属性从 <item> 元素中排除，并在其中嵌套用于定义可绘制项的 <bitmap>。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 BitmapDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<bitmap\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:src=\"@[package:]drawable/drawable_resource\"\n    android:antialias=[\"true\" | \"false\"]\n    android:dither=[\"true\" | \"false\"]\n    android:filter=[\"true\" | \"false\"]\n    android:gravity=[\"top\" | \"bottom\" | \"left\" | \"right\" | \"center_vertical\" |\n                      \"fill_vertical\" | \"center_horizontal\" | \"fill_horizontal\" |\n                      \"center\" | \"fill\" | \"clip_vertical\" | \"clip_horizontal\"]\n    android:mipMap=[\"true\" | \"false\"]\n    android:tileMode=[\"disabled\" | \"clamp\" | \"repeat\" | \"mirror\"] />\n元素：\n<bitmap>\n定义位图来源及其属性。\n属性：\n\nxmlns:android\n字符串。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。这仅当 <bitmap> 是根元素时才需要，当 <bitmap> 嵌套在 <item> 内时不需要。\nandroid:src\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:antialias\n布尔值。启用或停用抗锯齿。\nandroid:dither\n布尔值。当位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕），启用或停用位图抖动。\nandroid:filter\n布尔值。启用或停用位图过滤。当位图收缩或拉伸以使其外观平滑时使用过滤。\nandroid:gravity\n关键字。定义位图的重力。重力指示当位图小于容器时，可绘制对象在其容器中放置的位置。\n必须是以下一个或多个（用 '|' 分隔）常量值：\n\n值\t说明\ntop\t将对象放在其容器顶部，不改变其大小。\nbottom\t将对象放在其容器底部，不改变其大小。\nleft\t将对象放在其容器左边缘，不改变其大小。\nright\t将对象放在其容器右边缘，不改变其大小。\ncenter_vertical\t将对象放在其容器的垂直中心，不改变其大小。\nfill_vertical\t按需要扩展对象的垂直大小，使其完全适应其容器。\ncenter_horizontal\t将对象放在其容器的水平中心，不改变其大小。\nfill_horizontal\t按需要扩展对象的水平大小，使其完全适应其容器。\ncenter\t将对象放在其容器的水平和垂直轴中心，不改变其大小。\nfill\t按需要扩展对象的垂直大小，使其完全适应其容器。这是默认值。\nclip_vertical\t可设置为让子元素的上边缘和/或下边缘裁剪至其容器边界的附加选项。裁剪基于垂直重力：顶部重力裁剪上边缘，底部重力裁剪下边缘，任一重力不会同时裁剪两边。\nclip_horizontal\t可设置为让子元素的左边和/或右边裁剪至其容器边界的附加选项。裁剪基于水平重力：左边重力裁剪右边缘，右边重力裁剪左边缘，任一重力不会同时裁剪两边。\nandroid:mipMap\n布尔值。启用或停用 mipmap 提示。如需了解详情，请参阅 setHasMipMap()。默认值为 false。\nandroid:tileMode\n关键字。定义平铺模式。当平铺模式启用时，位图会重复。重力在平铺模式启用时将被忽略。\n必须是以下常量值之一：\n\n值\t说明\ndisabled\t不平铺位图。这是默认值。\nclamp\t当着色器绘制范围超出其原边界时复制边缘颜色\nrepeat\t水平和垂直重复着色器的图像。\nmirror\t水平和垂直重复着色器的图像，交替镜像图像以使相邻图像始终相接。\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:src=\"@drawable/icon\"\n    android:tileMode=\"repeat\" />\n另请参阅：\nBitmapDrawable\n创建别名资源\n九宫格\nNinePatch 是一种 PNG 图像，您可在其中定义可伸缩区域，以便 Android 在视图中的内容超出正常图像边界时进行缩放。此类图像通常指定为至少有一个尺寸设置为 \"wrap_content\" 的视图背景，而且当视图通过扩展来适应内容时，九宫格图像也会通过扩展来匹配视图的大小。举例而言，Android 的标准 Button 微件所使用的背景便是典型的九宫格图像，其必须通过伸缩来适应按钮内的文本（或图像）。\n\n与普通位图一样，您可直接引用九宫格文件，也可通过 XML 定义资源对其进行引用。\n\n如需完整了解如何创建包含可伸缩区域的九宫格文件，请参阅 2D 图形文件。\n\n九宫格文件\n文件位置：\nres/drawable/filename.9.png\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 NinePatchDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n示例：\n当图像保存为 res/drawable/myninepatch.9.png 后，此布局 XML 会将九宫格应用到视图：\n<Button\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:background=\"@drawable/myninepatch\" />\n另请参阅：\n2D 图形\nNinePatchDrawable\nXML 九宫格\nXML 九宫格是在 XML 中定义的资源，指向九宫格文件。XML 可以为图像指定抖动。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 NinePatchDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<nine-patch\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:src=\"@[package:]drawable/drawable_resource\"\n    android:dither=[\"true\" | \"false\"] />\n元素：\n<nine-patch>\n定义九宫格来源及其属性。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:src\n可绘制对象资源。必备。引用九宫格文件。\nandroid:dither\n布尔值。当位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕），启用或停用位图抖动。\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<nine-patch xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:src=\"@drawable/myninepatch\"\n    android:dither=\"false\" />\n图层列表\nLayerDrawable 是管理其他可绘制对象阵列的可绘制对象。列表中的每个可绘制对象均按照列表顺序绘制，列表中的最后一个可绘制对象绘于顶部。\n\n每个可绘制对象由单一 <layer-list> 元素内的 <item> 元素表示。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 LayerDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list\n    xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item\n        android:drawable=\"@[package:]drawable/drawable_resource\"\n        android:id=\"@[+][package:]id/resource_name\"\n        android:top=\"dimension\"\n        android:right=\"dimension\"\n        android:bottom=\"dimension\"\n        android:left=\"dimension\" />\n</layer-list>\n元素：\n<layer-list>\n必备。这必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\n<item>\n定义放于图层可绘制对象中由其属性所定义位置的可绘制对象。必须是 <layer-list> 元素的子项。接受子 <bitmap> 元素。\n属性：\n\nandroid:drawable\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:id\n资源 ID。此可绘制对象的唯一资源 ID。要为此项新建资源 ID，请使用以下形式：\"@+id/name\"。加号表示应创建为新 ID。您可以使用此 ID 检索和修改拥有 View.findViewById() 或 Activity.findViewById() 的可绘制对象。\nandroid:top\n整型。顶部偏移（像素）。\nandroid:right\n整型。右边偏移（像素）。\nandroid:bottom\n整型。底部偏移（像素）。\nandroid:left\n整型。左边偏移（像素）。\n默认情况下，所有可绘制项都会缩放以适应包含视图的大小。因此，将图像放在图层列表中的不同位置可能会增大视图的大小，并且有些图像会相应地缩放。为避免缩放列表中的项目，请在 <item> 元素内使用 <bitmap> 元素指定可绘制对象，并且对某些不缩放的项目（例如 \"center\"）定义重力。例如，以下 <item> 定义缩放以适应其容器视图的项目：\n\n<item android:drawable=\"@drawable/image\" />\n为避免缩放，以下示例使用重力居中的 <bitmap> 元素：\n\n<item>\n  <bitmap android:src=\"@drawable/image\"\n          android:gravity=\"center\" />\n</item>\n示例：\nXML 文件保存在 res/drawable/layers.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item>\n      <bitmap android:src=\"@drawable/android_red\"\n        android:gravity=\"center\" />\n    </item>\n    <item android:top=\"10dp\" android:left=\"10dp\">\n      <bitmap android:src=\"@drawable/android_green\"\n        android:gravity=\"center\" />\n    </item>\n    <item android:top=\"20dp\" android:left=\"20dp\">\n      <bitmap android:src=\"@drawable/android_blue\"\n        android:gravity=\"center\" />\n    </item>\n</layer-list>\n请注意，此示例使用嵌套的 <bitmap> 元素为每个具有“中心”重力的项目定义可绘制对象资源。这可确保没有图像会为了适应容器的大小而缩放，因为偏移图像会造成大小调整。\n\n此布局 XML 会将可绘制对象应用到视图：\n\n<ImageView\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:src=\"@drawable/layers\" />\n结果是一堆不断偏移的图像：\n\n\n另请参阅：\nLayerDrawable\n状态列表\nStateListDrawable 是在 XML 文件中定义的可绘制对象，它会根据对象状态，使用多个不同的图像来表示同一个图形。例如，Button 微件可以是多种不同状态（按下、聚焦或这两种状态都不是）中的其中一种，并且您可利用状态列表可绘制对象，为每种状态提供不同的背景图片。\n\n您可以在 XML 文件中描述状态列表。每个图形由单一 <selector> 元素内的 <item> 元素表示。每个 <item> 均使用各种属性来描述应用作可绘制对象的图形的状态。\n\n在每个状态变更期间，将从上到下遍历状态列表，并使用第一个与当前状态匹配的项目 —此选择并非基于“最佳匹配”，而是选择符合状态最低条件的第一个项目。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 StateListDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:constantSize=[\"true\" | \"false\"]\n    android:dither=[\"true\" | \"false\"]\n    android:variablePadding=[\"true\" | \"false\"] >\n    <item\n        android:drawable=\"@[package:]drawable/drawable_resource\"\n        android:state_pressed=[\"true\" | \"false\"]\n        android:state_focused=[\"true\" | \"false\"]\n        android:state_hovered=[\"true\" | \"false\"]\n        android:state_selected=[\"true\" | \"false\"]\n        android:state_checkable=[\"true\" | \"false\"]\n        android:state_checked=[\"true\" | \"false\"]\n        android:state_enabled=[\"true\" | \"false\"]\n        android:state_activated=[\"true\" | \"false\"]\n        android:state_window_focused=[\"true\" | \"false\"] />\n</selector>\n元素：\n<selector>\n必备。这必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:constantSize\n布尔值。如果可绘制对象报告的内部大小在状态变更时保持不变，则值为“true”（大小是所有状态的最大值）；如果大小根据当前状态而变化，则值为“false”。默认值为 false。\nandroid:dither\n布尔值。值为“true”时，将在位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕）启用位图的抖动；值为“false”时则停用抖动。默认值为 true。\nandroid:variablePadding\n布尔值。如果可绘制对象的内边距应根据选择的当前状态而变化，则值为“true”；如果内边距应保持不变（基于所有状态的最大内边距），则值为“false”。启用此功能要求您在状态变更时处理执行布局，这通常不受支持。默认值为 false。\n<item>\n定义要在某些状态期间使用的可绘制对象，如其属性所述。必须是 <selector> 元素的子项。\n属性：\n\nandroid:drawable\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:state_pressed\n布尔值。如果在按下对象（例如触摸/点按某按钮）时应使用此项目，则值为“true”；如果在默认的未按下状态时应使用此项目，则值为“false”。\nandroid:state_focused\n布尔值。如果在对象具有输入焦点（例如当用户选择文本输入时）时应使用此项目，则值为“true”；如果在默认的非焦点状态时应使用此项目，则值为“false”。\nandroid:state_hovered\n布尔值。如果当光标悬停在对象上时应使用此项目，则值为“true”；如果在默认的非悬停状态时应使用此项目，则值为“false”。通常，这个可绘制对象可能与用于“聚焦”状态的可绘制对象相同。\n此项为 API 级别 14 新引入的配置。\n\nandroid:state_selected\n布尔值。如果在使用定向控件浏览（例如使用方向键浏览列表）的情况下对象为当前用户选择时应使用此项目，则值为“true”；如果在未选择对象时应使用此项目，则值为“false”。\n当焦点 (android:state_focused) 不充分（例如，列表视图有焦点但使用方向键选择其中的项目）时，使用所选状态。\n\nandroid:state_checkable\n布尔值。如果当对象可选中时应使用此项目，则值为“true”；如果当对象不可选中时应使用此项目，则值为“false”。（仅当对象可在可选中与不可选中小部件之间转换时才有用。）\nandroid:state_checked\n布尔值。如果在对象已选中时应使用此项目，则值为“true”；如果在对象未选中时应使用此项目，则值为“false”。\nandroid:state_enabled\n布尔值。如果在对象启用（能够接收触摸/点击事件）时应使用此项目，则值为“true”；如果在对象停用时应使用此项目，则值为“false”。\nandroid:state_activated\n布尔值。如果在对象激活作为持续选择（例如，在持续导航视图中“突出显示”之前选中的列表项）时应使用此项目，则值为“true”；如果在对象未激活时应使用此项目，则值为“false”。\n此项为 API 级别 11 新引入的配置。\n\nandroid:state_window_focused\n布尔值。如果当应用窗口有焦点（应用在前台）时应使用此项目，则值为“true”；如果当应用窗口没有焦点（例如，通知栏下拉或对话框出现）时应使用此项目，则值为“false”。\n注：请记住，Android 将应用状态列表中第一个与对象当前状态匹配的项目。因此，如果列表中的第一个项目不含上述任何状态属性，则每次都会应用它，这就是默认值应始终放在最后的原因（如以下示例所示）。\n\n示例：\nXML 文件保存在 res/drawable/button.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:state_pressed=\"true\"\n          android:drawable=\"@drawable/button_pressed\" /> <!-- pressed -->\n    <item android:state_focused=\"true\"\n          android:drawable=\"@drawable/button_focused\" /> <!-- focused -->\n    <item android:state_hovered=\"true\"\n          android:drawable=\"@drawable/button_focused\" /> <!-- hovered -->\n    <item android:drawable=\"@drawable/button_normal\" /> <!-- default -->\n</selector>\n此布局 XML 将状态列表可绘制对象应用到按钮：\n\n<Button\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:background=\"@drawable/button\" />\n另请参阅：\nStateListDrawable\n级别列表\n管理大量备选可绘制对象的可绘制对象，每个可绘制对象都配有最大备选数量。若使用 setLevel() 设置可绘制对象的级别值，则会加载级别列表中 android:maxLevel 值大于或等于传递至方法的值的可绘制对象资源。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 LevelListDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<level-list\n    xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item\n        android:drawable=\"@drawable/drawable_resource\"\n        android:maxLevel=\"integer\"\n        android:minLevel=\"integer\" />\n</level-list>\n元素：\n<level-list>\n这必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\n<item>\n定义要在某特定级别使用的可绘制对象。\n属性：\n\nandroid:drawable\n可绘制对象资源。必备。引用要插入的可绘制对象资源。\nandroid:maxLevel\n整型。此项目允许的最高级别。\nandroid:minLevel\n整型。此项目允许的最低级别。\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<level-list xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item\n        android:drawable=\"@drawable/status_off\"\n        android:maxLevel=\"0\" />\n    <item\n        android:drawable=\"@drawable/status_on\"\n        android:maxLevel=\"1\" />\n</level-list>\n在将此项目应用到 View 后，您便可通过 setLevel() 或 setImageLevel() 更改级别。\n\n另请参阅：\nLevelListDrawable\n转换可绘制对象\nTransitionDrawable 是可在两种可绘制对象资源之间交错淡出的可绘制对象。\n\n每个可绘制对象由单个 <transition> 元素内的 <item> 元素表示。不支持超过两个项目。如要向前转换，请调用 startTransition()。如要向后转换，则调用 reverseTransition()。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 TransitionDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<transition\nxmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item\n        android:drawable=\"@[package:]drawable/drawable_resource\"\n        android:id=\"@[+][package:]id/resource_name\"\n        android:top=\"dimension\"\n        android:right=\"dimension\"\n        android:bottom=\"dimension\"\n        android:left=\"dimension\" />\n</transition>\n元素：\n<transition>\n必备。这必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\n<item>\n定义要用作可绘制对象转换一部分的可绘制对象。必须是 <transition> 元素的子项。接受子 <bitmap> 元素。\n属性：\n\nandroid:drawable\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:id\n资源 ID。此可绘制对象的唯一资源 ID。要为此项新建资源 ID，请使用以下形式：\"@+id/name\"。加号表示应创建为新 ID。您可以使用此 ID 检索和修改拥有 View.findViewById() 或 Activity.findViewById() 的可绘制对象。\nandroid:top\n整型。顶部偏移（像素）。\nandroid:right\n整型。右边偏移（像素）。\nandroid:bottom\n整型。底部偏移（像素）。\nandroid:left\n整型。左边偏移（像素）。\n示例：\nXML 文件保存在 res/drawable/transition.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<transition xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:drawable=\"@drawable/on\" />\n    <item android:drawable=\"@drawable/off\" />\n</transition>\n此布局 XML 会将可绘制对象应用到视图：\n\n<ImageButton\n    android:id=\"@+id/button\"\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\"\n    android:src=\"@drawable/transition\" />\n以下代码会执行从第一个项目到第二个项目的 500ms 转换：\n\nval button: ImageButton = findViewById(R.id.button)\nval drawable: Drawable = button.drawable\nif (drawable is TransitionDrawable) {\n    drawable.startTransition(500)\n}\nImageButton button = (ImageButton) findViewById(R.id.button);\nDrawable drawable = button.getDrawable();\nif (drawable instanceof TransitionDrawable) {\n    ((TransitionDrawable) drawable).startTransition(500);\n}\n另请参阅：\nTransitionDrawable\n插入可绘制对象\n在 XML 文件中定义，以指定距离插入其他可绘制对象的可绘制对象。当视图需要小于视图实际边界的背景时，此类可绘制对象很有用。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 InsetDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<inset\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/drawable_resource\"\n    android:insetTop=\"dimension\"\n    android:insetRight=\"dimension\"\n    android:insetBottom=\"dimension\"\n    android:insetLeft=\"dimension\" />\n元素：\n<inset>\n定义插入可绘制对象。这必须是根元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:drawable\n可绘制对象资源。必备。引用要插入的可绘制对象资源。\nandroid:insetTop\n尺寸。顶部插入，表示为尺寸值或尺寸资源\nandroid:insetRight\n尺寸。右边插入，表示为尺寸值或尺寸资源\nandroid:insetBottom\n尺寸。底部插入，表示为尺寸值或尺寸资源\nandroid:insetLeft\n尺寸。左边插入，表示为尺寸值或尺寸资源\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<inset xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/background\"\n    android:insetTop=\"10dp\"\n    android:insetLeft=\"10dp\" />\n另请参阅：\nInsetDrawable\n裁剪可绘制对象\n在 XML 文件中定义，对其他可绘制对象进行裁剪（根据其当前级别）的可绘制对象。您可以根据级别以及用于控制其在整个容器中位置的重力，来控制子可绘制对象的裁剪宽度和高度。通常用于实现进度栏之类的项目。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 ClipDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<clip\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/drawable_resource\"\n    android:clipOrientation=[\"horizontal\" | \"vertical\"]\n    android:gravity=[\"top\" | \"bottom\" | \"left\" | \"right\" | \"center_vertical\" |\n                     \"fill_vertical\" | \"center_horizontal\" | \"fill_horizontal\" |\n                     \"center\" | \"fill\" | \"clip_vertical\" | \"clip_horizontal\"] />\n元素：\n<clip>\n定义裁剪可绘制对象。这必须是根元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:drawable\n可绘制对象资源。必备。引用要裁剪的可绘制对象资源。\nandroid:clipOrientation\n关键字。裁剪方向。\n必须是以下常量值之一：\n\n值\t说明\nhorizontal\t水平裁剪可绘制对象。\nvertical\t垂直裁剪可绘制对象。\nandroid:gravity\n关键字。指定可绘制对象中要裁剪的位置。\n必须是以下一个或多个（用 '|' 分隔）常量值：\n\n值\t说明\ntop\t将对象放在其容器顶部，不改变其大小。当 clipOrientation 是 \"vertical\" 时，在可绘制对象的底部裁剪。\nbottom\t将对象放在其容器底部，不改变其大小。当 clipOrientation 是 \"vertical\" 时，在可绘制对象的顶部裁剪。\nleft\t将对象放在其容器左边缘，不改变其大小。这是默认值。当 clipOrientation 是 \"horizontal\" 时，在可绘制对象的右边裁剪。这是默认值。\nright\t将对象放在其容器右边缘，不改变其大小。当 clipOrientation 是 \"horizontal\" 时，在可绘制对象的左边裁剪。\ncenter_vertical\t将对象放在其容器的垂直中心，不改变其大小。裁剪行为与重力为 \"center\" 时相同。\nfill_vertical\t按需要扩展对象的垂直大小，使其完全适应其容器。当 clipOrientation 是 \"vertical\" 时，不会进行裁剪，因为可绘制对象会填充垂直空间（除非可绘制对象级别为 0，此时它不可见）。\ncenter_horizontal\t将对象放在其容器的水平中心，不改变其大小。裁剪行为与重力为 \"center\" 时相同。\nfill_horizontal\t按需要扩展对象的水平大小，使其完全适应其容器。当 clipOrientation 是 \"horizontal\" 时，不会进行裁剪，因为可绘制对象会填充水平空间（除非可绘制对象级别为 0，此时它不可见）。\ncenter\t将对象放在其容器的水平和垂直轴中心，不改变其大小。当 clipOrientation 是 \"horizontal\" 时，在左边和右边裁剪。当 clipOrientation 是 \"vertical\" 时，在顶部和底部裁剪。\nfill\t按需要扩展对象的垂直大小，使其完全适应其容器。不会进行裁剪，因为可绘制对象会填充水平和垂直空间（除非可绘制对象级别为 0，此时它不可见）。\nclip_vertical\t可设置为让子元素的上边缘和/或下边缘裁剪至其容器边界的附加选项。裁剪基于垂直重力：顶部重力裁剪上边缘，底部重力裁剪下边缘，任一重力不会同时裁剪两边。\nclip_horizontal\t可设置为让子元素的左边和/或右边裁剪至其容器边界的附加选项。裁剪基于水平重力：左边重力裁剪右边缘，右边重力裁剪左边缘，任一重力不会同时裁剪两边。\n示例：\nXML 文件保存在 res/drawable/clip.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<clip xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/android\"\n    android:clipOrientation=\"horizontal\"\n    android:gravity=\"left\" />\n以下布局 XML 会将裁剪可绘制对象应用到视图：\n\n<ImageView\n    android:id=\"@+id/image\"\n    android:background=\"@drawable/clip\"\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\" />\n以下代码用于获取可绘制对象，并增加裁剪量，以便逐渐显示图像：\n\nval imageview: ImageView = findViewById(R.id.image)\nval drawable: Drawable = imageview.background\nif (drawable is ClipDrawable) {\n    drawable.level = drawable.level + 1000\n}\nImageView imageview = (ImageView) findViewById(R.id.image);\nDrawable drawable = imageview.getBackground();\nif (drawable instanceof CLipDrawable) {\n    ((ClipDrawable)drawable).setLevel(drawable.getLevel() + 1000);\n}\n通过提高级别，即可减少裁剪量并慢慢显示图像。以下图像的级别为 7000：\n\n\n请注意：默认级别为 0，即完全裁剪，使图像不可见。当级别为 10,000 时，图像不会裁剪，而是完全可见。\n\n另请参阅：\nClipDrawable\n缩放可绘制对象\n在 XML 文件中定义的更改其他可绘制对象大小（根据其当前级别）的可绘制对象。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 ScaleDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<scale\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/drawable_resource\"\n    android:scaleGravity=[\"top\" | \"bottom\" | \"left\" | \"right\" | \"center_vertical\" |\n                          \"fill_vertical\" | \"center_horizontal\" | \"fill_horizontal\" |\n                          \"center\" | \"fill\" | \"clip_vertical\" | \"clip_horizontal\"]\n    android:scaleHeight=\"percentage\"\n    android:scaleWidth=\"percentage\" />\n元素：\n<scale>\n定义缩放可绘制对象。这必须是根元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:drawable\n可绘制对象资源。必备。引用可绘制对象资源。\nandroid:scaleGravity\n关键字。指定缩放后的重力位置。\n必须是以下一个或多个（用 '|' 分隔）常量值：\n\n值\t说明\ntop\t将对象放在其容器顶部，不改变其大小。\nbottom\t将对象放在其容器底部，不改变其大小。\nleft\t将对象放在其容器左边缘，不改变其大小。这是默认值。\nright\t将对象放在其容器右边缘，不改变其大小。\ncenter_vertical\t将对象放在其容器的垂直中心，不改变其大小。\nfill_vertical\t按需要扩展对象的垂直大小，使其完全适应其容器。\ncenter_horizontal\t将对象放在其容器的水平中心，不改变其大小。\nfill_horizontal\t按需要扩展对象的水平大小，使其完全适应其容器。\ncenter\t将对象放在其容器的水平和垂直轴中心，不改变其大小。\nfill\t按需要扩展对象的垂直大小，使其完全适应其容器。\nclip_vertical\t可设置为让子元素的上边缘和/或下边缘裁剪至其容器边界的附加选项。裁剪基于垂直重力：顶部重力裁剪上边缘，底部重力裁剪下边缘，任一重力不会同时裁剪两边。\nclip_horizontal\t可设置为让子元素的左边和/或右边裁剪至其容器边界的附加选项。裁剪基于水平重力：左边重力裁剪右边缘，右边重力裁剪左边缘，任一重力不会同时裁剪两边。\nandroid:scaleHeight\n百分比。缩放高度，表示为可绘制对象边界的百分比。值的格式为 XX%。例如：100%、12.5% 等。\nandroid:scaleWidth\n百分比。缩放宽度，表示为可绘制对象边界的百分比。值的格式为 XX%。例如：100%、12.5% 等。\n示例：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/logo\"\n    android:scaleGravity=\"center_vertical|center_horizontal\"\n    android:scaleHeight=\"80%\"\n    android:scaleWidth=\"80%\" />\n另请参阅：\nScaleDrawable\n形状可绘制对象\n这是一种在 XML 文件中定义的通用形状。\n\n文件位置：\nres/drawable/filename.xml\n文件名用作资源 ID。\n编译资源的数据类型：\n指向 GradientDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable/filename\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"] >\n    <corners\n        android:radius=\"integer\"\n        android:topLeftRadius=\"integer\"\n        android:topRightRadius=\"integer\"\n        android:bottomLeftRadius=\"integer\"\n        android:bottomRightRadius=\"integer\" />\n    <gradient\n        android:angle=\"integer\"\n        android:centerX=\"float\"\n        android:centerY=\"float\"\n        android:centerColor=\"integer\"\n        android:endColor=\"color\"\n        android:gradientRadius=\"integer\"\n        android:startColor=\"color\"\n        android:type=[\"linear\" | \"radial\" | \"sweep\"]\n        android:useLevel=[\"true\" | \"false\"] />\n    <padding\n        android:left=\"integer\"\n        android:top=\"integer\"\n        android:right=\"integer\"\n        android:bottom=\"integer\" />\n    <size\n        android:width=\"integer\"\n        android:height=\"integer\" />\n    <solid\n        android:color=\"color\" />\n    <stroke\n        android:width=\"integer\"\n        android:color=\"color\"\n        android:dashWidth=\"integer\"\n        android:dashGap=\"integer\" />\n</shape>\n元素：\n<shape>\n形状可绘制对象。这必须是根元素。\n属性：\n\nxmlns:android\n字符串。必备。定义 XML 命名空间，其必须是 \"http://schemas.android.com/apk/res/android\"。\nandroid:shape\n关键字。定义形状的类型。有效值为：\n值\t描述\n\"rectangle\"\t填充包含视图的矩形。这是默认形状。\n\"oval\"\t适应包含视图尺寸的椭圆形状。\n\"line\"\t跨越包含视图宽度的水平线。此形状需要 <stroke> 元素定义线宽。\n\"ring\"\t环形。\n仅当 android:shape=\"ring\" 如下时才使用以下属性：\n\nandroid:innerRadius\n尺寸。环内部（中间的孔）的半径，以尺寸值或尺寸资源表示。\nandroid:innerRadiusRatio\n浮点型。环内部的半径，以环宽度的比率表示。例如，如果 android:innerRadiusRatio=\"5\"，则内半径等于环宽度除以 5。此值被 android:innerRadius 覆盖。默认值为 9。\nandroid:thickness\n尺寸。环的厚度，以尺寸值或尺寸资源表示。\nandroid:thicknessRatio\n浮点型。环的厚度，表示为环宽度的比率。例如，如果 android:thicknessRatio=\"2\"，则厚度等于环宽度除以 2。此值被 android:innerRadius 覆盖。默认值为 3。\nandroid:useLevel\n布尔值。如果此属性用作 LevelListDrawable，则值为“true”。此属性的值通常应为“false”，否则无法显示形状。\n<corners>\n为形状产生圆角。仅当形状为矩形时适用。\n属性：\n\nandroid:radius\n尺寸。所有角的半径，以尺寸值或尺寸资源表示。对于每个角，这会被以下属性覆盖。\nandroid:topLeftRadius\n尺寸。左上角的半径，以尺寸值或尺寸资源表示。\nandroid:topRightRadius\n尺寸。右上角的半径，以尺寸值或尺寸资源表示。\nandroid:bottomLeftRadius\n尺寸。左下角的半径，以尺寸值或尺寸资源表示。\nandroid:bottomRightRadius\n尺寸。右下角的半径，以尺寸值或尺寸资源表示。\n注：（最初）必须为每个角提供大于 1 的角半径，否则无法产生圆角。如果希望特定角不要倒圆角，解决方法是使用 android:radius 设置大于 1 的默认角半径，然后使用实际所需的值替换每个角，为不希望倒圆角的角提供零（“0dp”）。\n\n<gradient>\n指定形状的渐变颜色。\n属性：\n\nandroid:angle\n整型。渐变的角度（度）。0 为从左到右，90 为从上到上。必须是 45 的倍数。默认值为 0。\nandroid:centerX\n浮点型。渐变中心的相对 X 轴位置 (0 - 1.0)。\nandroid:centerY\n浮点型。渐变中心的相对 Y 轴位置 (0 - 1.0)。\nandroid:centerColor\n颜色。起始颜色与结束颜色之间的可选颜色，以十六进制值或颜色资源表示。\nandroid:endColor\n颜色。结束颜色，表示为十六进制值或颜色资源。\nandroid:gradientRadius\n浮点型。渐变的半径。仅在 android:type=\"radial\" 时适用。\nandroid:startColor\n颜色。起始颜色，表示为十六进制值或颜色资源。\nandroid:type\n关键字。要应用的渐变图案的类型。有效值为：\n值\t说明\n\"linear\"\t线性渐变。这是默认值。\n\"radial\"\t径向渐变。起始颜色为中心颜色。\n\"sweep\"\t流线型渐变。\nandroid:useLevel\n布尔值。如果此属性用作 LevelListDrawable，则值为“true”。\n<padding>\n要应用到包含视图元素的内边距（这会填充视图内容的位置，而非形状）。\n属性：\n\nandroid:left\n尺寸。左内边距，表示为尺寸值或尺寸资源\nandroid:top\n尺寸。上内边距，表示为尺寸值或尺寸资源\nandroid:right\n尺寸。右内边距，表示为尺寸值或尺寸资源\nandroid:bottom\n尺寸。下内边距，表示为尺寸值或尺寸资源\n<size>\n形状的大小。\n属性：\n\nandroid:height\n尺寸。形状的高度，表示为尺寸值或尺寸资源\nandroid:width\n尺寸。形状的宽度，表示为尺寸值或尺寸资源\n注：默认情况下，形状根据此处定义的尺寸，按比例缩放至容器视图的大小。在 ImageView 中使用形状时，您可将 android:scaleType 设置为 \"center\"，从而限制缩放。\n\n<solid>\n用于填充形状的纯色。\n属性：\n\nandroid:color\n颜色。应用于形状的颜色，以十六进制值或颜色资源表示。\n<stroke>\n形状的笔划中线。\n属性：\n\nandroid:width\n尺寸。线宽，以尺寸值或尺寸资源表示。\nandroid:color\n颜色。线的颜色，表示为十六进制值或颜色资源。\nandroid:dashGap\n尺寸。短划线的间距，以尺寸值或尺寸资源表示。仅在设置了 android:dashWidth 时有效。\nandroid:dashWidth\n尺寸。每个短划线的大小，以尺寸值或尺寸资源表示。仅在设置了 android:dashGap 时有效。\n示例：\nXML 文件保存在 res/drawable/gradient_box.xml 中：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=\"rectangle\">\n    <gradient\n        android:startColor=\"#FFFF0000\"\n        android:endColor=\"#80FF00FF\"\n        android:angle=\"45\"/>\n    <padding android:left=\"7dp\"\n        android:top=\"7dp\"\n        android:right=\"7dp\"\n        android:bottom=\"7dp\" />\n    <corners android:radius=\"8dp\" />\n</shape>\n此布局 XML 会将形状可绘制对象应用到视图：\n\n<TextView\n    android:background=\"@drawable/gradient_box\"\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"wrap_content\" />\n此应用代码会获取形状可绘制对象，并将其应用至视图：\n\nval shape: Drawable? = \ngetDrawable\n(\nresources\n, R.drawable.gradient_box, \ngetTheme()\n)val tv: TextView = findViewById(R.id.textview)\ntv.background = shape\nResources res = \ngetResources()\n;\nDrawable shape = ResourcesCompat.\ngetDrawable\n(res, R.drawable.gradient_box, \ngetTheme()\n);TextView tv = (TextView)findViewById(R.id.textview);\ntv.setBackground(shape);\n另请参阅：\nShapeDrawable"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242357382},"updatedAt":{"$$date":1597242667798},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"AwLRKUfx1wdm1RjL"}
{"name":"kotlin-委托 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/delegation.html\n委托 - Kotlin 语言中文站\n6-7 minutes\n改进翻译\n属性委托在单独一页中讲：属性委托。\n\n委托模式已经证明是实现继承的一个很好的替代方式， 而 Kotlin 可以零样板代码地原生支持它。 Derived 类可以通过将其所有公有成员都委托给指定对象来实现一个接口 Base：\n\nTarget platform: JVMRunning on kotlin v. 1.3.72\n\nDerived 的超类型列表中的 by-子句表示 b 将会在 Derived 中内部存储， 并且编译器将生成转发给 b 的所有 Base 的方法。\n\n覆盖符合预期：编译器会使用 override 覆盖的实现而不是委托对象中的。如果将 override fun printMessage() { print(\"abc\") } 添加到 Derived，那么当调用 printMessage 时程序会输出“abc”而不是“10”：\n\ninterface Base {\n    fun printMessage()\n    fun printMessageLine()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override fun printMessage() { print(x) }\n    override fun printMessageLine() { println(x) }\n}\n\nclass Derived(b: Base) : Base by b {\n    override fun printMessage() { print(\"abc\") }\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    Derived(b).printMessage()\n    Derived(b).printMessageLine()\n}\n但请注意，以这种方式重写的成员不会在委托对象的成员中调用 ，委托对象的成员只能访问其自身对接口成员实现：\n\ninterface Base {\n    val message: String\n    fun print()\n}\n\nclass BaseImpl(val x: Int) : Base {\n    override val message = \"BaseImpl: x = $x\"\n    override fun print() { println(message) }\n}\n\nclass Derived(b: Base) : Base by b {\n    // 在 b 的 `print` 实现中不会访问到这个属性\n    override val message = \"Message of Derived\"\n}\n\nfun main() {\n    val b = BaseImpl(10)\n    val derived = Derived(b)\n    derived.print()\n    println(derived.message)\n}\n在 JVM 平台：当使用带有 default 方法的接口（包括带有 @JvmDefault 注解的 Kotlin 接口）进行委托时， 即使实际的委托类型提供了其自身的实现也会调用默认实现。 详细信息请参见在 Java 中调用 Kotlin。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307931075},"updatedAt":{"$$date":1597308387892},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"BIRE0ahkgl3UhE7g"}
{"name":"java-使用ReadWriteLock","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"前面讲到的ReentrantLock保证了只有一个线程可以执行临界区代码：\n\npublic class Counter {\n    private final Lock lock = new ReentrantLock();\n    private int[] counts = new int[10];\n\n    public void inc(int index) {\n        lock.lock();\n        try {\n            counts[index] += 1;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public int[] get() {\n        lock.lock();\n        try {\n            return Arrays.copyOf(counts, counts.length);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用inc()方法是必须获取锁，但是，get()方法只读取数据，不修改数据，它实际上允许多个线程同时调用。\n\n实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：\n\n读\t写\n读\t允许\t不允许\n写\t不允许\t不允许\n使用ReadWriteLock可以解决这个问题，它保证：\n\n只允许一个线程写入（其他线程既不能写入也不能读取）；\n没有写入时，多个线程允许同时读（提高性能）。\n用ReadWriteLock实现这个功能十分容易。我们需要创建一个ReadWriteLock实例，然后分别获取读锁和写锁：\n\npublic class Counter {\n    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();\n    private final Lock rlock = rwlock.readLock();\n    private final Lock wlock = rwlock.writeLock();\n    private int[] counts = new int[10];\n\n    public void inc(int index) {\n        wlock.lock(); // 加写锁\n        try {\n            counts[index] += 1;\n        } finally {\n            wlock.unlock(); // 释放写锁\n        }\n    }\n\n    public int[] get() {\n        rlock.lock(); // 加读锁\n        try {\n            return Arrays.copyOf(counts, counts.length);\n        } finally {\n            rlock.unlock(); // 释放读锁\n        }\n    }\n}\n把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。\n\n使用ReadWriteLock时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。\n\n例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用ReadWriteLock。\n\n小结\n使用ReadWriteLock可以提高读取效率：\n\nReadWriteLock只允许一个线程写入；\n\nReadWriteLock允许多个线程在没有写入时同时读取；\n\nReadWriteLock适合读多写少的场景。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826926090},"updatedAt":{"$$date":1594967729192},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"BXM6MredpppmTlDT"}
{"name":"kotlin-取集合的一部分 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-parts.html\n取集合的一部分 - Kotlin 语言中文站\n12-15 minutes\n改进翻译\nKotlin 标准库包含用于取集合的一部分的扩展函数。 这些函数提供了多种方法来选择结果集合的元素：显式列出其位置、指定结果大小等。\n\nslice() 返回具有给定索引的集合元素列表。 索引既可以是作为区间传入的也可以是作为整数值的集合传入的。\n\nfun main() {\n//sampleStart    \n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")    \n    println(numbers.slice(1..3))\n    println(numbers.slice(0..4 step 2))\n    println(numbers.slice(setOf(3, 5, 0)))    \n//sampleEnd\n}\n要从头开始获取指定数量的元素，请使用 take() 函数。 要从尾开始获取指定数量的元素，请使用 takeLast()。 当调用的数字大于集合的大小时，两个函数都将返回整个集合。\n\n要从头或从尾去除给定数量的元素，请调用 drop() 或 dropLast() 函数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.take(3))\n    println(numbers.takeLast(3))\n    println(numbers.drop(1))\n    println(numbers.dropLast(5))\n//sampleEnd\n}\n还可以使用谓词来定义要获取或去除的元素的数量。 有四个与上述功能相似的函数：\n\ntakeWhile() 是带有谓词的 take()：它将不停获取元素直到排除与谓词匹配的首个元素。如果首个集合元素与谓词匹配，则结果为空。\ntakeLastWhile() 与 takeLast() 类似：它从集合末尾获取与谓词匹配的元素区间。区间的首个元素是与谓词不匹配的最后一个元素右边的元素。如果最后一个集合元素与谓词匹配，则结果为空。\ndropWhile() 与具有相同谓词的 takeWhile() 相反：它将首个与谓词不匹配的元素返回到末尾。\ndropLastWhile() 与具有相同谓词的 takeLastWhile() 相反：它返回从开头到最后一个与谓词不匹配的元素。\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.takeWhile { !it.startsWith('f') })\n    println(numbers.takeLastWhile { it != \"three\" })\n    println(numbers.dropWhile { it.length == 3 })\n    println(numbers.dropLastWhile { it.contains('i') })\n//sampleEnd\n}\n要将集合分解为给定大小的“块”，请使用 chunked() 函数。 chunked() 采用一个参数（块的大小），并返回一个 List 其中包含给定大小的 List。 第一个块从第一个元素开始并包含 size 元素，第二个块包含下一个 size 元素，依此类推。 最后一个块的大小可能较小。\n\nfun main() {\n//sampleStart\n    val numbers = (0..13).toList()\n    println(numbers.chunked(3))\n//sampleEnd\n}\n还可以立即对返回的块应用转换。 为此，请在调用 chunked() 时将转换作为 lambda 函数提供。 lambda 参数是集合的一块。当通过转换调用 chunked() 时， 这些块是临时的 List，应立即在该 lambda 中使用。\n\nfun main() {\n//sampleStart\n    val numbers = (0..13).toList() \n    println(numbers.chunked(3) { it.sum() })  // `it` 为原始集合的一个块\n//sampleEnd\n}\n可以检索给定大小的集合元素中所有可能区间。 获取它们的函数称为 windowed()：它返回一个元素区间列表，比如通过给定大小的滑动窗口查看集合，则会看到该区间。 与 chunked() 不同，windowed() 返回从每个集合元素开始的元素区间（窗口）。 所有窗口都作为单个 List 的元素返回。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.windowed(3))\n//sampleEnd\n}\nwindowed() 通过可选参数提供更大的灵活性：\n\nstep 定义两个相邻窗口的第一个元素之间的距离。默认情况下，该值为 1，因此结果包含从所有元素开始的窗口。如果将 step 增加到 2，将只收到以奇数元素开头的窗口：第一个、第三个等。\npartialWindows 包含从集合末尾的元素开始的较小的窗口。例如，如果请求三个元素的窗口，就不能为最后两个元素构建它们。在本例中，启用 partialWindows 将包括两个大小为2与1的列表。\n最后，可以立即对返回的区间应用转换。 为此，在调用 windowed() 时将转换作为 lambda 函数提供。\n\nfun main() {\n//sampleStart\n    val numbers = (1..10).toList()\n    println(numbers.windowed(3, step = 2, partialWindows = true))\n    println(numbers.windowed(3) { it.sum() })\n//sampleEnd\n}\n要构建两个元素的窗口，有一个单独的函数——zipWithNext()。 它创建接收器集合的相邻元素对。 请注意，zipWithNext() 不会将集合分成几对；它为 每个 元素创建除最后一个元素外的对，因此它在 [1, 2, 3, 4] 上的结果为 [[1, 2], [2, 3], [3, 4]]，而不是 [[1, 2]，[3, 4]]。 zipWithNext() 也可以通过转换函数来调用；它应该以接收者集合的两个元素作为参数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    \n    println(numbers.zipWithNext())\n    println(numbers.zipWithNext() { s1, s2 -> s1.length > s2.length})\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382131429},"updatedAt":{"$$date":1597383731943},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"CIFrqFCg29Fd4H1g"}
{"name":"yyyy","folderId":"ni3NGVu7G","content":[{"label":"Fragment 1","language":"text","value":"sdfsdfsrrrr"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1596552721209},"updatedAt":{"$$date":1596552725709},"_id":"CZGpq7vmIsAaVg6x","folder":{"id":"ni3NGVu7G","name":"Default","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-数据类 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/data-classes.html\n数据类 - Kotlin 语言中文站\n8-9 minutes\n改进翻译\n我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为 data：\n\ndata class User(val name: String, val age: Int)\n编译器自动从主构造函数中声明的所有属性导出以下成员：\n\nequals()/hashCode() 对；\ntoString() 格式是 \"User(name=John, age=42)\"；\ncomponentN() 函数 按声明顺序对应于所有属性；\ncopy() 函数（见下文）。\n为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：\n\n主构造函数需要至少有一个参数；\n主构造函数的所有参数需要标记为 val 或 var；\n数据类不能是抽象、开放、密封或者内部的；\n（在1.1之前）数据类只能实现接口。\n此外，成员生成遵循关于成员继承的这些规则：\n\n如果在数据类体中有显式实现 equals()、 hashCode() 或者 toString()，或者这些函数在父类中有 final 实现，那么不会生成这些函数，而会使用现有函数；\n如果超类型具有 open 的 componentN() 函数并且返回兼容的类型， 那么会为数据类生成相应的函数，并覆盖超类的实现。如果超类型的这些函数由于签名不兼容或者是 final 而导致无法覆盖，那么会报错；\n从一个已具 copy(……) 函数且签名匹配的类型派生一个数据类在 Kotlin 1.2 中已弃用，并且在 Kotlin 1.3 中已禁用。\n不允许为 componentN() 以及 copy() 函数提供显式实现。\n自 1.1 起，数据类可以扩展其他类（示例请参见密封类）。\n\n在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。 （参见构造函数）。\n\ndata class User(val name: String = \"\", val age: Int = 0)\n请注意，对于那些自动生成的函数，编译器只使用在主构造函数内部定义的属性。如需在生成的实现中排除一个属性，请将其声明在类体中：\n\ndata class Person(val name: String) {\n    var age: Int = 0\n}\n在 toString()、 equals()、 hashCode() 以及 copy() 的实现中只会用到 name 属性，并且只有一个 component 函数 component1()。虽然两个 Person 对象可以有不同的年龄，但它们会视为相等。\n\ndata class Person(val name: String) {\n    var age: Int = 0\n}\nfun main() {\n//sampleStart\n    val person1 = Person(\"John\")\n    val person2 = Person(\"John\")\n    person1.age = 10\n    person2.age = 20\n//sampleEnd\n    println(\"person1 == person2: ${person1 == person2}\")\n    println(\"person1 with age ${person1.age}: ${person1}\")\n    println(\"person2 with age ${person2.age}: ${person2}\")\n}\n在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy() 函数就是为此而生成。对于上文的 User 类，其实现会类似下面这样：\n\nfun copy(name: String = this.name, age: Int = this.age) = User(name, age)     \n这让我们可以写：\n\nval jack = User(name = \"Jack\", age = 1)\nval olderJack = jack.copy(age = 2)\n为数据类生成的 Component 函数 使它们可在解构声明中使用：\n\nval jane = User(\"Jane\", 35)\nval (name, age) = jane\nprintln(\"$name, $age years of age\") // 输出 \"Jane, 35 years of age\"\n标准库提供了 Pair 与 Triple。尽管在很多情况下具名数据类是更好的设计选择， 因为它们通过为属性提供有意义的名称使代码更具可读性。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307921191},"updatedAt":{"$$date":1597308000463},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"CnY7t7Wss4IiEAfd"}
{"name":"andr-构建灵活的界面","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/basics/fragments/fragment-ui\n构建灵活的界面  |  Android 开发者  |  Android Developers\n6-8 minutes\n在设计支持各种屏幕尺寸的应用时，您可以在不同的布局配置中重复使用 Fragment，以根据可用的屏幕空间优化用户体验。\n\n例如，在手机上，一次只显示一个 Fragment 对于单窗格界面可能比较合适。相反，在平板电脑上，由于屏幕尺寸较大，因此您可能想要设置并排显示的 Fragment，以向用户显示更多信息。\n\n\n\n图 1. 同一 Activity 的两个 Fragment，采用不同的配置显示在不同屏幕尺寸的设备上。在较大的屏幕上，两个 Fragment 同屏并排显示，但在手机上，一次仅显示一个 Fragment，因此用户必须通过切换屏幕浏览这两个 Fragment。\n\n利用 FragmentManager 类提供的方法，您可以在运行时为 Activity 添加、移除和替换 Fragment，从而营造出动态的用户体验。\n\n如需详细了解如何实现 Fragment，请参阅以下资源。\n\nFragment\n支持平板电脑和手机\n示例应用\n在运行时为 Activity 添加 Fragment\n您可以在 Activity 运行时为其添加 Fragment，而不用像上一课中介绍的那样，使用 <fragment> 元素在布局文件中为 Activity 定义 Fragment。如果您打算在 Activity 的生命周期内更改 Fragment，就需要采用这种方法。\n\n要执行添加或移除 Fragment 等事务，您必须使用 FragmentManager 创建一个 FragmentTransaction，后者将提供添加、移除、替换 Fragment 以及执行其他 Fragment 事务所需的 API。\n\n如果您的 Activity 允许移除和替换 Fragment，应在 Activity 的 onCreate() 方法执行期间为其添加初始 Fragment。\n\n在处理 Fragment 时（尤其是在运行时添加 Fragment 时），需遵循的一个重要原则是，您的 Activity 布局必须包含一个可以插入 Fragment 的容器 View。\n\n下面是上一课所示布局的替代布局，该布局一次只显示一个 Fragment。为了能够将一个 Fragment 替换为另一个 Fragment，Activity 的布局包含一个充当 Fragment 容器的空 FrameLayout。\n\n请注意，虽然文件名与上一课中的布局文件相同，但布局目录没有 large 限定符，因此该布局会在设备屏幕尺寸小于“large”时使用，因为这种尺寸的屏幕无法同时容纳两个 Fragment。\n\nres/layout/news_articles.xml:\n\n    <FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:id=\"@+id/fragment_container\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n    \n在您的 Activity 内，使用支持库 API 调用 getSupportFragmentManager() 以获取 FragmentManager。然后，调用 beginTransaction() 以创建 FragmentTransaction，并调用 add() 以添加 Fragment。\n\n您可以使用同一 FragmentTransaction 为 Activity 执行多项 Fragment 事务。当您准备好进行更改时，必须调用 commit()。\n\n例如，下面展示了如何为先前的布局添加 Fragment：\n\n    import android.os.Bundle\n    import android.support.v4.app.FragmentActivityclass MainActivity : FragmentActivity() {\n        override fun onCreate(savedInstanceState: Bundle?) {\n            super.onCreate(savedInstanceState)\n            setContentView(R.layout.news_articles)// Check that the activity is using the layout version with\n            // the fragment_container FrameLayout\n            if (findViewById(R.id.fragment_container) != null) {// However, if we're being restored from a previous state,\n                // then we don't need to do anything and should return or else\n                // we could end up with overlapping fragments.\n                if (savedInstanceState != null) {\n                    return;\n                }// Create a new Fragment to be placed in the activity layout\n                val firstFragment = HeadlinesFragment()// In case this activity was started with special instructions from an\n                // Intent, pass the Intent's extras to the fragment as arguments\n                firstFragment.arguments = intent.extras// Add the fragment to the 'fragment_container' FrameLayout\n                supportFragmentManager.beginTransaction()\n                        .add(R.id.fragment_container, firstFragment).commit()\n            }\n        }\n    }\n    \n    import android.os.Bundle;\n    import android.support.v4.app.FragmentActivity;public class MainActivity extends FragmentActivity {\n        @Override\n        public void onCreate(Bundle savedInstanceState?) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.news_articles);// Check that the activity is using the layout version with\n            // the fragment_container FrameLayout\n            if (findViewById(R.id.fragment_container) != null) {// However, if we're being restored from a previous state,\n                // then we don't need to do anything and should return or else\n                // we could end up with overlapping fragments.\n                if (savedInstanceState != null) {\n                    return;\n                }// Create a new Fragment to be placed in the activity layout\n                HeadlinesFragment firstFragment = new HeadlinesFragment();// In case this activity was started with special instructions from an\n                // Intent, pass the Intent's extras to the fragment as arguments\n                firstFragment.setArguments(getIntent().getExtras());// Add the fragment to the 'fragment_container' FrameLayout\n                getSupportFragmentManager().beginTransaction()\n                        .add(R.id.fragment_container, firstFragment).commit();\n            }\n        }\n    }\n    \n由于该 Fragment 是在运行时被添加到 FrameLayout 容器的，而不是利用 <fragment> 元素在 Activity 布局中进行定义的，因此可以从 Activity 中移除该 Fragment，并将其替换为其他 Fragment。\n\n替换 Fragment\n替换 Fragment 的过程与添加 Fragment 类似，但需要调用 replace() 方法，而非 add()。\n\n请注意，当您执行替换或移除 Fragment 等 Fragment 事务时，通常最好让用户能够回退并“撤消”更改。要让用户回退所执行的 Fragment 事务，您必须先调用 addToBackStack()，然后再提交 FragmentTransaction。\n\n注意：当您移除或替换 Fragment 并向返回堆栈添加相应事务时，系统会停止（而非销毁）移除的 Fragment。如果用户执行回退操作进行 Fragment 恢复，该 Fragment 将重新启动。如果您不向返回堆栈添加相应事务，则系统会在您移除或替换 Fragment 时将其销毁。\n\n替换 Fragment 的示例：\n\n    // Create fragment and give it an argument specifying the article it should show\n    val newFragment = ArticleFragment()\n    Bundle args = Bundle()\n    args.putInt(ArticleFragment.ARG_POSITION, position)\n    newFragment.arguments = argsval transaction = supportFragmentManager.beginTransaction().apply {\n      // Replace whatever is in the fragment_container view with this fragment,\n      // and add the transaction to the back stack so the user can navigate back\n      replace(R.id.fragment_container, newFragment)\n      addToBackStack(null)\n    }// Commit the transaction\n    transaction.commit();\n    \n    // Create fragment and give it an argument specifying the article it should show\n    ArticleFragment newFragment = new ArticleFragment();\n    Bundle args = new Bundle();\n    args.putInt(ArticleFragment.ARG_POSITION, position);\n    newFragment.setArguments(args);FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,\n    // and add the transaction to the back stack so the user can navigate back\n    transaction.replace(R.id.fragment_container, newFragment);\n    transaction.addToBackStack(null);// Commit the transaction\n    transaction.commit();\n    \naddToBackStack() 方法采用一个可选的字符串参数，该参数会为事务指定一个唯一的名称。除非您打算使用 FragmentManager.BackStackEntry API 执行高级 Fragment 操作，否则不需要该名称。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243444508},"updatedAt":{"$$date":1597243862941},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"DHZV7IEIhdhSv2ow"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980163155},"updatedAt":{"$$date":1594980163155},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"EDUj8YWCnvHNUYm5"}
{"name":"kotlin-集合转换操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-transformations.html\n集合转换操作 - Kotlin 语言中文站\n20-25 minutes\n改进翻译\nKotlin 标准库为集合 转换 提供了一组扩展函数。 这些函数根据提供的转换规则从现有集合中构建新集合。 在此页面中，我们将概述可用的集合转换函数。\n\n映射 转换从另一个集合的元素上的函数结果创建一个集合。 基本的映射函数是 map()。 它将给定的 lambda 函数应用于每个后续元素，并返回 lambda 结果列表。 结果的顺序与元素的原始顺序相同。 如需应用还要用到元素索引作为参数的转换，请使用 mapIndexed()。\n\nTarget platform: JVMRunning on kotlin v. 1.3.72\n\n如果转换在某些元素上产生 null 值，则可以通过调用 mapNotNull() 函数取代 map() 或 mapIndexedNotNull() 取代 mapIndexed() 来从结果集中过滤掉 null 值。\n\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3)\n    println(numbers.mapNotNull { if ( it == 2) null else it * 3 })\n    println(numbers.mapIndexedNotNull { idx, value -> if (idx == 0) null else value * idx })\n//sampleEnd\n}\n映射转换时，有两个选择：转换键，使值保持不变，反之亦然。 要将指定转换应用于键，请使用 mapKeys()；反过来，mapValues() 转换值。 这两个函数都使用将映射条目作为参数的转换，因此可以操作其键与值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    println(numbersMap.mapKeys { it.key.toUpperCase() })\n    println(numbersMap.mapValues { it.value + it.key.length })\n//sampleEnd\n}\n双路合并 转换是根据两个集合中具有相同位置的元素构建配对。 在 Kotlin 标准库中，这是通过 zip() 扩展函数完成的。 在一个集合（或数组）上以另一个集合（或数组）作为参数调用时，zip() 返回 Pair 对象的列表（List）。 接收者集合的元素是这些配对中的第一个元素。 如果集合的大小不同，则 zip() 的结果为较小集合的大小；结果中不包含较大集合的后续元素。 zip() 也可以中缀形式调用 a zip b 。\n\nfun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    println(colors zip animals)\n\n    val twoAnimals = listOf(\"fox\", \"bear\")\n    println(colors.zip(twoAnimals))\n//sampleEnd\n}\n也可以使用带有两个参数的转换函数来调用 zip()：接收者元素和参数元素。 在这种情况下，结果 List 包含在具有相同位置的接收者对和参数元素对上调用的转换函数的返回值。\n\nfun main() {\n//sampleStart\n    val colors = listOf(\"red\", \"brown\", \"grey\")\n    val animals = listOf(\"fox\", \"bear\", \"wolf\")\n    \n    println(colors.zip(animals) { color, animal -> \"The ${animal.capitalize()} is $color\"})\n//sampleEnd\n}\n当拥有 Pair 的 List 时，可以进行反向转换 unzipping——从这些键值对中构建两个列表：\n\n第一个列表包含原始列表中每个 Pair 的键。\n第二个列表包含原始列表中每个 Pair 的值。\n要分割键值对列表，请调用 unzip()。\n\nfun main() {\n//sampleStart\n    val numberPairs = listOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"four\" to 4)\n    println(numberPairs.unzip())\n//sampleEnd\n}\n关联 转换允许从集合元素和与其关联的某些值构建 Map。 在不同的关联类型中，元素可以是关联 Map 中的键或值。\n\n基本的关联函数 associateWith() 创建一个 Map，其中原始集合的元素是键，并通过给定的转换函数从中产生值。 如果两个元素相等，则仅最后一个保留在 Map 中。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.associateWith { it.length })\n//sampleEnd\n}\n为了使用集合元素作为值来构建 Map，有一个函数 associateBy()。 它需要一个函数，该函数根据元素的值返回键。如果两个元素相等，则仅最后一个保留在 Map 中。 还可以使用值转换函数来调用 associateBy()。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.associateBy { it.first().toUpperCase() })\n    println(numbers.associateBy(keySelector = { it.first().toUpperCase() }, valueTransform = { it.length }))\n//sampleEnd\n}\n另一种构建 Map 的方法是使用函数 associate()，其中 Map 键和值都是通过集合元素生成的。 它需要一个 lambda 函数，该函数返回 Pair：键和相应 Map 条目的值。\n\n请注意，associate() 会生成临时的 Pair 对象，这可能会影响性能。 因此，当性能不是很关键或比其他选项更可取时，应使用 associate()。\n\n后者的一个示例：从一个元素一起生成键和相应的值。\n\nfun main() {\ndata class FullName (val firstName: String, val lastName: String)\n\nfun parseFullName(fullName: String): FullName {\n    val nameParts = fullName.split(\" \")\n    if (nameParts.size == 2) {\n        return FullName(nameParts[0], nameParts[1])\n    } else throw Exception(\"Wrong name format\")\n}\n\n//sampleStart\n    val names = listOf(\"Alice Adams\", \"Brian Brown\", \"Clara Campbell\")\n    println(names.associate { name -> parseFullName(name).let { it.lastName to it.firstName } })  \n//sampleEnd\n}\n此时，首先在一个元素上调用一个转换函数，然后根据该函数结果的属性建立 Pair。\n\n如需操作嵌套的集合，则可能会发现提供对嵌套集合元素进行打平访问的标准库函数很有用。\n\n第一个函数为 flatten()。可以在一个集合的集合（例如，一个 Set 组成的 List）上调用它。 该函数返回嵌套集合中的所有元素的一个 List。\n\nfun main() {\n//sampleStart\n    val numberSets = listOf(setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2))\n    println(numberSets.flatten())\n//sampleEnd\n}\n另一个函数——flatMap() 提供了一种灵活的方式来处理嵌套的集合。 它需要一个函数将一个集合元素映射到另一个集合。 因此，flatMap() 返回单个列表其中包含所有元素的值。 所以，flatMap() 表现为 map()（以集合作为映射结果）与 flatten() 的连续调用。\n\ndata class StringContainer(val values: List<String>)\n\nfun main() {\n//sampleStart\n    val containers = listOf(\n        StringContainer(listOf(\"one\", \"two\", \"three\")),\n        StringContainer(listOf(\"four\", \"five\", \"six\")),\n        StringContainer(listOf(\"seven\", \"eight\"))\n    )\n    println(containers.flatMap { it.values })\n//sampleEnd\n}\n如果需要以可读格式检索集合内容，请使用将集合转换为字符串的函数：joinToString() 与 joinTo()。\n\njoinToString() 根据提供的参数从集合元素构建单个 String。 joinTo() 执行相同的操作，但将结果附加到给定的 Appendable 对象。\n\n当使用默认参数调用时，函数返回的结果类似于在集合上调用 toString()：各元素的字符串表示形式以空格分隔而成的 String。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    println(numbers)         \n    println(numbers.joinToString())\n    \n    val listString = StringBuffer(\"The list of numbers: \")\n    numbers.joinTo(listString)\n    println(listString)\n//sampleEnd\n}\n要构建自定义字符串表示形式，可以在函数参数 separator、prefix 与 postfix中指定其参数。 结果字符串将以 prefix 开头，以 postfix 结尾。除最后一个元素外，separator 将位于每个元素之后。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")    \n    println(numbers.joinToString(separator = \" | \", prefix = \"start: \", postfix = \": end\"))\n//sampleEnd\n}\n对于较大的集合，可能需要指定 limit ——将包含在结果中元素的数量。 如果集合大小超出 limit，所有其他元素将被 truncated 参数的单个值替换。\n\nfun main() {\n//sampleStart\n    val numbers = (1..100).toList()\n    println(numbers.joinToString(limit = 10, truncated = \"<...>\"))\n//sampleEnd\n}\n最后，要自定义元素本身的表示形式，请提供 transform 函数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.joinToString { \"Element: ${it.toUpperCase()}\"})\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308436157},"updatedAt":{"$$date":1597382113910},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ErqgvGclTzaz7zJe"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973269349},"updatedAt":{"$$date":1594973269349},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"F6DJlCIGAhIj3Tmd"}
{"name":"py-Python的字符串","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。\n\n在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：\n\n>>> print('包含中文的str')\n包含中文的str\n对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：\n\n>>> ord('A')\n65\n>>> ord('中')\n20013\n>>> chr(66)\n'B'\n>>> chr(25991)\n'文'\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973930261},"updatedAt":{"$$date":1594974659105},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"FtzI1QTMZPuFWLVs"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241216525},"updatedAt":{"$$date":1597241216525},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Fvgd8mP9bscacn4s"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382143266},"updatedAt":{"$$date":1597382143266},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"FzlQl7Mg6qKQtzNb"}
{"name":"kotlin-过滤集合 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-filtering.html\n过滤集合 - Kotlin 语言中文站\n11-14 minutes\n改进翻译\n过滤是最常用的集合处理任务之一。在Kotlin中，过滤条件由 谓词 定义——接受一个集合元素并且返回布尔值的 lambda 表达式：true 说明给定元素与谓词匹配，false 则表示不匹配。\n\n标准库包含了一组让你能够通过单个调用就可以过滤集合的扩展函数。这些函数不会改变原始集合，因此它们既可用于可变集合也可用于只读集合。为了操作过滤结果，应该在过滤后将其赋值给变量或链接其他函数。\n\n基本的过滤函数是 filter()。当使用一个谓词来调用时，filter() 返回与其匹配的集合元素。对于 List 和 Set，过滤结果都是一个 List，对 Map 来说结果还是一个 Map。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    val longerThan3 = numbers.filter { it.length > 3 }\n    println(longerThan3)\n\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\nfilter() 中的谓词只能检查元素的值。如果想在过滤中使用元素在集合中的位置，应该使用 filterIndexed()。它接受一个带有两个参数的谓词：元素的索引和元素的值。\n\n如果想使用否定条件来过滤集合，请使用 filterNot()。它返回一个让谓词产生 false 的元素列表。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    \n    val filteredIdx = numbers.filterIndexed { index, s -> (index != 0) && (s.length < 5)  }\n    val filteredNot = numbers.filterNot { it.length <= 3 }\n\n    println(filteredIdx)\n    println(filteredNot)\n//sampleEnd\n}\n还有一些函数能够通过过滤给定类型的元素来缩小元素的类型：\n\nfilterIsInstance() 返回给定类型的集合元素。在一个 List<Any> 上被调用时，filterIsInstance<T>() 返回一个 List<T>，从而让你能够在集合元素上调用 T 类型的函数。\nfun main() {\n//sampleStart\n    val numbers = listOf(null, 1, \"two\", 3.0, \"four\")\n    println(\"All String elements in upper case:\")\n    numbers.filterIsInstance<String>().forEach {\n        println(it.toUpperCase())\n    }\n//sampleEnd\n}\nfilterNotNull() 返回所有的非空元素。在一个 List<T?> 上被调用时，filterNotNull() 返回一个 List<T: Any>，从而让你能够将所有元素视为非空对象。\nfun main() {\n//sampleStart\n    val numbers = listOf(null, \"one\", \"two\", null)\n    numbers.filterNotNull().forEach {\n        println(it.length)   // 对可空的 String 来说长度不可用\n    }\n//sampleEnd\n}\n另一个过滤函数 – partition() – 通过一个谓词过滤集合并且将不匹配的元素存放在一个单独的列表中。因此，你得到一个 List 的 Pair 作为返回值：第一个列表包含与谓词匹配的元素并且第二个列表包含原始集合中的所有其他元素。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val (match, rest) = numbers.partition { it.length > 3 }\n\n    println(match)\n    println(rest)\n//sampleEnd\n}\n最后，有些函数只是针对集合元素简单地检测一个谓词：\n\n如果至少有一个元素匹配给定谓词，那么 any() 返回 true。\n如果没有元素与给定谓词匹配，那么 none() 返回 true。\n如果所有元素都匹配给定谓词，那么 all() 返回 true。注意，在一个空集合上使用任何有效的谓词去调用 all() 都会返回 true 。这种行为在逻辑上被称为 vacuous truth。\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(numbers.any { it.endsWith(\"e\") })\n    println(numbers.none { it.endsWith(\"a\") })\n    println(numbers.all { it.endsWith(\"e\") })\n\n    println(emptyList<Int>().all { it > 5 })   // vacuous truth\n//sampleEnd\n}\nany() 和 none() 也可以不带谓词使用：在这种情况下它们只是用来检查集合是否为空。 如果集合中有元素，any() 返回 true，否则返回 false；none() 则相反。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val empty = emptyList<String>()\n\n    println(numbers.any())\n    println(empty.any())\n    \n    println(numbers.none())\n    println(empty.none())\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308437272},"updatedAt":{"$$date":1597382410219},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"GPt42dGAgBuagJbV"}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244744261},"updatedAt":{"$$date":1597244744261},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HDuTUHXWq0JvXUmb"}
{"name":"java-使用Atomic","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"Java的java.util.concurrent包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于java.util.concurrent.atomic包。\n\n我们以AtomicInteger为例，它提供的主要操作有：\n\n增加值并返回新值：int addAndGet(int delta)\n加1后返回新值：int incrementAndGet()\n获取当前值：int get()\n用CAS方式设置：int compareAndSet(int expect, int update)\nAtomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。\n\n如果我们自己通过CAS编写incrementAndGet()，它大概长这样：\n\npublic int incrementAndGet(AtomicInteger var) {\n    int prev, next;\n    do {\n        prev = var.get();\n        next = prev + 1;\n    } while ( ! var.compareAndSet(prev, next));\n    return next;\n}\nCAS是指，在这个操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。如果AtomicInteger的当前值不是prev，就什么也不干，返回false。通过CAS操作并配合do ... while循环，即使其他线程修改了AtomicInteger的值，最终的结果也是正确的。\n\n我们利用AtomicLong可以编写一个多线程安全的全局唯一ID生成器：\n\nclass IdGenerator {\n    AtomicLong var = new AtomicLong(0);\n\n    public long getNextId() {\n        return var.incrementAndGet();\n    }\n}\n通常情况下，我们并不需要直接用do ... while循环调用compareAndSet实现复杂的并发操作，而是用incrementAndGet()这样的封装好的方法，因此，使用起来非常简单。\n\n在高度竞争的情况下，还可以使用Java 8提供的LongAdder和LongAccumulator。\n\n小结\n使用java.util.concurrent.atomic提供的原子操作可以简化多线程编程：\n\n原子操作实现了无锁的线程安全；\n\n适用于计数器，累加器等。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826928487},"updatedAt":{"$$date":1594968002841},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HEpFMUgbRFH7Z7Lu"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241217956},"updatedAt":{"$$date":1597241217956},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HYy4LacymiW0u7DG"}
{"name":"java-Lambda基础","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"在了解Lambda之前，我们先回顾一下Java的方法。\n\nJava的方法分为实例方法，例如Integer定义的equals()方法：\n\npublic final class Integer {\n    boolean equals(Object o) {\n        ...\n    }\n}\n以及静态方法，例如Integer定义的parseInt()方法：\n\npublic final class Integer {\n    public static int parseInt(String s) {\n        ...\n    }\n}\n无论是实例方法，还是静态方法，本质上都相当于过程式语言的函数。例如C函数：\n\nchar* strcpy(char* dest, char* src)\n只不过Java的实例方法隐含地传入了一个this变量，即实例方法总是有一个隐含参数this。\n\n函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。历史上研究函数式编程的理论是Lambda演算，所以我们经常把支持函数式编程的编码风格称为Lambda表达式。\n\nLambda表达式\n在Java程序中，我们经常遇到一大堆单方法接口，即一个接口只定义了一个方法：\n\nComparator\nRunnable\nCallable\n以Comparator为例，我们想要调用Arrays.sort()时，可以传入一个Comparator实例，以匿名类方式编写如下：\n\nString[] array = ...\nArrays.sort(array, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n});\n上述写法非常繁琐。从Java 8开始，我们可以用Lambda表达式替换单方法接口。改写上述代码如下：\n\n// Lambda\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, (s1, s2) -> {\n            return s1.compareTo(s2);\n        });\n        System.out.println(String.join(\", \", array));\n    }\n}\n\n Run\n观察Lambda表达式的写法，它只需要写出方法定义：\n\n(s1, s2) -> {\n    return s1.compareTo(s2);\n}\n其中，参数是(s1, s2)，参数类型可以省略，因为编译器可以自动推断出String类型。-> { ... }表示方法体，所有代码写在内部即可。Lambda表达式没有class定义，因此写法非常简洁。\n\n如果只有一行return xxx的代码，完全可以用更简单的写法：\n\nArrays.sort(array, (s1, s2) -> s1.compareTo(s2));\n返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。\n\nFunctionalInterface\n我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口：\n\n@FunctionalInterface\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n再来看Comparator接口：\n\n@FunctionalInterface\npublic interface Comparator<T> {\n\n    int compare(T o1, T o2);\n\n    boolean equals(Object obj);\n\n    default Comparator<T> reversed() {\n        return Collections.reverseOrder(this);\n    }\n\n    default Comparator<T> thenComparing(Comparator<? super T> other) {\n        ...\n    }\n    ...\n}\n虽然Comparator接口有很多方法，但只有一个抽象方法int compare(T o1, T o2)，其他的方法都是default方法或static方法。另外注意到boolean equals(Object obj)是Object定义的方法，不算在接口方法内。因此，Comparator也是一个FunctionalInterface。\n\n练习\n从下载练习：使用Lambda表达式实现忽略大小写排序 （推荐使用IDE练习插件快速下载）\n\n小结\n单方法接口被称为FunctionalInterface。\n\n接收FunctionalInterface作为参数的时候，可以把实例化的匿名类改写为Lambda表达式，能大大简化代码。\n\nLambda表达式的参数和返回值均可由编译器自动推断。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973254137},"updatedAt":{"$$date":1594973597718},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HoxHsXrHuv41e1u5"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980159204},"updatedAt":{"$$date":1594980159204},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HpwUA8dwKuQz2CKz"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977487234},"updatedAt":{"$$date":1594977487234},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HrgxxoYWGSrnjZKf"}
{"name":"andr-布局","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/layout-resource\n布局资源  |  Android 开发者  |  Android Developers\n6-7 minutes\n布局资源定义了 Activity 中的界面或界面中的组件的架构。\n\n文件位置：\nres/layout/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 View（或子类）资源的资源指针。\n资源引用：\n在 Java 中：R.layout.filename\n在 XML 中：@[package:]layout/filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <ViewGroup\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:id=\"@[+][package:]id/resource_name\"\n        android:layout_height=[\"dimension\" | \"match_parent\" | \"wrap_content\"]\n        android:layout_width=[\"dimension\" | \"match_parent\" | \"wrap_content\"]\n        [ViewGroup-specific attributes] >\n        <View\n            android:id=\"@[+][package:]id/resource_name\"\n            android:layout_height=[\"dimension\" | \"match_parent\" | \"wrap_content\"]\n            android:layout_width=[\"dimension\" | \"match_parent\" | \"wrap_content\"]\n            [View-specific attributes] >\n            <requestFocus/>\n        </View>\n        <ViewGroup >\n            <View />\n        </ViewGroup>\n        <include layout=\"@layout/layout_resource\"/>\n    </ViewGroup>\n    \n注意：根元素可以是 ViewGroup、View 或 <merge> 元素，但只能有一个根元素，并且它必须包含带有 android 命名空间的 xmlns:android 属性，如上所示。\n\n元素：\n<ViewGroup>\n其他 View 元素的容器。ViewGroup 对象有许多种类型，每一种都支持您以不同的方式指定子元素的布局。不同类型的 ViewGroup 对象包括 LinearLayout、RelativeLayout 和 FrameLayout。\n您不应假设 ViewGroup 的任何派生对象都接受嵌套的 View。有些 ViewGroup 是 AdapterView 类的实现，该类仅从 Adapter 确定其子项。\n\n属性：\n\nandroid:id\n资源 ID。元素的唯一资源名称，可用于从应用中获取对 ViewGroup 的引用。要详细了解 android:id 的值，请参见下文。\nandroid:layout_height\n尺寸或关键字。必需。组的高度，采用尺寸值（或尺寸资源）或关键字（\"match_parent\" 或 \"wrap_content\"）的形式。请参阅下面的有效值。\nandroid:layout_width\n尺寸或关键字。必需。组的宽度，采用尺寸值（或尺寸资源）或关键字（\"match_parent\" 或 \"wrap_content\"）的形式。请参阅下面的有效值。\nViewGroup 基类支持更多属性，而且 的每个实现又另外支持很多属性。有关所有可用属性的参考信息，请参阅 ViewGroup 类的对应参考文档（例如，LinearLayout XML 属性）。\n\n<View>\n单个界面组件，通常称为“微件”。不同类型的 View 对象包括 TextView、Button 和 CheckBox。\n属性：\n\nandroid:id\n资源 ID。元素的唯一资源名称，可用于从应用中获取对 View 的引用。要详细了解 android:id 的值，请参见下文。\nandroid:layout_height\n尺寸或关键字。必需。元素的高度，采用尺寸值（或尺寸资源）或关键字（\"match_parent\" 或 \"wrap_content\"）的形式。请参阅下面的有效值。\nandroid:layout_width\n尺寸或关键字。必需。元素的宽度，采用尺寸值（或尺寸资源）或关键字（\"match_parent\" 或 \"wrap_content\"）的形式。请参阅下面的有效值。\nView 基类支持更多属性，而且 的每个实现又另外支持很多属性。如需了解详情，请参阅布局。有关所有可用属性的参考信息，请参阅对应的参考文档（例如，TextView XML 属性）。\n\n<requestFocus>\n任何代表 View 对象的元素都可以包含这个空元素，它会在屏幕上为其父项提供初始焦点。每个文件只能包含一个这种元素。\n<include>\n在此布局中包含一个布局文件。\n属性：\n\nlayout\n布局资源。必需。对布局资源的引用。\nandroid:id\n资源 ID。替换提供给所含布局中的根视图的 ID。\nandroid:layout_height\n尺寸或关键字。替换提供给所含布局中的根视图的高度。仅在同时也声明了 android:layout_width 时才有效。\nandroid:layout_width\n尺寸或关键字。替换提供给所含布局中的根视图的宽度。仅在同时也声明了 android:layout_height 时才有效。\n您可以在 <include> 中添加所含布局中的根元素所支持的任何其他布局属性，它们将替换根元素中定义的相应属性。\n\n注意：如果要使用 <include> 标记来替换布局属性，您必须同时替换 android:layout_height 和 android:layout_width 才能让其他布局属性生效。\n\n添加布局的另一种方式是使用 ViewStub。这是一个轻型视图，在对其进行明确膨胀（此时它会添加由其 android:layout 属性定义的布局文件）之前，它不会占用任何布局空间。如需详细了解如何使用 ViewStub，请参阅按需加载视图。\n\n<merge>\n未在布局层次结构中绘制的替代根元素。如果您知道此布局将被放置到一个已包含相应父视图的布局中，以包含 <merge> 元素的子项，则将此元素用作根元素会非常有用。当您打算使用 <include> 将此布局添加到另一个布局文件中，并且此布局不需要不同的 ViewGroup 容器时，这样做尤其有用。如需详细了解如何合并布局，请参阅通过 <include/> 重新使用布局。\nandroid:id 的值\n对于 ID 值，通常应该使用这种语法形式：\"@+id/name\"。加号 + 表示这是一个新的资源 ID，如果不存在，aapt 工具会在 R.java 类中创建一个新的资源整数。例如：\n\n    <TextView android:id=\"@+id/nameTextbox\"/>\n    \nnameTextbox 名称现在是附加到此元素的资源 ID。然后，您就可以在 Java 中引用与此 ID 关联的 TextView：\n\n    val textView: TextView? = findViewById(R.id.nameTextbox)\n    \n    TextView textView = findViewById(R.id.nameTextbox);\n    \n此代码会返回 TextView 对象。\n\n但是，如果您已经定义了一个 ID 资源并且尚未使用它，则可以通过去掉 android:id 值中的加号，将该 ID 应用到 View 元素。\n\nandroid:layout_height 和 android:layout_width 的值：\n高度和宽度值可使用 Android 支持的任意尺寸单位（px、dp、sp、pt、in、mm）或以下关键字来表示：\n\n值\t说明\nmatch_parent\t将尺寸设为与父元素的尺寸一致。在 API 级别 8 中引入以替代 fill_parent。\nwrap_content\t将尺寸设为适配此元素的内容所需的大小。\n自定义 View 元素\n您可以创建自己的自定义 View 和 ViewGroup 元素，并将它们应用到您的布局，就像应用标准布局元素一样。您还可以指定 XML 元素中支持的属性。要了解详情，请参阅自定义组件开发者指南。\n\n示例：\n保存在 res/layout/main_activity.xml 的 XML 文件：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"match_parent\"\n                  android:orientation=\"vertical\" >\n        <TextView android:id=\"@+id/text\"\n                  android:layout_width=\"wrap_content\"\n                  android:layout_height=\"wrap_content\"\n                  android:text=\"Hello, I am a TextView\" />\n        <Button android:id=\"@+id/button\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Hello, I am a Button\" />\n    </LinearLayout>\n    \n此应用代码会在 onCreate() 方法中加载 Activity 的布局：\n\n    public override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.main_activity)\n    }\n    \n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main_activity);\n    }\n    \n另请参阅：\n布局\nView\nViewGroup"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242640658},"updatedAt":{"$$date":1597242721544},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"HwQvISrWx3TDMxQ6"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977490826},"updatedAt":{"$$date":1594977490826},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"IOuAhkO4PsIXapZy"}
{"name":"andr-创建 Fragment ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/basics/fragments/creating\n创建 Fragment  |  Android 开发者  |  Android Developers\n4-5 minutes\n您可以将 Fragment 视为 Activity 的模块化部分，它有自己的生命周期，接收自己的输入事件，并且可以在 Activity 运行期间添加或移除（有些类似于可以在不同 Activity 中重用的“子 Activity”）。本节课介绍如何使用支持库扩展 Fragment 类，以便您的应用与搭载低至 Android 1.6 的系统版本的设备保持兼容。\n\n您应该创建一个生命周期感知组件，而不是在 Fragment 的生命周期方法中设置依赖组件。生命周期感知组件可以处理 Fragment 历经整个生命周期时所需的任何设置或拆解工作。该组件随后可以在其他 Fragment 和 Activity 中重复使用以避免代码重复，并减少您在 Fragment/Activity 本身中需要执行的设置量。有关详情，请参阅使用生命周期感知组件处理生命周期。\n\n在开始本节课之前，您必须设置 Android 项目以使用支持库。如果您以前没有使用过支持库，请按照支持库设置文档设置项目以使用 v4 库。不过，您也可以通过使用 v7 appcompat 库在 Activity 中加入应用栏，该库与 Android 2.1（API 级别 7）兼容，并且还包含 Fragment API。\n\n如需详细了解如何实现 Fragment，请参阅 Fragment。您还可以通过浏览相关示例应用了解详情。\n\n创建 Fragment 类\n要创建 Fragment，请扩展 Fragment 类，然后替换关键生命周期方法以插入应用逻辑，创建方式类似于 Activity 类。\n\n创建 Fragment 时的一个区别是您必须使用 onCreateView() 回调定义布局。事实上，这是为了让 Fragment 运行所需的唯一回调。例如，下面是一个指定其自身布局的简单 Fragment：\n\n    import android.os.Bundle\n    import android.support.v4.app.Fragment\n    import android.view.LayoutInflater\n    import android.view.ViewGroupclass ArticleFragment : Fragment() {\n        override fun onCreateView(inflater: LayoutInflater, container: ViewGroup,\n                         savedInstanceState: Bundle?): View {\n            // Inflate the layout for this fragment\n            return inflater.inflate(R.layout.article_view, container, false)\n        }\n    }\n    \n    import android.os.Bundle;\n    import android.support.v4.app.Fragment;\n    import android.view.LayoutInflater;\n    import android.view.ViewGroup;public class ArticleFragment extends Fragment {\n        @Override\n        public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n            // Inflate the layout for this fragment\n            return inflater.inflate(R.layout.article_view, container, false);\n        }\n    }\n    \n和 Activity 一样，Fragment 也应实现其他生命周期回调，以便您能在为 Activity 添加或移除 Fragment 以及 Activity 在其生命周期状态之间转换时管理 Fragment 的状态。例如，在调用 Activity 的 onPause() 方法时，Activity 中的任何 Fragment 也会收到对 onPause() 的调用。\n\n如需详细了解 Fragment 生命周期和回调方法，请参阅 Fragment 开发者指南。\n\n使用 XML 向 Activity 添加 Fragment\n虽然 Fragment 是可重复使用的模块化界面组件，但 Fragment 类的每个实例都必须与父级 FragmentActivity 相关联。您可以通过在 Activity 布局 XML 文件中定义每个 Fragment 来实现这种关联。\n\n注意：FragmentActivity 是支持库中提供的特殊 Activity，用于处理早于 API 级别 11 的系统版本上的 Fragment。如果您支持的最低系统版本为 API 级别 11 或更高版本，那么您可以使用常规 Activity。\n\n下面是一个示例布局文件，该文件在设备屏幕被视为“大”（由目录名称中的 large 限定符指定）时向 Activity 添加两个 Fragment。\n\nres/layout-large/news_articles.xml\n\n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:orientation=\"horizontal\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"><fragment android:name=\"com.example.android.fragments.HeadlinesFragment\"\n                  android:id=\"@+id/headlines_fragment\"\n                  android:layout_weight=\"1\"\n                  android:layout_width=\"0dp\"\n                  android:layout_height=\"match_parent\" /><fragment android:name=\"com.example.android.fragments.ArticleFragment\"\n                  android:id=\"@+id/article_fragment\"\n                  android:layout_weight=\"2\"\n                  android:layout_width=\"0dp\"\n                  android:layout_height=\"match_parent\" /></LinearLayout>\n    \n提示：如需详细了解如何针对不同屏幕尺寸创建布局，请参阅支持不同的屏幕尺寸。\n\n然后将布局应用到您的 Activity：\n\n    import android.os.Bundle\n    import android.support.v4.app.FragmentActivityclass MainActivity : FragmentActivity() {\n        override fun onCreate(savedInstanceState: Bundle?) {\n            super.onCreate(savedInstanceState)\n            setContentView(R.layout.news_articles)\n        }\n    }\n    \n    import android.os.Bundle;\n    import android.support.v4.app.FragmentActivity;public class MainActivity extends FragmentActivity {\n        @Override\n        public void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.news_articles);\n        }\n    }\n    \n如果您使用的是 v7 appcompat 库，那么 Activity 应扩展 AppCompatActivity，它是 FragmentActivity 的子类。有关详情，请阅读添加应用栏。\n\n注意：如果您通过在布局 XML 文件中定义 Fragment，将该 Fragment 添加到 Activity 布局中，您不能在运行时移除该 Fragment。如果您计划在用户互动期间更换 Fragment，则必须在 Activity 首次启动时就向其添加 Fragment，如构建灵活的界面中所示。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243443211},"updatedAt":{"$$date":1597243825295},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Iz9gEr41hm1VmvRS"}
{"name":"kotlin-可见性修饰符 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/visibility-modifiers.html\n可见性修饰符 - Kotlin 语言中文站\n7-8 minutes\n改进翻译\n类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 可见性修饰符。 （getter 总是与属性有着相同的可见性。） 在 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public。 如果没有显式指定修饰符的话，默认可见性是 public。\n\n在本页可以学到这些修饰符如何应用到不同类型的声明作用域。\n\n函数、属性和类、对象和接口可以在顶层声明，即直接在包内：\n\n如果你不指定任何可见性修饰符，默认为 public，这意味着你的声明将随处可见；\n如果你声明为 private，它只会在声明它的文件内可见；\n如果你声明为 internal，它会在相同模块内随处可见；\nprotected 不适用于顶层声明。\n注意：要使用另一包中可见的顶层声明，仍需将其导入进来。\n\n例如:\n\n// 文件名：example.kt\npackage foo\n\nprivate fun foo() { …… } // 在 example.kt 内可见\n\npublic var bar: Int = 5 // 该属性随处可见\n    private set         // setter 只在 example.kt 内可见\n    \ninternal val baz = 6    // 相同模块内可见\n对于类内部声明的成员：\n\nprivate 意味着只在这个类内部（包含其所有成员）可见；\nprotected—— 和 private一样 + 在子类中可见。\ninternal —— 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员；\npublic —— 能见到类声明的任何客户端都可见其 public 成员。\n请注意在 Kotlin 中，外部类不能访问内部类的 private 成员。\n\n如果你覆盖一个 protected 成员并且没有显式指定其可见性，该成员还会是 protected 可见性。\n\n例子:\n\nopen class Outer {\n    private val a = 1\n    protected open val b = 2\n    internal val c = 3\n    val d = 4  // 默认 public\n    \n    protected class Nested {\n        public val e: Int = 5\n    }\n}\n\nclass Subclass : Outer() {\n    // a 不可见\n    // b、c、d 可见\n    // Nested 和 e 可见\n\n    override val b = 5   // “b”为 protected\n}\n\nclass Unrelated(o: Outer) {\n    // o.a、o.b 不可见\n    // o.c 和 o.d 可见（相同模块）\n    // Outer.Nested 不可见，Nested::e 也不可见\n}\n要指定一个类的的主构造函数的可见性，使用以下语法（注意你需要添加一个显式 constructor 关键字）：\n\nclass C private constructor(a: Int) { …… }\n这里的构造函数是私有的。默认情况下，所有构造函数都是 public，这实际上等于类可见的地方它就可见（即 一个 internal 类的构造函数只能在相同模块内可见).\n\n局部变量、函数和类不能有可见性修饰符。\n\n可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件：\n\n一个 IntelliJ IDEA 模块；\n一个 Maven 项目；\n一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）；\n一次 <kotlinc> Ant 任务执行所编译的一套文件。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306189325},"updatedAt":{"$$date":1597307958560},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"JkP5wIclnJCRY9C1"}
{"name":"andr-视图绑定 ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/view-binding\n视图绑定  |  Android 开发者  |  Android Developers\n5-6 minutes\n通过视图绑定功能，您可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。\n\n在大多数情况下，视图绑定会替代 findViewById。\n\n设置说明\n视图绑定功能可按模块启用。要在某个模块中启用视图绑定，请将 viewBinding 元素添加到其 build.gradle 文件中，如下例所示：\n\nandroid {\n        ...\n        viewBinding {\n            enabled = true\n        }\n    }\n    \n如果您希望在生成绑定类时忽略某个布局文件，请将 tools:viewBindingIgnore=\"true\" 属性添加到相应布局文件的根视图中：\n\n<LinearLayout\n            ...\n            tools:viewBindingIgnore=\"true\" >\n        ...\n    </LinearLayout>\n    \n用法\n为某个模块启用视图绑定功能后，系统会为该模块中包含的每个 XML 布局文件生成一个绑定类。每个绑定类均包含对根视图以及具有 ID 的所有视图的引用。系统会通过以下方式生成绑定类的名称：将 XML 文件的名称转换为驼峰式大小写，并在末尾添加“Binding”一词。\n\n例如，假设某个布局文件的名称为 result_profile.xml：\n\n<LinearLayout ... >\n        <TextView android:id=\"@+id/name\" />\n        <ImageView android:cropToPadding=\"true\" />\n        <Button android:id=\"@+id/button\"\n            android:background=\"@drawable/rounded_button\" />\n    </LinearLayout>\n    \n所生成的绑定类的名称就为 ResultProfileBinding。此类具有两个字段：一个是名为 name 的 TextView，另一个是名为 button 的 Button。该布局中的 ImageView 没有 ID，因此绑定类中不存在对它的引用。\n\n每个绑定类还包含一个 getRoot() 方法，用于为相应布局文件的根视图提供直接引用。在此示例中，ResultProfileBinding 类中的 getRoot() 方法会返回 LinearLayout 根视图。\n\n以下几个部分介绍了生成的绑定类在 Activity 和 Fragment 中的使用。\n\n在 Activity 中使用视图绑定\n如需设置绑定类的实例以供 Activity 使用，请在 Activity 的 onCreate() 方法中执行以下步骤：\n\n调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Activity 使用。\n通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。\n将根视图传递到 setContentView()，使其成为屏幕上的活动视图。\n    private lateinit var binding: ResultProfileBindingoverride fun onCreate(savedInstanceState: Bundle) {\n        super.onCreate(savedInstanceState)\n        binding = ResultProfileBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n    }\n    \n    private ResultProfileBinding binding;@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        binding = ResultProfileBinding.inflate(getLayoutInflater());\n        View view = binding.getRoot();\n        setContentView(view);\n    }\n    \n您现在即可使用该绑定类的实例来引用任何视图：\n\n    binding.name.text = viewModel.name\n    binding.button.setOnClickListener { viewModel.userClicked() }\n    \n    binding.getName().setText(viewModel.getName());\n    binding.button.setOnClickListener(new View.OnClickListener() {\n        viewModel.userClicked()\n    });\n    \n在 Fragment 中使用视图绑定\n如需设置绑定类的实例以供 Fragment 使用，请在 Fragment 的 onCreateView() 方法中执行以下步骤：\n\n调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Fragment 使用。\n通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。\n从 onCreateView() 方法返回根视图，使其成为屏幕上的活动视图。\n    private var _binding: ResultProfileBinding? = null\n    // This property is only valid between onCreateView and\n    // onDestroyView.\n    private val binding get() = _binding!!override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        _binding = ResultProfileBinding.inflate(inflater, container, false)\n        val view = binding.root\n        return view\n    }override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n    \n    private ResultProfileBinding binding;@Override\n    public View onCreateView (LayoutInflater inflater,\n                              ViewGroup container,\n                              Bundle savedInstanceState) {\n        binding = ResultProfileBinding.inflate(inflater, container, false);\n        View view = binding.getRoot();\n        return view;\n    }@Override\n    public void onDestroyView() {\n        super.onDestroyView();\n        binding = null;\n    }\n    \n您现在即可使用该绑定类的实例来引用任何视图：\n\n    binding.name.text = viewModel.name\n    binding.button.setOnClickListener { viewModel.userClicked() }\n    \n    binding.getName().setText(viewModel.getName());\n    binding.button.setOnClickListener(new View.OnClickListener() {\n        viewModel.userClicked()\n    });\n    \n与 findViewById 的区别\n与使用 findViewById 相比，视图绑定具有一些很显著的优点：\n\nNull 安全：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 @Nullable 标记。\n类型安全：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。\n这些差异意味着布局和代码之间的不兼容将会导致构建在编译时（而非运行时）失败。\n\n与数据绑定的对比\n视图绑定和数据绑定均会生成可用于直接引用视图的绑定类。但是，视图绑定旨在处理更简单的用例，与数据绑定相比，具有以下优势：\n\n更快的编译速度：视图绑定不需要处理注释，因此编译时间更短。\n易于使用：视图绑定不需要特别标记的 XML 布局文件，因此在应用中采用速度更快。在模块中启用视图绑定后，它会自动应用于该模块的所有布局。\n反过来，与数据绑定相比，视图绑定也具有以下限制：\n\n视图绑定不支持布局变量或布局表达式，因此不能用于直接在 XML 布局文件中声明动态界面内容。\n视图绑定不支持双向数据绑定。\n考虑到这些因素，在某些情况下，最好在项目中同时使用视图绑定和数据绑定。您可以在需要高级功能的布局中使用数据绑定，而在不需要高级功能的布局中使用视图绑定。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243904043},"updatedAt":{"$$date":1597244134501},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"KPUAS4nZemP3SJuI"}
{"name":"py-返回多个值","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n函数可以返回多个值吗？答案是肯定的。\n\n比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：\n\nimport math\n\ndef move(x, y, step, angle=0):\n    nx = x + step * math.cos(angle)\n    ny = y - step * math.sin(angle)\n    return nx, ny\nimport math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。\n\n然后，我们就可以同时获得返回值：\n\n>>> x, y = move(100, 100, 60, math.pi / 6)\n>>> print(x, y)\n151.96152422706632 70.0\n但其实这只是一种假象，Python函数返回的仍然是单一值：\n\n>>> r = move(100, 100, 60, math.pi / 6)\n>>> print(r)\n(151.96152422706632, 70.0)\n原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973949442},"updatedAt":{"$$date":1594977447683},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"KSjojrgu1nvdM7Ed"}
{"name":"java-使用Future","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现Runnable接口，就可以让线程池去执行：\n\nclass Task implements Runnable {\n    public String result;\n\n    public void run() {\n        this.result = longTimeCalculation(); \n    }\n}\nRunnable接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个Callable接口，和Runnable接口比，它多了一个返回值：\n\nclass Task implements Callable<String> {\n    public String call() throws Exception {\n        return longTimeCalculation(); \n    }\n}\n并且Callable接口是一个泛型接口，可以返回指定类型的结果。\n\n现在的问题是，如何获得异步执行的结果？\n\n如果仔细看ExecutorService.submit()方法，可以看到，它返回了一个Future类型，一个Future类型的实例代表一个未来能获取结果的对象：\n\nExecutorService executor = Executors.newFixedThreadPool(4); \n// 定义任务:\nCallable<String> task = new Task();\n// 提交任务并获得Future:\nFuture<String> future = executor.submit(task);\n// 从Future获取异步执行返回的结果:\nString result = future.get(); // 可能阻塞\n当我们提交一个Callable任务后，我们会同时获得一个Future对象，然后，我们在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。在调用get()时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。\n\n一个Future<V>接口表示一个未来可能会返回的结果，它定义的方法有：\n\nget()：获取结果（可能会等待）\nget(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；\ncancel(boolean mayInterruptIfRunning)：取消当前任务；\nisDone()：判断任务是否已完成。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826930794},"updatedAt":{"$$date":1594973243287},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"KWeQgUlYEtqFyjFW"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973275877},"updatedAt":{"$$date":1594973275877},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"LsAWWBEv1HzFhhol"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382132706},"updatedAt":{"$$date":1597382132706},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"M2GufjtgNH0MywFo"}
{"name":"py-常量","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：\n\nPI = 3.14159265359\n但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。\n\n最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：\n\n>>> 10 / 3\n3.3333333333333335\n/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：\n\n>>> 9 / 3\n3.0\n还有一种除法是//，称为地板除，两个整数的除法仍然是整数：\n\n>>> 10 // 3\n3\n你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。\n\n因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：\n\n>>> 10 % 3\n1\n无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973929128},"updatedAt":{"$$date":1594974325253},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"MAh0TRvV3v6SFlEB"}
{"name":"py-字符串","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n字符串是以单引号'或双引号\"括起来的任意文本，比如'abc'，\"xyz\"等等。请注意，''或\"\"本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用\"\"括起来，比如\"I'm OK\"包含的字符是I，'，m，空格，O，K这6个字符。\n\n如果字符串内部既包含'又包含\"怎么办？可以用转义字符\\来标识，比如：\n\n'I\\'m \\\"OK\\\"!'\n表示的字符串内容是：\n\nI'm \"OK\"!\n转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\，可以在Python的交互式命令行用print()打印字符串看看：\n\n>>> print('I\\'m ok.')\nI'm ok.\n>>> print('I\\'m learning\\nPython.')\nI'm learning\nPython.\n>>> print('\\\\\\n\\\\')\n\\\n\\\n如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：\n\n>>> print('\\\\\\t\\\\')\n\\       \\\n>>> print(r'\\\\\\t\\\\')\n\\\\\\t\\\\\n如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：\n\n>>> print('''line1\n... line2\n... line3''')\nline1\nline2\nline3\n上面是在交互式命令行内输入，注意在输入多行内容时，提示符由>>>变为...，提示你可以接着上一行输入，注意...是提示符，不是代码的一部分：\n\n┌────────────────────────────────────────────────────────┐\n│Command Prompt - python                           _ □ x │\n├────────────────────────────────────────────────────────┤\n│>>> print('''line1                                      │\n│... line2                                               │\n│... line3''')                                           │\n│line1                                                   │\n│line2                                                   │\n│line3                                                   │\n│                                                        │\n│>>> _                                                   │\n│                                                        │\n│                                                        │\n│                                                        │\n└────────────────────────────────────────────────────────┘\n当输入完结束符```和括号)后，执行该语句并打印结果。\n\n如果写成程序并存为.py文件，就是：\n\nprint('''line1\nline2\nline3''')\n多行字符串'''...'''还可以在前面加上r使用，请自行测试：\n\n# -*- coding: utf-8 -*-\n\n\n\n\n\nprint(r'''hello,\\n\nworld''')\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973924013},"updatedAt":{"$$date":1594974078078},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"O1P0JH2AIN3WHAhZ"}
{"name":"py-格式化","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n\n\n在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：\n\n>>> 'Hello, %s' % 'world'\n'Hello, world'\n>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)\n'Hi, Michael, you have $1000000.'\n你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。\n\n常见的占位符有：\n\n占位符\t替换内容\n%d\t整数\n%f\t浮点数\n%s\t字符串\n%x\t十六进制整数\n其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：\n\n# -*- coding: utf-8 -*-\n\n\n\n\n\n\nprint('%2d-%02d' % (3, 1))\nprint('%.2f' % 3.1415926)\n\n\n\n如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：\n\n>>> 'Age: %s. Gender: %s' % (25, True)\n'Age: 25. Gender: True'\n有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：\n\n>>> 'growth rate: %d %%' % 7\n'growth rate: 7 %'\n\n\n\n\n\n\nformat()\n另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：\n\n>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)\n'Hello, 小明, 成绩提升了 17.1%'\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973933509},"updatedAt":{"$$date":1594974749861},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"O6UN8TC8mI9NiOWQ"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594980154109},"updatedAt":{"$$date":1597241187856},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"O7iTy6LhhSbSz6Ty"}
{"name":"kotlin-序列 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/sequences.html\n序列 - Kotlin 语言中文站\n12-14 minutes\n改进翻译\n除了集合之外，Kotlin 标准库还包含另一种容器类型——序列（Sequence<T>）。 序列提供与 Iterable 相同的函数，但实现另一种方法来进行多步骤集合处理。\n\n当 Iterable 的处理包含多个步骤时，它们会优先执行：每个处理步骤完成并返回其结果——中间集合。 在此集合上执行以下步骤。反过来，序列的多步处理在可能的情况下会延迟执行：仅当请求整个处理链的结果时才进行实际计算。\n\n操作执行的顺序也不同：Sequence 对每个元素逐个执行所有处理步骤。 反过来，Iterable 完成整个集合的每个步骤，然后进行下一步。\n\n因此，这些序列可避免生成中间步骤的结果，从而提高了整个集合处理链的性能。 但是，序列的延迟性质增加了一些开销，这些开销在处理较小的集合或进行更简单的计算时可能很重要。 因此，应该同时考虑使用 Sequence 与 Iterable，并确定在哪种情况更适合。\n\n要创建一个序列，请调用 sequenceOf() 函数，列出元素作为其参数。\n\n如果已经有一个 Iterable 对象（例如 List 或 Set），则可以通过调用 asSequence() 从而创建一个序列。\n\n创建序列的另一种方法是通过使用计算其元素的函数来构建序列。 要基于函数构建序列，请以该函数作为参数调用 generateSequence()。 （可选）可以将第一个元素指定为显式值或函数调用的结果。 当提供的函数返回 null 时，序列生成停止。因此，以下示例中的序列是无限的。\n\nfun main() {\n//sampleStart\n    val oddNumbers = generateSequence(1) { it + 2 } // `it` 是上一个元素\n    println(oddNumbers.take(5).toList())\n    //println(oddNumbers.count())     // 错误：此序列是无限的。\n//sampleEnd\n}\n要使用 generateSequence() 创建有限序列，请提供一个函数，该函数在需要的最后一个元素之后返回 null。\n\nfun main() {\n//sampleStart\n    val oddNumbersLessThan10 = generateSequence(1) { if (it < 10) it + 2 else null }\n    println(oddNumbersLessThan10.count())\n//sampleEnd\n}\n最后，有一个函数可以逐个或按任意大小的组块生成序列元素——sequence() 函数。 此函数采用一个 lambda 表达式，其中包含 yield() 与 yieldAll() 函数的调用。 它们将一个元素返回给序列使用者，并暂停 sequence() 的执行，直到使用者请求下一个元素。 yield() 使用单个元素作为参数；yieldAll() 中可以采用 Iterable 对象、Iterable 或其他 Sequence。yieldAll() 的 Sequence 参数可以是无限的。 当然，这样的调用必须是最后一个：之后的所有调用都永远不会执行。\n\nfun main() {\n//sampleStart\n    val oddNumbers = sequence {\n        yield(1)\n        yieldAll(listOf(3, 5))\n        yieldAll(generateSequence(7) { it + 2 })\n    }\n    println(oddNumbers.take(5).toList())\n//sampleEnd\n}\n关于序列操作，根据其状态要求可以分为以下几类：\n\n无状态 操作不需要状态，并且可以独立处理每个元素，例如 map() 或 filter()。 无状态操作还可能需要少量常数个状态来处理元素，例如 take() 与 drop()。\n有状态 操作需要大量状态，通常与序列中元素的数量成比例。\n如果序列操作返回延迟生成的另一个序列，则称为 中间序列。 否则，该操作为 末端 操作。 末端操作的示例为 toList() 或 sum()。只能通过末端操作才能检索序列元素。\n\n序列可以多次迭代；但是，某些序列实现可能会约束自己仅迭代一次。其文档中特别提到了这一点。\n\n我们通过一个示例来看 Iterable 与 Sequence 之间的区别。\n\n假定有一个单词列表。下面的代码过滤长于三个字符的单词，并打印前四个单词的长度。\n\nfun main() {    \n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    val lengthsList = words.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars:\")\n    println(lengthsList)\n//sampleEnd\n}\n运行此代码时，会看到 filter() 与 map() 函数的执行顺序与代码中出现的顺序相同。 首先，将看到 filter：对于所有元素，然后是 length：对于在过滤之后剩余的元素，然后是最后两行的输出。 列表处理如下图：\n\nList processing\n\n现在用序列写相同的逻辑：\n\nfun main() {\n//sampleStart\n    val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n    // 将列表转换为序列\n    val wordsSequence = words.asSequence()\n\n    val lengthsSequence = wordsSequence.filter { println(\"filter: $it\"); it.length > 3 }\n        .map { println(\"length: ${it.length}\"); it.length }\n        .take(4)\n\n    println(\"Lengths of first 4 words longer than 3 chars\")\n    // 末端操作：以列表形式获取结果。\n    println(lengthsSequence.toList())\n//sampleEnd\n}\n此代码的输出表明，仅在构建结果列表时才调用 filter() 与 map() 函数。 因此，首先看到文本 “Lengths of..” 的行，然后开始进行序列处理。 请注意，对于过滤后剩余的元素，映射在过滤下一个元素之前执行。 当结果大小达到 4 时，处理将停止，因为它是 take(4) 可以返回的最大大小。\n\n序列处理如下图：\n\nSequences processing\n\n在此示例中，序列处理需要 18 个步骤，而不是 23 个步骤来执行列表操作。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308433775},"updatedAt":{"$$date":1597377586640},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"PUXVQiLpwgam4dbd"}
{"name":"andr-资源类型概览","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/available-resources\n资源类型概览  |  Android 开发者  |  Android Developers\n2-2 minutes\n本部分中的每个页面介绍了一种您可以在项目资源目录 (res/) 中提供的应用资源的用法、格式和语法。\n\n以下是对每个页面的简要说明：\n\n动画资源\n定义预先确定的动画。\n补间动画保存在 res/anim/ 中并通过 R.anim 类访问。\n帧动画保存在 res/drawable/ 中并通过 R.drawable 类访问。\n颜色状态列表资源\n定义根据 View 状态而变化的颜色资源。\n保存在 res/color/ 中并通过 R.color 类访问。\n可绘制资源\n使用位图或 XML 定义各种图形。\n保存在 res/drawable/ 中并通过 R.drawable 类访问。\n布局资源\n定义应用界面的布局。\n保存在 res/layout/ 中并通过 R.layout 类访问。\n菜单资源\n定义应用菜单的内容。\n保存在 res/menu/ 中并通过 R.menu 类访问。\n字符串资源\n定义字符串、字符串数组和复数形式（并包括字符串格式和样式）。\n保存在 res/values/ 中，并通过 R.string、R.array 和 R.plurals 类访问。\n样式资源\n定义界面元素的外观和格式。\n保存在 res/values/ 中并通过 R.style 类访问。\n字体资源\n在 XML 中定义字体系列并包含自定义字体。\n保存在 res/font/ 中并通过 R.font 类访问。\n更多资源类型\n将其他原始值定义为静态资源，具体包括：\nBool\n包含布尔值的 XML 资源。\n颜色\n包含颜色值（十六进制颜色）的 XML 资源。\n维度\n包含维度值（及度量单位）的 XML 资源。\nID\n为应用资源和组件提供唯一标识符的 XML 资源。\n整数\n包含整数值的 XML 资源。\n整数数组\n提供整数数组的 XML 资源。\n类型化数组\n提供 TypedArray（可用于可绘制对象数组）的 XML 资源。\nContent and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2020-01-07 UTC."}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242328605},"updatedAt":{"$$date":1597242364810},"_id":"Paf5uvbk5k9KKmfg","folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382142141},"updatedAt":{"$$date":1597382142141},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"PjjXFL2gdwbHVg8w"}
{"name":"kotlin-vivo oppo 相机权限处理","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nblog.csdn.net /u010897392/article/details/82661495\nvivo oppo 相机权限处理_u010897392的专栏-CSDN博客_android vivo手机 相机权限申请问题\n7-8 minutes\n最近写权限图片上传功能用到了相机权限申请，发现vivo，oppo很多机型不管授权与否都返回\n\nPackageManager.PERMISSION_GRANTED（已授权），研究下了下源码发现有个mHasPermission 字段跟授权后的状态有关，已授权则返回true,否则返回false;既然已找到突破口，那处理起来就就简单了，直接上代码：\n\n新建一个权限工具类PermissionUtils 跟rom工具类RomUtils ：\n\npackage com.app.shanjiang.util;\n\nimport android.Manifest;\n\nimport android.content.Context;\n\nimport android.hardware.Camera;\n\nimport android.os.Build;\n\nimport java.lang.reflect.Field;\n\nimport pub.devrel.easypermissions.EasyPermissions;\n\n/**\n\n * @Title 权限工具类\n\n * @Description\n\n * @Author xuefeng.zhu\n\n * @Since 2018/9/3\n\n * @Version 2.7.0\n\n */\n\npublic class PermissionUtils {\n\nprivate static Boolean mCameraCanUse = true; //缓存上次的查询结果\n\nprivate static Camera mCamera = null;\n\n/**\n\n     * 检测相机权限\n\n     *\n\n     * @param context\n\n     * @return\n\n     */\n\npublic static boolean hasCameraPermissions(Context context) {\n\ntry {\n\nif (RomUtils.isOppo() || RomUtils.isVivo()) {\n\nif (!isCameraCanUse()) {\n\nreturn false;\n\n                }\n\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n\nif (!isHasCameraPermission()) {\n\nreturn false;\n\n                    }\n\n                }\n\n            }\n\n        } catch (Exception ex) {\n\n            ex.printStackTrace();\n\nreturn false;\n\n        }\n\nreturn EasyPermissions.hasPermissions(context, Manifest.permission.CAMERA);\n\n    }\n\n/**\n\n     * 相机是否可用\n\n     * ps:有些手机即使禁掉拍照权限获取到的camera也不为null（比如魅族，oppoR9s）\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isCameraCanUse() {\n\nboolean canUse = true;\n\ntry {\n\n            mCamera = getCamera();\n\n            Camera.Parameters mParameters = mCamera.getParameters();\n\n            mCamera.setParameters(mParameters);\n\n        } catch (Exception e) {\n\n            canUse = false;\n\n        }\n\n        mCameraCanUse = canUse;\n\nreturn canUse;\n\n    }\n\n/**\n\n     * 是否拿到相机权限\n\n     * ps: vivo ，opo手机不管授权与否都会\n\n     * 返回PackageManager.PERMISSION_GRANTED（已授权）故作特殊处理\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isHasCameraPermission() {\n\n        Field fieldPassword;\n\ntry {\n\n            mCamera = getCamera();\n\n//通过反射去拿相机是否获得了权限\n\n            fieldPassword = mCamera.getClass().getDeclaredField(\"mHasPermission\");\n\n            fieldPassword.setAccessible(true);\n\nBoolean result = (Boolean) fieldPassword.get(mCamera);\n\nif (mCamera != null) {\n\n                mCamera.release();\n\n            }\n\n            mCamera = null;\n\nreturn result;\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n            mCamera = null;\n\nreturn true;\n\n        }\n\n    }\n\n/**\n\n     * 相机是否可使用\n\n     *\n\n     * @return\n\n     */\n\npublic static Boolean getCameraCanUse() {\n\nreturn mCameraCanUse;\n\n    }\n\n/**\n\n     * 获取相机实例\n\n     *\n\n     * @return\n\n     */\n\npublic static Camera getCamera() {\n\nif (mCamera == null) {\n\nreturn Camera.open();\n\n        }\n\nreturn mCamera;\n\n    }\n\n}\n\npackage com.app.shanjiang.util;\n\nimport android.os.Build;\n\nimport android.text.TextUtils;\n\nimport android.util.Log;\n\nimport java.io.BufferedReader;\n\nimport java.io.IOException;\n\nimport java.io.InputStreamReader;\n\n/**\n\n * @Title Rom工具类\n\n * @Description\n\n * @Author xuefeng.zhu\n\n * @Since 2018/9/3\n\n * @Version 2.7.0\n\n */\n\npublic class RomUtils {\n\nprivate static final String TAG = \"Rom\";\n\npublic static final String ROM_MIUI = \"MIUI\";\n\npublic static final String ROM_EMUI = \"EMUI\";\n\npublic static final String ROM_FLYME = \"FLYME\";\n\npublic static final String ROM_OPPO = \"OPPO\";\n\npublic static final String ROM_SMARTISAN = \"SMARTISAN\";\n\npublic static final String ROM_VIVO = \"VIVO\";\n\npublic static final String ROM_QIKU = \"QIKU\";\n\nprivate static final String KEY_VERSION_MIUI = \"ro.miui.ui.version.name\";\n\nprivate static final String KEY_VERSION_EMUI = \"ro.build.version.emui\";\n\nprivate static final String KEY_VERSION_OPPO = \"ro.build.version.opporom\";\n\nprivate static final String KEY_VERSION_SMARTISAN = \"ro.smartisan.version\";\n\nprivate static final String KEY_VERSION_VIVO = \"ro.vivo.os.version\";\n\nprivate static String sName;//当前系统名称\n\nprivate static String sVersion;//当前系统版本号\n\n/**\n\n     * 是否为华为系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isEmui() {\n\nreturn check(ROM_EMUI);\n\n    }\n\n/**\n\n     * 是否为小米系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isMiui() {\n\nreturn check(ROM_MIUI);\n\n    }\n\n/**\n\n     * 是否为vivo系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isVivo() {\n\nreturn check(ROM_VIVO);\n\n    }\n\n/**\n\n     * 是否为oppo系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isOppo() {\n\nreturn check(ROM_OPPO);\n\n    }\n\n/**\n\n     * 是否为魅族系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isFlyme() {\n\nreturn check(ROM_FLYME);\n\n    }\n\n/**\n\n     * 是否为360系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean is360() {\n\nreturn check(ROM_QIKU) || check(\"360\");\n\n    }\n\n/**\n\n     * 是否为锤子系统\n\n     *\n\n     * @return\n\n     */\n\npublic static boolean isSmartisan() {\n\nreturn check(ROM_SMARTISAN);\n\n    }\n\npublic static String getName() {\n\nif (sName == null) {\n\n            check(\"\");\n\n        }\n\nreturn sName;\n\n    }\n\npublic static String getVersion() {\n\nif (sVersion == null) {\n\n            check(\"\");\n\n        }\n\nreturn sVersion;\n\n    }\n\n/**\n\n     * 获取手机的rom类型\n\n     *\n\n     * @param rom\n\n     * @return\n\n     */\n\npublic static boolean check(String rom) {\n\nif (sName != null) {\n\nreturn sName.equals(rom);\n\n        }\n\nif (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_MIUI))) {\n\n            sName = ROM_MIUI;\n\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_EMUI))) {\n\n            sName = ROM_EMUI;\n\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_OPPO))) {\n\n            sName = ROM_OPPO;\n\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_VIVO))) {\n\n            sName = ROM_VIVO;\n\n        } else if (!TextUtils.isEmpty(sVersion = getProp(KEY_VERSION_SMARTISAN))) {\n\n            sName = ROM_SMARTISAN;\n\n        } else {\n\n            sVersion = Build.DISPLAY;\n\nif (sVersion.toUpperCase().contains(ROM_FLYME)) {\n\n                sName = ROM_FLYME;\n\n            } else {\n\n                sVersion = Build.UNKNOWN;\n\n                sName = Build.MANUFACTURER.toUpperCase();\n\n            }\n\n        }\n\nreturn sName.equals(rom);\n\n    }\n\npublic static String getProp(String name) {\n\nString line = null;\n\n        BufferedReader input = null;\n\ntry {\n\n            Process p = Runtime.getRuntime().exec(\"getprop \" + name);\n\n            input = new BufferedReader(new InputStreamReader(p.getInputStream()), 1024);\n\n            line = input.readLine();\n\n            input.close();\n\n        } catch (IOException ex) {\n\n            Log.e(TAG, \"Unable to read prop \" + name, ex);\n\nreturn null;\n\n        } finally {\n\nif (input != null) {\n\ntry {\n\n                    input.close();\n\n                } catch (IOException e) {\n\n                    e.printStackTrace();\n\n                }\n\n            }\n\n        }\n\nreturn line;\n\n    }\n\n}\n\n在用到相机权限的地方作相关处理：\n\n@AfterPermissionGranted(RECOMMEND_CAMERA)\n\nprivate void requestRecommend() {\n\nif (PermissionUtils.hasCameraPermissions(this)) {\n\n            RecommendScanActivity.start(this, REFERENCE_REQUEST_CODE);\n\n        } else {\n\nif (!(RomUtils.isOppo() || RomUtils.isVivo()))\n\n                EasyPermissions.requestPermissions(this, getString(R.string.scan_permission), RECOMMEND_CAMERA, RECOMMEND_PERMISSION);\n\n        }\n\n    }\n\n这样相相当于对oppo，vivo系列的手机做了特殊处理；到此相机权限兼容完毕；\n\nps：代码中用到的EasyPermissions是一个github上面的权限申请库；"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382129894},"updatedAt":{"$$date":1597383306208},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Q72bBn1di0sP1tdU"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977484727},"updatedAt":{"$$date":1594977484727},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"QPGyrZNG1M79YRlg"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977489742},"updatedAt":{"$$date":1594977489742},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Qp3aCt5X3TFPnMCo"}
{"name":"kotlin-迭代器 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/iterators.html\n迭代器 - Kotlin 语言中文站\n9-11 minutes\n改进翻译\n对于遍历集合元素， Kotlin 标准库支持 迭代器 的常用机制——对象可按顺序提供对元素的访问权限，而不会暴露集合的底层结构。 当需要逐个处理集合的所有元素（例如打印值或对其进行类似更新）时，迭代器非常有用。\n\nIterable<T> 接口的继承者（包括 Set 与 List）可以通过调用 iterator() 函数获得迭代器。 一旦获得迭代器它就指向集合的第一个元素；调用 next() 函数将返回此元素，并将迭代器指向下一个元素（如果下一个元素存在）。 一旦迭代器通过了最后一个元素，它就不能再用于检索元素；也无法重新指向到以前的任何位置。要再次遍历集合，请创建一个新的迭代器。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val numbersIterator = numbers.iterator()\n    while (numbersIterator.hasNext()) {\n        println(numbersIterator.next())\n    }\n//sampleEnd\n}\n遍历 Iterable 集合的另一种方法是众所周知的 for 循环。在集合中使用 for 循环时，将隐式获取迭代器。因此，以下代码与上面的示例等效：\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    for (item in numbers) {\n        println(item)\n    }\n//sampleEnd\n}\n最后，有一个好用的 forEach() 函数，可自动迭代集合并为每个元素执行给定的代码。因此，等效的示例如下所示：\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    numbers.forEach {\n        println(it)\n    }\n//sampleEnd\n}\n对于列表，有一个特殊的迭代器实现： ListIterator 它支持列表双向迭代：正向与反向。 反向迭代由 hasPrevious() 和 previous() 函数实现。 此外， ListIterator 通过 nextIndex() 与 previousIndex() 函数提供有关元素索引的信息。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val listIterator = numbers.listIterator()\n    while (listIterator.hasNext()) listIterator.next()\n    println(\"Iterating backwards:\")\n    while (listIterator.hasPrevious()) {\n        print(\"Index: ${listIterator.previousIndex()}\")\n        println(\", value: ${listIterator.previous()}\")\n    }\n//sampleEnd\n}\n具有双向迭代的能力意味着 ListIterator 在到达最后一个元素后仍可以使用。\n\n为了迭代可变集合，于是有了 MutableIterator 来扩展 Iterator 使其具有元素删除函数 remove() 。因此，可以在迭代时从集合中删除元素。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\") \n    val mutableIterator = numbers.iterator()\n    \n    mutableIterator.next()\n    mutableIterator.remove()    \n    println(\"After removal: $numbers\")\n//sampleEnd\n}\n除了删除元素， MutableListIterator 还可以在迭代列表时插入和替换元素。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"four\", \"four\") \n    val mutableListIterator = numbers.listIterator()\n    \n    mutableListIterator.next()\n    mutableListIterator.add(\"two\")\n    mutableListIterator.next()\n    mutableListIterator.set(\"three\")   \n    println(numbers)\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308430780},"updatedAt":{"$$date":1597314006134},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Qs3zJoAOyXYrkzeg"}
{"name":"kotlin-内联函数与具体化的类型参数 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/inline-functions.html\n内联函数与具体化的类型参数 - Kotlin 语言中文站\n13-17 minutes\n改进翻译\n使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。 即那些在函数体内会访问到的变量。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。\n\n但是在许多情况下通过内联化 lambda 表达式可以消除这类的开销。 下述函数是这种情况的很好的例子。即 lock() 函数可以很容易地在调用处内联。 考虑下面的情况：\n\n编译器没有为参数创建一个函数对象并生成一个调用。取而代之，编译器可以生成以下代码：\n\nl.lock()\ntry {\n    foo()\n}\nfinally {\n    l.unlock()\n}\n这个不是我们从一开始就想要的吗？\n\n为了让编译器这么做，我们需要使用 inline 修饰符标记 lock() 函数：\n\ninline fun <T> lock(lock: Lock, body: () -> T): T { …… }\ninline 修饰符影响函数本身和传给它的 lambda 表达式：所有这些都将内联到调用处。\n\n内联可能导致生成的代码增加；不过如果我们使用得当（即避免内联过大函数），性能上会有所提升，尤其是在循环中的“超多态（megamorphic）”调用处。\n\n如果希望只内联一部分传给内联函数的 lambda 表达式参数，那么可以用 noinline 修饰符标记不希望内联的函数参数：\n\ninline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) { …… }\n可以内联的 lambda 表达式只能在内联函数内部调用或者作为可内联的参数传递， 但是 noinline 的可以以任何我们喜欢的方式操作：存储在字段中、传送它等等。\n\n需要注意的是，如果一个内联函数没有可内联的函数参数并且没有具体化的类型参数，编译器会产生一个警告，因为内联这样的函数很可能并无益处（如果你确认需要内联，则可以用 @Suppress(\"NOTHING_TO_INLINE\") 注解关掉该警告）。\n\n在 Kotlin 中，我们只能对具名或匿名函数使用正常的、非限定的 return 来退出。 这意味着要退出一个 lambda 表达式，我们必须使用一个标签，并且在 lambda 表达式内部禁止使用裸 return，因为 lambda 表达式不能使包含它的函数返回：\n\nfun ordinaryFunction(block: () -> Unit) {\n    println(\"hi!\")\n}\n//sampleStart\nfun foo() {\n    ordinaryFunction {\n        return // 错误：不能使 `foo` 在此处返回\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n但是如果 lambda 表达式传给的函数是内联的，该 return 也可以内联，所以它是允许的：\n\ninline fun inlined(block: () -> Unit) { println(\"hi!\") }\n\n//sampleStart\nfun foo() {\n    inlined {\n        return // OK：该 lambda 表达式是内联的\n    }\n}\n//sampleEnd\nfun main() {\n    foo()\n}\n这种返回（位于 lambda 表达式中，但退出包含它的函数）称为非局部返回。 我们习惯了在循环中用这种结构，其内联函数通常包含：\n\nfun hasZeros(ints: List<Int>): Boolean {\n    ints.forEach {\n        if (it == 0) return true // 从 hasZeros 返回\n    }\n    return false\n}\n请注意，一些内联函数可能调用传给它们的不是直接来自函数体、而是来自另一个执行上下文的 lambda 表达式参数，例如来自局部对象或嵌套函数。在这种情况下，该 lambda 表达式中也不允许非局部控制流。为了标识这种情况，该 lambda 表达式参数需要用 crossinline 修饰符标记:\n\ninline fun f(crossinline body: () -> Unit) {\n    val f = object: Runnable {\n        override fun run() = body()\n    }\n    // ……\n}\nbreak 和 continue 在内联的 lambda 表达式中还不可用，但我们也计划支持它们。\n\n有时候我们需要访问一个作为参数传给我们的一个类型：\n\nfun <T> TreeNode.findParentOfType(clazz: Class<T>): T? {\n    var p = parent\n    while (p != null && !clazz.isInstance(p)) {\n        p = p.parent\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return p as T?\n}\n在这里我们向上遍历一棵树并且检测每个节点是不是特定的类型。 这都没有问题，但是调用处不是很优雅：\n\ntreeNode.findParentOfType(MyTreeNode::class.java)\n我们真正想要的只是传一个类型给该函数，即像这样调用它：\n\ntreeNode.findParentOfType<MyTreeNode>()\n为能够这么做，内联函数支持具体化的类型参数，于是我们可以这样写：\n\ninline fun <reified T> TreeNode.findParentOfType(): T? {\n    var p = parent\n    while (p != null && p !is T) {\n        p = p.parent\n    }\n    return p as T?\n}\n我们使用 reified 修饰符来限定类型参数，现在可以在函数内部访问它了， 几乎就像是一个普通的类一样。由于函数是内联的，不需要反射，正常的操作符如 !is 和 as 现在都能用了。此外，我们还可以按照上面提到的方式调用它：myTree.findParentOfType<MyTreeNodeType>()。\n\n虽然在许多情况下可能不需要反射，但我们仍然可以对一个具体化的类型参数使用它：\n\ninline fun <reified T> membersOf() = T::class.members\n\nfun main(s: Array<String>) {\n    println(membersOf<StringBuilder>().joinToString(\"\\n\"))\n}\n普通的函数（未标记为内联函数的）不能有具体化参数。 不具有运行时表示的类型（例如非具体化的类型参数或者类似于Nothing的虚构类型） 不能用作具体化的类型参数的实参。\n\n相关底层描述，请参见规范文档。\n\ninline 修饰符可用于没有幕后字段的属性的访问器。 你可以标注独立的属性访问器：\n\nval foo: Foo\n    inline get() = Foo()\n\nvar bar: Bar\n    get() = ……\n    inline set(v) { …… }\n你也可以标注整个属性，将它的两个访问器都标记为内联：\n\ninline var bar: Bar\n    get() = ……\n    set(v) { …… }\n在调用处，内联访问器如同内联函数一样内联。\n\n当一个内联函数是 public 或 protected 而不是 private 或 internal 声明的一部分时，就会认为它是一个模块级的公有 API。可以在其他模块中调用它，并且也可以在调用处内联这样的调用。\n\n这带来了一些由模块做这样变更时导致的二进制兼容的风险——声明一个内联函数但调用它的模块在它修改后并没有重新编译。\n\n为了消除这种由非公有 API 变更引入的不兼容的风险，公有 API 内联函数体内不允许使用非公有声明，即，不允许使用 private 与 internal 声明以及其部件。\n\n一个 internal 声明可以由 @PublishedApi 标注，这会允许它在公有 API 内联函数中使用。当一个 internal 内联函数标记有 @PublishedApi 时，也会像公有函数一样检测其函数体。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308427675},"updatedAt":{"$$date":1597313799408},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"R4mR4ncbyKm9CVd6"}
{"name":"kotlin-Kotlin 数据类与密封类 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-data-sealed-classes.html\nKotlin 数据类与密封类 | 菜鸟教程\n2-3 minutes\n数据类\nKotlin 可以创建一个只包含数据的类，关键字为 data：\n\ndata class User(val name: String, val age: Int)\n编译器会自动的从主构造函数中根据所有声明的属性提取以下函数：\n\nequals() / hashCode()\ntoString() 格式如 \"User(name=John, age=42)\"\ncomponentN() functions 对应于属性，按声明顺序排列\ncopy() 函数\n如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。\n\n为了保证生成代码的一致性以及有意义，数据类需要满足以下条件：\n\n主构造函数至少包含一个参数。\n\n所有的主构造函数的参数必须标识为val 或者 var ;\n\n数据类不可以声明为 abstract, open, sealed 或者 inner;\n\n数据类不能继承其他类 (但是可以实现接口)。\n\n复制\n复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样：\n\nfun copy(name: String = this.name, age: Int = this.age) = User(name, age)\n实例\n使用 copy 类复制 User 数据类，并修改 age 属性:\n\ndata class User(val name: String, val age: Int)\n\n\nfun main(args: Array<String>) {\n    val jack = User(name = \"Jack\", age = 1)\n    val olderJack = jack.copy(age = 2)\n    println(jack)\n    println(olderJack)\n\n}\n输出结果为：\n\nUser(name=Jack, age=1)\nUser(name=Jack, age=2)\n数据类以及解构声明\n组件函数允许数据类在解构声明中使用：\n\nval jane = User(\"Jane\", 35)\nval (name, age) = jane\nprintln(\"$name, $age years of age\") // prints \"Jane, 35 years of age\"\n标准数据类\n标准库提供了 Pair 和 Triple 。在大多数情形中，命名数据类是更好的设计选择，因为这样代码可读性更强而且提供了有意义的名字和属性。\n\n密封类\n密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。\n\n声明一个密封类，使用 sealed 修饰类，密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。\n\nsealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误)\n\nsealed class Expr\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n\nfun eval(expr: Expr): Double = when (expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n}\n使用密封类的关键好处在于使用 when 表达式 的时候，如果能够 验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。\n\nfun eval(expr: Expr): Double = when(expr) {\n    is Expr.Const -> expr.number\n    is Expr.Sum -> eval(expr.e1) + eval(expr.e2)\n    Expr.NotANumber -> Double.NaN\n    // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304145626},"updatedAt":{"$$date":1597304236287},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"RP2Z1l128IanzfZi"}
{"name":"kotlin-Kotlin 循环控制 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-loop-control.html\nKotlin 循环控制 | 菜鸟教程\n3-4 minutes\nFor 循环\nfor 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下:\n\nfor (item in collection) print(item)\n循环体可以是一个代码块:\n\nfor (item: Int in ints) {\n    // ……\n}\n如上所述，for 可以循环遍历任何提供了迭代器的对象。\n\n如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：\n\nfor (i in array.indices) {\n    print(array[i])\n}\n注意这种\"在区间上遍历\"会编译成优化的实现而不会创建额外对象。\n\n或者你可以用库函数 withIndex：\n\nfor ((index, value) in array.withIndex()) {\n    println(\"the element at $index is $value\")\n}\n实例\n对集合进行迭代：\n\nfun main(args: Array<String>) {\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (item in items) {\n        println(item)\n    }\n\n    for (index in items.indices) {\n        println(\"item at $index is ${items[index]}\")\n    }\n}\n输出结果：\n\napple\nbanana\nkiwi\nitem at 0 is apple\nitem at 1 is banana\nitem at 2 is kiwi\nwhile 与 do...while 循环\nwhile是最基本的循环，它的结构为：\n\nwhile( 布尔表达式 ) {\n  //循环内容\n}\ndo…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\n\ndo…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。\n\ndo {\n       //代码语句\n}while(布尔表达式);\n实例\nfun main(args: Array<String>) {\n    println(\"----while 使用-----\")\n    var x = 5\n    while (x > 0) {\n        println( x--)\n    }\n    println(\"----do...while 使用-----\")\n    var y = 5\n    do {\n        println(y--)\n    } while(y>0)\n}\n输出结果：\n\n5\n4\n3\n2\n1\n----do...while 使用-----\n5\n4\n3\n2\n1\n返回和跳转\nKotlin 有三种结构化跳转表达式：\n\nreturn。默认从最直接包围它的函数或者匿名函数返回。\nbreak。终止最直接包围它的循环。\ncontinue。继续下一次最直接包围它的循环。\n在循环中 Kotlin 支持传统的 break 和 continue 操作符。\n\nfun main(args: Array<String>) {\n    for (i in 1..10) {\n        if (i==3) continue  // i 为 3 时跳过当前循环，继续下一次循环\n        println(i)\n        if (i>5) break   // i 为 6 时 跳出循环\n    }\n}\n输出结果：\n\n1\n2\n4\n5\n6\nBreak 和 Continue 标签\n在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可。\n\nloop@ for (i in 1..100) {\n    // ……\n}\n现在，我们可以用标签限制 break 或者continue：\n\nloop@ for (i in 1..100) {\n    for (j in 1..100) {\n        if (……) break@loop\n    }\n}\n标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。\n\n标签处返回\nKotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：\n\nfun foo() {\n    ints.forEach {\n        if (it == 0) return\n        print(it)\n    }\n}\n这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。\n\nfun foo() {\n    ints.forEach lit@ {\n        if (it == 0) return@lit\n        print(it)\n    }\n}\n现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。\n\nfun foo() {\n    ints.forEach {\n        if (it == 0) return@forEach\n        print(it)\n    }\n}\n或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回\n\nfun foo() {\n    ints.forEach(fun(value: Int) {\n        if (value == 0) return\n        print(value)\n    })\n}\n当要返一个回值的时候，解析器优先选用标签限制的 return，即\n\nreturn@a 1\n意为\"从标签 @a 返回 1\"，而不是\"返回一个标签标注的表达式 (@a 1)\"。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303690944},"updatedAt":{"$$date":1597303936638},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"RorDcFmMQNVAFMzs"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980158049},"updatedAt":{"$$date":1594980158049},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"SSnxaz5MuV2n69Bf"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980167316},"updatedAt":{"$$date":1594980167316},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"SrfFtoHY94KWFPOi"}
{"name":"kotlin-控制流：if、when、for、while - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/control-flow.html\n控制流：if、when、for、while - Kotlin 语言中文站\n12-14 minutes\n改进翻译\n在 Kotlin 中，if是一个表达式，即它会返回一个值。 因此就不需要三元运算符（条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。\n\n// 传统用法\nvar max = a \nif (a < b) max = b\n\n// With else \nvar max: Int\nif (a > b) {\n    max = a\n} else {\n    max = b\n}\n \n// 作为表达式\nval max = if (a > b) a else b\nif 的分支可以是代码块，最后的表达式作为该块的值：\n\nval max = if (a > b) {\n    print(\"Choose a\")\n    a\n} else {\n    print(\"Choose b\")\n    b\n}\n如果你使用 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支。\n\n参见 if 语法。\n\nwhen 取代了类 C 语言的 switch 操作符。其最简单的形式如下：\n\nwhen (x) {\n    1 -> print(\"x == 1\")\n    2 -> print(\"x == 2\")\n    else -> { // 注意这个块\n        print(\"x is neither 1 nor 2\")\n    }\n}\nwhen 将它的参数与所有的分支条件顺序比较，直到某个分支满足条件。 when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式， 符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。（像 if 一样，每一个分支可以是一个代码块，它的值是块中最后的表达式的值。）\n\n如果其他分支都不满足条件将会求值 else 分支。 如果 when 作为一个表达式使用，则必须有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了［例如，对于 枚举（enum）类条目与密封（sealed）类子类型］。\n\n如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：\n\nwhen (x) {\n    0, 1 -> print(\"x == 0 or x == 1\")\n    else -> print(\"otherwise\")\n}\n我们可以用任意表达式（而不只是常量）作为分支条件\n\nwhen (x) {\n    parseInt(s) -> print(\"s encodes x\")\n    else -> print(\"s does not encode x\")\n}\n我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：\n\nwhen (x) {\n    in 1..10 -> print(\"x is in the range\")\n    in validNumbers -> print(\"x is valid\")\n    !in 10..20 -> print(\"x is outside the range\")\n    else -> print(\"none of the above\")\n}\n另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法与属性而无需任何额外的检测。\n\nfun hasPrefix(x: Any) = when(x) {\n    is String -> x.startsWith(\"prefix\")\n    else -> false\n}\nwhen 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：\n\nwhen {\n    x.isOdd() -> print(\"x is odd\")\n    y.isEven() -> print(\"y is even\")\n    else -> print(\"x+y is even.\")\n}\n自 Kotlin 1.3 起，可以使用以下语法将 when 的主语（subject，译注：指 when 所判断的表达式）捕获到变量中：\n\nfun Request.getBody() =\n        when (val response = executeRequest()) {\n            is Success -> response.body\n            is HttpError -> throw HttpException(response.status)\n        }\n在 when 主语中引入的变量的作用域仅限于 when 主体。\n\n参见 when 语法。\n\nfor 循环可以对任何提供迭代器（iterator）的对象进行遍历，这相当于像 C# 这样的语言中的 foreach 循环。语法如下：\n\nfor (item in collection) print(item)\n循环体可以是一个代码块。\n\nfor (item: Int in ints) {\n    // ……\n}\n如上所述，for 可以循环遍历任何提供了迭代器的对象。即：\n\n有一个成员函数或者扩展函数 iterator()，它的返回类型\n有一个成员函数或者扩展函数 next()，并且\n有一个成员函数或者扩展函数 hasNext() 返回 Boolean。\n这三个函数都需要标记为 operator。\n\n如需在数字区间上迭代，请使用区间表达式:\n\nfun main() {\n//sampleStart\n    for (i in 1..3) {\n        println(i)\n    }\n    for (i in 6 downTo 0 step 2) {\n        println(i)\n    }\n//sampleEnd\n}\n对区间或者数组的 for 循环会被编译为并不创建迭代器的基于索引的循环。\n\n如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：\n\nfun main() {\nval array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for (i in array.indices) {\n        println(array[i])\n    }\n//sampleEnd\n}\n或者你可以用库函数 withIndex：\n\nfun main() {\n    val array = arrayOf(\"a\", \"b\", \"c\")\n//sampleStart\n    for ((index, value) in array.withIndex()) {\n        println(\"the element at $index is $value\")\n    }\n//sampleEnd\n}\n参见 for 语法。\n\nwhile 与 do..while 照常使用\n\nwhile (x > 0) {\n    x--\n}\n\ndo {\n  val y = retrieveData()\n} while (y != null) // y 在此处可见\n参见 while 语法.\n\n在循环中 Kotlin 支持传统的 break 与 continue 操作符。参见返回与跳转。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306176632},"updatedAt":{"$$date":1597307698061},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TM24xOKldv9P7wbX"}
{"name":"andr-属性动画概览","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/graphics/prop-animation\n属性动画概览  |  Android 开发者  |  Android Developers\n22-28 minutes\n属性动画系统是一个强健的框架，用于为几乎任何内容添加动画效果。您可以定义一个随时间更改任何对象属性的动画，无论其是否绘制到屏幕上。属性动画会在指定时长内更改属性（对象中的字段）的值。要添加动画效果，请指定要添加动画效果的对象属性，例如对象在屏幕上的位置、动画效果持续多长时间以及要在哪些值之间添加动画效果。\n\n借助属性动画系统，您可以定义动画的以下特性：\n\n时长：您可以指定动画的时长。默认时长为 300 毫秒。\n时间插值：您可以指定如何根据动画的当前已播放时长来计算属性的值。\n重复计数和行为：您可以指定是否在某个时长结束后重复播放动画以及重复播放动画多少次。您还可以指定是否要反向播放动画。如果将其设置为反向播放，则会先播放动画，然后反向播放动画，直到达到重复次数。\nAnimator 集：您可以将动画分成多个逻辑集，它们可以一起播放、按顺序播放或者在指定的延迟时间后播放。\n帧刷新延迟：您可以指定动画帧的刷新频率。默认设置为每 10 毫秒刷新一次，但应用刷新帧的速度最终取决于整个系统的繁忙程度以及系统为底层计时器提供服务的速度。\n要查看属性动画的完整示例，请参阅 GitHub 上 CustomTransition 示例中的 ChangeColor 类。\n\n属性动画的工作原理\n首先，让我们通过一个简单的示例来了解动画的工作原理。图 1 描绘了一个假设的对象，该对象的 x 属性（表示其在屏幕上的水平位置）添加了动画效果。动画时长设置为 40 毫秒，要移动的距离为 40 像素。该对象每隔 10 毫秒（这是默认的帧刷新频率）会水平移动 10 像素。在 40 毫秒时，动画停止，同时对象在水平位置 40 处停止。这是使用线性插值（表示对象以恒定速度移动）的动画示例。\n\n\n\n图 1. 线性动画示例\n\n您也可以指定动画使用非线性插值。图 2 展示了一个假设的对象，它在动画开始时加速，在动画结束前减速。该对象仍在 40 毫秒内移动了 40 像素，但这种移动是非线性的。开始时，此动画加速移动到中间点，然后从中间点减速移动，直至动画结束。如图 2 所示，动画在开头和结尾移动的距离小于在中间移动的距离。\n\n\n\n图 2. 非线性动画示例\n\n我们来详细了解一下属性动画系统的重要组成部分将如何计算如上所示的动画。图 3 描绘了主类之间是如何相互协作的。\n\n\n\n图 3. 如何计算动画\n\nValueAnimator 对象跟踪动画的时间，例如动画的已运行时长以及正在添加动画效果的属性的当前值。\n\nValueAnimator 包含 TimeInterpolator 和 TypeEvaluator；前者用于定义动画插值，后者用于定义如何计算正在添加动画效果的属性的值。例如，在图 2 中，所用的 TimeInterpolator 为 AccelerateDecelerateInterpolator，所用的 TypeEvaluator 为 IntEvaluator。\n\n要开始动画，请创建一个 ValueAnimator，并为您想要添加动画效果的属性赋予起始值和结束值，以及动画时长。当您调用 start() 时，动画即会开始播放。在整个动画播放期间，ValueAnimator 将基于动画时长和已播放时长计算已完成动画分数（在 0 和 1 之间）。已完成动画分数表示动画已完成时间的百分比，0 表示 0%，1 表示 100%。以图 1 为例，在 t = 10ms 处，已完成动画分数将为 0.25，因为总时长 t = 40ms。\n\n在 ValueAnimator 计算完已完成动画分数后，它会调用当前设置的 TimeInterpolator 来计算插值分数。插值分数会将已完成动画分数映射为一个新分数，该分数会考虑已设置的时间插值。例如，在图 2 中，由于动画缓慢加速，t = 10ms 时的插值分数（约 0.15）小于已完成动画分数 (0.25)。在图 1 中，插值分数始终等于已完成动画分数。\n\n计算插值分数后，ValueAnimator 会调用相应的 TypeEvaluator，以根据动画的插值分数、起始值和结束值来计算要添加动画效果的属性的值。例如，在图 2 中，t = 10ms 时的插值分数为 0.15，因此，此时属性的值为 0.15 × (40 - 0)，即 6。\n\n属性动画与视图动画的区别\n视图动画系统仅提供为 View 对象添加动画效果的功能，因此，如果您想为非 对象添加动画效果，则必须实现自己的代码才能做到。视图动画系统也存在一些限制，因为它仅公开 对象的部分方面来供您添加动画效果；例如，您可以对视图的缩放和旋转添加动画效果，但无法对背景颜色这样做。\n\n视图动画系统的另一个缺点是它只会在绘制视图的位置进行修改，而不会修改实际的视图本身。例如，如果您为某个按钮添加了动画效果，使其可以在屏幕上移动，该按钮会正确绘制，但能够点击按钮的实际位置并不会更改，因此您必须通过实现自己的逻辑来处理此事件。\n\n有了属性动画系统，您就可以完全摆脱这些束缚，还可以为任何对象（视图和非视图）的任何属性添加动画效果，并且实际修改的是对象本身。属性动画系统在执行动画方面也更为强健。概括地讲，您可以为要添加动画效果的属性（例如颜色、位置或大小）分配 Animator，还可以定义动画的各个方面，例如多个 Animator 的插值和同步。\n\n不过，视图动画系统的设置需要的时间较短，需要编写的代码也较少。如果视图动画可以完成您需要执行的所有操作，或者现有代码已按照您需要的方式运行，则无需使用属性动画系统。在某些用例中，也可以针对不同的情况同时使用这两种动画系统。\n\nAPI 概览\n您可以在 android.animation 中找到属性动画系统的大多数 API。视图动画系统已经在 android.view.animation 中定义了许多插值器，因此，您也可以在属性动画系统中使用这些插值器。下表描述了属性动画系统的主要组成部分。\n\nAnimator 类提供了创建动画的基本结构。您通常不会直接使用此类，因为它只提供极少的功能，这些功能必须经过扩展才能全面支持为值添加动画效果。以下子类可扩展 Animator：\n\n表 1. Animator\n\n评估程序负责告知属性动画系统如何计算指定属性的值。它们使用由 Animator 类提供的计时数据（即动画的起始值和结束值），并根据这些数据计算属性添加动画效果之后的值。属性动画系统可提供以下评估程序：\n\n表 2. 评估程序\n\n时间插值器指定了如何根据时间计算动画中的特定值。例如，您可以指定动画在整个动画中以线性方式播放，即动画在整个播放期间匀速移动；也可以指定动画使用非线性时间，例如动画在开始后加速并在结束前减速。表 3 介绍了 android.view.animation 中包含的插值器。如果下表提供的插值器都不能满足您的需求，请实现 TimeInterpolator 接口并创建您自己的插值器。如需详细了解如何编写自定义插值器，请参阅使用插值器。\n\n表 3. 插值器\n\n使用 ValueAnimator 添加动画效果\n借助 ValueAnimator 类，您可以为动画播放期间某些类型的值添加动画效果，只需指定一组要添加动画效果的 int、float 或颜色值即可。您可以通过调用 ValueAnimator 的任一工厂方法来获取它：ofInt()、ofFloat() 或 ofObject()。例如：\n\n    ValueAnimator.ofFloat(0f, 100f).apply {\n        duration = 1000\n        start()\n    }\n    \n    ValueAnimator animation = ValueAnimator.ofFloat(0f, 100f);\n    animation.setDuration(1000);\n    animation.start();\n    \n在上述代码中，当 start() 方法运行时，ValueAnimator 会开始计算 1000ms 时长内 0 和 100 之间的动画的值。\n\n您还可以通过执行以下操作来指定要添加动画效果的自定义类型：\n\n    ValueAnimator.ofObject(MyTypeEvaluator(), startPropertyValue, endPropertyValue).apply {\n        duration = 1000\n        start()\n    }\n    \n    ValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue);\n    animation.setDuration(1000);\n    animation.start();\n    \n在上述代码中，当 start() 方法运行时，ValueAnimator 会开始使用 MyTypeEvaluator 提供的逻辑计算 1000ms 时长内 startPropertyValue 和 endPropertyValue 之间的动画的值。\n\n您可以通过向 ValueAnimator 对象添加 AnimatorUpdateListener 来使用动画的值，如以下代码所示：\n\n    ValueAnimator.ofObject(...).apply {\n        ...\n        addUpdateListener { updatedAnimation ->\n            // You can use the animated value in a property that uses the\n            // same type as the animation. In this case, you can use the\n            // float value in the translationX property.\n            textView.translationX = updatedAnimation.animatedValue as Float\n        }\n        ...\n    }\n    \n    animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator updatedAnimation) {\n            // You can use the animated value in a property that uses the\n            // same type as the animation. In this case, you can use the\n            // float value in the translationX property.\n            float animatedValue = (float)updatedAnimation.getAnimatedValue();\n            textView.setTranslationX(animatedValue);\n        }\n    });\n    \n在 onAnimationUpdate() 方法中，您可以访问更新后的动画值，并将其用在您的某个视图的属性中。如需详细了解监听器，请参阅动画监听器部分。\n\n使用 ObjectAnimator 添加动画效果\nObjectAnimator 是上一部分中讨论的 ValueAnimator 的子类，它融合了 ValueAnimator 的计时引擎和值计算以及为目标对象的命名属性添加动画效果这一功能。这可以极大地简化为任何对象添加动画效果的过程，因为动画属性会自动更新，因此您也无需再实现 ValueAnimator.AnimatorUpdateListener 了。\n\n实例化 ObjectAnimator 与 ValueAnimator 的过程类似，但您也可以指定对象和该对象属性的名称（以字符串形式），以及要在哪些值之间添加动画效果：\n\n    ObjectAnimator.ofFloat(textView, \"translationX\", 100f).apply {\n        duration = 1000\n        start()\n    }\n    \n    ObjectAnimator animation = ObjectAnimator.ofFloat(textView, \"translationX\", 100f);\n    animation.setDuration(1000);\n    animation.start();\n    \n要使 ObjectAnimator 正确更新属性，您必须执行以下操作：\n\n要添加动画效果的对象属性必须具有 set<PropertyName>() 形式的 setter 函数（采用驼峰式大小写形式）。由于 ObjectAnimator 会在动画过程中自动更新属性，它必须能够使用此 setter 方法访问该属性。例如，如果属性名称为 foo，则需要使用 setFoo() 方法。如果此 setter 方法不存在，您有三个选择：\n如果您有权限，可将 setter 方法添加到类中。\n使用您有权更改的封装容器类，让该封装容器使用有效的 setter 方法接收值并将其转发给原始对象。\n改用 ValueAnimator。\n如果您在 ObjectAnimator 的一个工厂方法中仅为 values... 参数指定了一个值，则系统会假定它是动画的结束值。因此，要添加动画效果的对象属性必须具有用于获取动画起始值的 getter 函数。getter 函数必须采用 get<PropertyName>() 形式。例如，如果属性名称为 foo，则需要使用 getFoo() 方法。\n要添加动画效果的属性的 getter（如果需要）和 setter 方法的操作对象必须与您为 ObjectAnimator 指定的起始值和结束值的类型相同。例如，如果构建以下 ObjectAnimator，则必须具有 targetObject.setPropName(float) 和 targetObject.getPropName(float)：\n    ObjectAnimator.ofFloat(targetObject, \"propName\", 1f)\n    \n根据您要添加动画效果的属性或对象，您可能需要对视图调用 invalidate() 方法，以强制屏幕使用添加动画效果之后的值重新绘制自身。您可以在 onAnimationUpdate() 回调中执行此操作。例如，如果为可绘制对象的颜色属性添加动画效果，则仅当该对象重新绘制自身时，屏幕才会刷新。视图的所有属性 setter（如 setAlpha() 和 setTranslationX()）都会使视图失效，因此，在使用新值调用这些方法时，您无需使视图失效。如需详细了解监听器，请参阅动画监听器部分。\n使用 AnimatorSet 编排多个动画\n在许多情况下，您需要根据一个动画开始或结束的时间来播放另一个动画。借助 Android 系统，您可以将动画捆绑到一个 AnimatorSet 中，以便指定是同时播放动画、按顺序播放还是在指定的延迟时间后播放。您还可以相互嵌套 AnimatorSet 对象。\n\n以下代码段通过以下方式播放相应的 Animator 对象：\n\n播放 bounceAnim。\n同时播放 squashAnim1、squashAnim2、stretchAnim1 和 stretchAnim2。\n播放 bounceBackAnim。\n播放 fadeAnim。\n    val bouncer = AnimatorSet().apply {\n        play(bounceAnim).before(squashAnim1)\n        play(squashAnim1).with(squashAnim2)\n        play(squashAnim1).with(stretchAnim1)\n        play(squashAnim1).with(stretchAnim2)\n        play(bounceBackAnim).after(stretchAnim2)\n    }\n    val fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f).apply {\n        duration = 250\n    }\n    AnimatorSet().apply {\n        play(bouncer).before(fadeAnim)\n        start()\n    }\n    \n    AnimatorSet bouncer = new AnimatorSet();\n    bouncer.play(bounceAnim).before(squashAnim1);\n    bouncer.play(squashAnim1).with(squashAnim2);\n    bouncer.play(squashAnim1).with(stretchAnim1);\n    bouncer.play(squashAnim1).with(stretchAnim2);\n    bouncer.play(bounceBackAnim).after(stretchAnim2);\n    ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f);\n    fadeAnim.setDuration(250);\n    AnimatorSet animatorSet = new AnimatorSet();\n    animatorSet.play(bouncer).before(fadeAnim);\n    animatorSet.start();\n    \n动画监听器\n您可以使用下述监听器来监听动画播放期间的重要事件。\n\nAnimator.AnimatorListener\nonAnimationStart() - 在动画开始播放时调用。\nonAnimationEnd() - 在动画结束播放时调用。\nonAnimationRepeat() - 在动画重复播放时调用。\nonAnimationCancel() - 在动画取消播放时调用。取消的动画也会调用 onAnimationEnd()，无论它们以何种方式结束。\nValueAnimator.AnimatorUpdateListener\nonAnimationUpdate() - 对动画的每一帧调用。监听此事件即可使用 ValueAnimator 在动画播放期间生成的计算值。要使用该值，请查询传递到事件中的 ValueAnimator 对象，以使用 getAnimatedValue() 方法获取当前添加动画效果之后的值。如果使用了 ValueAnimator，则必须实现此监听器。\n\n根据您要添加动画效果的属性或对象，您可能需要对视图调用 invalidate()，以强制屏幕上的相应区域使用添加动画效果之后的新值重新绘制自身。例如，如果为可绘制对象的颜色属性添加动画效果，则仅当该对象重新绘制自身时，屏幕才会刷新。视图的所有属性 setter（如 setAlpha() 和 setTranslationX()）都会使视图失效，因此，在使用新值调用这些方法时，您无需使视图失效。\n\n如果您不一定需要实现 Animator.AnimatorListener 接口的所有方法，则可以扩展 AnimatorListenerAdapter 类，而非实现 接口。AnimatorListenerAdapter 类提供了方法的空实现，可供您选择替换。\n\n例如，以下代码段可仅为 onAnimationEnd() 回调创建 AnimatorListenerAdapter：\n\n    ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f).apply {\n        duration = 250\n        addListener(object : AnimatorListenerAdapter() {\n            override fun onAnimationEnd(animation: Animator) {\n                balls.remove((animation as ObjectAnimator).target)\n            }\n        })\n    }\n    \n    ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f);\n    fadeAnim.setDuration(250);\n    fadeAnim.addListener(new AnimatorListenerAdapter() {\n    public void onAnimationEnd(Animator animation) {\n        balls.remove(((ObjectAnimator)animation).getTarget());\n    }\n    \n为 ViewGroup 对象的布局更改添加动画效果\n属性动画系统提供对 ViewGroup 对象的更改添加动画效果的功能，还可轻松为视图对象本身添加动画效果。\n\n您可使用 LayoutTransition 类为 ViewGroup 内的布局更改添加动画效果。当您向 ViewGroup 添加视图或删除其中的视图时，或当您使用 VISIBLE、INVISIBLE 或 GONE 调用视图的 setVisibility() 方法时，这些视图可能会经历出现和消失动画。向 ViewGroup 添加视图或删除其中的视图时，其中剩余的视图还可能以动画形式移动到新位置。您可以调用 setAnimator() 并使用以下任一 LayoutTransition 常量传入 Animator 对象，从而在 LayoutTransition 对象中定义相应动画：\n\nAPPEARING - 该标记表示动画在容器中出现的项上运行。\nCHANGE_APPEARING - 该标记表示动画在因某个新项目在容器中出现而变化的项上运行。\nDISAPPEARING - 该标记表示动画在从容器中消失的项上运行。\nCHANGE_DISAPPEARING - 该标记表示动画在因某个项从容器中消失而变化的项上运行。\n您可以为这四类事件定义您自己的自定义动画，从而自定义布局转换的外观，或者告诉动画系统使用默认动画。\n\nAPI 演示中的 LayoutAnimations 示例介绍了如何为布局转换定义动画，然后在要添加动画效果的视图对象上设置动画。\n\nLayoutAnimationsByDefault 及其对应的 layout_animations_by_default.xml 布局资源文件介绍了如何在 XML 中为 ViewGroup 启用默认布局转换。您唯一需要做的就是将 ViewGroup 的 android:animateLayoutchanges 属性设置为 true。例如：\n\n    <LinearLayout\n        android:orientation=\"vertical\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"match_parent\"\n        android:id=\"@+id/verticalContainer\"\n        android:animateLayoutChanges=\"true\" />\n    \n将此属性设置为 true 可自动为添加到 ViewGroup 或从中删除的视图以及该 ViewGroup 中剩余的视图添加动画效果。\n\n使用 StateListAnimator 为视图状态更改添加动画效果\n通过 StateListAnimator 类，您可以定义在视图状态更改时运行的 Animator。此对象充当 Animator 对象的封装容器，只要指定的视图状态（例如“按下”或“聚焦”）发生更改，就会调用该动画。\n\n可使用根 <selector> 元素和子 <item> 元素在 XML 资源中定义 StateListAnimator，每个元素都指定一个由 StateListAnimator 类定义的不同视图状态。每个 <item> 都包含一个属性动画集的定义。\n\n例如，以下文件创建了一个状态列表 Animator，可在按下后更改视图的 x 和 y 比例：\n\nres/xml/animate_scale.xml\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n        <!-- the pressed state; increase x and y size to 150% -->\n        <item android:state_pressed=\"true\">\n            <set>\n                <objectAnimator android:propertyName=\"scaleX\"\n                    android:duration=\"@android:integer/config_shortAnimTime\"\n                    android:valueTo=\"1.5\"\n                    android:valueType=\"floatType\"/>\n                <objectAnimator android:propertyName=\"scaleY\"\n                    android:duration=\"@android:integer/config_shortAnimTime\"\n                    android:valueTo=\"1.5\"\n                    android:valueType=\"floatType\"/>\n            </set>\n        </item>\n        <!-- the default, non-pressed state; set x and y size to 100% -->\n        <item android:state_pressed=\"false\">\n            <set>\n                <objectAnimator android:propertyName=\"scaleX\"\n                    android:duration=\"@android:integer/config_shortAnimTime\"\n                    android:valueTo=\"1\"\n                    android:valueType=\"floatType\"/>\n                <objectAnimator android:propertyName=\"scaleY\"\n                    android:duration=\"@android:integer/config_shortAnimTime\"\n                    android:valueTo=\"1\"\n                    android:valueType=\"floatType\"/>\n            </set>\n        </item>\n    </selector>\n    \n要将状态列表 Animator 附加到视图，请添加 android:stateListAnimator 属性，如下所示：\n\n    <Button android:stateListAnimator=\"@xml/animate_scale\"\n            ... />\n    \n现在，当此按钮的状态发生变化时，会使用 animate_scale.xml 中定义的动画。\n\n或者，如果要转为在代码中将状态列表 Animator 分配给视图，则可使用 AnimatorInflater.loadStateListAnimator() 方法，然后使用 View.setStateListAnimator() 方法将 Animator 分配给相应视图。\n\n您还可以使用 AnimatedStateListDrawable 在状态更改间播放可绘制动画，而不是为视图的属性添加动画效果。Android 5.0 中的一些系统微件默认会使用这些动画。以下示例展示了如何将 AnimatedStateListDrawable 定义为 XML 资源：\n\n    <!-- res/drawable/myanimstatedrawable.xml -->\n    <animated-selector\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"><!-- provide a different drawable for each state-->\n        <item android:id=\"@+id/pressed\" android:drawable=\"@drawable/drawableP\"\n            android:state_pressed=\"true\"/>\n        <item android:id=\"@+id/focused\" android:drawable=\"@drawable/drawableF\"\n            android:state_focused=\"true\"/>\n        <item android:id=\"@id/default\"\n            android:drawable=\"@drawable/drawableD\"/><!-- specify a transition -->\n        <transition android:fromId=\"@+id/default\" android:toId=\"@+id/pressed\">\n            <animation-list>\n                <item android:duration=\"15\" android:drawable=\"@drawable/dt1\"/>\n                <item android:duration=\"15\" android:drawable=\"@drawable/dt2\"/>\n                ...\n            </animation-list>\n        </transition>\n        ...\n    </animated-selector>\n    \n使用 TypeEvaluator\n如果要为 Android 系统无法识别的类型添加动画效果，则可以通过实现 TypeEvaluator 接口来创建您自己的评估程序。Android 系统可以识别的类型为 int、float 或颜色，分别由 IntEvaluator、FloatEvaluator 和 ArgbEvaluator 类型评估程序提供支持。\n\nTypeEvaluator 接口中只有一种要实现的方法，那就是 evaluate() 方法。这样，您使用的 Animator 就会在动画的当前点为添加动画效果之后的属性返回适当的值。FloatEvaluator 类演示了如何做到这一点：\n\n    private class FloatEvaluator : TypeEvaluator<Any> {override fun evaluate(fraction: Float, startValue: Any, endValue: Any): Any {\n            return (startValue as Number).toFloat().let { startFloat ->\n                startFloat + fraction * ((endValue as Number).toFloat() - startFloat)\n            }\n        }}\n    \n    public class FloatEvaluator implements TypeEvaluator {public Object evaluate(float fraction, Object startValue, Object endValue) {\n            float startFloat = ((Number) startValue).floatValue();\n            return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);\n        }\n    }\n    \n注意：当 ValueAnimator（或 ObjectAnimator）运行时，它会计算动画当前的已完成动画分数（一个介于 0 和 1 之间的值），然后根据您正在使用的插值器来计算该分数的插值版本。插值分数是 TypeEvaluator 通过 fraction 参数接收的，因此您在计算添加动画效果之后的值时无需考虑插值器。\n\n使用插值器\n插值器指定了如何根据时间计算动画中的特定值。例如，您可以指定动画在整个动画中以线性方式播放，即动画在整个播放期间匀速移动；也可以指定动画使用非线性时间，例如动画在开始后加速并在结束前减速。\n\n动画系统中的插值器会接收来自 Animator 的分数，该分数表示动画的已播放时间。插值器会修改此分数，使其与要提供的动画类型保持一致。Android 系统在 android.view.animation package 中提供了一组常用的插值器。如果这些插值器都不能满足您的需求，您可以实现 TimeInterpolator 接口并创建您自己的插值器。\n\n以下示例对比了默认插值器 AccelerateDecelerateInterpolator 和 LinearInterpolator 计算插值分数的方式。LinearInterpolator 对已完成动画分数没有任何影响。AccelerateDecelerateInterpolator 会在动画开始后加速，并在动画结束前减速。以下方法定义了这些插值器的逻辑：\n\nAccelerateDecelerateInterpolator\n\n    override fun getInterpolation(input: Float): Float =\n            (Math.cos((input + 1) * Math.PI) / 2.0f).toFloat() + 0.5f\n    \n    @Override\n    public float getInterpolation(float input) {\n        return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;\n    }\n    \nLinearInterpolator\n\n    override fun getInterpolation(input: Float): Float = input\n    \n    @Override\n    public float getInterpolation(float input) {\n        return input;\n    }\n    \n下表表示这些插值器为时长 1000ms 的动画计算的近似值：\n\n已完成毫秒数\t已完成动画分数/插值分数（线性）\t插值分数（加速/减速）\n0\t0\t0\n200\t0.2\t0.1\n400\t0.4\t0.345\n600\t0.6\t0.8\n800\t0.8\t0.9\n1000\t1\t1\n如上表所示，LinearInterpolator 以相同的速度更改值，每 200ms 变化 0.2。AccelerateDecelerateInterpolator 在 200ms 到 600ms 之间更改值的速度会快于 LinearInterpolator，在 600ms 到 1000ms 之间会慢一些。\n\n指定关键帧\nKeyframe 对象由时间值对组成，用于在动画的特定时间定义特定的状态。每个关键帧还可以用自己的插值器控制动画在上一关键帧时间和此关键帧时间之间的时间间隔内的行为。\n\n要实例化 Keyframe 对象，您必须使用它的任一工厂方法（ofInt()、ofFloat() 或 ofObject()）来获取类型合适的 。然后，通过调用 ofKeyframe() 工厂方法来获取 PropertyValuesHolder 对象。获取对象后，您可以通过传入 PropertyValuesHolder 对象以及要添加动画效果的对象来获取 Animator。以下代码段演示了如何做到这一点：\n\n    val kf0 = Keyframe.ofFloat(0f, 0f)\n    val kf1 = Keyframe.ofFloat(.5f, 360f)\n    val kf2 = Keyframe.ofFloat(1f, 0f)\n    val pvhRotation = PropertyValuesHolder.ofKeyframe(\"rotation\", kf0, kf1, kf2)\n    ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation).apply {\n        duration = 5000\n    }\n    \n    Keyframe kf0 = Keyframe.ofFloat(0f, 0f);\n    Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);\n    Keyframe kf2 = Keyframe.ofFloat(1f, 0f);\n    PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(\"rotation\", kf0, kf1, kf2);\n    ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation);\n    rotationAnim.setDuration(5000);\n    \n为视图添加动画效果\n属性动画系统支持为视图对象添加经过简化的动画，与视图动画系统相比，它具有一定的优势。视图动画系统通过更改绘制视图对象的方式来转换视图对象。这是在每个视图的容器中处理的，因为视图本身没有可操控的属性。这会导致视图在表面上添加了动画效果，但视图对象本身没有任何变化。这会产生不好的效果，例如，某个对象已经在屏幕的其他位置绘制，但它仍位于其原始位置。在 Android 3.0 中，我们添加了新的属性以及相应的 getter 和 setter 方法来消除此缺陷。\n\n属性动画系统可以通过更改视图对象中的实际属性来为屏幕上的视图添加动画效果。此外，当视图的属性发生更改时，视图还会自动调用 invalidate() 方法来刷新屏幕。View 类中有利于属性动画的新属性包括：\n\ntranslationX 和 translationY：这些属性用于控制视图所在的位置，值为视图的布局容器所设置的左侧坐标和顶部坐标的增量。\nrotation、rotationX 和 rotationY：这些属性用于控制视图围绕轴心点进行的 2D（ 属性）和 3D 旋转。\nscaleX 和 scaleY：这些属性用于控制视图围绕其轴心点进行的 2D 缩放。\npivotX 和 pivotY：这些属性用于控制旋转和缩放转换所围绕的轴心点的位置。默认情况下，轴心点位于对象的中心。\nx 和 y：这些是简单的实用属性，用于描述视图在容器中的最终位置，值分别为左侧值与 translationX 值的和以及顶部值与 translationY 值的和。\nalpha：表示视图的 Alpha 透明度。此值默认为 1（不透明），值为 0 则表示完全透明（不可见）。\n要为视图对象的属性（例如其颜色或旋转值）添加动画效果，您只需创建一个属性 Animator 并指定要添加动画效果的视图属性即可。例如：\n\n    ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f)\n    \n    ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f);\n    \n如需详细了解如何创建 Animator，请参阅介绍如何使用 ValueAnimator 和 ObjectAnimator 添加动画效果的部分。\n\n使用 ViewPropertyAnimator 添加动画效果\nViewPropertyAnimator 有助于使用单个底层 Animator 对象轻松为 View 的多个属性并行添加动画效果。它的行为方式与 ObjectAnimator 非常相似，因为它会修改视图属性的实际值，但在同时为多个属性添加动画效果时，它更为高效。此外，使用 ViewPropertyAnimator 的代码更加简洁，也更易读。以下代码段展示了在同时为视图的 x 和 y 属性添加动画效果时，使用多个 ObjectAnimator 对象、使用单个 ObjectAnimator 对象以及使用 ViewPropertyAnimator 的区别。\n\n多个 ObjectAnimator 对象\n\n    val animX = ObjectAnimator.ofFloat(myView, \"x\", 50f)\n    val animY = ObjectAnimator.ofFloat(myView, \"y\", 100f)\n    AnimatorSet().apply {\n        playTogether(animX, animY)\n        start()\n    }\n    \n    ObjectAnimator animX = ObjectAnimator.ofFloat(myView, \"x\", 50f);\n    ObjectAnimator animY = ObjectAnimator.ofFloat(myView, \"y\", 100f);\n    AnimatorSet animSetXY = new AnimatorSet();\n    animSetXY.playTogether(animX, animY);\n    animSetXY.start();\n    \n一个 ObjectAnimator\n\n    val pvhX = PropertyValuesHolder.ofFloat(\"x\", 50f)\n    val pvhY = PropertyValuesHolder.ofFloat(\"y\", 100f)\n    ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvhY).start()\n    \n    PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"x\", 50f);\n    PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"y\", 100f);\n    ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvhY).start();\n    \nViewPropertyAnimator\n\n    myView.animate().x(50f).y(100f)\n    \n    myView.animate().x(50f).y(100f);\n    \n如需详细了解 ViewPropertyAnimator，请参阅相应的 Android 开发者博文。\n\n在 XML 中声明动画\n属性动画系统支持您使用 XML 声明属性动画，而不是以编程方式进行声明。通过在 XML 中定义动画，您可以轻松地在多个 Activity 中重复使用动画，还能更轻松地修改动画序列。\n\n为了将使用新属性动画 API 的动画文件与使用旧版视图动画框架的动画文件区分开来，从 Android 3.1 开始，您应将属性动画的 XML 文件保存到 res/animator/ 目录中。\n\n以下属性动画类具有带相应 XML 标签的 XML 声明支持：\n\nValueAnimator - <animator>\nObjectAnimator - <objectAnimator>\nAnimatorSet - <set>\n要查找 XML 声明中可使用的属性，请参阅动画资源。以下示例依次播放两组对象动画，其中第一个嵌套集会同时播放两个对象动画：\n\n    <set android:ordering=\"sequentially\">\n        <set>\n            <objectAnimator\n                android:propertyName=\"x\"\n                android:duration=\"500\"\n                android:valueTo=\"400\"\n                android:valueType=\"intType\"/>\n            <objectAnimator\n                android:propertyName=\"y\"\n                android:duration=\"500\"\n                android:valueTo=\"300\"\n                android:valueType=\"intType\"/>\n        </set>\n        <objectAnimator\n            android:propertyName=\"alpha\"\n            android:duration=\"500\"\n            android:valueTo=\"1f\"/>\n    </set>\n    \n为了运行此动画，您必须将代码中的 XML 资源扩充为 AnimatorSet 对象，然后在开始动画集之前为所有动画设置目标对象。调用 setTarget() 即可为 AnimatorSet 的所有子项设置一个目标对象，这是系统提供的便捷方式。以下代码展示了如何做到这一点：\n\n    (AnimatorInflater.loadAnimator(myContext, R.animator.property_animator) as AnimatorSet).apply {\n        setTarget(myObject)\n        start()\n    }\n    \n    AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,\n        R.animator.property_animator);\n    set.setTarget(myObject);\n    set.start();\n    \n您还可以在 XML 中声明 ValueAnimator，如以下示例所示：\n\n    <animator xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:duration=\"1000\"\n        android:valueType=\"floatType\"\n        android:valueFrom=\"0f\"\n        android:valueTo=\"-100f\" />\n    \n要使用代码中的上一个 ValueAnimator，您必须扩充对象、添加 AnimatorUpdateListener、获取更新后的动画值并在某个视图的属性中使用它，如下面的代码所示：\n\n    (AnimatorInflater.loadAnimator(this, R.animator.animator) as ValueAnimator).apply {\n        addUpdateListener { updatedAnimation ->\n            textView.translationX = updatedAnimation.animatedValue as Float\n        }\n        start\n\n()\n    }\n    \n    ValueAnimator xmlAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(this,\n            R.animator.animator);\n    xmlAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator updatedAnimation) {\n            float animatedValue = (float)updatedAnimation.getAnimatedValue();\n            textView.setTranslationX(animatedValue);\n        }\n    });\n    xmlAnimator\n\n.start();\n    \n如需了解定义属性动画的 XML 语法，请参阅动画资源。\n\n对界面性能的潜在影响\n用于更新界面的 Animator 会使动画运行的每一帧都进行额外的渲染。因此，使用资源密集型动画可能会对应用的性能产生负面影响。\n\n为界面添加动画效果所需的工作已添加到渲染管道的动画阶段。您可以启用 GPU 渲染模式分析并监控动画阶段，以了解您的动画是否会影响应用的性能。如需了解详情，请参阅 GPU 渲染模式分析演示。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243910245},"updatedAt":{"$$date":1597244861484},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TOQu3v19Zk9QgYNH"}
{"name":"andr-在 Fragment 之间传递数据","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\ndeveloper.android.google.cn /training/basics/fragments/pass-data-between\n在 Fragment 之间传递数据  |  Android 开发者  |  Android Developers\n6-7 minutes\n从 Fragment 1.3.0-alpha04 开始，每个 FragmentManager 都会实现 FragmentResultOwner。这意味着 FragmentManager 可以充当 Fragment 结果的集中存储区。此更改通过设置 Fragment 结果并监听这些结果，而不要求 Fragment 直接引用彼此，让单独的 Fragment 相互通信。\n\n如需将数据从 Fragment B 传回到 Fragment A，请先在接收结果的 Fragment A 上设置结果监听器。在 Fragment A 的 FragmentManager 上调用 setFragmentResultListener() API，如以下示例所示：\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    // Use the Kotlin extension in the fragment-ktx artifact\n    setResultListener(\"requestKey\") { key, bundle ->\n        // We use a String here, but any type that can be put in a Bundle is supported\n        val result = bundle.getString(\"bundleKey\")\n        // Do something with the result...\n    }\n}\n@Override\npublic void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    getParentFragmentManager().setFragmentResultListener(\"key\", this, new FragmentResultListener() {\n        @Override\n        public void onFragmentResult(@NonNull String key, @NonNull Bundle bundle) {\n            // We use a String here, but any type that can be put in a Bundle is supported\n            String result = bundle.getString(\"bundleKey\");\n            // Do something with the result...\n        }\n    });\n}\nFragment B 使用 Fragment 管理器将数据发送到 Fragment A\n图 1. Fragment B 使用 FragmentManager 将数据发送到 Fragment A。\n在生成结果的 Fragment B 中，您必须使用相同的 requestKey 在同一 FragmentManager 上设置结果。您可以使用 setFragmentResult() API 来完成此操作：\n\nbutton.setOnClickListener {\n    val result = \"result\"\n    // Use the Kotlin extension in the fragment-ktx artifact\n    setResult(\"requestKey\", bundleOf(\"bundleKey\" to result))\n}\nbutton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Bundle result = new Bundle();\n        result.putString(\"bundleKey\", \"result\");\n        getParentFragmentManager().setFragmentResult(\"requestKey\", result);\n    }\n});\n然后，在值为 STARTED 后，Fragment A 便会收到结果并执行监听器回调。\n\n对于一个指定键，您只能有一个监听器和一个结果。如果您对同一个键多次调用 setResult()，则系统会将 Fragment B 从返回堆栈退出之前的最近结果发送给 Fragment A。如果您设置的结果没有相应的监听器来接收，则结果会存储在 FragmentManager 中，直到您设置一个具有相同键的监听器。请注意，监听器的 Fragment 必须为 STARTED，然后该 Fragment 才能收到结果。监听器收到结果并触发 onFragmentResult() 回调后，结果会被清除。这种行为有两个主要影响：\n\n返回堆栈上的 Fragment 只有在被弹出栈顶且为 STARTED 之后才会收到结果。\n如果在设置结果时监听结果的 Fragment 为 STARTED，则系统会立即触发监听器的回调。\n在父级 Fragment 和子级 Fragment 之间传递结果\n如需将结果从子级 Fragment 传递到父级 Fragment，父级 Fragment 在调用 setFragmentResultListener() 时应使用 getChildFragmentManager() 而不是 getParentFragmentManager()。\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    // We set the listener on the child fragmentManager\n    childFragmentManager.setResultListener(\"requestKey\") { key, bundle ->\n        val result = bundle.getString(\"bundleKey\")\n        // Do something with the result..\n    }\n}\n@Override\npublic void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    // We set the listener on the child fragmentManager\n    getChildFragmentManager().setFragmentResultListener(\"key\", this, new FragmentResultListener() {\n        @Override\n        public void onFragmentResult(@NonNull String key, @NonNull Bundle bundle) {\n            String result = bundle.getString(\"bundleKey\");\n            // Do something with the result..\n        }\n    });\n}\n子级 Fragment 可以使用 Fragment 管理器将结果发送到其父级 Fragment\n图 2. 子级 Fragment 可以使用 FragmentManager 将结果发送到其父级 Fragment。\n子级 Fragment 在其 FragmentManager 上设置结果。然后，当父级 Fragment 为 STARTED 时便会收到结果：\n\nbutton.setOnClickListener {\n    val result = \"result\"\n    // Use the Kotlin extension in the fragment-ktx artifact\n    setResult(\"requestKey\", bundleOf(\"bundleKey\" to result))\n}\nbutton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Bundle result = new Bundle();\n        result.putString(\"bundleKey\", \"result\");// The child fragment needs to still set the result on its parent fragment manager\n        getParentFragmentManager().setFragmentResult(\"requestKey\", result);\n    }\n});\n测试 Fragment 结果\n使用 FragmentScenario 测试对 setFragmentResult() 和 setFragmentResultListener() 的调用。使用 launchFragmentInContainer 或 launchFragment 为被测 Fragment 创建场景，然后手动调用目前未测试的方法。\n\n如需测试 setResultListener()，请使用调用 setResultListener() 的 Fragment 创建一个场景。接下来，直接调用 setResult() 并验证结果：\n\n@Test\nfun testFragmentResultListener() {\n    val scenario = launchFragmentInContainer<ResultListenerFragment>()\n    scenario.onFragment { fragment ->\n        val expectedResult = \"result\"\n        fragment.parentFragmentManagager.setResult(\"requestKey\", bundleOf(\"bundleKey\" to expectedResult))\n        assertThat(fragment.result).isEqualTo(expectedResult)\n    }\n}class ResultListenerFragment : Fragment() {\n    var result : String? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // Use the Kotlin extension in the fragment-ktx artifact\n        setResultListener(\"requestKey\") { key, bundle ->\n            result = bundle.getString(\"bundleKey\")\n        }\n    }\n}\n如需测试 setResult()，请使用调用 setResult() 的 Fragment 创建一个场景。接下来，直接调用 setResultListener() 并验证结果：\n\n@Test\nfun testFragmentResult() {\n    val scenario = launchFragmentInContainer<ResultFragment>()\n    lateinit var actualResult: String?\n    scenario.onFragment { fragment ->\n        fragment.parentFragmentManagager.setResultListener(\"requestKey\") { key, bundle ->\n            actualResult = bundle.getString(\"bundleKey\")\n        }\n    }\n    onView(withId(R.id.result_button)).perform(click())\n    assertThat(actualResult).isEqualTo(\"result\")\n}class ResultFragment : Fragment(R.layout.fragment_result) {\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        view.findViewById(R.id.result_button).setOnClickListener {\n            val result = \"result\"\n            // Use the Kotlin extension in the fragment-ktx artifact\n            setResult(\"requestKey\", bundleOf(\"bundleKey\" to result))\n        }\n    }\n}\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243445624},"updatedAt":{"$$date":1597243889014},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TleHBclMu2mj7T5r"}
{"name":"andr-了解任务和返回堆栈","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/components/activities/tasks-and-back-stack\n了解任务和返回堆栈  |  Android 开发者  |  Android Developers\n10-12 minutes\n任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。例如，电子邮件应用可能有一个 Activity 来显示新邮件列表。当用户选择一封邮件时，系统会打开一个新的 Activity 来显示该邮件。这个新的 Activity 会添加到返回堆栈中。如果用户按返回按钮，这个新的 Activity 即会完成并从堆栈中退出。通过以下视频可以大致了解返回堆栈的工作原理。\n\nAndroid 7.0（API 级别 24）及更高版本支持多窗口环境，当应用在这种环境中同时运行时，系统会单独管理每个窗口的任务；而每个窗口可能包含多项任务。在 Chromebook 上运行的 Android 应用也是如此：系统按窗口管理任务或任务组。\n\n大多数任务都从设备主屏幕上启动。当用户轻触应用启动器中的图标（或主屏幕上的快捷方式）时，该应用的任务就会转到前台运行。如果该应用没有任务存在（应用最近没有使用过），则会创建一个新的任务，并且该应用的“主”Activity 将会作为堆栈的根 Activity 打开。\n\n在当前 Activity 启动另一个 Activity 时，新的 Activity 将被推送到堆栈顶部并获得焦点。上一个 Activity 仍保留在堆栈中，但会停止。当 Activity 停止时，系统会保留其界面的当前状态。当用户按返回按钮时，当前 Activity 会从堆栈顶部退出（该 Activity 销毁），上一个 Activity 会恢复（界面会恢复到上一个状态）。堆栈中的 Activity 永远不会重新排列，只会被送入和退出，在当前 Activity 启动时被送入堆栈，在用户使用返回按钮离开时从堆栈中退出。因此，返回堆栈按照“后进先出”的对象结构运作。图 1 借助一个时间轴直观地显示了这种行为。该时间轴显示了 Activity 之间的进展以及每个时间点的当前返回堆栈。\n\n\n\n图 1. 有关任务中的每个新 Activity 如何添加到返回堆栈的图示。当用户按返回按钮时，当前 Activity 会销毁，上一个 Activity 将恢复。\n\n如果用户继续按返回，则堆栈中的 Activity 会逐个退出，以显示前一个 Activity，直到用户返回到主屏幕（或任务开始时运行的 Activity）。移除堆栈中的所有 Activity 后，该任务将不复存在。\n\n\n\n图 2. 两个任务：任务 B 在前台接收用户互动，任务 A 在后台等待恢复。\n\n任务是一个整体单元，当用户开始一个新任务或通过主屏幕按钮进入主屏幕时，任务可移至“后台”。在后台时，任务中的所有 Activity 都会停止，但任务的返回堆栈会保持不变，当其他任务启动时，当前任务只是失去了焦点，如图 2 所示。这样一来，任务就可以返回到“前台”，以便用户可以从他们离开的地方继续操作。举例来说，假设当前任务（任务 A）的堆栈中有 3 个 Activity，当前 Activity 下有 2 个 Activity。用户按主屏幕按钮，然后从应用启动器中启动新应用。主屏幕出现后，任务 A 转到后台。当新应用启动时，系统会启动该应用的任务（任务 B），该任务具有自己的 Activity 堆栈。与该应用互动后，用户再次返回到主屏幕并选择最初启动任务 A 的应用。现在，任务 A 进入前台，其堆栈中的所有三个 Activity 都完好如初，堆栈顶部的 Activity 恢复运行。此时，用户仍可通过以下方式切换到任务 B：转到主屏幕并选择启动该任务的应用图标（或者从最近使用的应用屏幕中选择该应用的任务）。这就是在 Android 上进行多任务处理的一个例子。\n\n注意：多个任务可以同时在后台进行。但是，如果用户同时运行很多后台任务，系统可能会为了恢复内存而开始销毁后台 Activity，导致 Activity 状态丢失。\n\n\n\n图 3. 单个 Activity 会被多次实例化。\n\n由于返回堆栈中的 Activity 不会被重新排列，如果您的应用允许用户从多个 Activity 启动特定的 Activity，系统便会创建该 Activity 的新实例并将其推送到堆栈中（而不是将该 Activity 的某个先前的实例移至堆栈顶部）。这样一来，应用中的一个 Activity 就可能被多次实例化（甚至是从其他任务对其进行实例化），如图 3 所示。因此，如果用户使用返回按钮向后导航，Activity 的每个实例将按照它们被打开的顺序显示出来（每个实例都有自己的界面状态）。不过，如果您不希望某个 Activity 被实例化多次，可以修改此行为。有关如何实现此操作，将在后面的管理任务部分中讨论。\n\nActivity 和任务的默认行为总结如下：\n\n当 Activity A 启动 Activity B 时，Activity A 会停止，但系统会保留其状态（例如滚动位置和输入到表单中的文本）。如果用户在 Activity B 中按返回按钮，系统会恢复 Activity A 及其状态。\n当用户通过按主屏幕按钮离开任务时，当前 Activity 会停止，其任务会转到后台。系统会保留任务中每个 Activity 的状态。如果用户稍后通过点按该任务的启动器图标来恢复该任务，该任务会进入前台并恢复堆栈顶部的 Activity。\n如果用户按返回按钮，当前 Activity 将从堆栈中退出并销毁。堆栈中的上一个 Activity 将恢复。Activity 被销毁后，系统不会保留该 Activity 的状态。\nActivity 可以多次实例化，甚至是从其他任务对其进行实例化。\n导航设计\n\n要详细了解 Android 上的应用导航如何运作，请参阅 Android 设计中的导航指南。\n\n管理任务\n如上文所述，Android 管理任务和返回堆栈的方式是将所有接连启动的 Activity 放到同一任务和一个“后进先出”堆栈中，这对于大多数应用都很有效，而且您不必担心 Activity 如何与任务相关联，或者它们如何存在于返回堆栈中。不过，您可能需要决定是否要打破正常行为。或许您希望应用中的某个 Activity 在启动时开启一个新的任务（而不是被放入当前的任务中），或者当您启动某个 Activity 时，您希望调用它的一个现有实例（而不是在返回堆栈顶部创建一个新实例），或者您希望在用户离开任务时清除返回堆栈中除根 Activity 以外的所有 Activity。\n\n您可以借助 <activity> 清单元素中的属性以及您传递给 startActivity() 的 intent 中的标记来实现上述目的。\n\n在这方面，您可以使用的主要 <activity> 属性包括：\n\ntaskAffinity\nlaunchMode\nallowTaskReparenting\nclearTaskOnLaunch\nalwaysRetainTaskState\nfinishOnTaskLaunch\n您可以使用的主要 intent 标记包括：\n\nFLAG_ACTIVITY_NEW_TASK\nFLAG_ACTIVITY_CLEAR_TOP\nFLAG_ACTIVITY_SINGLE_TOP\n在下面几节中，您将了解到如何使用这些清单属性和 intent 标记来定义 Activity 与任务之间的关联方式，以及它们在返回堆栈中的行为。\n\n另外，下面还分别介绍了如何在最近使用的应用屏幕中表示和管理任务与 Activity。有关详情，请参阅“最近使用的应用”屏幕。通常，您应允许系统定义任务和 Activity 在最近使用的应用屏幕中的表示方式，您无需修改此行为。\n\n注意：大多数应用不应打破 Activity 和任务的默认行为。如果您确定需要让 Activity 改变默认行为，请谨慎操作，并且务必要测试该 Activity 在以下情况下的可用性：启动期间以及您通过返回按钮从其他 Activity 和任务返回该 Activity 时。务必要测试是否存在可能与用户预期的行为冲突的导航行为。\n\n定义启动模式\n您可以通过启动模式定义 Activity 的新实例如何与当前任务关联。您可以通过两种方式定义不同的启动模式：\n\n使用清单文件\n当您在清单文件中声明 Activity 时，您可以指定该 Activity 在启动时如何与任务关联。\n\n使用 Intent 标记\n当您调用 startActivity() 时，可以在 Intent 中添加一个标记，用于声明新 Activity 如何（或是否）与当前任务相关联。\n\n因此，如果 Activity A 启动 Activity B，Activity B 可在其清单中定义如何与当前任务相关联（如果关联的话），Activity A 也可以请求 Activity B 应该如何与当前任务关联。如果两个 Activity 都定义了 Activity B 应如何与任务关联，将优先遵循 Activity A 的请求（在 intent 中定义），而不是 Activity B 的请求（在清单中定义）。\n\n注意：有些启动模式可通过清单文件定义，但不能通过 intent 标记定义，同样，有些启动模式可通过 intent 标记定义，却不能在清单中定义。\n\n使用清单文件\n在清单文件中声明 Activity 时，可以使用 <activity> 元素的 launchMode 属性指定 Activity 应该如何与任务关联。\n\nlaunchMode 属性说明了 Activity 应如何启动到任务中。您可以为 launchMode 属性指定 4 种不同的启动模式：\n\n\"standard\"（默认模式）\n默认值。系统在启动该 Activity 的任务中创建 Activity 的新实例，并将 intent 传送给该实例。Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。\n\"singleTop\"\n如果当前任务的顶部已存在 Activity 的实例，则系统会通过调用其 onNewIntent() 方法来将 intent 转送给该实例，而不是创建 Activity 的新实例。Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例（但前提是返回堆栈顶部的 Activity 不是该 Activity 的现有实例）。\n例如，假设任务的返回堆栈包含根 Activity A 以及 Activity B、C 和位于顶部的 D（堆栈为 A-B-C-D；D 位于顶部）。收到以 D 类型 Activity 为目标的 intent。如果 D 采用默认的 \"standard\" 启动模式，则会启动该类的新实例，并且堆栈将变为 A-B-C-D-D。但是，如果 D 的启动模式为 \"singleTop\"，则 D 的现有实例会通过 onNewIntent() 接收 intent，因为它位于堆栈顶部，堆栈仍为 A-B-C-D。但是，如果收到以 B 类型 Activity 为目标的 intent，则会在堆栈中添加 B 的新实例，即使其启动模式为 \"singleTop\" 也是如此。\n\n注意：创建 Activity 的新实例后，用户可以按返回按钮返回到上一个 Activity。但是，当由 Activity 的现有实例处理新 intent 时，用户将无法通过按返回按钮返回到 onNewIntent() 收到新 intent 之前的 Activity 状态。\n\n\"singleTask\"\n系统会创建新任务，并实例化新任务的根 Activity。但是，如果另外的任务中已存在该 Activity 的实例，则系统会通过调用其 onNewIntent() 方法将 intent 转送到该现有实例，而不是创建新实例。Activity 一次只能有一个实例存在。\n注意：虽然 Activity 在新任务中启动，但用户按返回按钮仍会返回到上一个 Activity。\n\n\"singleInstance\"\n与 \"singleTask\" 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。\n再举个例子，Android 浏览器应用在 <activity> 元素中指定 singleTask 启动模式，由此声明网络浏览器 Activity 应始终在它自己的任务中打开。这意味着，如果您的应用发出打开 Android 浏览器的 intent，系统不会将其 Activity 置于您的应用所在的任务中，而是会为浏览器启动一个新任务，如果浏览器已经有任务在后台运行，则会将该任务转到前台来处理新 intent。\n\n无论 Activity 是在新任务中启动的，还是在和启动它的 Activity 相同的任务中启动，用户按返回按钮都会回到上一个 Activity。但是，如果您启动了指定 singleTask 启动模式的 Activity，而后台任务中已存在该 Activity 的实例，则系统会将该后台任务整个转到前台运行。此时，返回堆栈包含了转到前台的任务中的所有 Activity，这些 Activity 都位于堆栈的顶部。图 4 展示了具体的情景。\n\n\n\n图 4. 采用“singleTask”启动模式的 Activity 添加到返回堆栈的过程图示。如果 Activity 已经存在于某个具有自己的返回堆栈的后台任务中，那么整个返回堆栈也会转到前台，覆盖当前任务。\n\n要详细了解如何在清单文件中设置启动模式，请参阅 <activity> 元素的说明文档，里面详细介绍了 launchMode 属性和可接受的值。\n\n注意：您通过 launchMode 属性为 Activity 指定的行为，可被启动 Activity 的 intent 所包含的标记替换。下一节将对此进行介绍。\n\n使用 Intent 标记\n启动 Activity 时，您可以在传送给 startActivity() 的 intent 中添加相应的标记来修改 Activity 与其任务的默认关联。您可以使用以下标记来修改默认行为：\n\nFLAG_ACTIVITY_NEW_TASK\n在新任务中启动 Activity。如果您现在启动的 Activity 已经有任务在运行，则系统会将该任务转到前台并恢复其最后的状态，而 Activity 将在 onNewIntent() 中收到新的 intent。\n这与上一节中介绍的 \"singleTask\" launchMode 值产生的行为相同。\n\nFLAG_ACTIVITY_SINGLE_TOP\n如果要启动的 Activity 是当前 Activity（即位于返回堆栈顶部的 Activity），则现有实例会收到对 onNewIntent() 的调用，而不会创建 Activity 的新实例。\n这与上一节中介绍的 \"singleTop\" launchMode 值产生的行为相同。\n\nFLAG_ACTIVITY_CLEAR_TOP\n如果要启动的 Activity 已经在当前任务中运行，则不会启动该 Activity 的新实例，而是会销毁位于它之上的所有其他 Activity，并通过 onNewIntent() 将此 intent 传送给它的已恢复实例（现在位于堆栈顶部）。\nlaunchMode 属性没有可产生此行为的值。\n\nFLAG_ACTIVITY_CLEAR_TOP 最常与 FLAG_ACTIVITY_NEW_TASK 结合使用。将这两个标记结合使用，可以查找其他任务中的现有 Activity，并将其置于能够响应 intent 的位置。\n\n注意：如果指定 Activity 的启动模式为 \"standard\"，系统也会将其从堆栈中移除，并在它的位置启动一个新实例来处理传入的 intent。这是因为当启动模式为 \"standard\" 时，始终会为新 intent 创建新的实例。\n\n处理亲和性\n“亲和性”表示 Activity 倾向于属于哪个任务。默认情况下，同一应用中的所有 Activity 彼此具有亲和性。因此，在默认情况下，同一应用中的所有 Activity 都倾向于位于同一任务。不过，您可以修改 Activity 的默认亲和性。在不同应用中定义的 Activity 可以具有相同的亲和性，或者在同一应用中定义的 Activity 也可以被指定不同的任务亲和性。\n\n您可以使用 <activity> 元素的 taskAffinity 属性修改任何给定 Activity 的亲和性。\n\ntaskAffinity 属性采用字符串值，该值必须不同于 <manifest> 元素中声明的默认软件包名称，因为系统使用该名称来标识应用的默认任务亲和性。\n\n亲和性可在两种情况下发挥作用：\n\n当启动 Activity 的 intent 包含 FLAG_ACTIVITY_NEW_TASK 标记时。\n默认情况下，新 Activity 会启动到调用 startActivity() 的 Activity 的任务中。它会被推送到调用方 Activity 所在的返回堆栈中。但是，如果传递给 startActivity() 的 intent 包含 FLAG_ACTIVITY_NEW_TASK 标记，则系统会寻找其他任务来容纳新 Activity。通常会是一个新任务，但也可能不是。如果已存在与新 Activity 具有相同亲和性的现有任务，则会将 Activity 启动到该任务中。如果不存在，则会启动一个新任务。\n\n如果此标记导致 Activity 启动一个新任务，而用户按下主屏幕按钮离开该任务，则必须为用户提供某种方式来返回到该任务。有些实体（例如通知管理器）总是在外部任务中启动 Activity，而不在它们自己的任务中启动，因此它们总是将 FLAG_ACTIVITY_NEW_TASK 添加到传递给 startActivity() 的 intent 中。如果您的 Activity 可由外部实体调用，而该实体可能使用此标记，请注意用户可以通过一种独立的方式返回到所启动的任务，例如使用启动器图标（任务的根 Activity 具有一个 CATEGORY_LAUNCHER intent 过滤器；请参阅下面的启动任务部分）。\n\n当 Activity 的 allowTaskReparenting 属性设为 \"true\" 时。\n在这种情况下，一旦和 Activity 有亲和性的任务进入前台运行，Activity 就可从其启动的任务转移到该任务。\n\n举例来说，假设一款旅行应用中定义了一个报告特定城市天气状况的 Activity。该 Activity 与同一应用中的其他 Activity 具有相同的亲和性（默认应用亲和性），并通过此属性支持重新归属。当您的某个 Activity 启动该天气预报 Activity 时，该天气预报 Activity 最初会和您的 Activity 同属于一个任务。不过，当旅行应用的任务进入前台运行时，该天气预报 Activity 就会被重新分配给该任务并显示在其中。\n\n提示：如果一个 APK 文件中包含了就用户角度而言的多个“应用”，您可能需要使用 taskAffinity 属性为每个“应用”所关联的 Activity 指定不同的亲和性。\n\n清除返回堆栈\n如果用户离开任务较长时间，系统会清除任务中除根 Activity 以外的所有 Activity。当用户再次返回到该任务时，只有根 Activity 会恢复。系统之所以采取这种行为方式是因为，经过一段时间后，用户可能已经放弃了之前执行的操作，现在返回任务是为了开始某项新的操作。\n\n您可以使用一些 Activity 属性来修改此行为：\n\nalwaysRetainTaskState\n如果在任务的根 Activity 中将该属性设为 \"true\"，则不会发生上述默认行为。即使经过很长一段时间后，任务仍会在其堆栈中保留所有 Activity。\nclearTaskOnLaunch\n如果在任务的根 Activity 中将该属性设为 \"true\"，那么只要用户离开任务再返回，堆栈就会被清除到只剩根 Activity。也就是说，它与 alwaysRetainTaskState 正好相反。用户始终会返回到任务的初始状态，即便只是短暂离开任务也是如此。\nfinishOnTaskLaunch\n该属性与 clearTaskOnLaunch 类似，但它只会作用于单个 Activity 而非整个任务。它还可导致任何 Activity 消失，包括根 Activity。如果将该属性设为 \"true\"，则 Activity 仅在当前会话中归属于任务。如果用户离开任务再返回，则该任务将不再存在。\n启动任务\n您可以设置一个 Activity 作为任务的入口点，方法是为该 Activity 提供一个 intent 过滤器，并将 \"android.intent.action.MAIN\" 作为指定操作，将 \"android.intent.category.LAUNCHER\" 作为指定类别。例如：\n\n    <activity ... >\n        <intent-filter ... >\n            <action android:name=\"android.intent.action.MAIN\" />\n            <category android:name=\"android.intent.category.LAUNCHER\" />\n        </intent-filter>\n        ...\n    </activity>\n    \n这种 intent 过滤器可在应用启动器中显示 Activity 的图标和标签，让用户可以启动 Activity 并在启动后随时返回到该 Activity 创建的任务。\n\n第二个作用非常重要：用户必须能够离开任务，之后再使用此 Activity 启动器返回到该任务。因此，只有当 Activity 具有 ACTION_MAIN 和 CATEGORY_LAUNCHER 过滤器时，才应使用 \"singleTask\" 和 \"singleInstance\" 这两种启动模式，它们会将 Activity 标记为始终启动任务。比如，可以想象一下，如果缺少该过滤器会发生什么情况：intent 会启动 \"singleTask\" Activity，随之启动新任务，用户花了一些时间在该任务上。然后，用户按主屏幕按钮。此时，该任务会转到后台，不再可见。现在，用户无法返回到该任务，因为它未显示在应用启动器中。\n\n对于那些您不希望用户能够返回到 Activity 的情况，请将 <activity> 元素的 finishOnTaskLaunch 设置为 \"true\"（请参阅清除返回堆栈）。\n\n如需详细了解如何在概览屏幕中显示和管理任务及 Activity，请参阅“最近使用的应用”屏幕。\n\n更多资源\nAndroid 设计：导航\n<activity> 清单元素\n“最近使用的应用”屏幕\nAndroid 中的多任务处理"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243439887},"updatedAt":{"$$date":1597243681240},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"TwPGsi80VInGPIrk"}
{"name":"plus","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"dart","value":"fun main() {\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n\n    // plus (+)\n    println(numbersMap + Pair(\"four\", 4)) // {one=1, two=2, three=3, four=4}\n    println(numbersMap + Pair(\"one\", 10)) // {one=10, two=2, three=3}\n    println(numbersMap + Pair(\"five\", 5) + Pair(\"one\", 11)) // {one=11, two=2, three=3, five=5}\n\n    // minus (-)\n    println(numbersMap - \"one\") // {two=2, three=3}\n    println(numbersMap - listOf(\"two\", \"four\")) // {one=1, three=3}\n}\n\n\n\n////\ndata class Salary(var base: Int = 100){\n    override fun toString(): String = base.toString()\n}\n\noperator fun Salary.plus(other: Salary): Salary = Salary(base + other.base)\noperator fun Salary.minus(other: Salary): Salary = Salary(base - other.base)\n\nval s1 = Salary(10)\nval s2 = Salary(20)\nprintln(s1 + s2) // 30\nprintln(s1 - s2) // -10\n\n\n\n"}],"tags":["aZ7LswF9qbcVtQZT"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594728292744},"updatedAt":{"$$date":1594728360331},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"kotlin","_id":"aZ7LswF9qbcVtQZT","text":"kotlin"}],"_id":"UFiWdNvIKOHEvjv9"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973267266},"updatedAt":{"$$date":1594973267266},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Ue9VTEclkV43vaFD"}
{"name":"kotlin-委托属性 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/delegated-properties.html\n委托属性 - Kotlin 语言中文站\n27-33 minutes\n改进翻译\n有一些常见的属性类型，虽然我们可以在每次需要的时候手动实现它们， 但是如果能够为大家把他们只实现一次并放入一个库会更好。例如包括：\n\n延迟属性（lazy properties）: 其值只在首次访问时计算；\n可观察属性（observable properties）: 监听器会收到有关此属性变更的通知；\n把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。\n为了涵盖这些（以及其他）情况，Kotlin 支持 委托属性:\n\nclass Example {\n    var p: String by Delegate()\n}\n语法是： val/var <属性名>: <类型> by <表达式>。在 by 后面的表达式是该 委托， 因为属性对应的 get()（与 set()）会被委托给它的 getValue() 与 setValue() 方法。 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（与 setValue()——对于 var 属性）。 例如:\n\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, thank you for delegating '${property.name}' to me!\"\n    }\n \n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$value has been assigned to '${property.name}' in $thisRef.\")\n    }\n}\n当我们从委托到一个 Delegate 实例的 p 读取时，将调用 Delegate 中的 getValue() 函数， 所以它第一个参数是读出 p 的对象、第二个参数保存了对 p 自身的描述 （例如你可以取它的名字)。 例如:\n\nval e = Example()\nprintln(e.p)\n输出结果：\n\nExample@33a17727, thank you for delegating ‘p’ to me!\n类似地，当我们给 p 赋值时，将调用 setValue() 函数。前两个参数相同，第三个参数保存将要被赋予的值：\n\n输出结果：\n\nNEW has been assigned to ‘p’ in Example@33a17727.\n委托对象的要求规范可以在下文找到。\n\n请注意，自 Kotlin 1.1 起你可以在函数或代码块中声明一个委托属性，因此它不一定是类的成员。 你可以在下文找到其示例。\n\nKotlin 标准库为几种有用的委托提供了工厂方法。\n\nlazy() 是接受一个 lambda 并返回一个 Lazy <T> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。\n\nval lazyValue: String by lazy {\n    println(\"computed!\")\n    \"Hello\"\n}\n\nfun main() {\n    println(lazyValue)\n    println(lazyValue)\n}\n默认情况下，对于 lazy 属性的求值是同步锁的（synchronized）：该值只在一个线程中计算，并且所有线程会看到相同的值。如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给 lazy() 函数。 而如果你确定初始化将总是发生在与属性使用位于相同的线程， 那么可以使用 LazyThreadSafetyMode.NONE 模式：它不会有任何线程安全的保证以及相关的开销。\n\nDelegates.observable() 接受两个参数：初始值与修改时处理程序（handler）。 每当我们给属性赋值时会调用该处理程序（在赋值后执行）。它有三个参数：被赋值的属性、旧值与新值：\n\nimport kotlin.properties.Delegates\n\nclass User {\n    var name: String by Delegates.observable(\"<no name>\") {\n        prop, old, new ->\n        println(\"$old -> $new\")\n    }\n}\n\nfun main() {\n    val user = User()\n    user.name = \"first\"\n    user.name = \"second\"\n}\n如果你想截获赋值并“否决”它们，那么使用 vetoable() 取代 observable()。 在属性被赋新值生效之前会调用传递给 vetoable 的处理程序。\n\n一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他“动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。\n\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n在这个例子中，构造函数接受一个映射参数：\n\nval user = User(mapOf(\n    \"name\" to \"John Doe\",\n    \"age\"  to 25\n))\n委托属性会从这个映射中取值（通过字符串键——属性的名称）：\n\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}\n\nfun main() {\n    val user = User(mapOf(\n        \"name\" to \"John Doe\",\n        \"age\"  to 25\n    ))\n//sampleStart\n    println(user.name) // Prints \"John Doe\"\n    println(user.age)  // Prints 25\n//sampleEnd\n}\n这也适用于 var 属性，如果把只读的 Map 换成 MutableMap 的话：\n\nclass MutableUser(val map: MutableMap<String, Any?>) {\n    var name: String by map\n    var age: Int     by map\n}\n你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：\n\nfun example(computeFoo: () -> Foo) {\n    val memoizedFoo by lazy(computeFoo)\n\n    if (someCondition && memoizedFoo.isValid()) {\n        memoizedFoo.doSomething()\n    }\n}\nmemoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。\n\n这里我们总结了委托对象的要求。\n\n对于一个只读属性（即 val 声明的），委托必须提供一个操作符函数 getValue()，该函数具有以下参数：\n\nthisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是其超类型。\nproperty —— 必须是类型 KProperty<*> 或其超类型。\ngetValue() 必须返回与属性相同的类型（或其子类型）。\n\nclass Resource\n\nclass Owner {\n    val valResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return Resource()\n    }\n}\n对于一个可变属性（即 var 声明的），委托必须额外提供一个操作符函数 setValue()， 该函数具有以下参数：\n\nthisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是其超类型。\nproperty —— 必须是类型 KProperty<*> 或其超类型。\nvalue — 必须与属性类型相同（或者是其超类型）。\nclass Resource\n\nclass Owner {\n    var varResource: Resource by ResourceDelegate()\n}\n\nclass ResourceDelegate(private var resource: Resource = Resource()) {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return resource\n    }\n    operator fun setValue(thisRef: Owner, property: KProperty<*>, value: Any?) {\n        if (value is Resource) {\n            resource = value\n        }\n    }\n}\ngetValue() 或/与 setValue() 函数可以通过委托类的成员函数提供或者由扩展函数提供。 当你需要委托属性到原本未提供的这些函数的对象时后者会更便利。 两函数都需要用 operator 关键字来进行标记。\n\n委托类可以实现包含所需 operator 方法的 ReadOnlyProperty 或 ReadWriteProperty 接口之一。 这俩接口是在 Kotlin 标准库中声明的：\n\ninterface ReadOnlyProperty<in R, out T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n}\n\ninterface ReadWriteProperty<in R, T> {\n    operator fun getValue(thisRef: R, property: KProperty<*>): T\n    operator fun setValue(thisRef: R, property: KProperty<*>, value: T)\n}\n在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性：\n\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// 这段是由编译器生成的相应代码：\nclass C {\n    private val prop$delegate = MyDelegate()\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\nKotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。\n\n请注意，直接在代码中引用绑定的可调用引用的语法 this::prop 自 Kotlin 1.1 起才可用。\n\n通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来创建属性委托实例。\n\nprovideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检测属性一致性。\n\n例如，如果要在绑定之前检测属性名称，可以这样写：\n\nclass ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {\n    override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... }\n}\n    \nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(\n            thisRef: MyUI,\n            prop: KProperty<*>\n    ): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        // 创建委托\n        return ResourceDelegate()\n    }\n\n    private fun checkProperty(thisRef: MyUI, name: String) { …… }\n}\n\nclass MyUI {\n    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { …… }\n\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}\nprovideDelegate 的参数与 getValue 相同：\n\nthisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型；\nproperty —— 必须是类型 KProperty<*> 或其超类型。\n在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。\n\n如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：\n\n// 检测属性名称而不使用“provideDelegate”功能\nclass MyUI {\n    val image by bindResource(ResourceID.image_id, \"image\")\n    val text by bindResource(ResourceID.text_id, \"text\")\n}\n\nfun <T> MyUI.bindResource(\n        id: ResourceID<T>,\n        propertyName: String\n): ReadOnlyProperty<MyUI, T> {\n   checkProperty(this, propertyName)\n   // 创建委托\n}\n在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与上面（当 provideDelegate 方法不存在时）生成的代码：\n\nclass C {\n    var prop: Type by MyDelegate()\n}\n\n// 这段代码是当“provideDelegate”功能可用时\n// 由编译器生成的代码：\nclass C {\n    // 调用“provideDelegate”来创建额外的“delegate”属性\n    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}\n请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307932174},"updatedAt":{"$$date":1597308442533},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Uo27JveR0ktDbb6A"}
{"name":"kotlin-kotlin入门中文教程（2）","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\njuejin.im /post/6844904017487888392\nkotlin入门中文教程（2） - 掘金\n叶志陈 2019年12月10日 阅读 1547 已关注\n32-40 minutes\n本文已收录至学习笔记大全：JavaKotlinAndroidGuide\n\n作者：leavesC\n\n[TOC]\n\n十五、扩展函数和扩展属性\n15.1、扩展函数\n扩展函数用于为一个类增加一种新的行为，这是为缺少有用函数的类进行扩展的途径。扩展函数的用途就类似于在 Java 中实现的静态工具方法。而在 kotlin 中使用扩展函数的一个优势就是我们不需要在调用方法的时候把整个对象当作参数传入，扩展函数表现得就像是属于这个类本身的一样，可以使用 this 关键字并直接调用其所有 public 方法\n\n扩展函数并不允许你打破它的封装性，和在类内部定义的方法不同的是，扩展函数不能访问私有的或是受保护的成员\n\n\n\nfun String.lastChar() = get(length - 1)\n\n\n\nfun Int.doubleValue() = this * 2\n复制代码\n之后，我们就可以像调用类本身内部声明的方法一样，直接调用扩展函数\n\nfun main() {\n    val name = \"leavesC\"\n    println(\"$name lastChar is: \" + name.lastChar())\n\n    val age = 24\n    println(\"$age doubleValue is: \" + age.doubleValue())\n}\n复制代码\n如果需要声明一个静态的扩展函数，则必须将其定义在伴生对象上，这样就可以在没有 Namer 实例的情况下调用其扩展函数，就如同在调用 Java 的静态函数一样\n\nclass Namer {\n\n    companion object {\n\n        val defaultName = \"mike\"\n\n    }\n\n}\n\nfun Namer.Companion.getName(): String {\n    return defaultName\n}\n\nfun main() {\n    Namer.getName()\n}\n复制代码\n需要注意的是，如果扩展函数声明于 class 内部，则该扩展函数只能该类和其子类内部调用，因为此时相当于声明了一个非静态函数，外部无法引用到。所以一般都是将扩展函数声明为全局函数\n\n15.2、扩展属性\n扩展函数也可以用于属性\n\n\n\nvar String.customLen: Int\n    get() = length\n    set(value) {\n        println(\"set\")\n    }\n\nfun main() {\n    val name = \"leavesC\"\n    println(name.customLen)\n    name.customLen = 10\n    println(name.customLen)\n    \n    \n    \n}\n复制代码\n15.3、不可重写的扩展函数\n看以下例子，子类 Button 重写了父类 View 的 click() 函数，此时如果声明一个 View 变量，并赋值为 Button 类型的对象，调用的 click() 函数将是 Button 类重写的方法\n\nfun main() {\n    val view: View = Button()\n    view.click() \n}\n\nopen class View {\n    open fun click() = println(\"View clicked\")\n}\n\nclass Button : View() {\n    override fun click() = println(\"Button clicked\")\n}\n复制代码\n对于扩展函数来说，与以上的例子却不一样。如果基类和子类都分别定义了一个同名的扩展函数，此时要调用哪个扩展函数是由变量的静态类型来决定的，而非这个变量的运行时类型\n\nfun main() {\n    val view: View = Button()\n    view.longClick() \n}\n\nopen class View {\n    open fun click() = println(\"View clicked\")\n}\n\nclass Button : View() {\n    override fun click() = println(\"Button clicked\")\n}\n\nfun View.longClick() = println(\"View longClicked\")\n\nfun Button.longClick() = println(\"Button longClicked\")\n复制代码\n此外，如果一个类的成员函数和扩展函数有相同的签名，成员函数会被优先使用\n\n扩展函数并不是真正地修改了原来的类，其底层其实是以静态导入的方式来实现的。扩展函数可以被声明在任何一个文件中，因此有个通用的实践是把一系列有关的函数放在一个新建的文件里\n\n需要注意的是，扩展函数不会自动地在整个项目范围内生效，如果需要使用到扩展函数，需要进行导入\n\n15.4、可空接收者\n可以为可空的接收者类型定义扩展，即使接受者为 null，使得开发者在调用扩展函数前不必进行判空操作，且可以通过 this == null 来检查接收者是否为空\n\nfun main() {\n    var name: String? = null\n    name.check() \n    name = \"leavesC\"\n    name.check() \n}\n\nfun String?.check() {\n    if (this == null) {\n        println(\"this == null\")\n        return\n    }\n    println(\"this != null\")\n}\n复制代码\n十六、Lambda 表达式\nLambda 表达式本质上就是可以传递给其它函数的一小段代码，通过 Lambda 表达式可以把通用的代码结构抽取成库函数，也可以把 Lambda 表达式存储在一个变量中，把这个变量当做普通函数对待\n\n    \n    val plus1: (Int, Int) -> Int = { x: Int, y: Int -> x + y }\n    val plus2: (Int, Int) -> Int = { x, y -> x + y }\n    val plus3 = { x: Int, y: Int -> x + y }\n    println(plus3(1, 2))\n复制代码\n一个 Lambda 表达式始终用花括号包围，通过箭头把实参列表和函数体分开\n如果 Lambda 声明了函数类型，那么就可以省略函数体的类型声明\n如果 Lambda 声明了参数类型，且返回值支持类型推导，那么就可以省略函数类型声明\n虽然说倾向于尽量避免让 Lambda 表达式引用外部变量以避免副作用，但有些情况下让 Lambda 引用外部变量也可以简化计算结构。访问了外部环境变量的 Lambda 表达式称之为闭包，闭包可以被当做参数传递或者直接使用。与 Java 不同，kotlin 中的闭包不仅可以访问外部变量也可以对其进行修改\n\n例如，假设我们需要一个计算总和的方法，每次调用函数时都返回当前的总和大小。方法外部不提供保存当前总和的变量，由 Lambda 表达式内部进行存储\n\nfun main() {\n    val sum = sumFunc()\n    println(sum(10)) \n    println(sum(20)) \n    println(sum(30)) \n}\n\nfun sumFunc(): (Int) -> Int {\n    var base = 0\n    return fun(va: Int): Int {\n        base += va\n        return base\n    }\n}\n复制代码\n此外，kotlin 也支持一种自动运行的语法\n\n{ va1: Int, va2: Int -> println(va1 + va2) }(10, 20)\n复制代码\nLambda 表达式最常见的用途就是和集合一起工作，看以下例子\n\n要从一个人员列表中取出年龄最大的一位\n\ndata class Person(val name: String, val age: Int)\n\nfun main() {\n    val people = listOf(Person(\"leavesC\", 24), Person(\"Ye\", 22))\n    println(people.maxBy { it.age }) \n}\n复制代码\n当中，库函数 maxBy 可以在任何集合上调用，其需要一个实参：一个函数，用于指定要用来进行比较的函数。花括号中的代码 { it.age } 就是实现了这个逻辑的 Lambda 表达式\n\n上述 maxBy 函数的实参是简化后的写法，这里来看下 maxBy 函数的简化过程\n\n最原始的语法声明应该是这样的，用括号包裹着 Lambda 表达式\n\nprintln(people.maxBy({ p: Person -> p.age }))\n复制代码\nkotlin 有一种语法约定，如果 Lambda 表达式是函数调用的最后一个实参，可以将之放到括号的外边\n\n println(people.maxBy() { p: Person -> p.age })\n复制代码\n当 Lamdba 表达式是函数唯一的实参时，可以去掉调用代码中的空括号对\n\n println(people.maxBy { p: Person -> p.age })\n复制代码\n当 Lambda 表达式的参数类型是可以被推导出来时就可以省略声明参数类型\n\nprintln(people.maxBy { p -> p.age })\n复制代码\n如果当前上下文期待的是只有一个参数的 Lambda 表达式且参数类型可以被推断出来，就会为该参数生成一个默认名称：it\n\n println(people.maxBy { it.age })\n复制代码\nkotlin 和 Java 的一个显著区别就是，在 kotlin 中函数内部的 Lambda 表达式不会仅限于访问函数的参数以及 final 变量，在 Lambda 内部也可以访问并修改非 final 变量\n\n从 Lambda 内部访问外部变量，我们称这些变量被 Lambda 捕捉。当捕捉 final 变量时，变量值和使用这个值的 Lambda 代码一起存储，对非 final 变量来说，其值被封装在一个特殊的包装器中，对这个包装器的引用会和 Lambda 代码一起存储\n\n    var number = 0\n    val list = listOf(10, 20, 30, 40)\n    list.forEach {\n        if (it > 20) {\n            number++\n        }\n    }\n    println(number) \n复制代码\n成员引用用于创建一个调用单个方法或者访问单个属性的函数值，通过双冒号把类名称和要引用的成员（一个方法或者一个属性）名称分隔开\n\n成员引用的一个用途就是：如果要当做参数传递的代码块已经被定义成了函数，此时不必专门创建一个调用该函数的 Lambda 表达式，可以直接通过成员引用的方式来传递该函数（也可以传递属性）。此外，成员引用对扩展函数一样适用\n\ndata class Person(val name: String, val age: Int) {\n\n    val myAge = age\n\n    fun getPersonAge() = age\n}\n\nfun Person.filterAge() = age\n\nfun main() {\n    val people = listOf(Person(\"leavesC\", 24), Person(\"Ye\", 22))\n    println(people.maxBy { it.age })    \n    println(people.maxBy(Person::age))  \n    println(people.maxBy(Person::myAge))  \n    println(people.maxBy(Person::getPersonAge))  \n    println(people.maxBy(Person::filterAge))  \n}\n复制代码\n不管引用的是函数还是属性，都不要在成员引用的名称后面加括号\n\n此外，还可以引用顶层函数\n\nfun test() {\n    println(\"test\")\n}\n\nfun main() {\n    val t = ::test\n}\n复制代码\n也可以用构造方法引用存储或者延期执行创建类实例的动作\n\ndata class Person(val name: String, val age: Int)\n\nfun main() {\n    val createPerson = ::Person\n    val person = createPerson(\"leavesC\", 24)\n    println(person)\n}\n复制代码\n十七、标准库中的扩展函数\nkotlin 标准库中提供了几个比较实用的扩展函数，定义在 Standard 文件下\n\n17.1、run\nrun 函数接收一个函数参数并以该函数的返回值作为 run 函数的返回值\n\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n复制代码\n用例\n\nfun main() {\n    var nickName = \"leavesC\"\n    nickName = nickName.run {\n        if (isNotEmpty()) {\n            this\n        } else {\n            \"\"\n        }\n    }\n    println(nickName)\n}\n复制代码\n17.2、with\nwith 函数并不是扩展函数，不过由于作用相近，此处就一起介绍了。with 函数的第一个参数是接受者对象 receiver，第二个参数是在 receiver 对象类型上定义的扩展函数，所以可以在函数内部直接调用 receiver 其公开的方法和属性\n\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n复制代码\nwith 函数用于对同一个对象执行多次操作而不需要反复把对象的名称写出来\n\n例如，为了构建一个包含指定内容的字符串，需要先后如下调用\n\nfun main() {\n    val result = StringBuilder()\n    result.append(\"leavesC\")\n    result.append(\"\\n\")\n    for (letter in 'A'..'Z') {\n        result.append(letter)\n    }\n    println(result.toString())\n }\n复制代码\n改为通过 with 函数来构建的话会代码会简洁许多\n\n    val result = with(StringBuilder()) {\n        append(\"leavesC\")\n        append(\"\\n\")\n        for (letter in 'A'..'Z') {\n            append(letter)\n        }\n        toString()\n    }\n    println(result)\n复制代码\nwith 函数是一个接受两个参数的函数，在这个例子中就是一个 StringBuilder 和一个 Lambda 表达式，这里利用了把 Lambda 表达式放在括号外的约定\n\nwith 函数的返回值是执行 Lambda 表达式的结果，该结果就是 Lambda 中的最后一个表达式的返回值，因此如果将代码修改为如下所示的话，因为 println() 方法无返回值，所以打印出来的内容将是 kotlin.Unit\n\n    val result = with(StringBuilder()) {\n        append(\"leavesC\")\n        append(\"\\n\")\n        for (letter in 'A'..'Z') {\n            append(letter)\n        }\n        println(\"Hello\")\n    }\n    println(result)  \n复制代码\n17.3、apply\napply 函数被声明为类型 T 的扩展函数，它的接收者是作为实参的 Lambda 的接受者，最终函数返回 this 即对象本身\n\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n复制代码\n所以apply 函数和 with 函数的唯一区别在于：apply 函数始终会返回作为实参传递给它的对象\n\n val result = StringBuilder().apply {\n        append(\"leavesC\")\n        append(\"\\n\")\n        for (letter in 'A'..'Z') {\n            append(letter)\n        }\n        toString()\n    }\n    println(result)\n    println(result.javaClass) \n复制代码\n17.4、also\nalso 函数接收一个函数类型的参数，该参数又以接收者本身作为参数，最终返回接收者对象本身\n\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n复制代码\n用例\n\nfun main() {\n    val nickName = \"leavesC\"\n    val also = nickName.also {\n        it.length\n    }\n    println(also) \n}\n复制代码\n17.5、let\nalso 函数接收一个函数类型的参数，该参数又以接收者本身作为参数，最终返回函数的求值结果\n\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n复制代码\n用例\n\nfun main() {\n    val nickName = \"leavesC\"\n    val also = nickName.let {\n        it.length\n    }\n    println(also) \n}\n复制代码\n17.6、takeIf\ntakeIf 接收一个返回值类型为 bool 的函数，当该参数返回值为 true 时返回接受者对象本身，否则返回 null\n\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n复制代码\n用例\n\nfun main() {\n    println(check(\"leavesC\")) \n    println(check(null)) \n}\n\nfun check(name: String?): Int {\n    return name.takeIf { !it.isNullOrBlank() }?.length ?: 0\n}\n复制代码\n17.7、takeUnless\ntakeUnless 的判断条件与 takeIf 相反，这里不再赘述\n\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n复制代码\n十八、函数操作符\n18.1、总数操作符\n18.1.1、any\n如果至少有一个元素符合给出的判断条件，则返回 true\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.any { it > 13 })  \n    println(list.any { it > 7 })   \n复制代码\n18.1.2、all\n如果全部的元素符合给出的判断条件，则返回 true\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.all { it > 13 })  \n    println(list.all { it > 0 })   \n复制代码\n18.1.3、count\n返回符合给出判断条件的元素总数\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.count { it > 7 })  \n    println(list.count { it > 2 })  \n复制代码\n18.1.4、fold\n在一个初始值的基础上从第一项到最后一项通过一个函数累计所有的元素\n\nfun main() {\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.fold(2) { total, next->\n        println(\"$next , $total\")\n        next + total\n    })\n}\n复制代码\n1 , 2\n3 , 3\n5 , 6\n7 , 11\n9 , 18\n27\n复制代码\n18.1.5、foldRight\n与 fold 一样，但顺序是从最后一项到第一项\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.foldRight(2) { next, total->\n        println(\"$next , $total\")\n        next + total\n    })\n复制代码\n9 , 2\n7 , 11\n5 , 18\n3 , 23\n1 , 26\n27\n复制代码\n18.1.6、forEach\n    val list = listOf(1, 3, 5, 7, 9)\n    list.forEach { print(it + 1) } \n复制代码\n18.1.7、forEachIndexed\n类似于 forEach ，同时可以得到元素的索引\n\n    val list = listOf(1, 3, 5, 7, 9)\n    list.forEachIndexed { index, value -> println(\"$index value is $value\") }\n\n    0 value is 1\n\t1 value is 3\n\t2 value is 5\n    3 value is 7\n\t4 value is 9\n复制代码\n18.1.8、max\n返回最大的一项，如果没有则返回null\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.max()) \n复制代码\n18.1.9、maxBy\n根据给定的函数返回最大的一项，如果没有则返回 null\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.maxBy { -it }) \n复制代码\n18.1.10、min\n返回最小的一项，如果没有则返回null\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.min()) \n复制代码\n18.1.11、minBy\n根据给定的函数返回最小的一项，如果没有则返回null\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.minBy { -it }) \n复制代码\n18.1.12、none\n如果没有任何元素与给定的函数匹配，则返回true\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.none { it > 10 }) \n复制代码\n18.1.13、reduce\n与 fold 一样，但是没有一个初始值。通过一个函数从第一项到最后一项进行累计\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.reduce { total, next ->\n        println(\"$next , $total\")\n        total + next\n    })\n\t3 , 1\n\t5 , 4\n\t7 , 9\n\t9 , 16\n\t25\n复制代码\n18.1.14、reduceRight\n与 reduce 一样，但是顺序是从最后一项到第一项\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.reduceRight { next, total ->\n        println(\"$next , $total\")\n        total + next\n    })\n\n\t7 , 9\n\t5 , 16\n\t3 , 21\n\t1 , 24\n\t25\n复制代码\n18.1.15、sumBy\n返回所有每一项通过函数转换之后的数据的总和\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.sumBy { it + 1 }) \n复制代码\n18.2、过滤操作符\n18.2.1、drop\n返回包含去掉前n个元素的所有元素的列表\n\n    val list = listOf(1, 3, 5, 7, 9)\n    println(list.drop(2)) \n复制代码\n18.2.2、dropWhile\n返回从第一个开始不符合给定函数的元素起之后的列表\n\n    val list = listOf(1, 3, 5, 7, 9, 2)\n    println(list.dropWhile { it < 4 }) \n复制代码\n18.2.3、dropLastWhile\n从最后一项开始，返回从开始不符合给定函数的元素起之后的列表\n\n    val list = listOf(10, 1, 3, 5, 7, 9)\n    println(list.dropLastWhile { it > 4 }) \n复制代码\n18.2.4、filter\n过滤所有符合给定函数条件的元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2)\n    println(list.filter { it < 4 }) \n复制代码\n18.2.5、filterNot\n过滤所有不符合给定函数条件的元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2)\n    println(list.filterNot { it < 4 }) \n复制代码\n18.2.6、filterNotNull\n过滤所有元素中不是null的元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2, null)\n    println(list.filterNotNull()) \n复制代码\n18.2.7、slice\n过滤一个list中指定index的元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2, null)\n    println(list.slice(listOf(0, 3))) \n复制代码\n18.2.8、take\n返回从第一个开始的n个元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2, null)\n    println(list.take(2)) \n复制代码\n18.2.9、takeLast\n返回从最后一个开始的n个元素\n\n    val list = listOf(1, 3, 5, 7, 9, 2, null)\n    println(list.takeLast(2)) \n复制代码\n18.2.10、takeWhile\n返回从第一个开始符合给定函数条件的元素。\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.takeWhile { it > 2 }) \n    println(list.takeWhile { it > 0 }) \n复制代码\n18.3、映射操作符\n18.3.1、flatMap\n遍历所有的元素，为每一个创建一个集合，最后把所有的集合放在一个集合中\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.flatMap { listOf(it, it + 1) }) \n复制代码\n18.3.2、groupBy\n返回一个根据给定函数分组后的map\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.groupBy { listOf(it) }) \n    println(list.groupBy { listOf(it, it + 1) }) \n复制代码\n18.3.3、map\n返回一个每一个元素根据给定的函数转换所组成的List。\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.map { listOf(it) }) \n    println(list.map { listOf(it, it + 1) }) \n复制代码\n18.3.4、mapIndexed\n返回一个每一个元素根据给定的包含元素index的函数转换所组成的List\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.mapIndexed { index, value -> index }) \n    println(list.mapIndexed { index, value -> index * value }) \n复制代码\n18.3.5、mapNotNull\n返回一个每一个非null元素根据给定的函数转换所组成的List\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.mapNotNull { it }) \n复制代码\n18.4、元素操作符\n18.4.1、contains\n如果指定元素可以在集合中找到，则返回true\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.contains(3)) \n    println(list.contains(13)) \n复制代码\n18.4.2、elementAt\n返回给定index对应的元素，如果index数组越界则会抛出 IndexOutOfBoundsException\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.elementAt(3)) \n    println(list.elementAt(6)) \n复制代码\n11.4.3、elementAtOrElse\n返回给定index对应的元素，如果index数组越界则会根据给定函数返回默认值\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.elementAtOrElse(3, { it * 2 }))  \n    println(list.elementAtOrElse(16, { it * 2 })) \n\n复制代码\n18.4.4、elementAtOrNull\n返回给定index对应的元素，如果index数组越界则会返回null\n\n    val list = listOf(1, 3, 5, -1, 7, 9, null, 2)\n    println(list.elementAtOrNull(3))  \n    println(list.elementAtOrNull(16)) \n复制代码\n18.4.5、first\n返回符合给定函数条件的第一个元素\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.first { it % 3 == 0 })  \n复制代码\n18.4.6、firstOrNull\n返回符合给定函数条件的第一个元素，如果没有符合则返回null\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.firstOrNull { it % 3 == 0 })  \n    println(list.firstOrNull { it % 8 == 0 })  \n复制代码\n18.4.7、indexOf\n返回指定元素的第一个index，如果不存在，则返回 -1\n\n    val list = listOf(1, 3, 5, -1, 7, 9, 2)\n    println(list.indexOf(5))  \n    println(list.indexOf(12)) \n复制代码\n18.4.8、indexOfFirst\n返回第一个符合给定函数条件的元素的index，如果没有符合则返回 -1\n\n    val list = listOf(1, 3, 5, 1, 7, 9, 2)\n    println(list.indexOfFirst { it % 2 == 0 })   \n    println(list.indexOfFirst { it % 12 == 0 })  \n复制代码\n18.4.9、indexOfLast\n返回最后一个符合给定函数条件的元素的index，如果没有符合则返回 -1\n\n    val list = listOf(1, 3, 5, 6, 7, 9, 2)\n    println(list.indexOfLast { it % 2 == 0 })   \n    println(list.indexOfLast { it % 12 == 0 })  \n复制代码\n18.4.10、last\n返回符合给定函数条件的最后一个元素\n\n    val list = listOf(1, 3, 5, 6, 7, 9, 2)\n    println(list.last { it % 2 == 0 })   \n    println(list.last { it % 3 == 0 })   \n复制代码\n18.4.10、lastIndexOf\n返回指定元素的最后一个index，如果不存在，则返回 -1\n\n    val list = listOf(1, 3, 2, 6, 7, 9, 2)\n    println(list.lastIndexOf(2))    \n    println(list.lastIndexOf(12))   \n复制代码\n18.4.11、lastOrNull\n返回符合给定函数条件的最后一个元素，如果没有符合则返回null\n\n    val list = listOf(1, 3, 2, 6, 7, 9, 2)\n    println(list.lastOrNull { it / 3 == 3 })    \n    println(list.lastOrNull { it == 10 })       \n复制代码\n18.4.12、single\n返回符合给定函数的单个元素，如果没有符合或者超过一个，则抛出异常\n\n    val list = listOf(1, 9, 2, 6, 7, 9, 2)\n    println(list.single { it % 7 == 0 })  \n    println(list.single { it == 2 })      \n复制代码\n18.4.13、singleOrNull\n返回符合给定函数的单个元素，如果没有符合或者超过一个，则返回null\n\n    val list = listOf(1, 9, 2, 6, 7, 9, 2)\n    println(list.singleOrNull { it % 7 == 0 })  \n    println(list.singleOrNull { it == 2 })      \n复制代码\n18.5、生产操作符\n18.5.1、partition\n把一个给定的集合分割成两个，第一个集合是由原集合每一项元素匹配给定函数条 件返回 true 的元素组成，第二个集合是由原集合每一项元素匹配给定函数条件返回 false 的元素组成\n\n    val list = listOf(1, 9, 2, 6, 7, 9, 2)\n    val (list1, list2) = list.partition { it % 2 == 0 }\n    println(list1)  \n    println(list2)  \n复制代码\n18.5.2、plus\n返回一个包含原集合和给定集合中所有元素的集合，因为函数的名字原因，我们可以使用 + 操作符\n\n    val list1 = listOf(1, 9, 2, 6, 7, 9, 2)\n    val list2 = listOf(1, 2, 4, 6, 8, 10)\n    println(list1.plus(list2)) \n    println(list1 + list2)  \n复制代码\n18.5.3、zip\n返回由 pair 组成的List，每个 pair 由两个集合中相同index的元素组成。这个返回的List的大小由最小的那个集合决定\n\n    val list1 = listOf(1, 9, 2, 6, 7, 9, 2)\n    val list2 = listOf(1, 2, 4, 6, 8, 10)\n    val list3 = list1.zip(list2)\n    println(list3.javaClass)\n    println(list3.get(0).javaClass)\n    println(\"${list3.get(0).first} , ${list3.get(0).second}\")\n    list3.forEach { println(it) }\n复制代码\n    class java.util.ArrayList\n    class kotlin.Pair\n    1 , 1\n    (1, 1)\n    (9, 2)\n    (2, 4)\n    (6, 6)\n    (7, 8)\n    (9, 10)\n复制代码\n18.5.4、unzip\n从包含pair的List中生成包含List的Pair\n\n    val list1 = listOf(Pair(\"leavesC\", 1), Pair(\"leavesC_2\", 2), Pair(\"leavesC_3\", 3))\n    val list2 = list1.unzip()\n    println(list2.javaClass)\n    println(list2.first)\n    println(list2.second)\n复制代码\n    class kotlin.Pair\n    [leavesC, leavesC_2, leavesC_3]\n    [1, 2, 3]\n复制代码\n18.6、顺序操作符\n18.6.1、reverse\n返回一个与指定list相反顺序的list\n\n    val list1 = listOf(Pair(\"leavesC\", 1), Pair(\"leavesC_2\", 2), Pair(\"leavesC_3\", 3))\n    val list2 = list1.reversed()\n    println(list2)      \n复制代码\n18.6.2、sort\n返回一个自然排序后的list\n\n    val list1 = listOf(2, 4, 1, 9, 5, 10)\n    val list2 = list1.sorted()\n    println(list2) \n\n    val list3 = listOf(\"a\", \"c\", \"ab\", \"b\", \"cdd\", \"cda\")\n    val list4 = list3.sorted()\n    println(list4) \n复制代码\n18.6.3、sortBy\n返回一个根据指定函数排序后的list\n\n    val list1 = listOf(2, 4, 1, 9, 5, 10)\n    val list2 = list1.sortedBy { it - 3 }\n    println(list2) \n复制代码\n18.6.4、sortDescending\n返回一个降序排序后的List\n\n    val list1 = listOf(2, 4, 1, 9, 5, 10)\n    val list2 = list1.sortedDescending()\n    println(list2) \n复制代码\n18.6.5、sortDescendingBy\n返回一个根据指定函数降序排序后的list\n\n    val list1 = listOf(2, 4, 1, 9, 5, 10)\n    val list2 = list1.sortedByDescending { it % 2 }\n    println(list2) \n复制代码\n十九、异常\nkotlin 中异常处理的基本形式和 Java 类似\n\nfun compute(index: Int): Boolean {\n    if (index !in 0..10) {\n        throw IllegalArgumentException(\"参数错误\")\n    }\n    return true\n}\n复制代码\n和 Java 不同的是，kotlin 中 throw 结构是一个表达式，可以作为另一个表达式的一部分来使用\n\n例如下面这个例子，如果条件不满足，则将抛出异常，从而导致 status 变量也不会初始化\n\nval status = if (index in 0..10) index else throw IllegalArgumentException(\"参数错误\")\n复制代码\n此外，在 Java 中对于受检异常必须显式地处理，通过 try/catch 语句捕获异常或者是抛给其调用者来处理。而 kotlin 不区分受检异常和未受检异常，不用指定函数抛出的异常，可以处理也可以不处理异常\n\n在 kotlin 中 ，try 关键字引入了一个表达式，从而可以把表达式的值赋给一个变量。如果一个 try 代码块执行正常，代码块中最后一个表达式就是结果，如果捕获到了一个异常，则相应 catch 代码块中最后一个表达式就是结果\n\n看以下例子，如果 try 表达式包裹的表达式会抛出异常，则返回值为 null ，否则为 true\n\nfun main() {\n    compute(5)   \n    compute(100) \n}\n\nfun compute(index: Int) {\n    val status = try {\n        if (index in 0..10) true else throw IllegalArgumentException(\"参数错误\")\n    } catch (e: Exception) {\n        null\n    }\n    println(\"fun end : \" + status)\n}\n复制代码\n但是，如果在 catch 语句中使用 return 结束了 compute 函数，则没有任何输出\n\nfun main() {\n    compute(5)   \n    compute(100) \n}\n\nfun compute(index: Int) {\n    val status = try {\n        if (index in 0..10) true else throw IllegalArgumentException(\"参数错误\")\n    } catch (e: Exception) {\n        return\n    }\n    println(\"fun end : \" + status)\n}\n复制代码\n二十、运算符重载\nkotlin 允许为类型提供预定义的操作符实现，这些操作符具有固定的符号表示（例如 + 和 * ）和固定的优先级，通过操作符重载可以将操作符的行为映射到指定的方法。为实现这样的操作符，需要为类提供一个固定名字的成员函数或扩展函数，相应的重载操作符的函数需要用 operator 修饰符标记\n\n20.1、一元操作符\n操作符\t函数\n+a\ta.unaryPlus()\n-a\ta.unaryMinus()\n!a\ta.not()\na++\ta.inc()\na--\ta.dec()\n20.2、二元操作符\n操作符\t函数\na + b\ta.plus(b)\na - b\ta.minus(b)\na * b\ta.times(b)\na / b\ta.div(b)\na % b\ta.rem(b)\na..b\ta.rangeTo(b)\na in b\tb.contains(a)\na !in b\t!b.contains(a)\na += b\ta.plusAssign(b)\na -= b\ta.minusAssign(b)\na *= b\ta.timesAssign(b)\na /= b\ta.divAssign(b)\na %= b\ta.remAssign(b)\n20.3、数组操作符\n操作符\t函数\na[i]\ta.get(i)\na[i, j]\ta.get(i, j)\na[i_1, ..., i_n]\ta.get(i_1, ..., i_n)\na[i] = b\ta.set(i, b)\na[i, j] = b\ta.set(i, j, b)\na[i_1, ..., i_n] = b\ta.set(i_1, ..., i_n, b)\n20.4、等于操作符\n操作符\t函数\na == b\ta?.equals(b) ?: b === null\na != b\t!(a?.equals(b) ?: b === null)\n相等操作符有一点不同，为了达到正确合适的相等检查做了更复杂的转换，因为要得到一个确切的函数结构比较，不仅仅是指定的名称\n\n方法必须要如下准确地被实现：\n\noperator fun equals(other: Any?): Boolean\n复制代码\n操作符 === 和 !== 用来做身份检查（它们分别是 Java 中的 == 和 != ），并且它们不能被重载\n\n20.5、比较操作符\n操作符\t函数\na > b\ta.compareTo(b) > 0\na < b\ta.compareTo(b) < 0\na >= b\ta.compareTo(b) >= 0\na <= b\ta.compareTo(b) <= 0\n所有的比较都转换为对 compareTo 的调用，这个函数需要返回 Int 值\n\n20.6、函数调用\n方法\t调用\na()\ta.invoke()\na(i)\ta.invoke(i)\na(i, j)\ta.invoke(i, j)\na(i_1, ..., i_n)\ta.invoke(i_1, ..., i_n)\n20.7、例子\n看几个例子\n\ndata class Point(val x: Int, val y: Int) {\n\n    \n    operator fun unaryPlus() = Point(+x, +y)\n\n    \n    operator fun inc() = Point(x + 1, y + 1)\n\n    \n    operator fun plus(point: Point) = Point(x + point.x, y + point.y)\n\n    \n    operator fun plus(value: Int) = Point(x + value, y + value)\n\n    \n    operator fun get(index: Int): Int {\n        return when (index) {\n            0 -> x\n            1 -> y\n            else -> throw IndexOutOfBoundsException(\"无效索引\")\n        }\n    }\n\n    \n    operator fun invoke(index: Int) = when (index) {\n        0 -> x\n        1 -> y\n        else -> throw IndexOutOfBoundsException(\"无效索引\")\n    }\n\n}\n复制代码\nfun main() {\n    \n    println(\"+${Point(10, -20)}  =  ${+Point(10, -20)}\")\n\n    \n    var point = Point(10, -20)\n    println(\"${Point(10, -20)}++  =  ${point++}\")\n\n    \n    point = Point(10, -20)\n    println(\"++${Point(10, -20)}  =  ${++point}\")\n\n    \n    println(\"${Point(10, -20)} + ${Point(10, -20)}  =  ${Point(10, -20) + Point(10, -20)}\")\n\n    \n    println(\"${Point(10, -20)} + ${5}  =  ${Point(10, -20) + 5}\")\n\n    point = Point(10, -20)\n    \n    println(\"point[0] value is: ${point[0]}\")\n    \n    println(\"point[1] value is: ${point[1]}\")\n\n    \n    println(\"point(0) values is: ${point(0)}\")\n}\n复制代码\n二十一、中缀调用与解构声明\n21.1、中缀调用\n可以以以下形式创建一个 Map 变量\n\nfun main() {\n    val maps = mapOf(1 to \"leavesC\", 2 to \"ye\", 3 to \"czy\")\n    maps.forEach { key, value -> println(\"key is : $key , value is : $value\") }\n}\n复制代码\n使用 “to” 来声明 map 的 key 与 value 之间的对应关系，这种形式的函数调用被称为中缀调用\n\nkotlin 标准库中对 to 函数的声明如下所示，其作为扩展函数存在，且是一个泛型函数，返回值 Pair 最终再通过解构声明分别将 key 和 value 传给 Map\n\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n复制代码\n中缀调用只能与只有一个参数的函数一起使用，无论是普通的函数还是扩展函数。中缀符号需要通过 infix 修饰符来进行标记\n\nfun main() {\n    val pair = 10 test \"leavesC\"\n    val pair2 = 1.2 test 20\n    println(pair2.javaClass) \n}\n\ninfix fun Any.test(other: Any) = Pair(this, other)\n复制代码\n对于 mapOf 函数来说，它可以接收不定数量的 Pair 类型对象，因此我们也可以通过自定义的中缀调用符 test 来创建一个 map 变量\n\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n复制代码\n val map = mapOf(10 test \"leavesC\", 20 test \"hello\")\n复制代码\n21.2、解构声明\n有时会有把一个对象拆解成多个变量的需求，在 kotlin 中这种语法称为解构声明\n\n例如，以下例子将 Person 变量结构为了两个新变量：name 和 age，并且可以独立使用它们\n\ndata class Person(val name: String, val age: Int)\n\nfun main() {\n    val (name, age) = Person(\"leavesC\", 24)\n    println(\"Name: $name , age: $age\")\n    \n}\n复制代码\n一个解构声明会被编译成以下代码：\n\n    val name = person.component1()\n    val age = person.component2()\n复制代码\n其中的 component1() 和 component2() 函数是在 kotlin 中广泛使用的约定原则的另一个例子。任何表达式都可以出现在解构声明的右侧，只要可以对它调用所需数量的 component 函数即可\n\n需要注意的是，componentN() 函数需要用 operator 关键字标记，以允许在解构声明中使用它们\n\n对于数据类来说，其自动生成了 componentN() 函数，而对非数据类，为了使用解构声明，需要我们自己来手动声明函数\n\nclass Point(val x: Int, val y: Int) {\n    operator fun component1() = x\n    operator fun component2() = y\n}\n\nfun main() {\n    val point = Point(100, 200)\n    val (x, y) = point\n    println(\"x: $x , y: $y\")\n    \n}\n复制代码\n如果我们需要从一个函数返回两个或者更多的值，这时候使用解构声明就会比较方便了\n\n这里使用的是标准类 Pair 来包装要传递的数据，当然，也可以自定义数据类\n\nfun computer(): Pair<String, Int> {\n    \n    return Pair(\"leavesC\", 24)\n}\n\nfun main() {\n    val (name, age) = computer()\n    println(\"Name: $name , age: $age\")\n}\n复制代码\n此外，解构声明也可以用在 for 循环中\n\n    val list = listOf(Person(\"leavesC\", 24), Person(\"leavesC\", 25))\n    for ((name, age) in list) {\n        println(\"Name: $name , age: $age\")\n    }\n复制代码\n对于遍历 map 同样适用\n\n    val map = mapOf(\"leavesC\" to 24, \"ye\" to 25)\n    for ((name, age) in map) {\n        println(\"Name: $name , age: $age\")\n    }\n复制代码\n同样也适用于 lambda 表达式\n\n    val map = mapOf(\"leavesC\" to 24, \"ye\" to 25)\n    map.mapKeys { (key, value) -> println(\"key : $key , value : $value\") }\n复制代码\n如果在解构声明中不需要某个变量，那么可以用下划线取代其名称，此时不会调用相应的 componentN() 操作符函数\n\n    val map = mapOf(\"leavesC\" to 24, \"ye\" to 25)\n    for ((_, age) in map) {\n        println(\"age: $age\")\n    }\n复制代码\n二十二、Object 关键字\n22.1、对象声明\n在 kotlin 的世界中，可以通过对象声明这一功能来实现 Java 中的单例模式，将类声明与该类的单一实例声明结合到一起。与类一样，一个对象声明可以包含属性、方法、初始化语句块等的声明，且可以继承类和实现接口，唯一不被允许的是构造方法\n\n与普通类的实例不同，对象声明在定义的时候就被立即创建了，不需要在代码的其它地方调用构造方法，因此为对象声明定义构造方法是没有意义的\n\ninterface Fly {\n\n    fun fly()\n\n}\n\nopen class Eat {\n\n    fun eat() {\n        println(\"eat\")\n    }\n\n}\n\nobject Animal : Eat(), Fly {\n\n    override fun fly() {\n        println(\"fly\")\n    }\n\n}\n\nfun main() {\n    Animal.fly()\n    Animal.eat()\n}\n复制代码\nkotlin 中的对象声明被编译成了通过静态字段来持有它的单一实例的类，这个字段名字始终都是 INSTANCE\n\n例如，对于 kotlin 中的如下两个对象声明\n\nclass Test {\n\n    object SingleClass {\n        val names = arrayListOf<String>()\n    }\n\n    object SingleClass2 {\n        val names = arrayListOf<String>()\n    }\n\n}\n复制代码\n在 Java 代码中来访问这两个对象\n\n    public static void main(String[] args) {\n        Test.SingleClass.INSTANCE.getNames();\n        Test.SingleClass2.INSTANCE.getNames();\n    }\n复制代码\n22.2、伴生对象\n如果需要一个可以在没有类实例的情况下调用但是需要访问类内部的函数（类似于 Java 中的静态变量/静态函数），可以将其写成那个类中的对象声明的成员\n\n通过关键字 companion ，就可以获得通过容器类名称来访问这个对象的方法和属性的能力，不再需要显式地指明对象的名称\n\nclass Test {\n\n    companion object {\n\n        const val NAME = \"\"\n\n        fun testFun() {\n\n        }\n    }\n\n}\n\nfun main() {\n    Test.NAME\n    Test.testFun()\n}\n复制代码\n22.2.1、工厂模式\n可以利用伴生对象来实现工厂模式\n\nprivate class User private constructor(val name: String) {\n\n    companion object {\n        fun newById(id: Int) = User(id.toString())\n\n        fun newByDouble(double: Double) = User(double.toString())\n    }\n\n}\n\nfun main() {\n    \n    \n    val user2 = User.newById(10)\n    val user3 = User.newByDouble(1.3)\n}\n复制代码\n22.2.2、指定名称\n伴生对象既可以为其指定名字，也可以直接使用其默认名 Companion，在引用伴生对象时，可以自由选择是否要在类名后加上伴生对象名\n\n如果使用的是其默认名 Companion（没有自定义名称），则以下两种引用方式都是等价的\n\n    val user2 = User.Companion.newById(10)\n    val user3 = User.newByDouble(1.3)\n复制代码\n如果为伴生对象声明了自定义名称，引用方式等同\n\nprivate class User private constructor(val name: String) {\n\n    companion object UserLoader {\n        fun newById(id: Int) = User(id.toString())\n\n        fun newByDouble(double: Double) = User(double.toString())\n    }\n\n}\n\nfun main() {\n    \n    \n    val user2 = User.UserLoader.newById(10)\n    val user3 = User.newByDouble(1.3)\n}\n复制代码\n22.2.3、实现接口\n伴生对象也可以实现接口，且可以直接将包含它的类的名字当做实现了该接口的对象实例来使用\n\nprivate class User private constructor(val name: String) {\n\n    companion object UserLoader : Runnable {\n\n        override fun run() {\n\n        }\n    }\n\n}\n\nfun newThread(runnable: Runnable) = Thread(runnable)\n\nfun main() {\n    \n    val thread = newThread(User)\n    val thread2 = newThread(User.UserLoader)\n}\n复制代码\n22.3、对象表达式\nobject 能用来声明匿名对象，可用于替代 Java 中的匿名内部类，且对象表达式中的代码可以访问并修改其外部的非 final 型的变量\n\nfun newThread(runnable: Runnable) = Thread(runnable)\n\nfun main() {\n    var count = 0\n    val thread = newThread(object : Runnable {\n        override fun run() {\n            count++\n        }\n    })\n}\n复制代码\n二十三、委托\n23.1、委托模式\n委托模式是一种基本的设计模式，该模式下有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。kotlin 原生支持委托模式，可以零样板代码来实现，通过关键字 by 实现委托\n\ninterface Printer {\n\n    fun print()\n    \n}\n\nclass DefaultPrinter : Printer {\n\n    override fun print() {\n         println(\"DefaultPrinter print\")\n    }\n\n}\n\nclass CustomPrinter(val printer: Printer) : Printer by printer\n\nfun main() {\n    val printer = CustomPrinter(DefaultPrinter())\n    printer.print() \n}\n复制代码\nCustomPrinter 的 by 子句表示将会在 CustomPrinter 中存储 printer 变量，并且编译器将为 CustomPrinter 隐式生成 Printer 接口的所有抽象方法，并将这些方法的调用操作转发给 printer\n\n此外，CustomPrinter 也可以决定自己实现部分方法或全部自己实现，但重写的成员不会在委托对象的成员中调用 ，委托对象的成员只能访问其自身对接口成员实现\n\ninterface Printer {\n\n    val message: String\n\n    fun print()\n\n    fun reprint()\n\n}\n\nclass DefaultPrinter : Printer {\n\n    override val message: String = \"DefaultPrinter message\"\n\n    override fun print() {\n        println(message)\n    }\n\n    override fun reprint() {\n        println(\"DefaultPrinter reprint\")\n    }\n\n}\n\nclass CustomPrinter(val printer: Printer) : Printer by printer {\n\n    override val message: String = \"CustomPrinter message\"\n\n    override fun reprint() {\n        println(\"CustomPrinter reprint\")\n    }\n\n}\n\nfun main() {\n    val printer = CustomPrinter(DefaultPrinter())\n    printer.print() \n    printer.reprint() \n}\n复制代码\n23.2、属性委托\nkotlin 支持通过委托属性将对一个属性的访问操作委托给另外一个对象来完成，对应的语法格式是：\n\nval/var <属性名>: <类型> by <表达式>\n复制代码\n属性的委托不必实现任何的接口，但需要提供一个 getValue() 方法与 setValue()（对于 var 属性），对一个属性的 get 和 set 操作会被委托给属性的委托的这两个方法\n\nclass Delegate {\n    \n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n    }\n\t\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n    }\n}\n复制代码\n看以下的小例子，通过输出值就可以看出各个方法的调用时机\n\npackage test\n\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n\n    private var message: String? = null\n\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        println(\"${thisRef?.javaClass?.name}, thank you for delegating '${property.name}' to me!\")\n        return message ?: \"null value\"\n    }\n\n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$value has been assigned to '${property.name}' in ${thisRef?.javaClass?.name}.\")\n        message = value\n    }\n}\n\nclass Example {\n    var strValue: String by Delegate()\n}\n\nfun main() {\n    val example = Example()\n    println(example.strValue)\n    example.strValue = \"leaveC\"\n    println(example.strValue)\n\n\n\n\n\n}\n复制代码\n23.3、延迟属性\nlazy() 是接受一个 lambda 并返回一个 Lazy < T > 实例的函数，返回的实例可以作为实现延迟属性的委托，第一次调用 get() 会执行已传递给 lazy() 函数的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果\n\nclass Example {\n\n    val lazyValue1: String by lazy {\n        println(\"lazyValue1 computed!\")\n        \"Hello\"\n    }\n\n    val lazyValue2: String by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {\n        println(\"lazyValue2 computed!\")\n        computeLazyValue()\n    }\n\n    private fun computeLazyValue() = \"leavesC\"\n\n}\n\nfun main() {\n    val example = Example()\n    println(example.lazyValue1) \n    println(example.lazyValue1) \n    println(example.lazyValue2) \n}\n复制代码\n默认情况下，对于 lazy 属性的求值是带同步锁的（synchronized），即带有 LazyThreadSafetyMode.SYNCHRONIZED 参数，此时该值只允许同一时刻只能有一个线程对其进行初始化，并且所有线程会看到相同的初始化值。如果初始化委托的同步锁不是必需的，即如果允许多个线程同时执行，那么可以将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给 lazy() 函数。 而如果你确定初始化将总是发生在单个线程，那么可以使用 LazyThreadSafetyMode.NONE 模式， 此时不会有任何线程安全的保证以及相关的资源开销\n\n23.4、可观察属性\nDelegates.observable() 接受两个参数：初始值以及修改属性值时的回调函数。当为属性赋值后就会调用该回调函数，该回调函数包含三个参数：被赋值的属性、旧值与新值\n\nfun main() {\n    val example = Example()\n    example.age = 24 \n    example.age = 27 \n}\n\nclass Example {\n    var age: Int by Delegates.observable(-100) { kProperty: KProperty<*>, oldValue: Int, newValue: Int ->\n        println(\"kProperty.name: ${kProperty.name} , oldValue: $oldValue , newValue: $newValue\")\n    }\n}\n复制代码\n如果想要拦截一个赋值操作并判断是否进行否决，可以使用 vetoable() 函数，通过返回一个布尔值来决定是否进行拦截，该判断逻辑是在属性被赋新值生效之前进行\n\nfun main() {\n    val example = Example()\n    example.age = 24  \n    example.age = -10 \n    example.age = 30  \n}\n\nclass Example {\n    var age: Int by Delegates.vetoable(-100) { kProperty: KProperty<*>, oldValue: Int, newValue: Int ->\n        println(\"kProperty.name: ${kProperty.name} , oldValue: $oldValue , newValue: $newValue\")\n        age <= 0 \n    }\n}\n复制代码\n23.5、把属性储存在映射中\n可以在一个 map 映射里存储属性的值，然后把属性的存取操作委托给 map 进行管理\n\nfun main() {\n    val student = Student(\n        mapOf(\n            \"name\" to \"leavesC\",\n            \"age\" to 24\n        )\n    )\n    println(student.name)\n    println(student.age)\n}\n\nclass Student(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int by map\n}\n复制代码\n在上述示例中，属性 name 和 age 都是不可变的（val），因此 map 的类型也是 Map 而非 MutableMap（MutableMap 在赋值后可以修改），因此如果为了支持 var 属性，可以将只读的 Map 换成 MutableMap\n\n23.6、局部委托属性\n可以将局部变量声明为委托属性\n\nclass Printer {\n\n    fun print() {\n        println(\"temp.Printer print\")\n    }\n\n}\n\nfun getPrinter(): Printer {\n    println(\"temp.Printer getPrinter\")\n    return Printer()\n}\n\n\nfun example(getPrinter: () -> Printer) {\n    val lPrinter by lazy(getPrinter)\n    val valid = true\n    if (valid) {\n        lPrinter.print()\n    }\n}\n\nfun main() {\n    example { getPrinter() }\n    \n    \n}\n复制代码\n委托变量只会在第一次访问时才会进行初始化，因此如果 valid 为 false 的话，getPrinter() 方法就不会被调用\n\n二十四、注解\n注解是将元数据附加到代码元素上的一种方式，附件的元数据就可以在编译后的类文件或者运行时被相关的源代码工具访问\n\n注解的语法格式如下所示：\n\n    annotation class AnnotationName()\n复制代码\n注解的附加属性可以通过用元注解标注注解类来指定：\n\n@Target 指定该注解标注的允许范围（类、函数、属性等）\n@Retention 指定该注解是否要存储在编译后的 class 文件中，如果要保存，则在运行时可以通过反射来获取到该注解值\n@Repeatable 标明允许在单个元素上多次使用相同的该注解\n@MustBeDocumented 指定该注解是公有 API 的一部分，并且应该包含在生成的 API 文档中显示的类或方法的签名中\n    @Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)\n    @Retention(AnnotationRetention.RUNTIME)\n    @Repeatable\n    @MustBeDocumented\n    annotation class AnnotationName()\n复制代码\n注解可以声明包含有参数的构造函数\n\n    annotation class OnClick(val viewId: Long)\n复制代码\n允许的参数类型有：\n\n原生数据类型，对应 Java 原生的 int 、long、char 等\n字符串\nclass 对象\n枚举\n其他注解\n以上类型的数组\n注解参数不能包含有可空类型，因为 JVM 不支持将 null 作为注解属性的值来存储\n\n看一个在运行时获取注解值的例子\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class OnClick(val viewId: Long)\n\nclass AnnotationsTest {\n\n    @OnClick(200300)\n    fun onClickButton() {\n        println(\"Clicked\")\n    }\n\n}\n\nfun main() {\n    val annotationsTest = AnnotationsTest()\n    for (method in annotationsTest.javaClass.methods) {\n        for (annotation in method.annotations) {\n            if (annotation is OnClick) {\n                println(\"method name: \" + method.name)  \n                println(\"OnClick viewId: \" + annotation.viewId)  \n            }\n        }\n    }\n}\n复制代码"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304155310},"updatedAt":{"$$date":1597305432508},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"UyFSCCutkrNi6ea6"}
{"name":"使用 require 或者 check 函数作为条件检查","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"dart","value":"// 传统的做法\nval age = -1;\nif (age <= 0) {\n    throw IllegalArgumentException(\"age must  not be negative\")\n}\n\n// 使用 require 去检查\nrequire(age > 0) { \"age must be negative\" }\n\n// 使用 checkNotNull 检查\nval name: String? = null\ncheckNotNull(name){\n    \"name must not be null\"\n}\n\n作者：HiDhl\n链接：https://juejin.im/post/5edfd7c9e51d45789a7f206d\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}],"tags":["aZ7LswF9qbcVtQZT"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594728663925},"updatedAt":{"$$date":1594728663925},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"kotlin","_id":"aZ7LswF9qbcVtQZT","text":"kotlin"}],"_id":"V76phT9KREhVY2vF"}
{"name":"py-可变参数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。\n\n我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。\n\n要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：\n\ndef calc(numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n但是调用的时候，需要先组装出一个list或tuple：\n\n>>> calc([1, 2, 3])\n14\n>>> calc((1, 3, 5, 7))\n84\n如果利用可变参数，调用函数的方式可以简化成这样：\n\n>>> calc(1, 2, 3)\n14\n>>> calc(1, 3, 5, 7)\n84\n所以，我们把函数的参数改为可变参数：\n\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：\n\n>>> calc(1, 2)\n5\n>>> calc()\n0\n如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：\n\n>>> nums = [1, 2, 3]\n>>> calc(nums[0], nums[1], nums[2])\n14\n这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：\n\n>>> nums = [1, 2, 3]\n>>> calc(*nums)\n14\n*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977478427},"updatedAt":{"$$date":1594977686476},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"VHWAfsgfrAvCef04"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977496517},"updatedAt":{"$$date":1594977496517},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"VSuyIAsO09jo27nl"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977499804},"updatedAt":{"$$date":1594977499804},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"VZNqM8DM9AFgnnHz"}
{"name":"kotlin-使用命令行编译","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-command-line.html\nKotlin 使用命令行编译 | 菜鸟教程\n2-2 minutes\nKotlin 命令行编译工具下载地址：https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-2，目前最新为 1.1.2-2。\n\n你可以选择一个最新的稳定版下载。\n\n下载完成后，解压到指定目录，然后将 bin 目录添加到系统环境变量。bin 目录包含编译和运行 Kotlin 所需的脚本。\n\nSDKMAN!\n在 OS X、Linux、Cygwin、FreeBSD 和 Solaris 系统上也可以使用更简单的安装方法，命令如下：\n\n$ curl -s https://get.sdkman.io | bash\n\n$ sdk install kotlin\nHomebrew\n在 OS X 下，你可以使用 Homebrew 安装：\n\n$ brew update\n$ brew install kotlin\nMacPorts\n如果你是 MacPorts 用户，可以使用以下命令安装：\n\n$ sudo port install kotlin\n创建和运行第一个程序\n创建一个名为 hello.kt 文件，代码如下：\n\nhello.kt\nfun main(args: Array<String>) { println(\"Hello, World!\") }\n\n使用 Kotlin 编译器编译应用:\n\n$ kotlinc hello.kt -include-runtime -d hello.jar\n-d: 用来设置编译输出的名称，可以是 class 或 .jar 文件，也可以是目录。\n-include-runtime : 让 .jar 文件包含 Kotlin 运行库，从而可以直接运行。\n如果你想看所有的可用选项，运行:\n\n$ kotlinc -help\n运行应用\n\n$ java -jar hello.jar\nHello, World!\n编译成库\n若需要将生成的 jar 包供其他 Kotlin 程序使用，可无需包含 Kotlin 的运行库：\n\n$ kotlinc hello.kt -d hello.jar\n由于这样生成的 .jar 文件不包含 Kotlin 运行库，所以你应该确保当它被使用时，运行时在你的 classpath 上。\n\n你也可以使用 kotlin 命令来运行 Kotlin 编译器生成的 .jar 文件\n\n$ kotlin -classpath hello.jar HelloKt\nHelloKt 为编译器为 hello.kt 文件生成的默认类名。\n\n运行 REPL（交互式解释器）\n我们可以运行如下命令得到一个可交互的 shell，然后输入任何有效的 Kotlin 代码，并立即看到结果\n\n\n\n使用命令行执行脚本\nKotlin 也可以作为一个脚本语言使用，文件后缀名为 .kts 。\n\n例如我们创建一个名为 list_folders.kts，代码如下：\n\nimport java.io.File\n\nval folders = File(args[0]).listFiles { file -> file.isDirectory() }\nfolders?.forEach { folder -> println(folder) }\n执行时通过 -script 选项设置相应的脚本文件。\n\n$ kotlinc -script list_folders.kts <path_to_folder>\n$ kotlinc -script list_folders.kts"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303651182},"updatedAt":{"$$date":1597303736910},"_id":"Vmx389m8LLPYePVn","folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977498702},"updatedAt":{"$$date":1594977498702},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Vxpagdu45CnMF24U"}
{"name":"andr-ViewModel 概览","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\ndeveloper.android.google.cn /topic/libraries/architecture/viewmodel\nViewModel 概览  |  Android 开发者  |  Android Developers\n8-10 minutes\nViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。\n\nAndroid 框架可以管理界面控制器（如 Activity 和 Fragment）的生命周期。Android 框架可能会决定销毁或重新创建界面控制器，以响应完全不受您控制的某些用户操作或设备事件。\n\n如果系统销毁或重新创建界面控制器，则存储在其中的任何临时性界面相关数据都会丢失。例如，应用的某个 Activity 中可能包含用户列表。因配置更改而重新创建 Activity 后，新 Activity 必须重新提取用户列表。对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。\n\n另一个问题是，界面控制器经常需要进行异步调用，这些调用可能需要一些时间才能返回结果。界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄露。此项管理需要大量的维护工作，并且在因配置更改而重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。\n\n诸如 Activity 和 Fragment 之类的界面控制器主要用于显示界面数据、对用户操作做出响应或处理操作系统通信（如权限请求）。如果要求界面控制器也负责从数据库或网络加载数据，那么会使类越发膨胀。为界面控制器分配过多的责任可能会导致单个类尝试自己处理应用的所有工作，而不是将工作委托给其他类。以这种方式为界面控制器分配过多的责任也会大大增加测试的难度。\n\n从界面控制器逻辑中分离出视图数据所有权的做法更易行且更高效。\n\n实现 ViewModel\n架构组件为界面控制器提供了 ViewModel 辅助程序类，该类负责为界面准备数据。在配置更改期间会自动保留 ViewModel 对象，以便它们存储的数据立即可供下一个 Activity 或 Fragment 实例使用。例如，如果您需要在应用中显示用户列表，请确保将获取和保留该用户列表的责任分配给 ViewModel，而不是 Activity 或 Fragment，如以下示例代码所示：\n\nKotlin\n    class MyViewModel : ViewModel() {\n        private val users: MutableLiveData<List<User>> by lazy {\n            MutableLiveData().also {\n                loadUsers()\n            }\n        }\n\n        fun getUsers(): LiveData<List<User>> {\n            return users\n        }\n\n        private fun loadUsers() {\n            // Do an asynchronous operation to fetch users.\n        }\n    }\n    \nJava\n    public class MyViewModel extends ViewModel {\n        private MutableLiveData<List<User>> users;\n        public LiveData<List<User>> getUsers() {\n            if (users == null) {\n                users = new MutableLiveData<List<User>>();\n                loadUsers();\n            }\n            return users;\n        }\n\n        private void loadUsers() {\n            // Do an asynchronous operation to fetch users.\n        }\n    }\n    \n然后，您可以从 Activity 访问该列表，如下所示：\n\nKotlin\n    class MyActivity : AppCompatActivity() {\n\n        override fun onCreate(savedInstanceState: Bundle?) {\n            // Create a ViewModel the first time the system calls an activity's onCreate() method.\n            // Re-created activities receive the same MyViewModel instance created by the first activity.\n\n            // Use the 'by viewModels()' Kotlin property delegate\n            // from the activity-ktx artifact\n            val model: MyViewModel by viewModels()\n            model.getUsers().observe(this, Observer<List<User>>{ users ->\n                // update UI\n            })\n        }\n    }\n    \nJava\n    public class MyActivity extends AppCompatActivity {\n        public void onCreate(Bundle savedInstanceState) {\n            // Create a ViewModel the first time the system calls an activity's onCreate() method.\n            // Re-created activities receive the same MyViewModel instance created by the first activity.\n\n            MyViewModel model = new ViewModelProvider(this).get(MyViewModel.class);\n            model.getUsers().observe(this, users -> {\n                // update UI\n            });\n        }\n    }\n    \n如果重新创建了该 Activity，它接收的 MyViewModel 实例与第一个 Activity 创建的实例相同。当所有者 Activity 完成时，框架会调用 ViewModel 对象的 onCleared() 方法，以便它可以清理资源。\n\nViewModel 对象存在的时间比视图或 LifecycleOwners 的特定实例存在的时间更长。这还意味着，您可以更轻松地编写涵盖 ViewModel 的测试，因为它不了解视图和 Lifecycle 对象。ViewModel 对象可以包含 LifecycleObservers，如 LiveData 对象。但是，ViewModel 对象绝不能观察对生命周期感知型可观察对象（如 LiveData 对象）的更改。 如果 ViewModel 需要 Application 上下文（例如，为了查找系统服务），它可以扩展 AndroidViewModel 类并设置用于接收 Application 的构造函数，因为 Application 类会扩展 Context。\n\nViewModel 的生命周期\nViewModel 对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel 将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失：对于 Activity，是在 Activity 完成时；而对于 Fragment，是在 Fragment 分离时。\n\n图 1 说明了 Activity 经历屏幕旋转而后结束的过程中所处的各种生命周期状态。该图还在关联的 Activity 生命周期的旁边显示了 ViewModel 的生命周期。此图表说明了 Activity 的各种状态。这些基本状态同样适用于 Fragment 的生命周期。\n\n说明 ViewModel 随着 Activity 状态的改变而经历的生命周期。\n\n您通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel。系统可能会在 Activity 的整个生命周期内多次调用 onCreate()，如在旋转设备屏幕时。ViewModel 存在的时间范围是从您首次请求 ViewModel 直到 Activity 完成并销毁。\n\n在 Fragment 之间共享数据\nActivity 中的两个或更多 Fragment 需要相互通信是一种很常见的情况。想象一下主从 Fragment 的常见情况，假设您有一个 Fragment，在该 Fragment 中，用户从列表中选择一项，还有另一个 Fragment，用于显示选定项的内容。这种情况不太容易处理，因为这两个 Fragment 都需要定义某种接口描述，并且所有者 Activity 必须将两者绑定在一起。此外，这两个 Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。\n\n可以使用 ViewModel 对象解决这一常见的难点。这两个 Fragment 可以使用其 Activity 范围共享 ViewModel 来处理此类通信，如以下示例代码所示：\n\nKotlin\n    class SharedViewModel : ViewModel() {\n        val selected = MutableLiveData<Item>()\n\n        fun select(item: Item) {\n            selected.value = item\n        }\n    }\n\n    class MasterFragment : Fragment() {\n\n        private lateinit var itemSelector: Selector\n\n        // Use the 'by activityViewModels()' Kotlin property delegate\n        // from the fragment-ktx artifact\n        private val model: SharedViewModel by activityViewModels()\n\n        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            itemSelector.setOnClickListener { item ->\n                // Update the UI\n            }\n        }\n    }\n\n    class DetailFragment : Fragment() {\n\n        // Use the 'by activityViewModels()' Kotlin property delegate\n        // from the fragment-ktx artifact\n        private val model: SharedViewModel by activityViewModels()\n\n        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            model.selected.observe(viewLifecycleOwner, Observer<Item> { item ->\n                // Update the UI\n            })\n        }\n    }\n    \nJava\n    public class SharedViewModel extends ViewModel {\n        private final MutableLiveData<Item> selected = new MutableLiveData<Item>();\n\n        public void select(Item item) {\n            selected.setValue(item);\n        }\n\n        public LiveData<Item> getSelected() {\n            return selected;\n        }\n    }\n\n    public class MasterFragment extends Fragment {\n        private SharedViewModel model;\n\n        public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n            super.onViewCreated(view, savedInstanceState);\n            model = new ViewModelProvider(requireActivity()).get(SharedViewModel.class);\n            itemSelector.setOnClickListener(item -> {\n                model.select(item);\n            });\n        }\n    }\n\n    public class DetailFragment extends Fragment {\n\n        public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n            super.onViewCreated(view, savedInstanceState);\n            SharedViewModel model = new ViewModelProvider(requireActivity()).get(SharedViewModel.class);\n            model.getSelected().observe(getViewLifecycleOwner(), { item ->\n               // Update the UI.\n            });\n        }\n    }\n    \n请注意，这两个 Fragment 都会检索包含它们的 Activity。这样，当这两个 Fragment 各自获取 ViewModelProvider 时，它们会收到相同的 SharedViewModel 实例（其范围限定为该 Activity）。\n\n此方法具有以下优势：\n\nActivity 不需要执行任何操作，也不需要对此通信有任何了解。\n除了 SharedViewModel 约定之外，Fragment 不需要相互了解。如果其中一个 Fragment 消失，另一个 Fragment 将继续照常工作。\n每个 Fragment 都有自己的生命周期，而不受另一个 Fragment 的生命周期的影响。如果一个 Fragment 替换另一个 Fragment，界面将继续工作而没有任何问题。\n将加载器替换为 ViewModel\nCursorLoader 等加载器类经常用于使应用界面中的数据与数据库保持同步。您可以将 ViewModel 与一些其他类一起使用来替换加载器。使用 ViewModel 可将界面控制器与数据加载操作分离，这意味着类之间的强引用更少。\n\n在使用加载器的一种常见方法中，应用可能会使用 CursorLoader 观察数据库的内容。当数据库中的值发生更改时，加载器会自动触发数据的重新加载并更新界面：\n\n\n图 2. 使用加载器加载数据\nViewModel 与 Room 和 LiveData 一起使用可替换加载器。ViewModel 确保数据在设备配置更改后仍然存在。Room 在数据库发生更改时通知 LiveData，LiveData 进而使用修订后的数据更新界面。\n\n\n图 3. 使用 ViewModel 加载数据\n将协程与 ViewModel 一起使用\nViewModel 支持 Kotlin 协程。如需了解详情，请参阅将 Kotlin 协程与 Android 架构组件一起使用。\n\n更多信息\n随着数据变得越来越复杂，您可能会选择使用单独的类加载数据。ViewModel 的用途是封装界面控制器的数据，以使数据在配置更改后仍然存在。有关如何在配置更改后加载、保留和管理数据的信息，请参阅保存界面状态。\n\nAndroid 应用架构指南建议构建存储区类来处理这些功能。\n\n其他资源\n如需详细了解 ViewModel 类，请参阅以下资源。\n\n示例\nAndroid 架构组件基本示例\nSunflower，这是一款园艺应用，展示了使用 Android Jetpack 进行 Android 开发的最佳做法。\nCodelab\n带 View 的 Android Room (Java) (Kotlin)\nAndroid 生命周期感知型组件 Codelab\n博客\nViewModel：简单示例\nViewModel：持久性、onSaveInstanceState()、恢复界面状态和加载器\nViewModel 和 LiveData：模式 + 反模式\nKotlin 揭秘：理解速记 Lambda 语法\nKotlin 揭秘：范围函数\nKotlin 揭秘：何时使用自定义访问器\n使用架构组件加载生命周期感知数据\n视频\nAndroid Jetpack：ViewModel\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243907747},"updatedAt":{"$$date":1597244553082},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WBJkGPoqEsWlJwMv"}
{"name":"andr-应用清单","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\ndeveloper.android.google.cn /guide/topics/manifest/manifest-intro\n应用清单概览  |  Android 开发者  |  Android Developers\n7-9 minutes\n每个应用项目必须在项目源设置的根目录中加入 AndroidManifest.xml 文件（且必须使用此名称）。 清单文件会向 Android 构建工具、Android 操作系统和 Google Play 描述应用的基本信息。\n\n重点是，清单文件需声明以下内容：\n\n应用的软件包名称，其通常与代码的命名空间相匹配。 构建项目时，Android 构建工具会使用此信息来确定代码实体的位置。 打包应用时，构建工具会使用 Gradle 构建文件中的应用 ID 来替换此值，而此 ID 则用作系统和 Google Play 上的唯一应用标识符。了解关于软件包名称和应用 ID 的更多内容。\n应用的组件，包括所有 Activity、服务、广播接收器和内容提供程序。 每个组件都必须定义基本属性，例如其 Kotlin 或 Java 类的名称。 清单文件还能声明一些功能，例如其所能处理的设备配置，以及描述组件如何启动的 Intent 过滤器。了解关于应用组件的更多内容。\n应用为访问系统或其他应用的受保护部分所需的权限。 如果其他应用想要访问此应用的内容，则清单文件还会声明其必须拥有的权限。 了解关于权限的更多内容。\n应用需要的硬件和软件功能，这些功能会影响哪些设备能够从 Google Play 安装应用。了解关于设备兼容性的更多内容。\n如果您使用 Android Studio 构建应用，则系统会为您创建清单文件，并在您构建应用时（尤其是在使用代码模板时）添加大部分基本清单元素。\n\n文件功能\n下文介绍如何在清单文件中反映某些最重要的应用特性。\n\n软件包名称和应用 ID\n清单文件的根元素需包含应用软件包名称（通常与项目目录结构，即 Java 命名空间相匹配）的属性。\n\n例如，以下代码段显示包含软件包名称 \"com.example.myapp\" 的 <manifest> 根元素：\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.myapp\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" >\n    ...\n</manifest>\n在将应用构建为最终的应用软件包 (APK) 时，Android 构建工具会使用 package 属性完成两件事情：\n\n它会将此名称用作应用所生成 R.java 类（用于访问应用资源）的命名空间。\n示例：在上方的清单中，您可以在 com.example.myapp.R 处创建 R 类。\n\n它会使用此名称解析清单文件中声明的任何相关类名称。\n示例：在上方的清单中，系统会将声明为 <activity android:name=\".MainActivity\"> 的 Activity 解析为 com.example.myapp.MainActivity。\n\n因此，清单 package 属性中的名称应始终与项目中保存 Activity 和其他应用代码的基础软件包的名称相匹配。 当然，您可以在项目中加入其他子软件包，但此类文件必须使用 package 属性的命名空间导入 R.java 类。\n\n但请注意，APK 编译完成后，package 属性还可表示应用的通用唯一应用 ID。 当构建工具根据 package 名称执行上述任务后，它们会将 package 值替换为项目 build.gradle 文件（用于 Android Studio 项目）中赋予 applicationId 属性的值。 package 属性的这一最终值必须是通用唯一值，因为这是能确保在系统和 Google Play 中识别应用的唯一方式。\n\n清单中的 package 名称与 build.gradle 文件中 applicationId 的区别可能会令人感到有点困惑。 但若您保持二者一致，便无需担心任何问题。\n\n不过，如果您决定让代码的命名空间（以及清单中的 package 名称）有别于构建文件的 applicationId，请务必完全理解设置应用 ID的影响。 本页面将说明如何不依赖构建文件的 applicationId，安全调整清单的 package 名称，以及如何更改不同构建配置的应用 ID。\n\n应用组件\n对于在应用中创建的每个应用组件，您必须在清单文件中声明相应的 XML 元素：\n\n<activity> 用于 Activity 的每个子类。\n<service> 用于 Service 的每个子类。\n<receiver> 用于 BroadcastReceiver 的每个子类。\n<provider> 用于 ContentProvider 的每个子类。\n如果您创建此类组件的任何子类，但未在清单文件中对其进行声明，则系统便无法启动该子类。\n\n必须使用 name 属性指定子类的名称，且其必须使用完整的软件包名称。 例如，可对 Activity 子类进行如下声明：\n\n<manifest ... >\n    <application ... >\n        <activity android:name=\"com.example.myapp.MainActivity\" ... >\n        </activity>\n    </application>\n</manifest>\n不过，如果 name 值的第一个字符是句点，则应用的软件包名称（来自 <manifest> 元素的 package 属性）将作为此名称的前缀。 例如，以下 Activity 名称将解析为 `\"com.example.myapp.MainActivity\"`：\n\n<manifest package=\"com.example.myapp\" ... >\n    <application ... >\n        <activity android:name=\".MainActivity\" ... >\n            ...\n        </activity>\n    </application>\n</manifest>\n如果您拥有位于子软件包中（如在 com.example.myapp.purchases 中）的应用组件，则 name 值必须添加缺失的子软件包名称（如 \".purchases.PayActivity\"）或使用完全限定的软件包名称。\n\nIntent 过滤器\n应用的 Activity、服务和广播接收器均由 Intent 激活。 Intent 是由 Intent 对象定义的消息，用于描述要执行的操作，其中包括要执行操作的数据、应执行操作的组件类别以及其他相关说明。\n\n当应用向系统发布 Intent 后，系统会根据每个应用清单文件中的 Intent 过滤器来查找可处理此 Intent 的应用组件。 系统会启动匹配组件的实例，并向该组件传递 Intent 对象。 如果有多个应用可以处理此 Intent，则用户可选择使用哪个应用。\n\n应用组件可包含任意数量的 Intent 过滤器（通过 <intent-filter> 元素定义），每个过滤器描述该组件的不同功能。\n\n如需了解更多信息，请参阅 Intent 和 Intent 过滤器文档。\n\n图标和标签\n许多清单元素拥有 icon 和 label 属性，二者分别用于向对应应用组件的用户显示小图标和文本标签。\n\n任何情况下，在父元素中设置的图标和标签都会成为所有子元素的默认 icon 和 label 值。 例如，在 <application> 元素中设置的图标和标签即为每个应用组件（如所有 Activity）的默认图标和标签。\n\n只要以实现 Intent 的选项形式呈现组件，系统便会向用户显示在该组件的 <intent-filter> 中设置的图标和标签。 默认情况下，此图标继承自为父组件（<activity> 或 <application> 元素）声明的任何图标，但如果 Intent 过滤器提供唯一操作，且您希望该操作在选择器对话框中有更好的指示，则您可能需更改此图标。 如需了解更多信息，请参阅允许其他应用启动您的 Activity。\n\n权限\n如要访问敏感用户数据（如联系人和短信）或某些系统功能（如相机和互联网访问），则 Android 应用必须请求相关权限。 每个权限均由唯一标签标识。 例如，如果应用需要发送短信，则必须在清单中添加以下代码行：\n\n<manifest ... >\n    <uses-permission android:name=\"android.permission.SEND_SMS\"/>\n    ...\n</manifest>\n从 Android 6.0（API 级别 23）开始，用户可以在运行时同意或拒绝某些应用权限。 但是，无论您的应用支持哪个 Android 版本，您都必须使用清单中的 <uses-permission> 元素声明所有权限请求。 授予应用权限后，该应用便能使用受保护的功能。 否则，该应用在尝试访问这些功能时会失败。\n\n应用也可使用权限保护自己的组件。 它可以使用 Android 定义的任何权限（如 android.Manifest.permission 中所列），或在其他应用中声明的权限。 应用也可定义自己的权限。 应用可通过 <permission> 元素来声明新权限。\n\n如需了解更多信息，请参阅权限概览。\n\n设备兼容性\n清单文件也可用于声明应用所需的硬件或软件功能类型，以及应用兼容的设备类型。 Google Play 商店不允许在未提供应用所需功能或系统版本的设备上安装应用。\n\n某些清单标签可定义与应用兼容的设备。 以下是一些最常见的此类标签。\n\n<uses-feature>\n<uses-feature> 元素允许您声明应用所需的硬件和软件功能。 例如，如果您的应用无法在缺少罗盘传感器的设备上实现基础功能，则您可使用以下清单标记将罗盘传感器声明为必需功能：\n\n<manifest ... >\n    <uses-feature android:name=\"android.hardware.sensor.compass\"\n                  android:required=\"true\" />\n    ...\n</manifest>\n注意： 如果您想在 Chromebook 上使用自己的应用，则应考虑一些重要的硬件和软件功能限制。 如需了解更多信息，请参阅 Chromebook 的应用清单兼容性。\n\n<uses-sdk>\n每个后续平台版本往往都会新增先前版本未提供的 API。 如要指明与应用兼容的最低版本，您的清单必须包含 <uses-sdk> 标签及其 minSdkVersion 属性。\n\n但请注意，<uses-sdk> 元素中的这些属性会被 build.gradle 文件中的相应属性覆盖。 因此，如果您使用的是 Android Studio，则必须在此处指定 minSdkVersion 和 targetSdkVersion 值：\n\nandroid {\n  defaultConfig {\n    applicationId 'com.example.myapp'// Defines the minimum API level required to run the app.\n    minSdkVersion 15// Specifies the API level used to test the app.\n    targetSdkVersion 28...\n  }\n}\n如需了解关于 build.gradle 文件的更多信息，请阅读如何配置您的构建。\n\n如要详细了解如何声明应用对不同设备的支持，请参阅设备兼容性概览。\n\n文件约定\n此部分描述普遍适用于清单文件中所有元素和属性的约定和规则。\n\n元素\n只有 <manifest> 和 <application> 元素是必需的， 二者必须且只能出现一次。 大多数其他元素可以不出现或多次出现。 但是，必须提供某些元素才能使清单文件发挥作用。\n必须通过属性（而非以元素内的字符数据形式）设置所有值。\n\n同一级别的元素通常不分先后顺序。 例如，<activity>、<provider> 和<service> 元素可按任何顺序放置。 这条规则有两个主要的例外情况：\n\n<activity-alias> 元素必须跟在别名所指的 <activity> 之后。\n<application> 元素必须是 <manifest> 元素内的最后一个元素。\n属性\n严格来说，所有属性都是可选的。 但是，必须指定某些属性才可让元素实现其目的。 对于真正可选的属性，参考文档会指定默认值。\n除了根 <manifest> 元素的某些属性外，所有属性名称均以 android: 前缀开头。 例如，android:alwaysRetainTaskState。 由于该前缀是通用的，因此在按名称引用属性时，参考文档通常会将其忽略。\n\n多个值\n如果可以指定多个值，则几乎总是在重复元素，而非列出单个元素内的多个值。 例如，Intent 过滤器可以列出多个操作：\n<intent-filter ... >\n    <action android:name=\"android.intent.action.EDIT\" />\n    <action android:name=\"android.intent.action.INSERT\" />\n    <action android:name=\"android.intent.action.DELETE\" />\n    ...\n</intent-filter>\n资源值\n某些属性的值可以显示给用户，例如，Activity 的标题或应用图标。 这些属性的值可能因用户的语言或其他设备配置而异（例如根据设备的像素密度提供不同的图标大小），因此您应根据资源或主题设置值，而非将其硬编码到清单文件中。 随后，您可根据为不同设备配置提供的备用资源更改实际值。\n资源将通过以下格式表示为值：\n\n\"@[package:]type/name\"\n\n如果资源由您的应用提供，则您可以忽略软件包名称（其亦适用于资源由库依赖项提供的情况，因为 库资源会合并到您的资源中）。 当您想要使用 Android 框架中的资源时，唯一的其他有效包名称是 android。\n\ntype 是资源类型（例如 string 或 drawable），name 是标识特定资源的名称。 下面是示例：\n\n<activity android:icon=\"@drawable/smallPic\" ... >\n有关如何在项目中添加资源的更多信息，请阅读提供资源。\n\n如要应用主题中定义的值，第一个字符必须是 ?，而非 @：\n\n\"?[package:]type/name\"\n\n字符串值\n如果属性值为字符串，则您必须使用双反斜杠 (\\\\) 来转义字符，例如：使用 \\\\n 表示换行符或使用 \\\\uxxxx 表示 Unicode 字符。\n清单元素参考\n下表提供 AndroidManifest.xml 文件中所有有效元素的参考文档链接。\n\n清单文件示例\n以下 XML 文件为 AndroidManifest.xml 的一个简单示例，该示例为应用声明两个 Activity。\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\"\n    package=\"com.example.myapp\"><!-- Beware that these values are overridden by the build.gradle file -->\n    <uses-sdk android:minSdkVersion=\"15\" android:targetSdkVersion=\"26\" /><application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:label=\"@string/app_name\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\"><!-- This name is resolved to com.example.myapp.MainActivity\n             based upon the package attribute -->\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity><activity\n            android:name=\".DisplayMessageActivity\"\n            android:parentActivityName=\".MainActivity\" />\n    </application>\n</manifest>\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242645987},"updatedAt":{"$$date":1597243135044},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WWTpDkQ70Hapt4Vd"}
{"name":"py-list","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\nPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。\n\n比如，列出班里所有同学的名字，就可以用一个list表示：\n\n>>> classmates = ['Michael', 'Bob', 'Tracy']\n>>> classmates\n['Michael', 'Bob', 'Tracy']\n变量classmates就是一个list。用len()函数可以获得list元素的个数：\n\n>>> len(classmates)\n3\n用索引来访问list中每一个位置的元素，记得索引是从0开始的：\n\n>>> classmates[0]\n'Michael'\n>>> classmates[1]\n'Bob'\n>>> classmates[2]\n'Tracy'\n>>> classmates[3]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。\n\n如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：\n\n>>> classmates[-1]\n'Tracy'\n以此类推，可以获取倒数第2个、倒数第3个：\n\n>>> classmates[-2]\n'Bob'\n>>> classmates[-3]\n'Michael'\n>>> classmates[-4]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n当然，倒数第4个就越界了。\n\nlist是一个可变的有序表，所以，可以往list中追加元素到末尾：\n\n>>> classmates.append('Adam')\n>>> classmates\n['Michael', 'Bob', 'Tracy', 'Adam']\n也可以把元素插入到指定的位置，比如索引号为1的位置：\n\n>>> classmates.insert(1, 'Jack')\n>>> classmates\n['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']\n要删除list末尾的元素，用pop()方法：\n\n>>> classmates.pop()\n'Adam'\n>>> classmates\n['Michael', 'Jack', 'Bob', 'Tracy']\n要删除指定位置的元素，用pop(i)方法，其中i是索引位置：\n\n>>> classmates.pop(1)\n'Jack'\n>>> classmates\n['Michael', 'Bob', 'Tracy']\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：\n\n>>> classmates[1] = 'Sarah'\n>>> classmates\n['Michael', 'Sarah', 'Tracy']\nlist里面的元素的数据类型也可以不同，比如：\n\n>>> L = ['Apple', 123, True]\nlist元素也可以是另一个list，比如：\n\n>>> s = ['python', 'java', ['asp', 'php'], 'scheme']\n>>> len(s)\n4\n要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：\n\n>>> p = ['asp', 'php']\n>>> s = ['python', 'java', p, 'scheme']\n要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。\n\n如果一个list中一个元素也没有，就是一个空的list，它的长度为0：\n\n>>> L = []\n>>> len(L)\n0"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973934421},"updatedAt":{"$$date":1594974810062},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"WcCHCkelakDVqByn"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973277479},"updatedAt":{"$$date":1594973277479},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"X0arW7y7ZqPYdX1Z"}
{"name":"andr-将 Kotlin 协程与架构组件一起使用","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/architecture/coroutines\n将 Kotlin 协程与架构组件一起使用  |  Android 开发者  |  Android Developers\n7-9 minutes\nKotlin 协程提供了一个可供您编写异步代码的 API。通过 Kotlin 协程，您可以定义 CoroutineScope，以帮助您管理何时应运行协程。每个异步操作都在特定范围内运行。\n\n架构组件针对应用中的逻辑范围以及与 LiveData 的互操作层为协程提供了一流的支持。 本主题介绍了如何有效地结合使用协程与架构组件。\n\n添加 KTX 依赖项\n本主题中介绍的内置协程范围包含在每个相应架构组件的 KTX 扩展程序中。请务必在使用这些范围时添加相应的依赖项。\n\n对于 ViewModelScope，请使用 androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0-beta01 或更高版本。\n对于 LifecycleScope，请使用 androidx.lifecycle:lifecycle-runtime-ktx:2.2.0-alpha01 或更高版本。\n对于 liveData，请使用 androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha01 或更高版本。\n生命周期感知型协程范围\n架构组件定义了以下内置范围供您在应用中使用。\n\nViewModelScope\n为应用中的每个 ViewModel 定义了 ViewModelScope。如果 ViewModel 已清除，则在此范围内启动的协程都会自动取消。如果您具有仅在 ViewModel 处于活动状态时才需要完成的工作，此时协程非常有用。例如，如果要为布局计算某些数据，则应将工作范围限定至 ViewModel，以便在 ViewModel 清除后，系统会自动取消工作以避免消耗资源。\n\n您可以通过 ViewModel 的 viewModelScope 属性访问 ViewModel 的 CoroutineScope，如以下示例所示：\n\nclass MyViewModel: ViewModel() {\n        init {\n            viewModelScope.launch {\n                // Coroutine that will be canceled when the ViewModel is cleared.\n            }\n        }\n    }\n    \nLifecycleScope\n为每个 Lifecycle 对象定义了 LifecycleScope。在此范围内启动的协程会在 Lifecycle 被销毁时取消。您可以通过 lifecycle.coroutineScope 或 lifecycleOwner.lifecycleScope 属性访问 Lifecycle 的 CoroutineScope。\n\n以下示例演示了如何使用 lifecycleOwner.lifecycleScope 异步创建预计算文本：\n\nclass MyFragment: Fragment() {\n        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            viewLifecycleOwner.lifecycleScope.launch {\n                val params = TextViewCompat.getTextMetricsParams(textView)\n                val precomputedText = withContext(Dispatchers.Default) {\n                    PrecomputedTextCompat.create(longTextContent, params)\n                }\n                TextViewCompat.setPrecomputedText(textView, precomputedText)\n            }\n        }\n    }\n    \n暂停生命周期感知型协程\n即使 CoroutineScope 提供了适当的方法来自动取消长时间运行的操作，在某些情况下，您可能需要暂停执行代码块（除非 Lifecycle 处于特定状态）。例如，要运行 FragmentTransaction，您必须等到 Lifecycle 至少为 STARTED。对于这些情况，Lifecycle 提供了其他方法：lifecycle.whenCreated、lifecycle.whenStarted 和 lifecycle.whenResumed。如果 Lifecycle 未至少处于所需的最低状态，则会暂停在这些块内运行的任何协程。\n\n以下示例包含仅当关联的 Lifecycle 至少处于 STARTED 状态时才会运行的代码块：\n\nclass MyFragment: Fragment {\n        init { // Notice that we can safely launch in the constructor of the Fragment.\n            lifecycleScope.launch {\n                whenStarted {\n                    // The block inside will run only when Lifecycle is at least STARTED.\n                    // It will start executing when fragment is started and\n                    // can call other suspend methods.\n                    loadingView.visibility = View.VISIBLE\n                    val canAccess = withContext(Dispatchers.IO) {\n                        checkUserAccess()\n                    }// When checkUserAccess returns, the next line is automatically\n                    // suspended if the Lifecycle is not *at least* STARTED.\n                    // We could safely run fragment transactions because we know the\n                    // code won't run unless the lifecycle is at least STARTED.\n                    loadingView.visibility = View.GONE\n                    if (canAccess == false) {\n                        findNavController().popBackStack()\n                    } else {\n                        showContent()\n                    }\n                }// This line runs only after the whenStarted block above has completed.}\n        }\n    }\n    \n如果在协程处于活动状态时通过某种 when 方法销毁了 Lifecycle，协程会自动取消。在以下示例中，一旦 Lifecycle 状态变为 DESTROYED，finally 块即会运行：\n\nclass MyFragment: Fragment {\n        init {\n            lifecycleScope.launchWhenStarted {\n                try {\n                    // Call some suspend functions.\n                } finally {\n                    // This line might execute after Lifecycle is DESTROYED.\n                    if (lifecycle.state >= STARTED) {\n                        // Here, since we've checked, it is safe to run any\n                        // Fragment transactions.\n                    }\n                }\n            }\n        }\n    }\n    \n将协程与 LiveData 一起使用\n使用 LiveData 时，您可能需要异步计算值。例如，您可能需要检索用户的偏好设置并将其传送给界面。在这些情况下，您可以使用 liveData 构建器函数调用 suspend 函数，并将结果作为 LiveData 对象传送。\n\n在以下示例中，loadUser() 是在其他位置声明的暂停函数。使用 liveData 构建器函数异步调用 loadUser()，然后使用 emit() 发出结果：\n\nval user: LiveData<User> = liveData {\n        val data = database.loadUser() // loadUser is a suspend function.\n        emit(data)\n    }\n    \nliveData 构建块用作协程和 LiveData 之间的结构化并发基元。当 LiveData 变为活动状态时，代码块开始执行；当 LiveData 变为非活动状态时，代码块会在可配置的超时过后自动取消。如果代码块在完成前取消，则会在 LiveData 再次变为活动状态后重启；如果在上次运行中成功完成，则不会重启。请注意，代码块只有在自动取消的情况下才会重启。如果代码块由于任何其他原因（例如，抛出 CancelationException）而取消，则不会重启。\n\n您还可以从代码块中发出多个值。每次 emit() 调用都会暂停执行代码块，直到在主线程上设置 LiveData 值。\n\nval user: LiveData<Result> = liveData {\n        emit(Result.loading())\n        try {\n            emit(Result.success(fetchUser()))\n        } catch(ioException: Exception) {\n            emit(Result.error(ioException))\n        }\n    }\n    \n您也可以将 liveData 与 Transformations 结合使用，如以下示例所示：\n\nclass MyViewModel: ViewModel() {\n        private val userId: LiveData<String> = MutableLiveData()\n        val user = userId.switchMap { id ->\n            liveData(context = viewModelScope.coroutineContext + Dispatchers.IO) {\n                emit(database.loadUserById(id))\n            }\n        }\n    }\n    \n您可以从 LiveData 中发出多个值，方法是在每次想要发出新值时调用 emitSource() 函数。请注意，每次调用 emit() 或 emitSource() 都会移除之前添加的来源。\n\nclass UserDao: Dao {\n        @Query(\"SELECT * FROM User WHERE id = :id\")\n        fun getUser(id: String): LiveData<User>\n    }class MyRepository {\n        fun getUser(id: String) = liveData<User> {\n            val disposable = emitSource(\n                userDao.getUser(id).map {\n                    Result.loading(it)\n                }\n            )\n            try {\n                val user = webservice.fetchUser(id)\n                // Stop the previous emission to avoid dispatching the updated user\n                // as `loading`.\n                disposable.dispose()\n                // Update the database.\n                userDao.insert(user)\n                // Re-establish the emission with success type.\n                emitSource(\n                    userDao.getUser(id).map {\n                        Result.success(it)\n                    }\n                )\n            } catch(exception: IOException) {\n                // Any call to `emit` disposes the previous one automatically so we don't\n                // need to dispose it here as we didn't get an updated value.\n                emitSource(\n                    userDao.getUser(id).map {\n                        Result.error(exception, it)\n                    }\n                )\n            }\n        }\n    }\n    \n如需更多与协程相关的信息，请参阅以下链接：\n\n利用 Kotlin 协程提升应用性能\n协程概览\n在 CoroutineWorker 中进行线程处理\n其他资源\n要详细了解如何将协程与架构组件一起使用，请参阅下面列出的其他资源。\n\n示例\nKotlin 协程与架构组件\n博客\nAndroid 上的协程：应用模式\nAndroid 中的简易协程：viewModelScope\n在协程中测试两个连续的 LiveData 发出对象"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243908881},"updatedAt":{"$$date":1597244731299},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"XRiR47ijoALhZc5W"}
{"name":"ad-资源类型概览","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"developer.android.google.cn /guide/topics/resources/available-resources\n资源类型概览  |  Android 开发者  |  Android Developers\n2-2 minutes\n本部分中的每个页面介绍了一种您可以在项目资源目录 (res/) 中提供的应用资源的用法、格式和语法。\n\n以下是对每个页面的简要说明：\n\n动画资源\n定义预先确定的动画。\n补间动画保存在 res/anim/ 中并通过 R.anim 类访问。\n帧动画保存在 res/drawable/ 中并通过 R.drawable 类访问。\n颜色状态列表资源\n定义根据 View 状态而变化的颜色资源。\n保存在 res/color/ 中并通过 R.color 类访问。\n可绘制资源\n使用位图或 XML 定义各种图形。\n保存在 res/drawable/ 中并通过 R.drawable 类访问。\n布局资源\n定义应用界面的布局。\n保存在 res/layout/ 中并通过 R.layout 类访问。\n菜单资源\n定义应用菜单的内容。\n保存在 res/menu/ 中并通过 R.menu 类访问。\n字符串资源\n定义字符串、字符串数组和复数形式（并包括字符串格式和样式）。\n保存在 res/values/ 中，并通过 R.string、R.array 和 R.plurals 类访问。\n样式资源\n定义界面元素的外观和格式。\n保存在 res/values/ 中并通过 R.style 类访问。\n字体资源\n在 XML 中定义字体系列并包含自定义字体。\n保存在 res/font/ 中并通过 R.font 类访问。\n更多资源类型\n将其他原始值定义为静态资源，具体包括：\nBool\n包含布尔值的 XML 资源。\n颜色\n包含颜色值（十六进制颜色）的 XML 资源。\n维度\n包含维度值（及度量单位）的 XML 资源。\nID\n为应用资源和组件提供唯一标识符的 XML 资源。\n整数\n包含整数值的 XML 资源。\n整数数组\n提供整数数组的 XML 资源。\n类型化数组\n提供 TypedArray（可用于可绘制对象数组）的 XML 资源。\nContent and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2020-01-07 UTC."}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594980152912},"updatedAt":{"$$date":1597242242941},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"XpGStpIuXdRdEBzE"}
{"name":"Untitled snippet","folderId":null,"content":[{"label":"Fragment 1","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594709019986},"updatedAt":{"$$date":1594709019986},"_id":"XwNmnCdkgGDihMy9"}
{"name":"kotlin-Kotlin 类和对象 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-class-object.html\nKotlin 类和对象 | 菜鸟教程\n7-8 minutes\n类定义\nKotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。\n\nKotlin 中使用关键字 class 声明类，后面紧跟类名：\n\nclass Runoob {  // 类名为 Runoob\n    // 大括号内是类体构成\n}\n我们也可以定义一个空类：\n\nclass Empty\n可以在类中定义成员函数：\n\nclass Runoob() {\n    fun foo() { print(\"Foo\") } // 成员函数\n}\n类的属性\n属性定义\n类的属性可以用关键字 var 声明为可变的，否则使用只读关键字 val 声明为不可变。\n\nclass Runoob {\n    var name: String = ……\n    var url: String = ……\n    var city: String = ……\n}\n我们可以像使用普通函数那样使用构造函数创建类实例：\n\nval site = Runoob() // Kotlin 中没有 new 关键字\n要使用一个属性，只要用名称引用它即可\n\nsite.name           // 使用 . 号来引用\nsite.url\nKoltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后:\n\nclass Person constructor(firstName: String) {}\n如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。\n\nclass Person(firstName: String) {\n}\ngetter 和 setter\n属性声明的完整语法：\n\nvar <propertyName>[: <PropertyType>] [= <property_initializer>]\n    [<getter>]\n    [<setter>]\n \ngetter 和 setter 都是可选\n\n如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。\n\nvar allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法\nvar initialized = 1    // 类型为 Int, 默认实现了 getter 和 setter\nval simple: Int?       // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化\nval inferredType = 1   // 类型为 Int 类型,默认实现 getter\n实例\n以下实例定义了一个 Person 类，包含两个可变变量 lastName 和 no，lastName 修改了 getter 方法，no 修改了 setter 方法。\n\nclass Person {\n\n    var lastName: String = \"zhang\"\n        get() = field.toUpperCase()   // 将变量赋值后转换为大写\n        set\n\n    var no: Int = 100\n        get() = field                // 后端变量\n        set(value) {\n            if (value < 10) {       // 如果传入的值小于 10 返回该值\n                field = value\n            } else {\n                field = -1         // 如果传入的值大于等于 10 返回 -1\n            }\n        }\n\n    var heiht: Float = 145.4f\n        private set\n}\n\n// 测试\nfun main(args: Array<String>) {\n    var person: Person = Person()\n\n    person.lastName = \"wang\"\n\n    println(\"lastName:${person.lastName}\")\n\n    person.no = 9\n    println(\"no:${person.no}\")\n\n    person.no = 20\n    println(\"no:${person.no}\")\n\n}\n输出结果为：\n\nlastName:WANG\nno:9\nno:-1\nKotlin 中类不能有字段。提供了 Backing Fields(后端变量) 机制,备用字段使用field关键字声明,field 关键词只能用于属性的访问器，如以上实例：\n\nvar no: Int = 100\n        get() = field                // 后端变量\n        set(value) {\n            if (value < 10) {       // 如果传入的值小于 10 返回该值\n                field = value\n            } else {\n                field = -1         // 如果传入的值大于等于 10 返回 -1\n            }\n        }\n非空属性必须在定义的时候初始化,kotlin提供了一种可以延迟初始化的方案,使用 lateinit 关键字描述属性：\n\npublic class MyTest {\n    lateinit var subject: TestSubject\n\n    @SetUp fun setup() {\n        subject = TestSubject()\n    }\n\n    @Test fun test() {\n        subject.method()  // dereference directly\n    }\n}\n主构造器\n主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。\n\nclass Person constructor(firstName: String) {\n    init {\n        println(\"FirstName is $firstName\")\n    }\n}\n注意：主构造器的参数可以在初始化代码段中使用，也可以在类主体n定义的属性初始化代码中使用。 一种简洁语法，可以通过主构造器来定义属性并初始化属性值（可以是var或val）：\n\nclass People(val firstName: String, val lastName: String) {\n    //...\n}\n如果构造器有注解，或者有可见度修饰符，这时constructor关键字是必须的，注解和修饰符要放在它之前。\n\n实例\n创建一个 Runoob类，并通过构造函数传入网站名：\n\nclass Runoob  constructor(name: String) {  // 类名为 Runoob\n    // 大括号内是类体构成\n    var url: String = \"http://www.runoob.com\"\n    var country: String = \"CN\"\n    var siteName = name\n\n    init {\n        println(\"初始化网站名: ${name}\")\n    }\n\n    fun printTest() {\n        println(\"我是类的函数\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val runoob =  Runoob(\"菜鸟教程\")\n    println(runoob.siteName)\n    println(runoob.url)\n    println(runoob.country)\n    runoob.printTest()\n}\n输出结果为：\n\n初始化网站名: 菜鸟教程\n菜鸟教程\nhttp://www.runoob.com\nCN\n我是类的函数\n次构造函数\n类也可以有二级构造函数，需要加前缀 constructor:\n\nclass Person { \n    constructor(parent: Person) {\n        parent.children.add(this) \n    }\n}\n如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：\n\nclass Person(val name: String) {\n    constructor (name: String, age:Int) : this(name) {\n        // 初始化...\n    }\n}\n如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数：\n\nclass DontCreateMe private constructor () {\n}\n注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得 Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。\n\nclass Customer(val customerName: String = \"\")\n实例\nclass Runoob  constructor(name: String) {  // 类名为 Runoob\n    // 大括号内是类体构成\n    var url: String = \"http://www.runoob.com\"\n    var country: String = \"CN\"\n    var siteName = name\n\n    init {\n        println(\"初始化网站名: ${name}\")\n    }\n    // 次构造函数\n    constructor (name: String, alexa: Int) : this(name) {\n        println(\"Alexa 排名 $alexa\")\n    }\n\n    fun printTest() {\n        println(\"我是类的函数\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val runoob =  Runoob(\"菜鸟教程\", 10000)\n    println(runoob.siteName)\n    println(runoob.url)\n    println(runoob.country)\n    runoob.printTest()\n}\n输出结果为：\n\n初始化网站名: 菜鸟教程\nAlexa 排名 10000\n菜鸟教程\nhttp://www.runoob.com\nCN\n我是类的函数\n抽象类\n抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。\n\n注意：无需对抽象类或抽象成员标注open注解。\n\nopen class Base {\n    open fun f() {}\n}\n\nabstract class Derived : Base() {\n    override abstract fun f()\n}\n嵌套类\n我们可以把类嵌套在其他类中，看以下实例：\n\nclass Outer {                  // 外部类\n    private val bar: Int = 1\n    class Nested {             // 嵌套类\n        fun foo() = 2\n    }\n}\n\nfun main(args: Array<String>) {\n    val demo = Outer.Nested().foo() // 调用格式：外部类.嵌套类.嵌套类方法/属性\n    println(demo)    // == 2\n}\n内部类\n内部类使用 inner 关键字来表示。\n\n内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。\n\nclass Outer {\n    private val bar: Int = 1\n    var v = \"成员属性\"\n    /**嵌套内部类**/\n    inner class Inner {\n        fun foo() = bar  // 访问外部类成员\n        fun innerTest() {\n            var o = this@Outer //获取外部类的成员变量\n            println(\"内部类可以引用外部类的成员，例如：\" + o.v)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val demo = Outer().Inner().foo()\n    println(demo) //   1\n    val demo2 = Outer().Inner().innerTest()   \n    println(demo2)   // 内部类可以引用外部类的成员，例如：成员属性\n}\n为了消除歧义，要访问来自外部作用域的 this，我们使用this@label，其中 @label 是一个 代指 this 来源的标签。\n\n匿名内部类\n使用对象表达式来创建匿名内部类：\n\nclass Test {\n    var v = \"成员属性\"\n\n    fun setInterFace(test: TestInterFace) {\n        test.test()\n    }\n}\n\n/**\n * 定义接口\n */\ninterface TestInterFace {\n    fun test()\n}\n\nfun main(args: Array<String>) {\n    var test = Test()\n\n    /**\n     * 采用对象表达式来创建接口对象，即匿名内部类的实例。\n     */\n    test.setInterFace(object : TestInterFace {\n        override fun test() {\n            println(\"对象表达式创建匿名内部类的实例\")\n        }\n    })\n}\n类的修饰符\n类的修饰符包括 classModifier 和_accessModifier_:\n\nclassModifier: 类属性修饰符，标示类本身特性。\n\nabstract    // 抽象类  \nfinal       // 类不可继承，默认属性\nenum        // 枚举类\nopen        // 类可继承，类默认是final的\nannotation  // 注解类\naccessModifier: 访问权限修饰符\n\nprivate    // 仅在同一个文件中可见\nprotected  // 同一个文件中或子类可见\npublic     // 所有调用的地方都可见\ninternal   // 同一个模块中可见\n实例\n// 文件名：example.kt\npackage foo\n\nprivate fun foo() {} // 在 example.kt 内可见\n\npublic var bar: Int = 5 // 该属性随处可见\n\ninternal val baz = 6    // 相同模块内可见"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303692034},"updatedAt":{"$$date":1597303992327},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YCZ5QP7lSIY8z4Bp"}
{"name":"kotlin-Kotlin 基本数据类型 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-basic-types.html\nKotlin 基本数据类型 | 菜鸟教程\n4-5 minutes\nKotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。\n\n类型\t位宽度\nDouble\t64\nFloat\t32\nLong\t64\nInt\t32\nShort\t16\nByte\t8\n字面常量\n下面是所有类型的字面常量：\n\n十进制：123\n长整型以大写的 L 结尾：123L\n16 进制以 0x 开头：0x0F\n2 进制以 0b 开头：0b00001011\n注意：8进制不支持\nKotlin 同时也支持传统符号表示的浮点数值：\n\nDoubles 默认写法: 123.5, 123.5e10\nFloats 使用 f 或者 F 后缀：123.5f\n你可以使用下划线使数字常量更易读：\n\nval oneMillion = 1_000_000\nval creditCardNumber = 1234_5678_9012_3456L\nval socialSecurityNumber = 999_99_9999L\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n比较两个数字\nKotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所以在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。\n\n在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。\n\nfun main(args: Array<String>) {\n    val a: Int = 10000\n    println(a === a) // true，值相等，对象地址相等\n\n    //经过了装箱，创建了两个不同的对象\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n\n    //虽然经过了装箱，但是值是相等的，都是10000\n    println(boxedA === anotherBoxedA) //  false，值相等，对象地址不一样\n    println(boxedA == anotherBoxedA) // true，值相等\n}\n类型转换\n由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。\n\nval b: Byte = 1 // OK, 字面值是静态检测的\nval i: Int = b // 错误\n我们可以代用其toInt()方法。\n\nval b: Byte = 1 // OK, 字面值是静态检测的\nval i: Int = b.toInt() // OK\n每种数据类型都有下面的这些方法，可以转化为其它的类型：\n\ntoByte(): Byte\ntoShort(): Short\ntoInt(): Int\ntoLong(): Long\ntoFloat(): Float\ntoDouble(): Double\ntoChar(): Char\n有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的：\n\nval l = 1L + 3 // Long + Int => Long\n位操作符\n对于Int和Long类型，还有一系列的位操作符可以使用，分别是：\n\nshl(bits) – 左移位 (Java’s <<)\nshr(bits) – 右移位 (Java’s >>)\nushr(bits) – 无符号右移位 (Java’s >>>)\nand(bits) – 与\nor(bits) – 或\nxor(bits) – 异或\ninv() – 反向\n字符\n和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 ' 包含起来的。比如普通字符 '0'，'a'。\n\nfun check(c: Char) {\n    if (c == 1) { // 错误：类型不兼容\n        // ……\n    }\n}\n字符字面值用单引号括起来: '1'。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\\t、 \\b、\\n、\\r、\\'、\\\"、\\\\ 和 \\$。 编码其他字符要用 Unicode 转义序列语法：'\\uFF00'。\n\n我们可以显式把字符转换为 Int 数字：\n\nfun decimalDigitValue(c: Char): Int {\n    if (c !in '0'..'9')\n        throw IllegalArgumentException(\"Out of range\")\n    return c.toInt() - '0'.toInt() // 显式转换为数字\n}\n当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。\n\n布尔\n布尔用 Boolean 类型表示，它有两个值：true 和 false。\n\n若需要可空引用布尔会被装箱。\n\n内置的布尔运算有：\n\n|| – 短路逻辑或\n&& – 短路逻辑与\n! - 逻辑非\n数组\n数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。\n\n数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组：\n\nfun main(args: Array<String>) {\n    //[1,2,3]\n    val a = arrayOf(1, 2, 3)\n    //[0,2,4]\n    val b = Array(3, { i -> (i * 2) })\n\n    //读取数组内容\n    println(a[0])    // 输出结果：1\n    println(b[1])    // 输出结果：2\n}\n如上所述，[] 运算符代表调用成员函数 get() 和 set()。\n\n注意: 与 Java 不同的是，Kotlin 中数组是不协变的（invariant）。\n\n除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样：\n\nval x: IntArray = intArrayOf(1, 2, 3)\nx[0] = x[1] + x[2]\n字符串\n和 Java 一样，String 是不可变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历：\n\nfor (c in str) {\n    println(c)\n}\nKotlin 支持三个引号 \"\"\" 扩起来的字符串，支持多行字符串，比如：\n\nfun main(args: Array<String>) {\n    val text = \"\"\"\n    多行字符串\n    多行字符串\n    \"\"\"\n    println(text)   // 输出有一些前置空格\n}\nString 可以通过 trimMargin() 方法来删除多余的空白。\n\nfun main(args: Array<String>) {\n    val text = \"\"\"\n    |多行字符串\n    |菜鸟教程\n    |多行字符串\n    |Runoob\n    \"\"\".trimMargin()\n    println(text)    // 前置空格删除了\n}\n默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(\">\")。\n\n字符串模板\n字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:\n\nfun main(args: Array<String>) {\n    val i = 10\n    val s = \"i = $i\" // 求值结果为 \"i = 10\"\n    println(s)\n}\n或者用花括号扩起来的任意表达式:\n\nfun main(args: Array<String>) {\n    val s = \"runoob\"\n    val str = \"$s.length is ${s.length}\" // 求值结果为 \"runoob.length is 6\"\n    println(str)\n}\n原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：\n\nfun main(args: Array<String>) {\n    val price = \"\"\"\n    ${'\n   \n  \n  \n  \n\n\n}9.99\n    \"\"\"\n    println(price)  // 求值结果为 $9.99\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303688467},"updatedAt":{"$$date":1597303842660},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YMuUumshn6YUgFzT"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241214846},"updatedAt":{"$$date":1597241214846},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YPVEnYDWzZ3y5Ral"}
{"name":"andr-Parcelable 和 Bundle","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/components/activities/parcelables-and-bundles\nParcelable 和 Bundle  |  Android 开发者  |  Android Developers\n2-3 minutes\nParcelable 和 Bundle 对象可跨进程边界使用，例如与 IPC/Binder 事务之间，带有 intent 的 Activity 之间等，还可以用来存储跨配置更改的瞬时状态。本页介绍了使用 Parcelable 和 Bundle 对象的建议和最佳做法。\n\n注意：Parcel 不是通用序列化机制，您绝不能将任何 Parcel 数据存储在磁盘上或通过网络发送。\n\n在 Activity 之间发送数据\n当应用创建 Intent 对象以在 startActivity(android.content.Intent) 中用于启动新的 Activity 时，应用可使用 putExtra(java.lang.String, java.lang.String) 方法传入参数。\n\n以下示例代码段演示了如何执行此操作。\n\n    val intent = Intent(this, MyActivity::class.java).apply {\n        putExtra(\"media_id\", \"a1b2c3\")\n        // ...\n    }\n    startActivity(intent)\n    \n    Intent intent = new Intent(this, MyActivity.class);\n    intent.putExtra(\"media_id\", \"a1b2c3\");\n    // ...\n    startActivity(intent);\n    \n操作系统会将 intent 的基础 Bundle 打包。然后，操作系统会创建新的 Activity，将数据拆包，并将 intent 传递给新的 Activity。\n\n我们建议您使用 Bundle 类为 Intent 对象设置操作系统已知的基元。Bundle 类针对使用 parcel 进行编组和解组进行了高度优化。\n\n在某些情况下，您可能需要一种机制来跨 Activity 发送复合对象或复杂对象。在这种情况下，自定义类应实现 Parcelable，并提供相应的 writeToParcel(android.os.Parcel, int) 方法。它还必须提供实现 Parcelable.Creator 接口的非空字段 CREATOR，该接口的 createFromParcel() 方法用于将 Parcel 转回为当前对象。如需了解详情，请参阅 Parcelable 对象的参考文档。\n\n通过 intent 发送数据时，应小心地将数据大小限制为几 KB。发送过多数据会导致系统抛出 TransactionTooLargeException 异常。\n\n在进程之间发送数据\n在进程之间发送数据与在 Activity 之间发送数据类似。不过，在进程之间发送时，我们建议您不要使用自定义 Parcelable。如果您将一个自定义 Parcelable 对象从一个应用发送到另一个应用，则需要确保发送和接收的应用上都存在版本完全相同的自定义类。通常情况下，这可能是在两个应用中都会使用的通用库。如果您的应用尝试向系统发送自定义 Parblelable，则可能会发生错误，因为系统无法对其不了解的类进行解组。\n\n例如，某个应用可能会使用 AlarmManager 类设置闹钟，并对闹钟 intent 使用自定义Parcelable。当闹钟响铃时，系统会修改 intent 的 extra Bundle 以添加重复计数。此修改可导致系统从 extra 中剥离自定义 Parcelable。这种剥离进而会导致应用在收到修改后的警报 intent 时崩溃，因为应用预计会收到 extra 数据，而它已不存在。\n\nBinder 事务缓冲区的大小固定有限，目前为 1MB，由进程中正在处理的所有事务共享。由于此限制是进程级别而不是 Activity 级别的限制，因此这些事务包括应用中的所有 binder 事务，例如 onSaveInstanceState，startActivity 以及与系统的任何互动。超过大小限制时，将引发 TransactionTooLargeException。\n\n对于 savedInstanceState 的具体情况，应将数据量保持在较小的规模，因为只要用户可以返回到该 Activity，系统进程就需要保留所提供的数据（即使 Activity 的进程已终止）。我们建议您将保存的状态保持在 50k 数据以下。\n\n注意：在 Android 7.0（API 级别 24）或更高版本中，系统会在运行时抛出 TransactionTooLargeException 异常。在较低版本的 Android 中，系统仅在 logcat 中显示警告。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243441107},"updatedAt":{"$$date":1597243712940},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YatiXPyAeOHq3Ll8"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382139474},"updatedAt":{"$$date":1597382139474},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Yjach19u2aDqDEVt"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973279148},"updatedAt":{"$$date":1594973279148},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YlC1ukwYNcBH8L9x"}
{"name":"kotlin-编码规范 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"www.kotlincn.net /docs/reference/coding-conventions.html\n编码规范 - Kotlin 语言中文站\n43-53 minutes\n改进翻译\n本页包含当前 Kotlin 语言的编码风格。\n\n源代码组织\n命名规则\n格式化\n文档注释\n避免重复结构\n语言特性的惯用法\n库的编码规范\n如需根据本风格指南配置 IntelliJ 格式化程序，请安装 Kotlin 插件 1.2.20 或更高版本，转到 Settings | Editor | Code Style | Kotlin，点击右上角的 Set from… 链接，并从菜单中选择 Predefined style | Kotlin style guide。\n\n如需验证代码已按风格指南格式化，请转到探查设置（Inspections）并启用 Kotlin | Style issues | File is not formatted according to project settings 探查项。 验证风格指南中描述的其他问题（如命名约定）的附加探查项默认已启用。\n\n在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构。例如，如果项目中的所有代码都位于 org.example.kotlin 包及其子包中，那么 org.example.kotlin 包的文件应该直接放在源代码根目录下，而 org.example.kotlin.network.socket 中的文件应该放在源代码根目录下的 network/socket 子目录中。\n\n对于 JVM 平台：Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中。\n\n如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。 使用首字母大写的驼峰风格（例如 ProcessDeclarations.kt）。\n\n文件的名称应该描述文件中代码的作用。因此，应避免在文件名中使用诸如“Util”之类的无意义词语。\n\n鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。\n\n特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。不要只是为了保存 “Foo 的所有扩展函数”而创建文件。\n\n通常，一个类的内容按以下顺序排列：\n\n属性声明与初始化块\n次构造函数\n方法声明\n伴生对象\n不要按字母顺序或者可见性对方法声明排序，也不要将常规方法与扩展方法分开。而是要把相关的东西放在一起，这样从上到下阅读类的人就能够跟进所发生事情的逻辑。选择一个顺序（高级别优先，或者相反）并坚持下去。\n\n将嵌套类放在紧挨使用这些类的代码之后。如果打算在外部使用嵌套类，而且类中并没有引用这些类，那么把它们放到末尾，在伴生对象之后。\n\n在实现一个接口时，实现成员的顺序应该与该接口的成员顺序相同（如果需要， 还要插入用于实现的额外的私有方法）\n\n在类中总是将重载放在一起。\n\n在 Kotlin 中，包名与类名的命名规则非常简单：\n\n包的名称总是小写且不使用下划线（org.example.project）。 通常不鼓励使用多个词的名称，但是如果确实需要使用多个词，可以将它们连接在一起或使用驼峰风格（org.example.myProject）。\n\n类与对象的名称以大写字母开头并使用驼峰风格：\n\nopen class DeclarationProcessor { /*……*/ }\n\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*……*/ }\n函数、属性与局部变量的名称以小写字母开头、使用驼峰风格而不使用下划线：\n\nfun processDeclarations() { /*……*/ }\nvar declarationCount = 1\n例外：用于创建类实例的工厂函数可以与抽象返回类型具有相同的名称：\n\ninterface Foo { /*……*/ }\n\nclass FooImpl : Foo { /*……*/ }\n\nfun Foo(): Foo { return FooImpl() }\n当且仅当在测试中，可以使用反引号括起来的带空格的方法名。 （请注意，Android 运行时目前不支持这样的方法名。）测试代码中也允许方法名使用下划线。\n\nclass MyTestCase {\n     @Test fun `ensure everything works`() { /*...*/ }\n     \n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}\n常量名称（标有 const 的属性，或者保存不可变数据的没有自定义 get 函数的顶层/对象 val 属性）应该使用大写、下划线分隔的名称：\n\nconst val MAX_COUNT = 8\nval USER_NAME_FIELD = \"UserName\"\n保存带有行为的对象或者可变数据的顶层/对象属性的名称应该使用驼峰风格名称：\n\nval mutableCollection: MutableSet<String> = HashSet()\n保存单例对象引用的属性的名称可以使用与 object 声明相同的命名风格：\n\nval PersonComparator: Comparator<Person> = /*...*/\n对于枚举常量，可以使用大写、下划线分隔的名称 （enum class Color { RED, GREEN }）也可使用首字母大写的常规驼峰名称，具体取决于用途。\n\n如果一个类有两个概念上相同的属性，一个是公共 API 的一部分，另一个是实现细节，那么使用下划线作为私有属性名称的前缀：\n\nclass C {\n    private val _elementList = mutableListOf<Element>()\n\n    val elementList: List<Element>\n         get() = _elementList\n}\n类的名称通常是用来解释类是什么的名词或者名词短语：List、 PersonReader。\n\n方法的名称通常是动词或动词短语，说明该方法做什么：close、 readPersons。 修改对象或者返回一个新对象的名称也应遵循建议。例如 sort 是对一个集合就地排序，而 sorted 是返回一个排序后的集合副本。\n\n名称应该表明实体的目的是什么，所以最好避免在名称中使用无意义的单词 （Manager、 Wrapper 等）。\n\n当使用首字母缩写作为名称的一部分时，如果缩写由两个字母组成，就将其大写（IOStream）； 而如果缩写更长一些，就只大写其首字母（XmlFormatter、 HttpInputStream）。\n\n使用 4 个空格缩进。不要使用 tab。\n\n对于花括号，将左花括号放在结构起始处的行尾，而将右花括号放在与左括结构横向对齐的单独一行。\n\nif (elements != null) {\n    for (element in elements) {\n        // ……\n    }\n}\n（注意：在 Kotlin 中，分号是可选的，因此换行很重要。语言设计采用 Java 风格的花括号格式，如果尝试使用不同的格式化风格，那么可能会遇到意外的行为。）\n\n在二元操作符左右留空格（a + b）。例外：不要在“range to”操作符（0..i）左右留空格。\n\n不要在一元运算符左右留空格（a++）\n\n在控制流关键字（if、 when、 for 以及 while）与相应的左括号之间留空格。\n\n不要在主构造函数声明、方法声明或者方法调用的左括号之前留空格。\n\nclass A(val x: Int)\n\nfun foo(x: Int) { …… }\n\nfun bar() {\n    foo(1)\n}\n绝不在 (、 [ 之后或者 ]、 ) 之前留空格。\n\n绝不在. 或者 ?. 左右留空格：foo.bar().filter { it > 2 }.joinToString(), foo?.bar()\n\n在 // 之后留一个空格：// 这是一条注释\n\n不要在用于指定类型参数的尖括号前后留空格：class Map<K, V> { …… }\n\n不要在 :: 前后留空格：Foo::class、 String::length\n\n不要在用于标记可空类型的 ? 前留空格：String?\n\n作为一般规则，避免任何类型的水平对齐。将标识符重命名为不同长度的名称不应该影响声明或者任何用法的格式。\n\n在以下场景中的 : 之前留一个空格：\n\n当它用于分隔类型与超类型时；\n当委托给一个超类的构造函数或者同一类的另一个构造函数时；\n在 object 关键字之后。\n而当分隔声明与其类型时，不要在 : 之前留空格。\n\n在 : 之后总要留一个空格。\n\nabstract class Foo<out T : Any> : IFoo {\n    abstract fun foo(a: Int): T\n}\n\nclass FooImpl : Foo() {\n    constructor(x: String) : this(x) { /*……*/ }\n    \n    val x = object : IFoo { /*……*/ } \n} \n具有少数主构造函数参数的类可以写成一行：\n\nclass Person(id: Int, name: String)\n具有较长类头的类应该格式化，以使每个主构造函数参数都在带有缩进的独立的行中。 另外，右括号应该位于一个新行上。如果使用了继承，那么超类的构造函数调用或者所实现接口的列表应该与右括号位于同一行：\n\nclass Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name) { /*……*/ }\n对于多个接口，应该将超类构造函数调用放在首位，然后将每个接口应放在不同的行中：\n\nclass Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name),\n    KotlinMaker { /*……*/ }\n对于具有很长超类型列表的类，在冒号后面换行，并横向对齐所有超类型名：\n\nclass MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne {\n\n    fun foo() { /*...*/ }\n}\n为了将类头与类体分隔清楚，当类头很长时，可以在类头后放一空行 （如上例所示）或者将左花括号放在独立行上：\n\nclass MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne \n{\n    fun foo() { /*...*/ }\n}\n构造函数参数使用常规缩进（4 个空格）。\n\n理由：这确保了在主构造函数中声明的属性与 在类体中声明的属性具有相同的缩进。\n\n如果一个声明有多个修饰符，请始终按照以下顺序安放：\n\npublic / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation\ncompanion\ninline\ninfix\noperator\ndata\n将所有注解放在修饰符前：\n\n@Named(\"Foo\")\nprivate val foo: Foo\n除非你在编写库，否则请省略多余的修饰符（例如 public）。\n\n注解通常放在单独的行上，在它们所依附的声明之前，并使用相同的缩进：\n\n@Target(AnnotationTarget.PROPERTY)\nannotation class JsonExclude\n无参数的注解可以放在同一行：\n\n@JsonExclude @JvmField\nvar x: String\n无参数的单个注解可以与相应的声明放在同一行：\n\n@Test fun foo() { /*……*/ }\n文件注解位于文件注释（如果有的话）之后、package 语句之前，并且用一个空白行与 package 分开（为了强调其针对文件而不是包）。\n\n/** 授权许可、版权以及任何其他内容 */\n@file:JvmName(\"FooBar\")\n\npackage foo.bar\n如果函数签名不适合单行，请使用以下语法：\n\nfun longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType\n): ReturnType {\n    // 函数体\n}\n函数参数使用常规缩进（4 个空格）。\n\n理由：与构造函数参数一致\n\n对于由单个表达式构成的函数体，优先使用表达式形式。\n\nfun foo(): Int {     // 不良\n    return 1 \n}\n\nfun foo() = 1        // 良好\n如果函数的表达式函数体与函数声明不适合放在同一行，那么将 = 留在第一行。 将表达式函数体缩进 4 个空格。\n\nfun f(x: String) =\n    x.length\n对于非常简单的只读属性，请考虑单行格式：\n\nval isEmpty: Boolean get() = size == 0\n对于更复杂的属性，总是将 get 与 set 关键字放在不同的行上：\n\nval foo: String\n    get() { /*……*/ }\n对于具有初始化器的属性，如果初始化器很长，那么在等号后增加一个换行并将初始化器缩进四个空格：\n\nprivate val defaultCharset: Charset? =\n    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)\n如果 if 或 when 语句的条件有多行，那么在语句体外边总是使用大括号。 将该条件的每个后续行相对于条件语句起始处缩进 4 个空格。 将该条件的右圆括号与左花括号放在单独一行：\n\nif (!component.isSyncing &&\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}\n理由：对齐整齐并且将条件与语句体分隔清楚\n\n将 else、 catch、 finally 关键字以及 do/while 循环的 while 关键字与之前的花括号放在相同的行上：\n\nif (condition) {\n    // 主体\n} else {\n    // else 部分\n}\n\ntry {\n    // 主体\n} finally {\n    // 清理\n}\n在 when 语句中，如果一个分支不止一行，可以考虑用空行将其与相邻的分支块分开：\n\nprivate fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken ->\n            callback.visitValue(propName, token.value)\n\n        Token.LBRACE -> { // ……\n        }\n    }\n}\n将短分支放在与条件相同的行上，无需花括号。\n\nwhen (foo) {\n    true -> bar() // 良好\n    false -> { baz() } // 不良\n}\n在较长参数列表的左括号后添加一个换行符。按 4 个空格缩进参数。 将密切相关的多个参数分在同一行。\n\ndrawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)\n在分隔参数名与值的 = 左右留空格。\n\n当对链式调用换行时，将 . 字符或者 ?. 操作符放在下一行，并带有单倍缩进：\n\nval anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }\n调用链的第一个调用通常在换行之前，当然如果能让代码更有意义也可以忽略这点。\n\n在 lambda 表达式中，应该在花括号左右以及分隔参数与代码体的箭头左右留空格。 如果一个调用接受单个 lambda 表达式，应该尽可能将其放在圆括号外边传入。\n\n如果为 lambda 表达式分配一个标签，那么不要在该标签与左花括号之间留空格：\n\nfun foo() {\n    ints.forEach lit@{\n        // ……\n    }\n}\n在多行的 lambda 表达式中声明参数名时，将参数名放在第一行，后跟箭头与换行符：\n\nappendCommaSeparated(properties) { prop ->\n    val propertyValue = prop.get(obj)  // ……\n}\n如果参数列表太长而无法放在一行上，请将箭头放在单独一行：\n\nfoo {\n   context: Context,\n   environment: Env\n   ->\n   context.configureEnv(environment)\n}\n对于较长的文档注释，将开头 /** 放在一个独立行中，并且后续每行都以星号开头：\n\n简短注释可以放在一行内：\n\n通常，避免使用 @param 与 @return 标记。而是将参数与返回值的描述直接合并到文档注释中，并在提到参数的任何地方加上参数链接。 只有当需要不适合放进主文本流程的冗长描述时才应使用 @param 与 @return。\n\n// 避免这样：\n\n/**\n * Returns the absolute value of the given number.\n * @param number The number to return the absolute value for.\n * @return The absolute value.\n */\nfun abs(number: Int) { /*……*/ }\n\n// 而要这样：\n\n/**\n * Returns the absolute value of the given [number].\n */\nfun abs(number: Int) { /*……*/ }\n一般来说，如果 Kotlin 中的某种语法结构是可选的并且被 IDE 高亮为冗余的，那么应该在代码中省略之。为了清楚起见，不要在代码中保留不必要的语法元素 。\n\n如果函数返回 Unit，那么应该省略返回类型：\n\nfun foo() { // 这里省略了“: Unit”\n\n}\n尽可能省略分号。\n\n将简单变量传入到字符串模版中时不要使用花括号。只有用到更长表达式时才使用花括号。\n\nprintln(\"$name has ${children.size} children\")\n优先使用不可变（而不是可变）数据。初始化后未修改的局部变量与属性，总是将其声明为 val 而不是 var 。\n\n总是使用不可变集合接口（Collection, List, Set, Map）来声明无需改变的集合。使用工厂函数创建集合实例时，尽可能选用返回不可变集合类型的函数：\n\n// 不良：使用可变集合类型作为无需改变的值\nfun validateValue(actualValue: String, allowedValues: HashSet<String>) { …… }\n\n// 良好：使用不可变集合类型\nfun validateValue(actualValue: String, allowedValues: Set<String>) { …… }\n\n// 不良：arrayListOf() 返回 ArrayList<T>，这是一个可变集合类型\nval allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n\n// 良好：listOf() 返回 List<T>\nval allowedValues = listOf(\"a\", \"b\", \"c\")\n优先声明带有默认参数的函数而不是声明重载函数。\n\n// 不良\nfun foo() = foo(\"a\")\nfun foo(a: String) { /*……*/ }\n\n// 良好\nfun foo(a: String = \"a\") { /*……*/ }\n如果有一个在代码库中多次用到的函数类型或者带有类型参数的类型，那么最好为它定义一个类型别名：\n\ntypealias MouseClickHandler = (Any, MouseEvent) -> Unit\ntypealias PersonIndex = Map<String, Person>\n在简短、非嵌套的 lambda 表达式中建议使用 it 用法而不是显式声明参数。而在有参数的嵌套 lambda 表达式中，始终应该显式声明参数。\n\n避免在 lambda 表达式中使用多个返回到标签。请考虑重新组织这样的 lambda 表达式使其只有单一退出点。 如果这无法做到或者不够清晰，请考虑将 lambda 表达式转换为匿名函数。\n\n不要在 lambda 表达式的最后一条语句中使用返回到标签。\n\n当一个方法接受多个相同的原生类型参数或者多个 Boolean 类型参数时，请使用具名参数语法， 除非在上下文中的所有参数的含义都已绝对清楚。\n\ndrawSquare(x = 10, y = 10, width = 100, height = 100, fill = true)\n优先使用 try、if 与 when 的表达形式。例如：\n\nreturn if (x) foo() else bar()\n\nreturn when(x) {\n    0 -> \"zero\"\n    else -> \"nonzero\"\n}\n优先选用上述代码而不是：\n\nif (x)\n    return foo()\nelse\n    return bar()\n    \nwhen(x) {\n    0 -> return \"zero\"\n    else -> return \"nonzero\"\n}    \n二元条件优先使用 if 而不是 when。不要使用\n\nwhen (x) {\n    null -> // ……\n    else -> // ……\n}\n而应使用 if (x == null) …… else ……\n\n如果有三个或多个选项时优先使用 when。\n\n如果需要在条件语句中用到可空的 Boolean, 使用 if (value == true) 或 if (value == false) 检测。\n\n优先使用高阶函数（filter、map 等）而不是循环。例外：forEach（优先使用常规的 for 循环， 除非 forEach 的接收者是可空的或者 forEach 用做长调用链的一部分。）\n\n当在使用多个高阶函数的复杂表达式与循环之间进行选择时，请了解每种情况下所执行操作的开销并且记得考虑性能因素。\n\n使用 until 函数在一个开区间上循环：\n\nfor (i in 0..n - 1) { /*……*/ }  // 不良\nfor (i in 0 until n) { /*……*/ }  // 良好\n优先使用字符串模板而不是字符串拼接。\n\n优先使用多行字符串而不是将 \\n 转义序列嵌入到常规字符串字面值中。\n\n如需在多行字符串中维护缩进，当生成的字符串不需要任何内部缩进时使用 trimIndent，而需要内部缩进时使用 trimMargin：\n\nassertEquals(\n    \"\"\"\n    Foo\n    Bar\n    \"\"\".trimIndent(), \n    value\n)\n\nval a = \"\"\"if(a > 1) {\n          |    return a\n          |}\"\"\".trimMargin()\n在某些情况下，不带参数的函数可与只读属性互换。 虽然语义相似，但是在某种程度上有一些风格上的约定。\n\n底层算法优先使用属性而不是函数：\n\n不会抛异常\n计算开销小（或者在首次运行时缓存）\n如果对象状态没有改变，那么多次调用都会返回相同结果\n放手去用扩展函数。每当你有一个主要用于某个对象的函数时，可以考虑使其成为一个以该对象为接收者的扩展函数。为了尽量减少 API 污染，尽可能地限制扩展函数的可见性。根据需要，使用局部扩展函数、成员扩展函数或者具有私有可视性的顶层扩展函数。\n\n一个函数只有用于两个角色类似的对象时才将其声明为中缀函数。良好示例如：and、 to、zip。 不良示例如：add。\n\n如果一个方法会改动其接收者，那么不要声明为中缀形式。\n\n如果为一个类声明一个工厂函数，那么不要让它与类自身同名。优先使用独特的名称， 该名称能表明为何该工厂函数的行为与众不同。只有当确实没有特殊的语义时， 才可以使用与该类相同的名称。\n\n例如：\n\nclass Point(val x: Double, val y: Double) {\n    companion object {\n        fun fromPolar(angle: Double, radius: Double) = Point(...)\n    }\n}\n如果一个对象有多个重载的构造函数，它们并非调用不同的超类构造函数，并且不能简化为具有默认参数值的单个构造函数，那么优先用工厂函数取代这些重载的构造函数。\n\n返回平台类型表达式的公有函数/方法必须显式声明其 Kotlin 类型：\n\nfun apiCall(): String = MyJavaApi.getProperty(\"name\")\n任何使用平台类型表达式初始化的属性（包级别或类级别）必须显式声明其 Kotlin 类型：\n\nclass Person {\n    val name: String = MyJavaApi.getProperty(\"name\")\n}\n使用平台类型表达式初始化的局部值可以有也可以没有类型声明：\n\nfun main() {\n    val name = MyJavaApi.getProperty(\"name\")\n    println(name)\n}\nKotlin 提供了一系列用来在给定对象上下文中执行代码块的函数：let、 run、 with、 apply 以及 also。 关于不同情况下选择正确作用域函数的准则，请参考作用域函数。\n\n在编写库时，建议遵循一组额外的规则以确保 API 的稳定性：\n\n总是显式指定成员的可见性（以避免将声明意外暴露为公有 API ）\n总是显式指定函数返回类型以及属性类型（以避免当实现改变时意外更改返回类型）\n为所有公有成员提供 KDoc 注释，不需要任何新文档的覆盖成员除外 （以支持为该库生成文档）"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306169562},"updatedAt":{"$$date":1597307252302},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Yn4wumKYLpHhyFnY"}
{"name":"andr-向项目添加组件 ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/architecture/adding-components\n向项目添加组件  |  Android 开发者  |  Android Developers\n1-2 minutes\n在开始之前，我们建议您阅读架构组件的应用架构指南。该指南包含一些适用于所有 Android 应用的有用原则，并展示了如何将架构组件组合到一起使用。\n\n架构组件可从 Google 的 Maven 代码库中获得。要使用这些组件，您必须将代码库添加到项目中。\n\n打开项目的 build.gradle 文件（而不是应用或模块的该文件）并添加 google() 代码库，如下所示：\n\n    allprojects {\n        repositories {\n            google()\n            jcenter()\n        }\n    }\n    \n声明依赖项\n打开应用或模块的 build.gradle 文件，然后添加所需的软件工件作为依赖项。您可以为所有架构组件添加依赖项，也可以选择其中一部分。\n\n请参阅版本说明中关于为每个架构组件声明依赖项的说明：\n\nFutures（可在 androidx.concurrent 中找到）\n生命周期组件（包括 ViewModel）\n导航（包括 SafeArgs）\nPaging\nRoom\nWorkManager\n如需详细了解 AndroidX 重构及其对这些类包和模块 ID 的影响，请参阅 AndroidX 重构文档。\n\nKotlin\nKotlin 扩展模块支持使用多个 AndroidX 依赖项。这些模块的名称后附加了后缀“-ktx”。例如：\n\nimplementation \"androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version\"\n    \n会变为\n\nimplementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version\"\n    \n您可以在 ktx 文档中找到更多信息，包括 Kotlin 扩展程序的文档。\n\n注意：对于基于 Kotlin 的应用，请确保使用 kapt 而不是annotationProcessor。您还应添加 kotlin-kapt 插件。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243902702},"updatedAt":{"$$date":1597244054538},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YuLOPJ6GQKtlzu1V"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980155146},"updatedAt":{"$$date":1594980155146},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"YyL9H9HN2Px1LM6D"}
{"name":"kotlin-密封类 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/sealed-classes.html\n密封类 - Kotlin 语言中文站\n4-4 minutes\n改进翻译\n密封类用来表示受限的类继承结构：当一个值为有限几种的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。\n\n要声明一个密封类，需要在类名前面添加 sealed 修饰符。虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前， 该规则更加严格：子类必须嵌套在密封类声明的内部）。\n\nsealed class Expr\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()\n（上文示例使用了 Kotlin 1.1 的一个额外的新功能：数据类扩展包括密封类在内的其他类的可能性。 ）\n\n一个密封类是自身抽象的，它不能直接实例化并可以有抽象（abstract）成员。\n\n密封类不允许有非-private 构造函数（其构造函数默认为 private）。\n\n请注意，扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。\n\n使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。当然，这只有当你用 when 作为表达式（使用结果）而不是作为语句时才有用。\n\nfun eval(expr: Expr): Double = when(expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n    // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307922502},"updatedAt":{"$$date":1597308021281},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Z2qE8cvpy4SldhXn"}
{"name":"kotlin-加减操作符 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-plus-minus.html\n加减操作符 - Kotlin 语言中文站\n3-4 minutes\n改进翻译\n在 Kotlin 中，为集合定义了 plus (+) 和 minus (-) 操作符。 它们把一个集合作为第一个操作数；第二个操作数可以是一个元素或者是另一个集合。 返回值是一个新的只读集合：\n\nplus 的结果包含原始集合 和 第二个操作数中的元素。\nminus 的结果包含原始集合中的元素，但第二个操作数中的元素 除外。 如果第二个操作数是一个元素，那么 minus 移除其在原始集合中的 第一次 出现；如果是一个集合，那么移除其元素在原始集合中的 所有 出现。\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    val plusList = numbers + \"five\"\n    val minusList = numbers - listOf(\"three\", \"four\")\n    println(plusList)\n    println(minusList)\n//sampleEnd\n}\n有关 map 的 plus 和 minus 操作符的详细信息，请参见 Map 相关操作。 \n也为集合定义了广义赋值操作符 plusAssign (+=) 和 minusAssign (-=)。 \n然而，对于只读集合，它们实际上使用 plus 或者 minus 操作符并尝试将结果赋值给同一变量。 \n因此，它们仅在由 var 声明的只读集合中可用。 对于可变集合，如果它是一个 val，\n那么它们会修改集合。更多详细信息请参见集合写操作。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382121213},"updatedAt":{"$$date":1597382559637},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ZHoQsArltgOLwIBb"}
{"name":"kotlin-类型别名（自 1.1 起） - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/type-aliases.html\n类型别名（自 1.1 起） - Kotlin 语言中文站\n3-4 minutes\n改进翻译\n类型别名为现有类型提供替代名称。 如果类型名称太长，你可以另外引入较短的名称，并使用新的名称替代原类型名。\n\n它有助于缩短较长的泛型类型。 例如，通常缩减集合类型是很有吸引力的：\n\n你可以为函数类型提供另外的别名：\n\ntypealias MyHandler = (Int, String, Any) -> Unit\n\ntypealias Predicate<T> = (T) -> Boolean\n你可以为内部类和嵌套类创建新名称：\n\nclass A {\n    inner class Inner\n}\nclass B {\n    inner class Inner\n}\n\ntypealias AInner = A.Inner\ntypealias BInner = B.Inner\n类型别名不会引入新类型。 它们等效于相应的底层类型。 当你在代码中添加 typealias Predicate<T> 并使用 Predicate<Int> 时，Kotlin 编译器总是把它扩展为 (Int) -> Boolean。 因此，当你需要泛型函数类型时，你可以传递该类型的变量，反之亦然：\n\ntypealias Predicate<T> = (T) -> Boolean\n\nfun foo(p: Predicate<Int>) = p(42)\n\nfun main() {\n    val f: (Int) -> Boolean = { it > 0 }\n    println(foo(f)) // 输出 \"true\"\n\n    val p: Predicate<Int> = { it > 0 }\n    println(listOf(1, -2).filter(p)) // 输出 \"[1]\"\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307928886},"updatedAt":{"$$date":1597308147597},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ZoAVIhjj8gdWbOt9"}
{"name":"kotlin-扩展 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/extensions.html\n扩展 - Kotlin 语言中文站\n18-22 minutes\n改进翻译\nKotlin 能够扩展一个类的新功能而无需继承该类或者使用像装饰者这样的设计模式。 这通过叫做 扩展 的特殊声明完成。 例如，你可以为一个你不能修改的、来自第三方库中的类编写一个新的函数。 这个新增的函数就像那个原始类本来就有的函数一样，可以用普通的方法调用。 这种机制称为 扩展函数 。此外，也有 扩展属性 ， 允许你为一个已经存在的类添加新的属性。\n\n声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面代码为 MutableList<Int> 添加一个swap 函数：\n\n这个 this 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象） 现在，我们对任意 MutableList<Int> 调用该函数了：\n\nval list = mutableListOf(1, 2, 3)\nlist.swap(0, 2) // “swap()”内部的“this”会保存“list”的值\n当然，这个函数对任何 MutableList<T> 起作用，我们可以泛化它：\n\nfun <T> MutableList<T>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // “this”对应该列表\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n为了在接收者类型表达式中使用泛型，我们要在函数名前声明泛型参数。 参见泛型函数。\n\n扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。\n\n我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如：\n\nfun main() {\n//sampleStart\n    open class Shape\n    \n    class Rectangle: Shape()\n    \n    fun Shape.getName() = \"Shape\"\n    \n    fun Rectangle.getName() = \"Rectangle\"\n    \n    fun printClassName(s: Shape) {\n        println(s.getName())\n    }    \n    \n    printClassName(Rectangle())\n//sampleEnd\n}\n这个例子会输出 \"Shape\"，因为调用的扩展函数只取决于参数 s 的声明类型，该类型是 Shape 类。\n\n如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、 相同的名字，并且都适用给定的参数，这种情况总是取成员函数。 例如：\n\nfun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType() { println(\"Extension function\") }\n    \n    Example().printFunctionType()\n//sampleEnd\n}\n这段代码输出“Class method”。\n\n当然，扩展函数重载同样名字但不同签名成员函数也完全可以：\n\nfun main() {\n//sampleStart\n    class Example {\n        fun printFunctionType() { println(\"Class method\") }\n    }\n    \n    fun Example.printFunctionType(i: Int) { println(\"Extension function\") }\n    \n    Example().printFunctionType(1)\n//sampleEnd\n}\n注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为 null，并且可以在函数体内检测 this == null，这能让你在没有检测 null 的时候调用 Kotlin 中的toString()：检测发生在扩展函数的内部。\n\nfun Any?.toString(): String {\n    if (this == null) return \"null\"\n    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()\n    // 解析为 Any 类的成员函数\n    return toString()\n}\n与函数类似，Kotlin 支持扩展属性：\n\nval <T> List<T>.lastIndex: Int\n    get() = size - 1\n注意：由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。\n\n例如:\n\nval House.number = 1 // 错误：扩展属性不能有初始化器\n如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数与属性。就像伴生对象的常规成员一样， 可以只使用类名作为限定符来调用伴生对象的扩展成员：\n\nclass MyClass {\n    companion object { }  // 将被称为 \"Companion\"\n}\n\nfun MyClass.Companion.printCompanion() { println(\"companion\") }\n\nfun main() {\n    MyClass.printCompanion()\n}\n大多数时候我们在顶层定义扩展——直接在包里：\n\npackage org.example.declarations\n \nfun List<String>.getLongestString() { /*……*/}\n要使用所定义包之外的一个扩展，我们需要在调用方导入它：\n\npackage org.example.usage\n\nimport org.example.declarations.getLongestString\n\nfun main() {\n    val list = listOf(\"red\", \"green\", \"blue\")\n    list.getLongestString()\n}\n更多信息参见导入\n\n在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个 隐式接收者 —— 其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为 分发接收者，扩展方法调用所在的接收者类型的实例称为 扩展接收者 。\n\nclass Host(val hostname: String) {\n    fun printHostname() { print(hostname) }\n}\n\nclass Connection(val host: Host, val port: Int) {\n     fun printPort() { print(port) }\n\n     fun Host.printConnectionString() {\n         printHostname()   // 调用 Host.printHostname()\n         print(\":\")\n         printPort()   // 调用 Connection.printPort()\n     }\n\n     fun connect() {\n         /*……*/\n         host.printConnectionString()   // 调用扩展函数\n     }\n}\n\nfun main() {\n    Connection(Host(\"kotl.in\"), 443).connect()\n    //Host(\"kotl.in\").printConnectionString(443)  // 错误，该扩展函数在 Connection 外不可用\n}\n对于分发接收者与扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者的成员你可以使用 限定的 this 语法。\n\nclass Connection {\n    fun Host.getConnectionString() {\n        toString()         // 调用 Host.toString()\n        this@Connection.toString()  // 调用 Connection.toString()\n    }\n}\n声明为成员的扩展可以声明为 open 并在子类中覆盖。这意味着这些函数的分发对于分发接收者类型是虚拟的，但对于扩展接收者类型是静态的。\n\nopen class Base { }\n\nclass Derived : Base() { }\n\nopen class BaseCaller {\n    open fun Base.printFunctionInfo() {\n        println(\"Base extension function in BaseCaller\")\n    }\n\n    open fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in BaseCaller\")\n    }\n\n    fun call(b: Base) {\n        b.printFunctionInfo()   // 调用扩展函数\n    }\n}\n\nclass DerivedCaller: BaseCaller() {\n    override fun Base.printFunctionInfo() {\n        println(\"Base extension function in DerivedCaller\")\n    }\n\n    override fun Derived.printFunctionInfo() {\n        println(\"Derived extension function in DerivedCaller\")\n    }\n}\n\nfun main() {\n    BaseCaller().call(Base())   // “Base extension function in BaseCaller”\n    DerivedCaller().call(Base())  // “Base extension function in DerivedCaller”——分发接收者虚拟解析\n    DerivedCaller().call(Derived())  // “Base extension function in DerivedCaller”——扩展接收者静态解析\n}\n扩展的可见性与相同作用域内声明的其他实体的可见性相同。例如：\n\n在文件顶层声明的扩展可以访问同一文件中的其他 private 顶层声明；\n如果扩展是在其接收者类型外部声明的，那么该扩展不能访问接收者的 private 成员。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306190500},"updatedAt":{"$$date":1597307977253},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"a2fUO3iAWaRB8fYd"}
{"name":"andr-动画","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"developer.android.google.cn /guide/topics/resources/animation-resource\n动画资源  |  Android 开发者  |  Android Developers\n16-20 minutes\n一个动画资源可以定义以下两种动画类型之一：\n\n属性动画\n通过使用 Animator 在设定的时间段内修改对象的属性值来创建动画。\n视图动画\n使用视图动画框架可以创建两种类型的动画：\n\n补间动画：通过使用 Animation 对单张图片执行一系列转换来创建动画\n帧动画：通过使用 AnimationDrawable 按顺序显示一系列图片来创建动画。\n属性动画\n在 XML 中定义的动画，用于在设定的一段时间内修改目标对象的属性，例如背景颜色或 Alpha 值。\n\n文件位置：\nres/animator/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 ValueAnimator、ObjectAnimator 或 AnimatorSet 的资源指针。\n资源引用：\n在 Java 或 Kotlin 代码中：R.animator.filename\n在 XML 中：@[package:]animator/filename\n语法：\n    <set\n      android:ordering=[\"together\" | \"sequentially\"]><objectAnimator\n            android:propertyName=\"string\"\n            android:duration=\"int\"\n            android:valueFrom=\"float | int | color\"\n            android:valueTo=\"float | int | color\"\n            android:startOffset=\"int\"\n            android:repeatCount=\"int\"\n            android:repeatMode=[\"repeat\" | \"reverse\"]\n            android:valueType=[\"intType\" | \"floatType\"]/><animator\n            android:duration=\"int\"\n            android:valueFrom=\"float | int | color\"\n            android:valueTo=\"float | int | color\"\n            android:startOffset=\"int\"\n            android:repeatCount=\"int\"\n            android:repeatMode=[\"repeat\" | \"reverse\"]\n            android:valueType=[\"intType\" | \"floatType\"]/><set>\n            ...\n        </set>\n    </set>\n    \n该文件必须具有一个根元素，可以是 <set>、<objectAnimator> 或 <valueAnimator>。您可以将动画元素（包括其他 <set> 元素）组合到 <set> 元素中。\n\n元素：\n<set>\n容纳其他动画元素（<objectAnimator>、<valueAnimator> 或其他 <set> 元素）的容器。代表 AnimatorSet。\n您可以指定嵌套的 <set> 标记来将动画进一步组合在一起。每个 <set> 都可以定义自己的 ordering 属性。\n\n属性：\n\nandroid:ordering\n关键字。指定此集合中动画的播放顺序。\n值\t说明\nsequentially\t依序播放此集合中的动画\ntogether（默认）\t同时播放此集合中的动画。\n<objectAnimator>\n在特定的一段时间内为对象的特定属性创建动画。代表 ObjectAnimator。\n属性：\n\nandroid:propertyName\n字符串。必需。要添加动画的对象属性，通过其名称引用。例如，您可以为 View 对象指定 \"alpha\" 或 \"backgroundColor\"。 但是，objectAnimator 元素不包含 target 属性，因此您无法在 XML 声明中设置要添加动画的对象。您必须通过调用 loadAnimator() 来扩充您的动画 XML 资源，然后调用 setTarget() 来设置包含此属性的目标对象。\nandroid:valueTo\n浮点数、整数或颜色。必需。动画属性的结束值。颜色以六位十六进制数字表示（例如，#333333）。\nandroid:valueFrom\n浮点数、整数或颜色。动画属性的开始值。如果未指定，则动画将从属性的 get 方法获得的值开始。颜色以六位十六进制数字表示（例如，#333333）。\nandroid:duration\n整数。动画的时间，以毫秒为单位。默认为 300 毫秒。\nandroid:startOffset\n整数。调用 start() 后动画延迟的毫秒数。\nandroid:repeatCount\n整数。动画的重复次数。设为 \"-1\" 表示无限次重复，也可设为正整数。例如，值 \"1\" 表示动画在初次播放后重复播放一次，因此动画总共播放两次。默认值为 \"0\"，表示不重复。\nandroid:repeatMode\n整数。动画播放到结尾处的行为。android:repeatCount 必须设置为正整数或 \"-1\"，该属性才有效。设置为 \"reverse\" 可让动画在每次迭代时反向播放，设置为 \"repeat\" 则可让动画每次从头开始循环播放。\nandroid:valueType\n关键字。如果值为颜色，则不要指定此属性。动画框架会自动处理颜色值\n值\t说明\nintType\t指定动画值为整数\nfloatType（默认）\t指定动画值为浮点数\n<animator>\n在指定的时间段内执行动画。代表 ValueAnimator。\n属性：\n\nandroid:valueTo\n浮点数、整数或颜色。必需。动画的结束值。颜色以六位十六进制数字表示（例如，#333333）。\nandroid:valueFrom\n浮点数、整数或颜色。必需。动画的开始值。颜色以六位十六进制数字表示（例如，#333333）。\nandroid:duration\n整数。动画的时间，以毫秒为单位。默认为 300ms。\nandroid:startOffset\n整数。调用 start() 后动画延迟的毫秒数。。\nandroid:repeatCount\n整数。动画的重复次数。设为 \"-1\" 表示无限次重复，也可设为正整数。例如，值 \"1\" 表示动画在初次播放后重复播放一次，因此动画总共播放两次。默认值为 \"0\"，表示不重复。\nandroid:repeatMode\n整数。动画播放到结尾处的行为。android:repeatCount 必须设置为正整数或 \"-1\"，该属性才有效。设置为 \"reverse\" 可让动画在每次迭代时反向播放，设置为 \"repeat\" 则可让动画每次从头开始循环播放。\nandroid:valueType\n关键字。如果值为颜色，则不要指定此属性。动画框架会自动处理颜色值。\n值\t说明\nintType\t指定动画值为整数\nfloatType（默认）\t指定动画值为浮点数\n示例：\n保存在 res/animator/property_animator.xml 的 XML 文件：\n    <set android:ordering=\"sequentially\">\n        <set>\n            <objectAnimator\n                android:propertyName=\"x\"\n                android:duration=\"500\"\n                android:valueTo=\"400\"\n                android:valueType=\"intType\"/>\n            <objectAnimator\n                android:propertyName=\"y\"\n                android:duration=\"500\"\n                android:valueTo=\"300\"\n                android:valueType=\"intType\"/>\n        </set>\n        <objectAnimator\n            android:propertyName=\"alpha\"\n            android:duration=\"500\"\n            android:valueTo=\"1f\"/>\n    </set>\n    \n为了运行此动画，您必须将代码中的 XML 资源扩充为 AnimatorSet 对象，然后在开始运行动画集之前为所有动画设置目标对象。为方便起见，调用 setTarget() 即可设置一个用于 AnimatorSet 的所有子项的目标对象。以下代码展示了如何执行此操作：\n\n    val set: AnimatorSet = AnimatorInflater.loadAnimator(myContext, R.animator.property_animator)\n        .apply {\n            setTarget(myObject)\n            start()\n        }\n    \n    AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,\n        R.animator.property_animator);\n    set.setTarget(myObject);\n    set.start();\n    \n另请参阅：\n属性动画\n有关如何使用属性动画系统的示例，请参阅 API 演示。\n视图动画\n视图动画框架可支持补间动画和逐帧动画，两者都可以在 XML 中声明。以下几个部分介绍如何使用这两种方法。\n\n补间动画\n在 XML 中定义的动画，用于对图形执行旋转、淡出、移动和拉伸等转换。\n\n文件位置：\nres/anim/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 Animation 的资源指针。\n资源引用：\n在 Java 中：R.anim.filename\n在 XML 中：@[package:]anim/filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:interpolator=\"@[package:]anim/interpolator_resource\"\n        android:shareInterpolator=[\"true\" | \"false\"] >\n        <alpha\n            android:fromAlpha=\"float\"\n            android:toAlpha=\"float\" />\n        <scale\n            android:fromXScale=\"float\"\n            android:toXScale=\"float\"\n            android:fromYScale=\"float\"\n            android:toYScale=\"float\"\n            android:pivotX=\"float\"\n            android:pivotY=\"float\" />\n        <translate\n            android:fromXDelta=\"float\"\n            android:toXDelta=\"float\"\n            android:fromYDelta=\"float\"\n            android:toYDelta=\"float\" />\n        <rotate\n            android:fromDegrees=\"float\"\n            android:toDegrees=\"float\"\n            android:pivotX=\"float\"\n            android:pivotY=\"float\" />\n        <set>\n            ...\n        </set>\n    </set>\n    \n该文件必须具有一个根元素，可以是 <alpha>、<scale>、<translate>、<rotate> 或包含一组（或多组）其他动画元素（甚至是嵌套的 <set> 元素）的 <set> 元素。\n\n元素：\n<set>\n容纳其他动画元素（<alpha>、<scale>、<translate>、<rotate>）或其他 <set> 元素的容器。代表 AnimationSet。\n属性：\n\nandroid:interpolator\n插值器资源。 要应用于动画的 Interpolator。 该值必须是对指定插值器的资源的引用（而不是插值器类名称）。您可以使用平台提供的默认插值器资源，也可以创建自己的插值器资源。有关插值器的详细信息，请参阅以下说明。\nandroid:shareInterpolator\n布尔值。如果要在所有子元素中共用同一插值器，则为“true”。\n<alpha>\n淡入或淡出动画。代表 AlphaAnimation。\n属性：\n\nandroid:fromAlpha\n浮点数。起始不透明度偏移，0.0 表示透明，1.0 表示不透明。\nandroid:toAlpha\n浮点数。结束不透明度偏移，0.0 表示透明，1.0 表示不透明。\n要了解 <alpha> 支持的更多属性，请参阅 Animation 类引用（其中所有 XML 属性均由此元素继承）。\n\n<scale>\n大小调整动画。您可以通过指定 pivotX 和 pivotY，来指定图片向外（或向内）扩展的中心点。例如，如果这两个值为 0、0（左上角），则所有扩展均向右下方向进行。代表 ScaleAnimation。\n属性：\n\nandroid:fromXScale\n浮点数。起始 X 尺寸偏移，其中 1.0 表示不变。\nandroid:toXScale\n浮点数。结束 X 尺寸偏移，其中 1.0 表示不变。\nandroid:fromYScale\n浮点数。起始 Y 尺寸偏移，其中 1.0 表示不变。\nandroid:toYScale\n浮点数。结束 Y 尺寸偏移，其中 1.0 表示不变。\nandroid:pivotX\n浮点数。在对象缩放时要保持不变的 X 坐标。\nandroid:pivotY\n浮点数。在对象缩放时要保持不变的 Y 坐标。\n要了解 <scale> 支持的更多属性，请参阅 Animation 类引用（其中所有 XML 属性均由此元素继承）。\n\n<translate>\n垂直和/或水平移动。支持采用以下三种格式之一的以下属性：从 -100 到 100 的以“％”结尾的值，表示相对于自身的百分比；从 -100 到 100 的以“％p”结尾的值，表示相对于其父项的百分比；不带后缀的浮点值，表示绝对值。代表 TranslateAnimation。\n属性：\n\nandroid:fromXDelta\n浮动数或百分比。起始 X 偏移。表示方式：相对于正常位置的像素数（例如 \"5\"），相对于元素宽度的百分比（例如 \"5%\"），或相对于父项宽度的百分比（例如 \"5%p\"）。\nandroid:toXDelta\n浮动数或百分比。结束 X 偏移。表示方式：相对于正常位置的像素数（例如 \"5\"），相对于元素宽度的百分比（例如 \"5%\"），或相对于父项宽度的百分比（例如 \"5%p\"）。\nandroid:fromYDelta\n浮动数或百分比。起始 Y 偏移。表示方式：相对于正常位置的像素数（例如 \"5\"），相对于元素高度的百分比（例如 \"5%\"），或相对于父项高度的百分比（例如 \"5%p\"）。\nandroid:toYDelta\n浮动数或百分比。结束 Y 偏移。表示方式：相对于正常位置的像素数（例如 \"5\"），相对于元素高度的百分比（例如 \"5%\"），或相对于父项高度的百分比（例如 \"5%p\"）。\n要了解 <translate> 支持的更多属性，请参阅 Animation 类引用（其中所有 XML 属性均由此元素继承）。\n\n<rotate>\n旋转动画。代表 RotateAnimation。\n属性：\n\nandroid:fromDegrees\n浮点数。起始角度位置，以度为单位。\nandroid:toDegrees\n浮点数。结束角度位置，以度为单位。\nandroid:pivotX\n浮动数或百分比。旋转中心的 X 坐标。表示方式：相对于对象左边缘的像素数（例如 \"5\"），相对于对象左边缘的百分比（例如 \"5%\"），或相对于父级容器左边缘的百分比（例如 \"5%p\"）。\nandroid:pivotY\n浮点数或百分比。旋转中心的 Y 坐标。表示方式：相对于对象上边缘的像素数（例如 \"5\"），相对于对象上边缘的百分比（例如 \"5%\"），或相对于父级容器上边缘的百分比（例如 \"5%p\"）。\n要了解 <rotate> 支持的更多属性，请参阅 Animation 类引用（其中所有 XML 属性均由此元素继承）。\n\n示例：\n保存在 res/anim/hyperspace_jump.xml 的 XML 文件：\n    <set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:shareInterpolator=\"false\">\n        <scale\n            android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n            android:fromXScale=\"1.0\"\n            android:toXScale=\"1.4\"\n            android:fromYScale=\"1.0\"\n            android:toYScale=\"0.6\"\n            android:pivotX=\"50%\"\n            android:pivotY=\"50%\"\n            android:fillAfter=\"false\"\n            android:duration=\"700\" />\n        <set\n            android:interpolator=\"@android:anim/accelerate_interpolator\"\n            android:startOffset=\"700\">\n            <scale\n                android:fromXScale=\"1.4\"\n                android:toXScale=\"0.0\"\n                android:fromYScale=\"0.6\"\n                android:toYScale=\"0.0\"\n                android:pivotX=\"50%\"\n                android:pivotY=\"50%\"\n                android:duration=\"400\" />\n            <rotate\n                android:fromDegrees=\"0\"\n                android:toDegrees=\"-45\"\n                android:toYScale=\"0.0\"\n                android:pivotX=\"50%\"\n                android:pivotY=\"50%\"\n                android:duration=\"400\" />\n        </set>\n    </set>\n    \n以下应用代码会将动画应用到 ImageView 并启动动画：\n\n    val image: ImageView = findViewById(R.id.image)\n    val hyperspaceJump: Animation = AnimationUtils.\nloadAnimation\n(this, R.anim.hyperspace_jump)\n    image.\nstartAnimation\n(hyperspaceJump)\n    \n    ImageView image = (ImageView) findViewById(R.id.image);\n    Animation hyperspaceJump = AnimationUtils.\nloadAnimation\n(this, R.anim.hyperspace_jump);\n    image.\nstartAnimation\n(hyperspaceJump);\n    \n另请参阅：\n2D 图形：补间动画\n插值器\n插值器是在 XML 中定义的动画修改器，它会影响动画的变化率。插值器可对现有的动画效果执行加速、减速、重复、退回等。\n\n插值器通过 android:interpolator 属性应用于动画元素，该属性的值是对插值器资源的引用。\n\nAndroid 中提供的所有插值器都是 Interpolator 类的子类。为便于您使用 android:interpolator 属性将插值器应用于动画，Android 针对每个插值器类包含了一个可供您引用的公共资源。下表指定了每个插值器要使用的资源：\n\n您可以通过以下方式使用 android:interpolator 属性应用上述某个插值器：\n\n    <set android:interpolator=\"@android:anim/accelerate_interpolator\">\n        ...\n    </set>\n    \n自定义插值器\n如果您对平台提供的插值器（在上表中列出）不满意，则可以使用修改过的属性创建自定义插值器资源。例如，您可以调整 AnticipateInterpolator 的加速率或调整 CycleInterpolator 的循环次数。为此，您需要在 XML 文件中创建自己的插值器资源。\n\n文件位置：\nres/anim/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向相应插值器对象的资源指针。\n资源引用：\n在 XML 中：@[package:]anim/filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <InterpolatorName xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:attribute_name=\"value\"\n        />\n    \n如果您不应用任何属性，则您的插值器的运作方式将与平台提供的插值器（在上表中列出）完全相同。\n\n元素：\n请注意，在 XML 中定义的每个 Interpolator 实现的名称都以小写字母开头。\n<accelerateDecelerateInterpolator>\n变化率在开始和结束时缓慢，但在中间会加快。\n没有属性。\n\n<accelerateInterpolator>\n变化率在开始时较为缓慢，然后会加快。\n属性：\n\nandroid:factor\n浮点数。加速率（默认为 1）。\n<anticipateInterpolator>\n先反向变化，然后再急速正向变化。\n属性：\n\nandroid:tension\n浮点数。要应用的张力（默认为 2）。\n<anticipateOvershootInterpolator>\n先反向变化，再急速正向变化并超过目标值，然后以最终值结束。\n属性：\n\nandroid:tension\n浮点数。要应用的张力（默认为 2）。\nandroid:extraTension\n浮点数。张力要乘以的倍数（默认值为 1.5）。\n<bounceInterpolator>\n变化会在结束时退回。\n没有属性。\n\n<cycleInterpolator>\n按指定的循环次数重复动画。变化率符合正弦曲线图。\n属性：\n\nandroid:cycles\n整数。循环次数（默认值为 1）。\n<decelerateInterpolator>\n变化率开始时很快，然后减慢。\n属性：\n\nandroid:factor\n浮点数。减速率（默认值为 1）。\n<linearInterpolator>\n变化率恒定不变。\n没有属性。\n\n<overshootInterpolator>\n先急速正向变化，再超过最终值，然后回到最终值。\n属性：\n\nandroid:tension\n浮点数。要应用的张力（默认为 2）。\n示例：\n保存在 res/anim/my_overshoot_interpolator.xml 的 XML 文件：\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <overshootInterpolator xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:tension=\"7.0\"\n        />\n    \n此动画 XML 将应用插值器：\n\n    <scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:interpolator=\"@anim/my_overshoot_interpolator\"\n        android:fromXScale=\"1.0\"\n        android:toXScale=\"3.0\"\n        android:fromYScale=\"1.0\"\n        android:toYScale=\"3.0\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:duration=\"700\" />\n    \n帧动画\n在 XML 中定义的按顺序显示一系列图片的动画（如电影）。\n\n文件位置：\nres/drawable/filename.xml\n该文件名将用作资源 ID。\n编译后的资源数据类型：\n指向 AnimationDrawable 的资源指针。\n资源引用：\n在 Java 中：R.drawable.filename\n在 XML 中：@[package:]drawable.filename\n语法：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:oneshot=[\"true\" | \"false\"] >\n        <item\n            android:drawable=\"@[package:]drawable/drawable_resource_name\"\n            android:duration=\"integer\" />\n    </animation-list>\n    \n元素：\n<animation-list>\n必需。此元素必须是根元素。包含一个或多个 <item> 元素。\n属性：\n\nandroid:oneshot\n布尔值。如果您想要执行一次动画，则为“true”；如果要循环播放动画，则为“false”。\n<item>\n单帧动画。必须是 <animation-list> 元素的子元素。\n属性：\n\nandroid:drawable\n可绘制资源。要用于此帧的可绘制对象。\nandroid:duration\n整数。显示此帧的持续时间，以毫秒为单位。\n示例：\n保存在 res/drawable/rocket.xml 的 XML 文件：\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:oneshot=\"false\">\n        <item android:drawable=\"@drawable/rocket_thrust1\" android:duration=\"200\" />\n        <item android:drawable=\"@drawable/rocket_thrust2\" android:duration=\"200\" />\n        <item android:drawable=\"@drawable/rocket_thrust3\" android:duration=\"200\" />\n    </animation-list>\n    \n以下应用代码会将该动画设置为 View 的背景，然后播放动画：\n另请参阅：\n2D 图形：帧动画\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242354407},"updatedAt":{"$$date":1597242403503},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"a4sq0zwgBohpdNtc"}
{"name":"py-tuple","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：\n\n>>> classmates = ('Michael', 'Bob', 'Tracy')\n现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。\n\n不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n\ntuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：\n\n>>> t = (1, 2)\n>>> t\n(1, 2)\n如果要定义一个空的tuple，可以写成()：\n\n>>> t = ()\n>>> t\n()\n但是，要定义一个只有1个元素的tuple，如果你这么定义：\n\n>>> t = (1)\n>>> t\n1\n定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。\n\n所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：\n\n>>> t = (1,)\n>>> t\n(1,)\nPython在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。\n\n最后来看一个“可变的”tuple：\n\n>>> t = ('a', 'b', ['A', 'B'])\n>>> t[2][0] = 'X'\n>>> t[2][1] = 'Y'\n>>> t\n('a', 'b', ['X', 'Y'])\n这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？\n\n别急，我们先看看定义的时候tuple包含的3个元素：\n\ntuple-0\n\n当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：\n\ntuple-1\n\n表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973936435},"updatedAt":{"$$date":1594976863644},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"a81dmxIgcDEMynAr"}
{"name":"使用 require 或者 check 函数作为条件检查","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"dart","value":"// 传统的做法\nval age = -1;\nif (age <= 0) {\n    throw IllegalArgumentException(\"age must  not be negative\")\n}\n\n// 使用 require 去检查\nrequire(age > 0) { \"age must be negative\" }\n\n// 使用 checkNotNull 检查\nval name: String? = null\ncheckNotNull(name){\n    \"name must not be null\"\n}\n\n作者：HiDhl\n链接：https://juejin.im/post/5edfd7c9e51d45789a7f206d\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}],"tags":["aZ7LswF9qbcVtQZT"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594728306573},"updatedAt":{"$$date":1594728649563},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[{"name":"kotlin","_id":"aZ7LswF9qbcVtQZT","text":"kotlin"}],"_id":"aOo0gNUoasiSzVMr"}
{"name":"kotlin-集合操作概述 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-operations.html\n集合操作概述 - Kotlin 语言中文站\n9-11 minutes\n改进翻译\nKotlin 标准库提供了用于对集合执行操作的多种函数。这包括简单的操作，例如获取或添加元素，以及更复杂的操作，包括搜索、排序、过滤、转换等。\n\n集合操作在标准库中以两种方式声明：集合接口的成员函数和扩展函数。\n\n成员函数定义了对于集合类型是必不可少的操作。例如，Collection 包含函数 isEmpty() 来检查其是否为空； List 包含用于对元素进行索引访问的 get()，等等。\n\n创建自己的集合接口实现时，必须实现其成员函数。 为了使新实现的创建更加容易，请使用标准库中集合接口的框架实现：AbstractCollection、AbstractList、AbstractSet、AbstractMap 及其相应可变抽象类。\n\n其他集合操作被声明为扩展函数。这些是过滤、转换、排序和其他集合处理功能。\n\n公共操作可用于只读集合与可变集合。 常见操作分为以下几类：\n\n集合转换\n集合过滤\nplus 与 minus 操作符\n分组\n取集合的一部分\n取单个元素\n集合排序\n集合聚合操作\n这些页面中描述的操作将返回其结果，而不会影响原始集合。例如，一个过滤操作产生一个_新集合_，其中包含与过滤谓词匹配的所有元素。 此类操作的结果应存储在变量中，或以其他方式使用，例如，传到其他函数中。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  \n    numbers.filter { it.length > 3 }  // `numbers` 没有任何改变，结果丢失\n    println(\"numbers are still $numbers\")\n    val longerThan3 = numbers.filter { it.length > 3 } // 结果存储在 `longerThan3` 中\n    println(\"numbers longer than 3 chars are $longerThan3\")\n//sampleEnd\n}\n\n对于某些集合操作，有一个选项可以指定 目标 对象。 目标是一个可变集合，该函数将其结果项附加到该可变对象中，而不是在新对象中返回它们。 对于执行带有目标的操作，有单独的函数，其名称中带有 To 后缀，例如，用 filterTo() 代替 filter() 以及用 associateTo() 代替 associate()。 这些函数将目标集合作为附加参数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val filterResults = mutableListOf<String>()  // 目标对象\n    numbers.filterTo(filterResults) { it.length > 3 }\n    numbers.filterIndexedTo(filterResults) { index, _ -> index == 0 }\n    println(filterResults) // 包含两个操作的结果\n//sampleEnd\n}\n为了方便起见，这些函数将目标集合返回了，因此您可以在函数调用的相应参数中直接创建它：\n\nfun main() {\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n//sampleStart\n    // 将数字直接过滤到新的哈希集中，\n    // 从而消除结果中的重复项\n    val result = numbers.mapTo(HashSet()) { it.length }\n    println(\"distinct item lengths are $result\")\n//sampleEnd\n}\n具有目标的函数可用于过滤、关联、分组、展平以及其他操作。 有关目标操作的完整列表，请参见 Kotlin collections reference。\n\n对于可变集合，还存在可更改集合状态的 写操作 。这些操作包括添加、删除和更新元素。写操作在集合写操作以及 List 写操作与 Map 写操作的相应部分中列出。\n\n对于某些操作，有成对的函数可以执行相同的操作：一个函数就地应用该操作，另一个函数将结果作为单独的集合返回。 例如， sort() 就地对可变集合进行排序，因此其状态发生了变化； sorted() 创建一个新集合，该集合包含按排序顺序相同的元素。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    val sortedNumbers = numbers.sorted()\n    println(numbers == sortedNumbers)  // false\n    numbers.sort()\n    println(numbers == sortedNumbers)  // true\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308434927},"updatedAt":{"$$date":1597377733865},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"aQ6x8SNpUseCLwZi"}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244742316},"updatedAt":{"$$date":1597244742316},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"aYoK97UTKLIsw6As"}
{"name":"kotlin-基本语法 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/basic-syntax.html\n基本语法 - Kotlin 语言中文站\n30-38 minutes\n改进翻译\n包的声明应处于源文件顶部：\n\npackage my.demo\n\nimport kotlin.text.*\n\n// ……\n目录与包的结构无需匹配：源代码可以在文件系统的任意位置。\n\n参见包。\n\nKotlin 应用程序的入口点是 main 函数。\n\nfun main() {\n    println(\"Hello world!\")\n}\n带有两个 Int 参数、返回 Int 的函数：\n\n//sampleStart\nfun sum(a: Int, b: Int): Int {\n    return a + b\n}\n//sampleEnd\n\nfun main() {\n    print(\"sum of 3 and 5 is \")\n    println(sum(3, 5))\n}\n将表达式作为函数体、返回值类型自动推断的函数：\n\n//sampleStart\nfun sum(a: Int, b: Int) = a + b\n//sampleEnd\n\nfun main() {\n    println(\"sum of 19 and 23 is ${sum(19, 23)}\")\n}\n函数返回无意义的值：\n\n//sampleStart\nfun printSum(a: Int, b: Int): Unit {\n    println(\"sum of $a and $b is ${a + b}\")\n}\n//sampleEnd\n\nfun main() {\n    printSum(-1, 8)\n}\nUnit 返回类型可以省略：\n\n//sampleStart\nfun printSum(a: Int, b: Int) {\n    println(\"sum of $a and $b is ${a + b}\")\n}\n//sampleEnd\n\nfun main() {\n    printSum(-1, 8)\n}\n参见函数。\n\n定义只读局部变量使用关键字 val 定义。只能为其赋值一次。\n\nfun main() {\n//sampleStart\n    val a: Int = 1  // 立即赋值\n    val b = 2   // 自动推断出 `Int` 类型\n    val c: Int  // 如果没有初始值类型不能省略\n    c = 3       // 明确赋值\n//sampleEnd\n    println(\"a = $a, b = $b, c = $c\")\n}\n可重新赋值的变量使用 var 关键字：\n\nfun main() {\n//sampleStart\n    var x = 5 // 自动推断出 `Int` 类型\n    x += 1\n//sampleEnd\n    println(\"x = $x\")\n}\n顶层变量：\n\n//sampleStart\nval PI = 3.14\nvar x = 0\n\nfun incrementX() { \n    x += 1 \n}\n//sampleEnd\n\nfun main() {\n    println(\"x = $x; PI = $PI\")\n    incrementX()\n    println(\"incrementX()\")\n    println(\"x = $x; PI = $PI\")\n}\n参见属性与字段。\n\n与大多数现代语言一样，Kotlin 支持单行（或行末）与多行（块）注释。\n\n// 这是一个行注释\n\n/* 这是一个多行的\n   块注释。 */\nKotlin 中的块注释可以嵌套。\n\n/* 注释从这里开始\n/* 包含嵌套的注释 */     \n并且在这里结束。 */\n参见编写 Kotlin 代码文档 查看关于文档注释语法的信息。\n\nfun main() {\n//sampleStart\n    var a = 1\n    // 模板中的简单名称：\n    val s1 = \"a is $a\" \n    \n    a = 2\n    // 模板中的任意表达式：\n    val s2 = \"${s1.replace(\"is\", \"was\")}, but now is $a\"\n//sampleEnd\n    println(s2)\n}\n参见字符串模板。\n\n//sampleStart\nfun maxOf(a: Int, b: Int): Int {\n    if (a > b) {\n        return a\n    } else {\n        return b\n    }\n}\n//sampleEnd\n\nfun main() {\n    println(\"max of 0 and 42 is ${maxOf(0, 42)}\")\n}\n在 Kotlin 中，if 也可以用作表达式：\n\n//sampleStart\nfun maxOf(a: Int, b: Int) = if (a > b) a else b\n//sampleEnd\n\nfun main() {\n    println(\"max of 0 and 42 is ${maxOf(0, 42)}\")\n}\n参见if 表达式。\n\n空值与 null 检测\n当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空。\n\n如果 str 的内容不是数字返回 null：\n\nfun parseInt(str: String): Int? {\n    // ……\n}\n使用返回可空值的函数:\n\nfun parseInt(str: String): Int? {\n    return str.toIntOrNull()\n}\n\n//sampleStart\nfun printProduct(arg1: String, arg2: String) {\n    val x = parseInt(arg1)\n    val y = parseInt(arg2)\n\n    // 直接使用 `x * y` 会导致编译错误，因为它们可能为 null\n    if (x != null && y != null) {\n        // 在空检测后，x 与 y 会自动转换为非空值（non-nullable）\n        println(x * y)\n    }\n    else {\n        println(\"'$arg1' or '$arg2' is not a number\")\n    }    \n}\n//sampleEnd\n\n\nfun main() {\n    printProduct(\"6\", \"7\")\n    printProduct(\"a\", \"7\")\n    printProduct(\"a\", \"b\")\n}\n或者\n\nfun parseInt(str: String): Int? {\n    return str.toIntOrNull()\n}\n\nfun printProduct(arg1: String, arg2: String) {\n    val x = parseInt(arg1)\n    val y = parseInt(arg2)\n    \n//sampleStart\n    // ……\n    if (x == null) {\n        println(\"Wrong number format in arg1: '$arg1'\")\n        return\n    }\n    if (y == null) {\n        println(\"Wrong number format in arg2: '$arg2'\")\n        return\n    }\n\n    // 在空检测后，x 与 y 会自动转换为非空值\n    println(x * y)\n//sampleEnd\n}\n\nfun main() {\n    printProduct(\"6\", \"7\")\n    printProduct(\"a\", \"7\")\n    printProduct(\"99\", \"b\")\n}\n参见空安全。\n\n类型检测与自动类型转换\nis 运算符检测一个表达式是否某类型的一个实例。 如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换：\n\n//sampleStart\nfun getStringLength(obj: Any): Int? {\n    if (obj is String) {\n        // `obj` 在该条件分支内自动转换成 `String`\n        return obj.length\n    }\n\n    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型\n    return null\n}\n//sampleEnd\n\n\nfun main() {\n    fun printLength(obj: Any) {\n        println(\"'$obj' string length is ${getStringLength(obj) ?: \"... err, not a string\"} \")\n    }\n    printLength(\"Incomprehensibilities\")\n    printLength(1000)\n    printLength(listOf(Any()))\n}\n或者\n\n//sampleStart\nfun getStringLength(obj: Any): Int? {\n    if (obj !is String) return null\n\n    // `obj` 在这一分支自动转换为 `String`\n    return obj.length\n}\n//sampleEnd\n\n\nfun main() {\n    fun printLength(obj: Any) {\n        println(\"'$obj' string length is ${getStringLength(obj) ?: \"... err, not a string\"} \")\n    }\n    printLength(\"Incomprehensibilities\")\n    printLength(1000)\n    printLength(listOf(Any()))\n}\n甚至\n\n//sampleStart\nfun getStringLength(obj: Any): Int? {\n    // `obj` 在 `&&` 右边自动转换成 `String` 类型\n    if (obj is String && obj.length > 0) {\n      return obj.length\n    }\n\n    return null\n}\n//sampleEnd\n\n\nfun main() {\n    fun printLength(obj: Any) {\n        println(\"'$obj' string length is ${getStringLength(obj) ?: \"... err, is empty or not a string at all\"} \")\n    }\n    printLength(\"Incomprehensibilities\")\n    printLength(\"\")\n    printLength(1000)\n}\n参见类以及类型转换。\n\nfun main() {\n//sampleStart\n    val items = listOf(\"apple\", \"banana\", \"kiwifruit\")\n    for (item in items) {\n        println(item)\n    }\n//sampleEnd\n}\n或者\n\nfun main() {\n//sampleStart\n    val items = listOf(\"apple\", \"banana\", \"kiwifruit\")\n    for (index in items.indices) {\n        println(\"item at $index is ${items[index]}\")\n    }\n//sampleEnd\n}\n参见 for 循环。\n\nfun main() {\n//sampleStart\n    val items = listOf(\"apple\", \"banana\", \"kiwifruit\")\n    var index = 0\n    while (index < items.size) {\n        println(\"item at $index is ${items[index]}\")\n        index++\n    }\n//sampleEnd\n}\n参见 while 循环。\n\n//sampleStart\nfun describe(obj: Any): String =\n    when (obj) {\n        1          -> \"One\"\n        \"Hello\"    -> \"Greeting\"\n        is Long    -> \"Long\"\n        !is String -> \"Not a string\"\n        else       -> \"Unknown\"\n    }\n//sampleEnd\n\nfun main() {\n    println(describe(1))\n    println(describe(\"Hello\"))\n    println(describe(1000L))\n    println(describe(2))\n    println(describe(\"other\"))\n}\n参见 when 表达式。\n\n使用 in 运算符来检测某个数字是否在指定区间内：\n\nfun main() {\n//sampleStart\n    val x = 10\n    val y = 9\n    if (x in 1..y+1) {\n        println(\"fits in range\")\n    }\n//sampleEnd\n}\n检测某个数字是否在指定区间外:\n\nfun main() {\n//sampleStart\n    val list = listOf(\"a\", \"b\", \"c\")\n    \n    if (-1 !in 0..list.lastIndex) {\n        println(\"-1 is out of range\")\n    }\n    if (list.size !in list.indices) {\n        println(\"list size is out of valid list indices range, too\")\n    }\n//sampleEnd\n}\n区间迭代:\n\nfun main() {\n//sampleStart\n    for (x in 1..5) {\n        print(x)\n    }\n//sampleEnd\n}\n或数列迭代：\n\nfun main() {\n//sampleStart\n    for (x in 1..10 step 2) {\n        print(x)\n    }\n    println()\n    for (x in 9 downTo 0 step 3) {\n        print(x)\n    }\n//sampleEnd\n}\n参见区间。\n\n对集合进行迭代:\n\nfun main() {\n    val items = listOf(\"apple\", \"banana\", \"kiwifruit\")\n//sampleStart\n    for (item in items) {\n        println(item)\n    }\n//sampleEnd\n}\n使用 in 运算符来判断集合内是否包含某实例：\n\nfun main() {\n    val items = setOf(\"apple\", \"banana\", \"kiwifruit\")\n//sampleStart\n    when {\n        \"orange\" in items -> println(\"juicy\")\n        \"apple\" in items -> println(\"apple is fine too\")\n    }\n//sampleEnd\n}\n使用 lambda 表达式来过滤（filter）与映射（map）集合：\n\nfun main() {\n//sampleStart\n    val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\")\n    fruits\n      .filter { it.startsWith(\"a\") }\n      .sortedBy { it }\n      .map { it.toUpperCase() }\n      .forEach { println(it) }\n//sampleEnd\n}\n参见集合概述。\n\nfun main() {\n//sampleStart\n    val rectangle = Rectangle(5.0, 2.0)\n    val triangle = Triangle(3.0, 4.0, 5.0)\n//sampleEnd\n    println(\"Area of rectangle is ${rectangle.calculateArea()}, its perimeter is ${rectangle.perimeter}\")\n    println(\"Area of triangle is ${triangle.calculateArea()}, its perimeter is ${triangle.perimeter}\")\n}\n\nabstract class Shape(val sides: List<Double>) {\n    val perimeter: Double get() = sides.sum()\n    abstract fun calculateArea(): Double\n}\n\ninterface RectangleProperties {\n    val isSquare: Boolean\n}\n\nclass Rectangle(\n    var height: Double,\n    var length: Double\n) : Shape(listOf(height, length, height, length)), RectangleProperties {\n    override val isSquare: Boolean get() = length == height\n    override fun calculateArea(): Double = height * length\n}\n\nclass Triangle(\n    var sideA: Double,\n    var sideB: Double,\n    var sideC: Double\n) : Shape(listOf(sideA, sideB, sideC)) {\n    override fun calculateArea(): Double {\n        val s = perimeter / 2\n        return Math.sqrt(s * (s - sideA) * (s - sideB) * (s - sideC))\n    }\n}\n参见类以及对象与实例。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304157492},"updatedAt":{"$$date":1597306061214},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"b1scXF7M7CPUDuK9"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977501879},"updatedAt":{"$$date":1594977501879},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bH7bL4r3r4eFTEsz"}
{"name":"py-空值","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。\n\n此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973927062},"updatedAt":{"$$date":1594974238383},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bPhh96qnfrGP3Abm"}
{"name":"andr-应用权限最佳做法","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/permissions/usage-notes\n应用权限最佳做法  |  Android 开发者  |  Android Developers\n8-9 minutes\n权限请求可以保护设备中的敏感信息，仅当需要访问敏感信息才能使应用正常运行时，才应使用权限请求。利用本文档介绍的技巧，您无需访问此类信息即可实现相同（或更好的）功能；但本文不会详细讨论权限在 Android 操作系统中的工作方式。\n\n如需大致了解 Android 权限，请参阅权限概览。如需详细了解如何在代码中使用权限，请参阅请求应用权限。\n\n使用 Android 权限的原则\n使用 Android 权限时，我们建议遵循以下原则：\n\n1：仅使用应用正常工作所需的权限。根据您使用权限的方式，您可以通过其他方式执行所需的操作（系统 intent、标识符、电话后台处理），而无需依赖于访问敏感信息。\n\n2：注意库所需的权限。添加某个库时，您也会继承它的权限要求。您应了解您正在添加的库、它们需要的权限以及这些权限的用途。\n\n3：公开透明。请求权限时，请清晰说明您要访问的内容以及访问原因，以便用户可以做出明智的决策。在请求权限时（包括安装、运行时或更新权限对话框）提供这些信息。\n\n4：以显式方式访问系统。在访问敏感功能（例如，相机或麦克风）时提供连续指示，让用户知道您在收集数据，避免让他们认为您在偷偷地收集数据。\n\n本指南其余部分将以开发 Android 应用为背景详细介绍这些规则。\n\nAndroid 6.0 及更高版本中的权限\nAndroid 6.0 Marshmallow 引入了一种新的权限模式，让应用可以在运行时而不是安装之前向用户请求权限。支持这个新模式的应用会在应用确实需要相关服务或这些服务保护的数据时请求权限。尽管这不会（不一定会）改变整体应用行为，但会给敏感用户数据的处理方式带来一些变化：\n\n增加了情境背景信息：系统会在运行时在应用的情境中，提示用户提供访问相关权限组涵盖的功能所需的权限。用户对请求权限的情境更加敏感，如果您请求的权限与应用的用途不匹配，那么更需要向用户详细解释您为什么请求此权限；您应尽可能在请求时以及万一用户拒绝请求后出现的后续对话框中解释您的请求。\n\n在授予权限时更加灵活：用户可以在收到请求时以及在设置中拒绝单个权限，但是当功能因此而中断时，他们可能仍会感到惊讶。最好监控有多少用户拒绝权限请求，例如使用 Google Analytics（分析）进行监控，以便重构应用以避免依赖该权限，或更好地解释应用需要此权限才能正常工作的原因。您还应确保应用可以处理当用户拒绝权限请求或在设置中停用权限时产生的异常。\n\n增加了事务负担：系统将要求用户单独授予权限组的访问权限，而不是以集合的形式授予。这样，最大程度降低请求的权限数量就变得非常重要，因为数量多会增加用户授予权限的负担，并且会增大至少有一个请求被拒绝的概率。\n\n需要成为默认处理程序的权限\n有些应用依赖于访问与调用日志和短信有关的敏感用户信息。如果您想请求特定于通话记录和短信的权限，并将应用发布到 Play 商店，则必须在请求这些运行时权限之前，提示用户将应用设置为默认处理程序以获得核心系统功能。\n\n如需详细了解默认处理程序，包括有关如何向用户显示默认处理程序提示的指南，请参阅有关仅在默认处理程序中使用的权限的指南。\n\n避免请求不必要的权限\n每次您请求某个权限时，都是在强迫用户做出决定。应尽量减少提出这些请求的次数。如果用户运行的是 Android 6.0（API 级别 23）或更高版本，则每次用户尝试要求提供权限的新应用功能时，应用都必须中断用户的操作并发起权限请求。如果用户运行的是更低版本的 Android，则在安装应用时需要授予应用每一项权限；如果权限列表过长或看起来不合适，用户可能会决定不安装该应用。因此，应尽量减少应用需要的权限数量。\n\n本部分提供了常见用例的替代方法，有助于降低提出权限请求的次数。与其他请求较少权限的类似应用相比，向用户请求更多数量和类型的权限会影响下载量，因此最好避免为不必要的功能请求权限。\n\n改用 intent\n在许多情况下，要让应用执行某项任务，有两种方法供您选择。应用可以要求提供权限以自行执行该任务，也可以使用 intent 让其他应用执行该任务。\n\n例如，假设应用需要使用设备摄像头拍摄照片。应用可以请求 CAMERA 权限，从而直接访问摄像头。然后，应用将使用 Camera API 控制摄像头并拍摄照片。此方法使应用能够完全控制拍摄过程，并且您可以将摄像头界面整合到应用中。\n\n不过，如果您很少需要访问用户数据，换句话说，每次您需要访问数据时都向用户显示运行时对话框，这种中断操作并非不可接受，那么您可以使用基于 intent 的请求。Android 提供了一些系统 intent，应用可使用这些 intent 而无需请求权限，因为在发出基于 intent 的请求时用户会选择与应用共享的内容（如果有）。\n\n例如，您可以使用 MediaStore.ACTION_IMAGE_CAPTURE 或 MediaStore.ACTION_VIDEO_CAPTURE intent 操作类型拍摄图像或视频，无需直接使用 Camera 对象（或请求权限）。在这种情况下，每次拍摄图像时，系统 intent 都会代表您请求用户提供权限。\n\n同样，如果您需要拨打电话、访问用户的联系人或执行其他操作，可以通过创建适当的 intent 完成，也可以直接请求权限并访问相应的对象。每种方法各有优缺点。\n\n如果使用权限：\n\n当应用执行操作时，应用可以完全控制用户体验。不过，如此广泛的控制会增加代码的复杂性，因为您需要设计适当的界面。\n系统会在运行时或安装时（具体取决于用户的 Android 版本）提示用户授予权限一次。之后，应用即可执行操作，不再需要用户进行其他互动。不过，如果用户未授予权限（或之后撤消权限），则应用根本无法执行该操作。\n如果使用 intent：\n\n您不必为操作设计界面。处理 intent 的应用将提供界面。\n用户可以使用他们首选的应用执行任务。例如，用户可以选择用他们喜爱的照片应用拍照。\n如果用户没有执行相应操作的默认应用，则系统会提示用户选择应用。如果用户未指定默认处理程序，则必须在每次执行此操作时都要额外处理一个对话框。\n不要让用户感到无所适从\n如果用户运行的是 Android 6.0（API 级别 23）或更高版本，则用户必须在运行应用时为其授予权限。如果您让用户一次面对大量权限请求，用户可能会感到无所适从并因此退出应用。替代做法是，您应根据需要请求权限。\n\n在某些情况下，一项或几项权限可能对您的应用来说必不可少。在这种情况下，合理的做法是，在应用启动之后立即请求所有这些权限。例如，如果您创建的是摄影应用，则该应用将需要访问设备的摄像头。当用户首次启动该应用时，系统会要求他们提供摄像头使用权限，这不会令他们感到惊讶。 但是，如果同一应用还具备与用户联系人分享照片的功能，则您最好不要在应用首次启动时就要求用户提供 READ_CONTACTS 权限，而应等到用户尝试使用“分享”功能之后再请求该权限。\n\n如果应用提供教程，则合理的做法是，在教程结束时请求提供应用的必要权限。\n\n失去音频焦点后暂停媒体\n在这种情况下，用户接到电话时您的应用需要转入后台，只有在通话停止后才会重新获得焦点。\n\n对于此类情况，例如，媒体播放器在手机通话期间静音或暂停，通常采用的方法是使用 PhoneStateListener 监听通话状态有无变化或监听 android.intent.action.PHONE_STATE 的广播。这种解决方案的问题是它需要 READ_PHONE_STATE 权限，这将强制用户授予对各种敏感数据的访问权限，如用户的设备和 SIM 硬件 ID 以及来电的电话号码。此外，当应用在 Android 10（API 级别 29）或更高版本上运行时，LISTEN_CELL_LOCATION 和 LISTEN_CELL_INFO 事件需要位置权限（具体而言，当应用以 Android 10 或更高版本为目标平台时将需要 ACCESS_FINE_LOCATION）。\n\n您可以通过为应用请求 AudioFocus，在没有 READ_PHONE_STATE 或 MODIFY_PHONE_STATE 权限的情况下检测用户是否在通话中，这么做不需要显式权限（因为不访问敏感信息）。只需将让音频在后台运行所需的代码放入 onAudioFocusChange() 事件处理程序，当操作系统切换其音频焦点时，该代码将自动运行。如需详细了解如何执行此操作，请参阅此文档。\n\n确定正在运行实例的设备\n在这种情况下，您需要一个唯一标识符来确定应用实例正在哪个设备上运行。\n\n应用可能具有设备特定的偏好设置或消息，例如，在云端为用户保存设备特定的播放列表，以便他们在车上和家里可以有不同的播放列表。常见的解决方案是利用设备标识符（如 Device IMEI），但这需要 Device ID and call information 权限组（在搭载 M 及更高版本的设备中为 PHONE）。它还使用一个无法重置且在所有应用之间共享的标识符。\n\n下面两种方法可以替代这些类型的标识符：\n\n使用 com.google.android.gms.iid InstanceID API。 getInstance(Context context).getID() 将为您的应用实例返回一个唯一设备标识符。结果是一个应用实例范围标识符，在存储与应用有关的信息时可以将该标识符用作密钥，在用户重新安装应用时该标识符将重置。\n使用 randomUUID() 之类的基本系统函数创建您自己的标识符，其范围限定为应用的存储空间。\n为广告或用户分析创建唯一标识符\n在这种情况下，您需要使用一个唯一标识符为没有登录应用的用户构建个人资料（例如，用于广告定位或衡量转化率）。\n\n为广告和用户分析构建个人资料有时需要一个在其他应用之间共享的标识符。此问题的常见解决方法包括有效利用设备标识符（例如 Device IMEI），设备标识符需要 Device ID and call information 权限组（在 API 级别 23 及更高级别中为 PHONE），并且无法由用户重置。如果出现上述任何情况，除了使用不可重置的标识符并请求用户可能认为不寻常的权限外，还会违反 Play 开发者计划政策。\n\n遗憾的是，由于 ID 可能需要在各个应用中共享，在这些情况下使用 com.google.android.gms.iid InstanceID API 或系统函数创建应用作用域 ID 并不是适当的解决方法。一种替代解决方法是使用通过 getId() 方法从 AdvertisingIdClient.Info 类中获取的 Advertising Identifier。您可以使用 getAdvertisingIdInfo(Context) 方法创建一个 AdvertisingIdClient.Info 对象，并调用 getId() 方法以使用标识符。请注意，此方法会造成堵塞，因此，您不应从主线程调用它；有关此方法的详细说明，请点击此处。\n\n了解您正在使用的库\n有时，您在应用中使用的库需要权限。例如，广告和分析库可能需要访问 LOCATION 权限组以实现必需的功能。但从用户的角度来看，权限请求来自于您的应用，而不是库。\n\n就像用户会选择使用较少权限即可实现相同功能的应用一样，开发者也应检查他们的库，并选择不会使用非必要权限的第三方 SDK。例如，如果您使用的库提供了定位功能，请确保您不会请求 FINE_LOCATION 权限，除非您要使用基于位置的定位功能。\n\n限制对位置信息的后台使用权\n当您的应用在后台运行时，访问位置信息应该对应用的核心功能至关重要，并为用户带来明显的好处。\n\n解释为何需要权限\n系统在您调用 requestPermissions() 时显示的权限对话框将说明应用需要哪些权限，但不会解释为何需要这些权限。在某些情况下，用户可能会感到困惑。因此，最好在调用 requestPermissions() 之前向用户解释应用需要相应权限的原因。\n\n研究表明，如果用户知道应用需要相应权限的原因，他们会更容易接受权限请求。用户研究表明：\n\n用户是否愿意为某个移动应用授予给定权限，在很大程度上受此类权限关联用途的影响。例如，用户是否愿意授予访问其位置的访问权限取决于该权限请求是否为支持应用的核心功能所必需，或者应用是否会与广告网络或分析公司分享此信息。1\n\n卡内基梅隆大学 (CMU) 的 Jason Hong 教授根据他所带领的小组的研究成果得出一个一般结论：\n\n...与只是告诉用户应用正在使用其位置信息相比，如果用户知道应用为什么使用像他们的位置这样敏感的信息（例如，用于定向广告），用户会更容易接受。1\n\n因此，如果您仅使用归入权限组的一小部分 API 调用，明确列出您使用哪些权限以及使用原因会非常有用。例如：\n\n如果您仅使用粗略位置，请在应用说明或应用帮助文档中告知用户。\n如果您需要访问短信以接收身份验证码，从而防止用户被欺诈，请在应用说明中和/或首次访问数据时告知用户。\n\n注意：如果应用面向 Android 8.0（API 级别 26）或更高版本，请不要在验证用户凭据过程中请求 READ_SMS 权限，而应使用 createAppSpecificSmsToken() 生成应用特定的令牌，然后将此令牌传递给可以发送验证短信的其他应用或服务。\n\n在特定条件下，让用户实时了解应用在访问敏感数据也是非常有益的。例如，如果您要访问相机或麦克风，通常最好在应用中的某个位置或在通知托盘中（如果应用正在后台运行）使用通知图标通知用户，从而不会让您看上去是在偷偷地收集数据。\n\n最后，如果您需要请求权限以便在应用中运行某项功能，但用户不清楚原因，则需要找到一种方法让用户知道您为什么需要最敏感的权限。\n\n测试两种权限模型\n从 Android 6.0（API 级别 23）开始，用户将在运行时授予和撤消应用权限，而不是在安装应用时授予和撤消应用权限。因此，您必须在更广泛的条件下测试应用。在低于 Android 6.0 的版本中，您可以合理地认为，如果应用能运行，它就已经获得在应用清单中声明的全部权限。自 Android 6.0 起，用户可以开启或关闭任何应用的权限，即使面向 API 级别 22 或更低级别的应用也是如此。您应测试以确保您的应用能正常运行，无论它是否具有任何权限。\n\n以下提示可帮助您在搭载 API 级别 23 或更高级别的设备上找出与权限有关的代码问题：\n\n确定应用的当前权限和相关的代码路径。\n在各种受权限保护的服务和数据中测试用户流。\n使用授予或撤消权限的各种组合进行测试。例如，相机应用可能会在清单中列出 CAMERA、READ_CONTACTS 和 ACCESS_FINE_LOCATION。您应在测试该应用时逐一开启和关闭这些权限，确保应用可以妥善处理所有权限配置。\n使用 adb 工具从命令行管理权限：\n按组列出权限和状态：\n$ adb shell pm list permissions -d -g\n授予或撤消一项或多项权限：\n$ adb shell pm [grant|revoke] <permission-name> ...\n针对使用权限的服务对应用进行分析。\n其他资源\nAndroid 权限的 Material Design 准则\nAndroid Marshmallow 6.0：请求权限 - 此视频介绍了 Android 运行时权限模式以及请求用户提供权限的正确方法。\n解释为什么应用需要权限\n唯一标识符最佳做法\n参考\n[1] Modeling Users’ Mobile App Privacy Preferences: Restoring Usability in a Sea of Permission Settings，作者：J. Lin B. Liu、N. Sadeh 和 J. Hong。发表于 2014 年 SOUPS 会议记录。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242657709},"updatedAt":{"$$date":1597243512187},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bSU4kn5xx529kO0k"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980165074},"updatedAt":{"$$date":1594980165074},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bSw3Z8Ew5wjZaP3n"}
{"name":"andr-与其他 Fragment 通信 ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /training/basics/fragments/communicating\n与其他 Fragment 通信  |  Android 开发者  |  Android Developers\n7-9 minutes\n为了重复使用 Fragment 界面组件，您应将每个组件构建为一个完全独立的模块化组件，定义它自己的布局和行为。定义这些可重用的 Fragment 后，您可以将它们与 Activity 相关联，并将其与应用逻辑相关联以实现整个复合界面。\n\n您经常需要一个 Fragment 与另一个 Fragment 通信，比如为了根据用户事件更改内容。所有 Fragment 到 Fragment 的通信都是通过共享的 ViewModel 或关联的 Activity 来完成的。两个 Fragment 绝不能直接通信。\n\n如需在 Fragment 之间通信，建议创建一个共享的 ViewModel 对象。两个 Fragment 都可以通过所在的 Activity 访问 ViewModel。Fragment 可在 ViewModel 内更新数据，如果使用 LiveData 公开该数据，新状态会被推送至其他 Fragment（只要它正在从 ViewModel 观察 LiveData）。要了解如何实现这种通信机制，请参阅 ViewModel 指南中的“在 Fragment 之间共享数据”部分。\n\n如果无法使用共享的 ViewModel 在 Fragment 之间进行通信，可以使用接口手动实现通信机制。但是，这种方式最终需要实现更多的工作，并且无法在其他 Fragment 中轻松重用。\n\n定义接口\n要允许 Fragment 与其 Activity 进行通信，可以在 Fragment 类中定义接口并在 Activity 中实现该接口。Fragment 在其 onAttach() 生命周期方法中捕获接口实现，然后可以调用接口方法，以便与 Activity 通信。\n\n以下是 Fragment 到 Activity 通信的示例：\n\nHeadlinesFragment\n\n    class HeadlinesFragment : ListFragment() {\n        internal var callback: OnHeadlineSelectedListenerfun setOnHeadlineSelectedListener(callback: OnHeadlineSelectedListener) {\n            this.callback = callback\n        }// This interface can be implemented by the Activity, parent Fragment,\n        // or a separate test implementation.\n        interface OnHeadlineSelectedListener {\n            fun onArticleSelected(position: Int)\n        }// ...\n    }\n    \n    public class HeadlinesFragment extends ListFragment {\n        OnHeadlineSelectedListener callback;public void setOnHeadlineSelectedListener(OnHeadlineSelectedListener callback) {\n            this.callback = callback;\n        }// This interface can be implemented by the Activity, parent Fragment,\n        // or a separate test implementation.\n        public interface OnHeadlineSelectedListener {\n            public void onArticleSelected(int position);\n        }// ...\n    }\n    \nMainActivity\n\n    class MainActivity : Activity(), HeadlinesFragment.OnHeadlineSelectedListener {\n        // ...fun onAttachFragment(fragment: Fragment) {\n            if (fragment is HeadlinesFragment) {\n                fragment.setOnHeadlineSelectedListener(this)\n            }\n        }\n    }\n    \n    public static class MainActivity extends Activity\n            implements HeadlinesFragment.OnHeadlineSelectedListener{\n        // ...@Override\n        public void onAttachFragment(Fragment fragment) {\n            if (fragment instanceof HeadlinesFragment) {\n                HeadlinesFragment headlinesFragment = (HeadlinesFragment) fragment;\n                headlinesFragment.setOnHeadlineSelectedListener(this);\n            }\n        }\n    }\n    \n现在，Fragment 可以使用 OnHeadlineSelectedListener 接口的 mCallback 实例调用 onArticleSelected() 方法（或接口中的其他方法），从而向 Activity 传递消息。\n\n例如，当用户点击列表项时，系统会调用 Fragment 中的以下方法。Fragment 使用回调接口将事件传递给父 Activity。\n\n    override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) {\n        // Send the event to the host activity\n        callback.onArticleSelected(position)\n    }\n    \n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Send the event to the host activity\n        callback.onArticleSelected(position);\n    }\n    \n实现接口\n要从 Fragment 接收事件回调，托管它的 Activity 必须实现 Fragment 类中定义的接口。\n\n例如，以下 Activity 将实现上述示例中的接口。\n\n    class MainActivity : Activity(), HeadlinesFragment.OnHeadlineSelectedListener {\n        ...fun onArticleSelected(position: Int) {\n            // The user selected the headline of an article from the HeadlinesFragment\n            // Do something here to display that article\n        }\n    }\n    \n    public static class MainActivity extends Activity\n            implements HeadlinesFragment.OnHeadlineSelectedListener{\n        ...public void onArticleSelected(int position) {\n            // The user selected the headline of an article from the HeadlinesFragment\n            // Do something here to display that article\n        }\n    }\n    \n将消息传递到 Fragment\n托管 Activity 可通过使用 findFragmentById() 捕获 Fragment 实例，将消息传递到 Fragment，然后直接调用 Fragment 的公共方法。\n\n例如，假设上方所示的 Activity 可能包含另一个 Fragment，该 Fragment 用于显示由上述回调方法中返回的数据指定的项。在这种情况下，Activity 可以将回调方法中收到的信息传递给显示该项的另一个 Fragment：\n\n    class MainActivity : Activity(), HeadlinesFragment.OnHeadlineSelectedListener {\n        ...fun onArticleSelected(position: Int) {\n            // The user selected the headline of an article from the HeadlinesFragment\n            // Do something here to display that articleval articleFrag = supportFragmentManager.findFragmentById(R.id.article_fragment) as ArticleFragment?if (articleFrag != null) {\n                // If article frag is available, we're in two-pane layout...// Call a method in the ArticleFragment to update its content\n                articleFrag.updateArticleView(position)\n            } else {\n                // Otherwise, we're in the one-pane layout and must swap frags...\n                // Create fragment and give it an argument for the selected article\n                val newFragment = ArticleFragment()\n                val args = Bundle()\n                args.putInt(ArticleFragment.ARG_POSITION, position)\n                newFragment.arguments = argsval transaction = supportFragmentManager.beginTransaction()// Replace whatever is in the fragment_container view with this fragment,\n                // and add the transaction to the back stack so the user can navigate back\n                transaction.replace(R.id.fragment_container, newFragment)\n                transaction.addToBackStack(null)// Commit the transaction\n                transaction.commit()\n            }\n        }\n    }\n    \n    public static class MainActivity extends Activity\n            implements HeadlinesFragment.OnHeadlineSelectedListener{\n        ...public void onArticleSelected(int position) {\n            // The user selected the headline of an article from the HeadlinesFragment\n            // Do something here to display that articleArticleFragment articleFrag = (ArticleFragment)\n                    getSupportFragmentManager().findFragmentById(R.id.article_fragment);if (articleFrag != null) {\n                // If article frag is available, we're in two-pane layout...// Call a method in the ArticleFragment to update its content\n                articleFrag.updateArticleView(position);\n            } else {\n                // Otherwise, we're in the one-pane layout and must swap frags...// Create fragment and give it an argument for the selected article\n                ArticleFragment newFragment = new ArticleFragment();\n                Bundle args = new Bundle();\n                args.putInt(ArticleFragment.ARG_POSITION, position);\n                newFragment.setArguments(args);FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,\n                // and add the transaction to the back stack so the user can navigate back\n                transaction.replace(R.id.fragment_container, newFragment);\n                transaction.addToBackStack(null);// Commit the transaction\n                transaction.commit();\n            }\n        }\n    }\n    \n要详细了解如何实现 Fragment，请参阅 Fragment。 您还可以浏览相关示例应用了解详情。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243446745},"updatedAt":{"$$date":1597243931427},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"bVPgc5Itbj0XOAoR"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973266120},"updatedAt":{"$$date":1594973266120},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cPPproC0uX9yAiHJ"}
{"name":"kotlin-基本类型：数字、字符串、数组 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/basic-types.html\n基本类型：数字、字符串、数组 - Kotlin 语言中文站\n32-39 minutes\n改进翻译\n在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。 一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。 在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。\n\nKotlin 提供了一组表示数字的内置类型。 对于整数，有四种不同大小的类型，因此值的范围也不同。\n\n类型\t大小（比特数）\t最小值\t最大值\nByte\t8\t-128\t127\nShort\t16\t-32768\t32767\nInt\t32\t-2,147,483,648 (-231)\t2,147,483,647 (231 - 1)\nLong\t64\t-9,223,372,036,854,775,808 (-263)\t9,223,372,036,854,775,807 (263 - 1)\n所有以未超出 Int 最大值的整型值初始化的变量都会推断为 Int 类型。如果初始值超过了其最大值，那么推断为 Long 类型。 如需显式指定 Long 型值，请在该值后追加 L 后缀。\n\nval one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1\n对于浮点数，Kotlin 提供了 Float 与 Double 类型。 根据 IEEE 754 标准， 两种浮点类型的十进制位数（即可以存储多少位十进制数）不同。 Float 反映了 IEEE 754 单精度，而 Double 提供了双精度。\n\n类型\t大小（比特数）\t有效数字比特数\t指数比特数\t十进制位数\nFloat\t32\t24\t8\t6-7\nDouble\t64\t53\t11\t15-16\n对于以小数初始化的变量，编译器会推断为 Double 类型。 如需将一个值显式指定为 Float 类型，请添加 f 或 F 后缀。 如果这样的值包含多于 6～7 位十进制数，那么会将其舍入。\n\nval pi = 3.14 // Double\nval e = 2.7182818284 // Double\nval eFloat = 2.7182818284f // Float，实际值为 2.7182817\n请注意，与一些其他语言不同，Kotlin 中的数字没有隐式拓宽转换。 例如，具有 Double 参数的函数只能对 Double 值调用，而不能对 Float、 Int 或者其他数字值调用。\n\nfun main() {\n    fun printDouble(d: Double) { print(d) }\n\n    val i = 1    \n    val d = 1.1\n    val f = 1.1f \n\n    printDouble(d)\n//    printDouble(i) // 错误：类型不匹配\n//    printDouble(f) // 错误：类型不匹配\n}\n如需将数值转换为不同的类型，请使用显示转换。\n\n数值常量字面值有以下几种:\n\n十进制: 123\nLong 类型用大写 L 标记: 123L\n十六进制: 0x0F\n二进制: 0b00001011\n注意: 不支持八进制\n\nKotlin 同样支持浮点数的常规表示方法:\n\n默认 double：123.5、123.5e10\nFloat 用 f 或者 F 标记: 123.5f\n你可以使用下划线使数字常量更易读：\n\nval oneMillion = 1_000_000\nval creditCardNumber = 1234_5678_9012_3456L\nval socialSecurityNumber = 999_99_9999L\nval hexBytes = 0xFF_EC_DE_5E\nval bytes = 0b11010010_01101001_10010100_10010010\n在 Java 平台数字是物理存储为 JVM 的原生类型，除非我们需要一个可空的引用（如 Int?）或泛型。 后者情况下会把数字装箱。\n\n注意数字装箱不一定保留同一性:\n\nfun main() {\n//sampleStart\n    val a: Int = 100\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    \n    val b: Int = 10000\n    val boxedB: Int? = b\n    val anotherBoxedB: Int? = b\n    \n    println(boxedA === anotherBoxedA) // true\n    println(boxedB === anotherBoxedB) // false\n//sampleEnd\n}\n另一方面，它保留了相等性:\n\nfun main() {\n//sampleStart\n    val a: Int = 10000\n    println(a == a) // 输出“true”\n    val boxedA: Int? = a\n    val anotherBoxedA: Int? = a\n    println(boxedA == anotherBoxedA) // 输出“true”\n//sampleEnd\n}\n由于不同的表示方式，较小类型并不是较大类型的子类型。 如果它们是的话，就会出现下述问题：\n\n// 假想的代码，实际上并不能编译：\nval a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)\nval b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)\nprint(b == a) // 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long\n所以相等性会在所有地方悄无声息地失去，更别说同一性了。\n\n因此较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。\n\nfun main() {\n//sampleStart\n    val b: Byte = 1 // OK, 字面值是静态检测的\n    val i: Int = b // 错误\n//sampleEnd\n}\n我们可以显式转换来拓宽数字\n\nfun main() {\n    val b: Byte = 1\n//sampleStart\n    val i: Int = b.toInt() // OK：显式拓宽\n    print(i)\n//sampleEnd\n}\n每个数字类型支持如下的转换:\n\ntoByte(): Byte\ntoShort(): Short\ntoInt(): Int\ntoLong(): Long\ntoFloat(): Float\ntoDouble(): Double\ntoChar(): Char\n缺乏隐式类型转换很少会引起注意，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如：\n\nval l = 1L + 3 // Long + Int => Long\nKotlin支持数字运算的标准集（+ - * / %），运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。 参见运算符重载。\n\n请注意，整数间的除法总是返回整数。会丢弃任何小数部分。例如：\n\nfun main() {\n//sampleStart\n    val x = 5 / 2\n    //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'\n    println(x == 2)\n//sampleEnd\n}\n对于任何两个整数类型之间的除法来说都是如此。\n\nfun main() {\n//sampleStart\n    val x = 5L / 2\n    println(x == 2L)\n//sampleEnd\n}\n如需返回浮点类型，请将其中的一个参数显式转换为浮点类型。\n\nfun main() {\n//sampleStart\n    val x = 5 / 2.toDouble()\n    println(x == 2.5)\n//sampleEnd\n}\n对于位运算，没有特殊字符来表示，而只可用中缀方式调用具名函数，例如:\n\nval x = (1 shl 2) and 0x000FF000\n这是完整的位运算列表（只用于 Int 与 Long）：\n\nshl(bits) – 有符号左移\nshr(bits) – 有符号右移\nushr(bits) – 无符号右移\nand(bits) – 位与\nor(bits) – 位或\nxor(bits) – 位异或\ninv() – 位非\n本节讨论的浮点数操作如下：\n\n相等性检测：a == b 与 a != b\n比较操作符：a < b、 a > b、 a <= b、 a >= b\n区间实例以及区间检测：a..b、 x in a..b、 x !in a..b\n当其中的操作数 a 与 b 都是静态已知的 Float 或 Double 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者智能类型转换的结果是该类型），两数字所形成的操作或者区间遵循 IEEE 754 浮点运算标准。\n\n然而，为了支持泛型场景并提供全序支持，当这些操作数并非静态类型为浮点数（例如是 Any、 Comparable<……>、 类型参数）时，这些操作使用为 Float 与 Double 实现的不符合标准的 equals 与 compareTo，这会出现：\n\n认为 NaN 与其自身相等\n认为 NaN 比包括正无穷大（POSITIVE_INFINITY）在内的任何其他元素都大\n认为 -0.0 小于 0.0\n字符用 Char 类型表示。它们不能直接当作数字\n\nfun check(c: Char) {\n    if (c == 1) { // 错误：类型不兼容\n        // ……\n    }\n}\n字符字面值用单引号括起来: '1'。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\\t、 \\b、\\n、\\r、\\'、\\\"、\\\\ 与 \\$。 编码其他字符要用 Unicode 转义序列语法：'\\uFF00'。\n\n我们可以显式把字符转换为 Int 数字：\n\nfun decimalDigitValue(c: Char): Int {\n    if (c !in '0'..'9')\n        throw IllegalArgumentException(\"Out of range\")\n    return c.toInt() - '0'.toInt() // 显式转换为数字\n}\n当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。\n\n布尔用 Boolean 类型表示，它有两个值：true 与 false。\n\n若需要可空引用布尔会被装箱。\n\n内置的布尔运算有：\n\n|| – 短路逻辑或\n&& – 短路逻辑与\n! - 逻辑非\n数组在 Kotlin 中使用 Array 类来表示，它定义了 get 与 set 函数（按照运算符重载约定这会转变为 []）以及 size 属性，以及一些其他有用的成员函数：\n\nclass Array<T> private constructor() {\n    val size: Int\n    operator fun get(index: Int): T\n    operator fun set(index: Int, value: T): Unit\n\n    operator fun iterator(): Iterator<T>\n    // ……\n}\n我们可以使用库函数 arrayOf() 来创建一个数组并传递元素值给它，这样 arrayOf(1, 2, 3) 创建了 array [1, 2, 3]。 或者，库函数 arrayOfNulls() 可以用于创建一个指定大小的、所有元素都为空的数组。\n\n另一个选项是用接受数组大小以及一个函数参数的 Array 构造函数，用作参数的函数能够返回给定索引的每个元素初始值：\n\nfun main() {\n//sampleStart\n    // 创建一个 Array<String> 初始化为 [\"0\", \"1\", \"4\", \"9\", \"16\"]\n    val asc = Array(5) { i -> (i * i).toString() }\n    asc.forEach { println(it) }\n//sampleEnd\n}\n如上所述，[] 运算符代表调用成员函数 get() 与 set()。\n\nKotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 Array<String> 赋值给 Array<Any>，以防止可能的运行时失败（但是你可以使用 Array<out Any>, 参见类型投影）。\n\nKotlin 也有无装箱开销的专门的类来表示原生类型数组: ByteArray、 ShortArray、IntArray 等等。这些类与 Array 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法:\n\nval x: IntArray = intArrayOf(1, 2, 3)\nx[0] = x[1] + x[2]\n// 大小为 5、值为 [0, 0, 0, 0, 0] 的整型数组\nval arr = IntArray(5)\n\n// 例如：用常量初始化数组中的值\n// 大小为 5、值为 [42, 42, 42, 42, 42] 的整型数组\nval arr = IntArray(5) { 42 }\n\n// 例如：使用 lambda 表达式初始化数组中的值\n// 大小为 5、值为 [0, 1, 2, 3, 4] 的整型数组（值初始化为其索引值）\nvar arr = IntArray(5) { it * 1 } \n无符号类型自 Kotlin 1.3 起才可用，并且目前是实验性的。详见下文\n\nKotlin 为无符号整数引入了以下类型：\n\nkotlin.UByte: 无符号 8 比特整数，范围是 0 到 255\nkotlin.UShort: 无符号 16 比特整数，范围是 0 到 65535\nkotlin.UInt: 无符号 32 比特整数，范围是 0 到 2^32 - 1\nkotlin.ULong: 无符号 64 比特整数，范围是 0 到 2^64 - 1\n无符号类型支持其对应有符号类型的大多数操作。\n\n请注意，将类型从无符号类型更改为对应的有符号类型（反之亦然）是二进制不兼容变更\n\n无符号类型是使用另一个实验性特性（即内联类）实现的。\n\n与原生类型相同，每个无符号类型都有相应的为该类型特化的表示数组的类型：\n\nkotlin.UByteArray: 无符号字节数组\nkotlin.UShortArray: 无符号短整型数组\nkotlin.UIntArray: 无符号整型数组\nkotlin.ULongArray: 无符号长整型数组\n与有符号整型数组一样，它们提供了类似于 Array 类的 API 而没有装箱开销。\n\n此外，区间与数列也支持 UInt 与 ULong（通过这些类 kotlin.ranges.UIntRange、 kotlin.ranges.UIntProgression、 kotlin.ranges.ULongRange、 kotlin.ranges.ULongProgression）\n\n为使无符号整型更易于使用，Kotlin 提供了用后缀标记整型字面值来表示指定无符号类型（类似于 Float/Long）：\n\n后缀 u 与 U 将字面值标记为无符号。确切类型会根据预期类型确定。如果没有提供预期的类型，会根据字面值大小选择 UInt 或者 ULong\nval b: UByte = 1u  // UByte，已提供预期类型\nval s: UShort = 1u // UShort，已提供预期类型\nval l: ULong = 1u  // ULong，已提供预期类型\n\nval a1 = 42u // UInt：未提供预期类型，常量适于 UInt\nval a2 = 0xFFFF_FFFF_FFFFu // ULong：未提供预期类型，常量不适于 UInt\n后缀 uL 与 UL 显式将字面值标记为无符号长整型。\nval a = 1UL // ULong，即使未提供预期类型并且常量适于 UInt\n无符号类型的设计是实验性的，这意味着这个特性改进很快并且没有给出兼容性保证。当在 Kotlin 1.3+ 中使用无符号算术时，会报出警告表明这个特性是实验性的。如需移除警告，必须选择加入（opt-in）无符号类型的实验性使用。\n\n选择加入无符号整型有两种可行的方式：将 API 标记为实验性的，或者无需标记。\n\n如需传播实验性，请以 @ExperimentalUnsignedTypes 标注使用了无符号整型的声明。\n如需选择加入而不传播实验性，要么使用 @OptIn(ExperimentalUnsignedTypes::class) 注解标注声明，要么将 -Xopt-in=kotlin.ExperimentalUnsignedTypes 传给编译器。\n你的客户是否必须选择使用你的 API 取决于你，不过请记住，无符号整型是一个实验性特性，因此使用它们的 API 可能会因语言的变更而发生突然破坏。\n\n技术细节也参见实验性 API KEEP。\n\n关于技术细节与深入探讨请参见无符号类型的语言提案。\n\n字符串用 String 类型表示。字符串是不可变的。 字符串的元素——字符可以使用索引运算符访问: s[i]。 可以用 for 循环迭代字符串:\n\nfun main() {\nval str = \"abcd\"\n//sampleStart\nfor (c in str) {\n    println(c)\n}\n//sampleEnd\n}\n可以用 + 操作符连接字符串。这也适用于连接字符串与其他类型的值， 只要表达式中的第一个元素是字符串：\n\nfun main() {\n//sampleStart\nval s = \"abc\" + 1\nprintln(s + \"def\")\n//sampleEnd\n}\n请注意，在大多数情况下，优先使用字符串模板或原始字符串而不是字符串连接。\n\nKotlin 有两种类型的字符串字面值: 转义字符串可以有转义字符， 以及原始字符串可以包含换行以及任意文本。以下是转义字符串的一个示例:\n\nval s = \"Hello, world!\\n\"\n转义采用传统的反斜杠方式。参见上面的 字符 查看支持的转义序列。\n\n原始字符串 使用三个引号（\"\"\"）分界符括起来，内部没有转义并且可以包含换行以及任何其他字符:\n\nval text = \"\"\"\n    for (c in \"foo\")\n        print(c)\n\"\"\"\n你可以通过 trimMargin() 函数去除前导空格：\n\nval text = \"\"\"\n    |Tell me and I forget.\n    |Teach me and I remember.\n    |Involve me and I learn.\n    |(Benjamin Franklin)\n    \"\"\".trimMargin()\n默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(\">\")。\n\n字符串字面值可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:\n\nfun main() {\n//sampleStart\n    val i = 10\n    println(\"i = $i\") // 输出“i = 10”\n//sampleEnd\n}\n或者用花括号括起来的任意表达式:\n\nfun main() {\n//sampleStart\n    val s = \"abc\"\n    println(\"$s.length is ${s.length}\") // 输出“abc.length is 3”\n//sampleEnd\n}\n原始字符串与转义字符串内部都支持模板。 如果你需要在原始字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：\n\nval price = \"\"\"\n${'\n   \n  \n  \n  \n\n\n}9.99\n\"\"\""}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306173070},"updatedAt":{"$$date":1597307591670},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cdD7N3rMe5Z28cr9"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382136115},"updatedAt":{"$$date":1597382136115},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cnO122tqe2FtXBH7"}
{"name":"kotlin-Kotlin 条件控制 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-condition-control.html\nKotlin 条件控制 | 菜鸟教程\n3-4 minutes\nIF 表达式\n一个 if 语句包含一个布尔表达式和一条或多条语句。\n\n// 传统用法\nvar max = a \nif (a < b) max = b\n\n// 使用 else \nvar max: Int\nif (a > b) {\n    max = a\n} else {\n    max = b\n}\n \n// 作为表达式\nval max = if (a > b) a else b\n我们也可以把 IF 表达式的结果赋值给一个变量。\n\nval max = if (a > b) {\n    print(\"Choose a\")\n    a\n} else {\n    print(\"Choose b\")\n    b\n}\n这也说明我也不需要像Java那种有一个三元操作符，因为我们可以使用它来简单实现：\n\nval c = if (condition) a else b\n实例\nfun main(args: Array<String>) {\n    var x = 0\n    if(x>0){\n        println(\"x 大于 0\")\n    }else if(x==0){\n        println(\"x 等于 0\")\n    }else{\n        println(\"x 小于 0\")\n    }\n\n    var a = 1\n    var b = 2\n    val c = if (a>=b) a else b\n    println(\"c 的值为 $c\")\n}\n输出结果为：\n\nx 等于 0\nc 的值为 2\n使用区间\n使用 in 运算符来检测某个数字是否在指定区间内，区间格式为 x..y ：\n\n实例\n\nfun main(args: Array<String>) {\n    val x = 5\n    val y = 9\n    if (x in 1..8) {\n        println(\"x 在区间内\")\n    }\n}\n输出结果为：\n\nx 在区间内\nWhen 表达式\nwhen 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。\n\nwhen 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。\n\nwhen 类似其他语言的 switch 操作符。其最简单的形式如下：\n\nwhen (x) {\n    1 -> print(\"x == 1\")\n    2 -> print(\"x == 2\")\n    else -> { // 注意这个块\n        print(\"x 不是 1 ，也不是 2\")\n    }\n}\n在 when 中，else 同 switch 的 default。如果其他分支都不满足条件将会求值 else 分支。\n\n如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：\n\nwhen (x) {\n    0, 1 -> print(\"x == 0 or x == 1\")\n    else -> print(\"otherwise\")\n}\n我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：\n\nwhen (x) {\n    in 1..10 -> print(\"x is in the range\")\n    in validNumbers -> print(\"x is valid\")\n    !in 10..20 -> print(\"x is outside the range\")\n    else -> print(\"none of the above\")\n}\n另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测。\n\nfun hasPrefix(x: Any) = when(x) {\n    is String -> x.startsWith(\"prefix\")\n    else -> false\n}\nwhen 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：\n\nwhen {\n    x.isOdd() -> print(\"x is odd\")\n    x.isEven() -> print(\"x is even\")\n    else -> print(\"x is funny\")\n}\n实例\nfun main(args: Array<String>) {\n    var x = 0\n    when (x) {\n        0, 1 -> println(\"x == 0 or x == 1\")\n        else -> println(\"otherwise\")\n    }\n\n    when (x) {\n        1 -> println(\"x == 1\")\n        2 -> println(\"x == 2\")\n        else -> { // 注意这个块\n            println(\"x 不是 1 ，也不是 2\")\n        }\n    }\n\n    when (x) {\n        in 0..10 -> println(\"x 在该区间范围内\")\n        else -> println(\"x 不在该区间范围内\")\n    }\n}\n输出结果：\n\nx == 0 or x == 1\nx 不是 1 ，也不是 2\nx 在该区间范围内\nwhen 中使用 in 运算符来判断集合内是否包含某实例：\n\nfun main(args: Array<String>) {\n    val items = setOf(\"apple\", \"banana\", \"kiwi\")\n    when {\n        \"orange\" in items -> println(\"juicy\")\n        \"apple\" in items -> println(\"apple is fine too\")\n    }\n}\n输出结果：\n\napple is fine too"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303689818},"updatedAt":{"$$date":1597303879714},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"czCnKTgTnWd6ixVL"}
{"name":"kotlin-泛型：in、out、where - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/generics.html\n泛型：in、out、where - Kotlin 语言中文站\n25-31 minutes\n改进翻译\n与 Java 类似，Kotlin 中的类也可以有类型参数：\n\nclass Box<T>(t: T) {\n    var value = t\n}\n一般来说，要创建这样类的实例，我们需要提供类型参数：\n\nval box: Box<Int> = Box<Int>(1)\n但是如果类型参数可以推断出来，例如从构造函数的参数或者从其他途径，允许省略类型参数：\n\nval box = Box(1) // 1 具有类型 Int，所以编译器知道我们说的是 Box<Int>。\nJava 类型系统中最棘手的部分之一是通配符类型（参见 Java Generics FAQ）。 而 Kotlin 中没有。 相反，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。\n\n首先，让我们思考为什么 Java 需要那些神秘的通配符。在 《Effective Java》第三版 解释了该问题——第 31 条：利用有限制通配符来提升 API 的灵活性。 首先，Java 中的泛型是不型变的，这意味着 List<String> 并不是 List<Object> 的子类型。 为什么这样？ 如果 List 不是不型变的，它就没比 Java 的数组好到哪去，因为如下代码会通过编译然后导致运行时异常：\n\n// Java\nList<String> strs = new ArrayList<String>();\nList<Object> objs = strs; // ！！！此处的编译器错误让我们避免了之后的运行时异常\nobjs.add(1); // 这里我们把一个整数放入一个字符串列表\nString s = strs.get(0); // ！！！ ClassCastException：无法将整数转换为字符串\n因此，Java 禁止这样的事情以保证运行时的安全。但这样会有一些影响。例如，考虑 Collection 接口中的 addAll() 方法。该方法的签名应该是什么？直觉上，我们会这样：\n\n// Java\ninterface Collection<E> …… {\n  void addAll(Collection<E> items);\n}\n但随后，我们就无法做到以下简单的事情（这是完全安全）：\n\n// Java\nvoid copyAll(Collection<Object> to, Collection<String> from) {\n  to.addAll(from);\n  // ！！！对于这种简单声明的 addAll 将不能编译：\n  // Collection<String> 不是 Collection<Object> 的子类型\n}\n（在 Java 中，我们艰难地学到了这个教训，参见《Effective Java》第三版，第 28 条：列表优先于数组）\n\n这就是为什么 addAll() 的实际签名是以下这样：\n\n// Java\ninterface Collection<E> …… {\n  void addAll(Collection<? extends E> items);\n}\n通配符类型参数 ? extends E 表示此方法接受 E 或者 E 的 一些子类型对象的集合，而不只是 E 自身。 这意味着我们可以安全地从其中（该集合中的元素是 E 的子类的实例）读取 E，但不能写入， 因为我们不知道什么对象符合那个未知的 E 的子类型。 反过来，该限制可以让Collection<String>表示为Collection<? extends Object>的子类型。 简而言之，带 extends 限定（上界）的通配符类型使得类型是协变的（covariant）。\n\n理解为什么这个技巧能够工作的关键相当简单：如果只能从集合中获取项目，那么使用 String 的集合， 并且从其中读取 Object 也没问题 。反过来，如果只能向集合中 放入 项目，就可以用 Object 集合并向其中放入 String：在 Java 中有 List<? super String> 是 List<Object> 的一个超类。\n\n后者称为逆变性（contravariance），并且对于 List <? super String> 你只能调用接受 String 作为参数的方法 （例如，你可以调用 add(String) 或者 set(int, String)），当然如果调用函数返回 List<T> 中的 T，你得到的并非一个 String 而是一个 Object。\n\nJoshua Bloch 称那些你只能从中读取的对象为生产者，并称那些你只能写入的对象为消费者。他建议：“为了灵活性最大化，在表示生产者或消费者的输入参数上使用通配符类型”，并提出了以下助记符：\n\nPECS 代表生产者-Extens，消费者-Super（Producer-Extends, Consumer-Super）。\n\n注意：如果你使用一个生产者对象，如 List<? extends Foo>，在该对象上不允许调用 add() 或 set()。但这并不意味着该对象是不可变的：例如，没有什么阻止你调用 clear()从列表中删除所有项目，因为 clear() 根本无需任何参数。通配符（或其他类型的型变）保证的唯一的事情是类型安全。不可变性完全是另一回事。\n\n假设有一个泛型接口 Source<T>，该接口中不存在任何以 T 作为参数的方法，只是方法返回 T 类型值：\n\n// Java\ninterface Source<T> {\n  T nextT();\n}\n那么，在 Source <Object> 类型的变量中存储 Source <String> 实例的引用是极为安全的——没有消费者-方法可以调用。但是 Java 并不知道这一点，并且仍然禁止这样操作：\n\n// Java\nvoid demo(Source<String> strs) {\n  Source<Object> objects = strs; // ！！！在 Java 中不允许\n  // ……\n}\n为了修正这一点，我们必须声明对象的类型为 Source<? extends Object>，这是毫无意义的，因为我们可以像以前一样在该对象上调用所有相同的方法，所以更复杂的类型并没有带来价值。但编译器并不知道。\n\n在 Kotlin 中，有一种方法向编译器解释这种情况。这称为声明处型变：我们可以标注 Source 的类型参数 T 来确保它仅从 Source<T> 成员中返回（生产），并从不被消费。 为此，我们提供 out 修饰符：\n\ninterface Source<out T> {\n    fun nextT(): T\n}\n\nfun demo(strs: Source<String>) {\n    val objects: Source<Any> = strs // 这个没问题，因为 T 是一个 out-参数\n    // ……\n}\n一般原则是：当一个类 C 的类型参数 T 被声明为 out 时，它就只能出现在 C 的成员的输出-位置，但回报是 C<Base> 可以安全地作为 C<Derived>的超类。\n\n简而言之，他们说类 C 是在参数 T 上是协变的，或者说 T 是一个协变的类型参数。 你可以认为 C 是 T 的生产者，而不是 T 的消费者。\n\nout修饰符称为型变注解，并且由于它在类型参数声明处提供，所以我们称之为声明处型变。 这与 Java 的使用处型变相反，其类型用途通配符使得类型协变。\n\n另外除了 out，Kotlin 又补充了一个型变注释：in。它使得一个类型参数逆变：只可以被消费而不可以被生产。逆变类型的一个很好的例子是 Comparable：\n\ninterface Comparable<in T> {\n    operator fun compareTo(other: T): Int\n}\n\nfun demo(x: Comparable<Number>) {\n    x.compareTo(1.0) // 1.0 拥有类型 Double，它是 Number 的子类型\n    // 因此，我们可以将 x 赋给类型为 Comparable <Double> 的变量\n    val y: Comparable<Double> = x // OK！\n}\n我们相信 in 和 out 两词是自解释的（因为它们已经在 C# 中成功使用很长时间了）， 因此上面提到的助记符不是真正需要的，并且可以将其改写为更高的目标：\n\n存在性（The Existential） 转换：消费者 in, 生产者 out! :-)\n\n将类型参数 T 声明为 out 非常方便，并且能避免使用处子类型化的麻烦，但是有些类实际上不能限制为只返回 T！ 一个很好的例子是 Array：\n\nclass Array<T>(val size: Int) {\n    fun get(index: Int): T { …… }\n    fun set(index: Int, value: T) { …… }\n}\n该类在 T 上既不能是协变的也不能是逆变的。这造成了一些不灵活性。考虑下述函数：\n\nfun copy(from: Array<Any>, to: Array<Any>) {\n    assert(from.size == to.size)\n    for (i in from.indices)\n        to[i] = from[i]\n}\n这个函数应该将项目从一个数组复制到另一个数组。让我们尝试在实践中应用它：\n\nval ints: Array<Int> = arrayOf(1, 2, 3)\nval any = Array<Any>(3) { \"\" } \ncopy(ints, any)\n//   ^ 其类型为 Array<Int> 但此处期望 Array<Any>\n这里我们遇到同样熟悉的问题：Array <T> 在 T 上是不型变的，因此 Array <Int> 和 Array <Any> 都不是另一个的子类型。为什么？ 再次重复，因为 copy 可能做坏事，也就是说，例如它可能尝试写一个 String 到 from， 并且如果我们实际上传递一个 Int 的数组，一段时间后将会抛出一个 ClassCastException 异常。\n\n那么，我们唯一要确保的是 copy() 不会做任何坏事。我们想阻止它写到 from，我们可以：\n\nfun copy(from: Array<out Any>, to: Array<Any>) { …… }\n这里发生的事情称为类型投影：我们说from不仅仅是一个数组，而是一个受限制的（投影的）数组：我们只可以调用返回类型为类型参数 T 的方法，如上，这意味着我们只能调用 get()。这就是我们的使用处型变的用法，并且是对应于 Java 的 Array<? extends Object>、 但使用更简单些的方式。\n\n你也可以使用 in 投影一个类型：\n\nfun fill(dest: Array<in String>, value: String) { …… }\nArray<in String> 对应于 Java 的 Array<? super String>，也就是说，你可以传递一个 CharSequence 数组或一个 Object 数组给 fill() 函数。\n\n有时你想说，你对类型参数一无所知，但仍然希望以安全的方式使用它。 这里的安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化将是该投影的子类型。\n\nKotlin 为此提供了所谓的星投影语法：\n\n对于 Foo <out T : TUpper>，其中 T 是一个具有上界 TUpper 的协变类型参数，Foo <*> 等价于 Foo <out TUpper>。 这意味着当 T 未知时，你可以安全地从 Foo <*> 读取 TUpper 的值。\n对于 Foo <in T>，其中 T 是一个逆变类型参数，Foo <*> 等价于 Foo <in Nothing>。 这意味着当 T 未知时，没有什么可以以安全的方式写入 Foo <*>。\n对于 Foo <T : TUpper>，其中 T 是一个具有上界 TUpper 的不型变类型参数，Foo<*> 对于读取值时等价于 Foo<out TUpper> 而对于写值时等价于 Foo<in Nothing>。\n如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 interface Function <in T, out U>，我们可以想象以下星投影：\n\nFunction<*, String> 表示 Function<in Nothing, String>；\nFunction<Int, *> 表示 Function<Int, out Any?>；\nFunction<*, *> 表示 Function<in Nothing, out Any?>。\n注意：星投影非常像 Java 的原始类型，但是安全。\n\n不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前：\n\nfun <T> singletonList(item: T): List<T> {\n    // ……\n}\n\nfun <T> T.basicToString(): String {  // 扩展函数\n    // ……\n}\n要调用泛型函数，在调用处函数名之后指定类型参数即可：\n\nval l = singletonList<Int>(1)\n可以省略能够从上下文中推断出来的类型参数，所以以下示例同样适用：\n\n能够替换给定类型参数的所有可能类型的集合可以由泛型约束限制。\n\n最常见的约束类型是与 Java 的 extends 关键字对应的 上界：\n\nfun <T : Comparable<T>> sort(list: List<T>) {  …… }\n冒号之后指定的类型是上界：只有 Comparable<T> 的子类型可以替代 T。 例如：\n\nsort(listOf(1, 2, 3)) // OK。Int 是 Comparable<Int> 的子类型\nsort(listOf(HashMap<Int, String>())) // 错误：HashMap<Int, String> 不是 Comparable<HashMap<Int, String>> 的子类型\n默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，我们需要一个单独的 where-子句：\n\nfun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>\n    where T : CharSequence,\n          T : Comparable<T> {\n    return list.filter { it > threshold }.map { it.toString() }\n}\n所传递的类型必须同时满足 where 子句的所有条件。在上述示例中，类型 T 必须既实现了 CharSequence 也实现了 Comparable。\n\nKotlin 为泛型声明用法执行的类型安全检测仅在编译期进行。 运行时泛型类型的实例不保留关于其类型实参的任何信息。 其类型信息称为被擦除。例如，Foo<Bar> 与 Foo<Baz?> 的实例都会被擦除为 Foo<*>。\n\n因此，并没有通用的方法在运行时检测一个泛型类型的实例是否通过指定类型参数所创建 ，并且编译器禁止这种 is 检测。\n\n类型转换为带有具体类型参数的泛型类型，如 foo as List<String> 无法在运行时检测。 当高级程序逻辑隐含了类型转换的类型安全而无法直接通过编译器推断时， 可以使用这种非受检类型转换。编译器会对非受检类型转换发出警告，并且在运行时只对非泛型部分检测（相当于 foo as List<*>）。\n\n泛型函数调用的类型参数也同样只在编译期检测。在函数体内部， 类型参数不能用于类型检测，并且类型转换为类型参数（foo as T）也是非受检的。然而， 内联函数的具体化的类型参数会由调用处内联函数体中的类型实参所代入，因此可以用于类型检测与转换， 与上述泛型类型的实例具有相同限制。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307924262},"updatedAt":{"$$date":1597308042376},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"e8ey8GNQuBhjUP1B"}
{"name":"kotlin-Kotlin 接口 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-interface.html\nKotlin 接口 | 菜鸟教程\n2-3 minutes\nKotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：\n\ninterface MyInterface { fun bar() fun foo() { println(\"foo\") } }\n\n实现接口\n一个类或者对象可以实现一个或多个接口。\n\nclass Child : MyInterface { override fun bar() { } }\n\n实例\ninterface MyInterface { fun bar() fun foo() { println(\"foo\") } } class Child : MyInterface { override fun bar() { println(\"bar\") } } fun main(args: Array<String>) { val c = Child() c.foo(); c.bar(); }\n\n输出结果为：\n\nfoo\nbar\n接口中的属性\n接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：\n\ninterface MyInterface{ var name:String } class MyImpl:MyInterface{ override var name: String = \"runoob\" }\n\n实例\ninterface MyInterface { var name:String fun bar() fun foo() { println(\"foo\") } } class Child : MyInterface { override var name: String = \"runoob\" override fun bar() { println(\"bar\") } } fun main(args: Array<String>) { val c = Child() c.foo(); c.bar(); println(c.name) }\n\n输出结果为：\n\nfoo\nbar\nrunoob\n函数重写\n实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如:\n\n实例\ninterface A { fun foo() { print(\"A\") } fun bar() } interface B { fun foo() { print(\"B\") } fun bar() { print(\"bar\") } } class C : A { override fun bar() { print(\"bar\") } } class D : A, B { override fun foo() { super<A>.foo() super<B>.foo() } override fun bar() { super<B>.bar() } } fun main(args: Array<String>) { val d = D() d.foo(); d.bar(); }\n\n输出结果为：\n\nABbar\n实例中接口 A 和 B 都定义了方法 foo() 和 bar()， 两者都实现了 foo(), B 实现了 bar()。因为 C 是一个实现了 A 的具体类，所以必须要重写 bar() 并实现这个抽象方法。\n\n然而，如果我们从 A 和 B 派生 D，我们需要实现多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则 既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303694355},"updatedAt":{"$$date":1597304161561},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"eg3iqh70CcnryrQW"}
{"name":"andr-设备兼容性概览","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/practices/compatibility\n设备兼容性概览  |  Android 开发者  |  Android Developers\n6-7 minutes\nAndroid 适用于众多类型的设备，从手机到平板电脑和电视都能搭载使用。作为开发者，如此广泛的设备类型能为您的应用带来广大的潜在受众群体。为了能在所有这些设备上顺利运行，应用应该容许部分设备功能的变化，并提供可适应不同屏幕配置的灵活界面。\n\n为了帮助您实现这一目标，Android 提供了一个动态应用框架，供您在静态文件中提供特定于配置的应用资源（例如针对不同屏幕尺寸的不同 XML 布局）。然后，Android 会根据当前设备配置加载适当的资源。因此，在对应用设计和一些额外的应用资源进行一些事先规划后，您可以发布单个应用软件包 (APK)，并在各种设备上提供优化的用户体验。\n\n但是，您可以根据需要指定应用的功能要求，并控制哪些类型的设备可以通过 Google Play 商店安装您的应用。本页介绍了如何控制哪些设备可以访问您的应用，以及如何准备您的应用以确保它们覆盖合适的受众群体。如需详细了解如何让您的应用适应不同的设备，请参阅支持不同的设备。\n\n“兼容性”是什么意思？\n随着您进一步阅读 Android 开发相关内容，您可能会在各种语境下遇到“兼容性”一词。兼容性有两种类型：设备兼容性和应用兼容性。\n\n由于 Android 是一个开源项目，因此任何硬件制造商都可以制造搭载 Android 操作系统的设备。不过，设备“兼容 Android”的前提是它可以正常运行针对 Android 执行环境编写的应用。Android 执行环境的具体细节由 Android 兼容性计划定义，每台设备都必须通过兼容性测试套件 (CTS) 测试才能被视为兼容。\n\n作为应用开发者，您无需担心设备是否兼容 Android，因为只有与 Android 兼容的设备才会附带 Google Play 商店。因此，您可以放心，通过 Google Play 商店安装您的应用的用户使用的是 Android 兼容设备。\n\n不过，您确实需要考虑您的应用是否兼容每一种可能的设备配置。由于 Android 以各种设备配置运行，因此部分功能并不适用于所有设备。例如，某些设备可能未配备罗盘传感器。如果应用的核心功能需要使用罗盘传感器，那么应用只能与带有罗盘传感器的设备兼容。\n\n控制应用在设备上的可用性\n应用可通过平台 API 利用 Android 支持的各种功能。有些功能基于硬件（例如罗盘传感器），有些功能基于软件（如应用窗口微件），有些功能则依赖于平台版本。并非每台设备都支持所有功能，因此您可能需要根据应用所需的功能控制应用在设备上的可用性。\n\n要尽可能扩大应用的用户群，您应设法使用单个 APK 支持尽可能多的设备配置。在大多数情况下，要实现这一目标，您可以在运行时停用可选功能，并为应用资源提供针对不同配置的替代选项（例如针对不同屏幕尺寸的不同布局）。不过，如果需要，您可以根据以下设备特征，通过 Google Play 商店限制应用在设备上的可用性：\n\n设备功能\n平台版本\n屏幕配置\n设备功能\n为了让您根据设备功能管理应用的可用性，Android 为可能并不适用于所有设备的任何硬件或软件功能定义了功能 ID。例如，罗盘传感器的功能 ID 为 FEATURE_SENSOR_COMPASS，而应用微件的功能 ID 为 FEATURE_APP_WIDGETS。\n\n根据需要，要在用户的设备不具备特定功能时阻止用户安装您的应用，您可以通过应用清单文件中的 <uses-feature> 元素声明这一点。\n\n例如，如果您的应用在没有罗盘传感器的设备上没有意义，您可以使用以下清单标记声明需要罗盘传感器：\n\n    <manifest ... >\n        <uses-feature android:name=\"android.hardware.sensor.compass\"\n                      android:required=\"true\" />\n        ...\n    </manifest>\n    \nGoogle Play 商店会将您的应用所需的功能与每个用户的设备上可用的功能进行比较，以确定您的应用是否与每台设备兼容。如果设备不具备您的应用所需的所有功能，则用户无法安装您的应用。\n\n但是，如果应用的主要功能不需要某项设备功能，则应将 required 属性设置为 \"false\" 并在运行时检查是否有该设备功能。如果应用功能在当前设备上不可用，请适当降级相应的应用功能。例如，您可以通过调用 hasSystemFeature() 来查询功能是否可用，如下所示：\n\n    if (!packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) {\n        // This device does not have a compass, turn off the compass feature\n        disableCompassFeature()\n    }\n    \n    PackageManager pm = getPackageManager();\n    if (!pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) {\n        // This device does not have a compass, turn off the compass feature\n        disableCompassFeature();\n    }\n    \n如需了解您可以用来通过 Google Play 商店控制应用对用户是否可用的所有过滤器，请参阅 Google Play 上的过滤器文档。\n\n注意：一些系统权限会隐式要求具备某项设备功能。例如，如果您的应用请求对 BLUETOOTH 的访问权限，这就隐式要求具备 FEATURE_BLUETOOTH 设备功能。要停用基于此功能的过滤，并使您的应用可用于没有蓝牙的设备，您可以在 <uses-feature> 标记中将 required 属性设置为 \"false\"。如需详细了解隐式要求的设备功能，请参阅隐含功能要求的权限。\n\n平台版本\n不同的设备可能会运行不同版本的 Android 平台，例如 Android 4.0 或 Android 4.4。每个后续的平台版本通常会添加之前版本中不可用的新 API。为表明可用的 API 集，每个平台版本都会指定 API 级别。例如，Android 1.0 是 API 级别 1，而 Android 4.4 是 API 级别 19。\n\n通过 API 级别，您可以使用 <uses-sdk> 清单标记及其 minSdkVersion 属性来声明应用兼容的最低版本。例如，Android 4.0（API 级别 14）中添加了日历提供程序 API。如果您的应用在没有这些 API 的情况下无法运行，您应将 API 级别 14 声明为应用的最低支持版本。\n\nminSdkVersion 属性声明应用兼容的最低版本，targetSdkVersion 属性声明应用经过优化后适用的最高版本。\n\n不过，请注意 <uses-sdk> 元素中的属性会被替换为 build.gradle 文件中的相应属性。因此，如果您使用的是 Android Studio，则必须在其中指定 minSdkVersion 和 targetSdkVersion 值：\n\n    android {\n      defaultConfig {\n        applicationId 'com.example.myapp'// Defines the minimum API level required to run the app.\n        minSdkVersion 15// Specifies the API level used to test the app.\n        targetSdkVersion 28...\n      }\n    }\n    \n要详细了解 build.gradle 文件，请参阅如何配置编译版本。\n\n每个后续版本的 Android 都为使用之前平台版本的 API 构建的应用提供兼容性，因此您的应用应始终与未来版本的 Android 兼容，同时使用已记录的 Android API。\n\n注意：targetSdkVersion 属性不会阻止您的应用安装在高于指定值的平台版本上，但它很重要，因为它向系统指示您的应用是否应继承较新版本中的行为更改。如果您不将 targetSdkVersion 更新到最新版本，则系统会认为您的应用在最新版本上运行时需要一些向后兼容性行为。例如，在 Android 4.4 中的行为更改中，使用 AlarmManager API 创建的闹钟现在默认不精确，因此系统可以批量处理应用闹钟并节省系统电量，但如果您的目标 API 级别低于“19”，则系统会为您的应用保留之前的 API 行为。\n\n不过，如果您的应用使用的是较新平台版本中添加的 API，但其主要功能并不需要这些 API，则应在运行时检查 API 级别，并在 API 级别过低时适当降级相应的功能。在这种情况下，请将 minSdkVersion 尽量设置为适用于应用主要功能的最低值，然后将当前系统的版本 SDK_INT 与 Build.VERSION_CODES 中对应于您要检查的 API 级别的一个代号常量进行比较。例如：\n\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n        // Running on something older than API level 11, so disable\n        // the drag/drop features that use <code><a href=\"/reference/android/content/ClipboardManager.html\">ClipboardManager</a></code> APIs\n        disableDragAndDrop()\n    }\n    \n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n        // Running on something older than API level 11, so disable\n        // the drag/drop features that use <code><a href=\"/reference/android/content/ClipboardManager.html\">ClipboardManager</a></code> APIs\n        disableDragAndDrop();\n    }\n    \n屏幕配置\nAndroid 可在各种尺寸的设备上运行，包括手机、平板电脑和电视。为了按照屏幕类型对设备进行分类，Android 为每种设备定义了两个特征：屏幕尺寸（屏幕的物理尺寸）和屏幕密度（屏幕上像素的物理密度，称为 DPI）。为了简化不同的配置，Android 将这些变体归纳成组，使它们更容易作为定位目标：\n\n四种广义的尺寸：小、标准、大和特大。\n还有几种广义的密度：mdpi（中）、hdpi（高）、xhdpi（超高）、xxhdpi（超超高）等。\n默认情况下，您的应用会兼容所有屏幕尺寸和密度，因为系统会根据需要对各个屏幕的界面布局和图片资源进行相应的调整。不过，您应针对不同的屏幕尺寸添加专门的布局，针对常见的屏幕密度添加优化的位图图片，以优化每种屏幕配置的用户体验。\n\n如需了解如何针对不同屏幕创建备用资源以及如何在必要时将应用限制为特定屏幕尺寸，请参阅支持不同屏幕。\n\n出于业务原因控制应用的可用性\n除了根据设备特征限制应用的可用性之外，您还可能需要出于业务或法律方面的原因限制应用的可用性。例如，显示伦敦地铁列车时刻表的应用不太可能适用于英国以外的用户。针对此类情况，Google Play 商店在 Play 管理中心提供了过滤选项，供您出于非技术原因（例如用户的语言区域或无线运营商）控制应用的可用性。\n\n针对技术兼容性（例如必需的硬件组件）的过滤始终基于 APK 文件中包含的信息。但是，出于非技术原因（如地理语言区域）的过滤始终在 Google Play 管理中心中处理。\n\n继续阅读以下内容：\n提供资源\n介绍了 Android 应用如何采用将应用资源与应用代码分开的结构，包括如何为特定设备配置提供备用资源。\nGoogle Play 上的过滤器\n介绍了 Google Play 商店阻止您的应用安装在不同设备上的不同方式。\n您可能还对以下内容感兴趣：\n系统权限\nAndroid 如何通过权限系统要求应用在获得用户同意后才能使用特定 API，从而限制应用对这些 API 的访问权限。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243438504},"updatedAt":{"$$date":1597243628229},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"fpEAxoblhvcFircI"}
{"name":"py-整数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\nPython可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。\n\n计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。\n\n浮点数\n浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。\n\n整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973910549},"updatedAt":{"$$date":1594973973120},"_id":"g0IVVihOupc9H0F2","folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"kotlin-属性与字段：Getters、Setters、const、lateinit - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/properties.html\n属性与字段：Getters、Setters、const、lateinit - Kotlin 语言中文站\n12-15 minutes\n改进翻译\nKotlin 类中的属性既可以用关键字 var 声明为可变的，也可以用关键字 val 声明为只读的。\n\n要使用一个属性，只要用名称引用它即可：\n\nfun copyAddress(address: Address): Address {\n    val result = Address() // Kotlin 中没有“new”关键字\n    result.name = address.name // 将调用访问器\n    result.street = address.street\n    // ……\n    return result\n}\n声明一个属性的完整语法是\n\nvar <propertyName>[: <PropertyType>] [= <property_initializer>]\n    [<getter>]\n    [<setter>]\n其初始器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始器 （或者从其 getter 返回值，如下文所示）中推断出来，也可以省略。\n\n例如:\n\nvar allByDefault: Int? // 错误：需要显式初始化器，隐含默认 getter 和 setter\nvar initialized = 1 // 类型 Int、默认 getter 和 setter\n一个只读属性的语法和一个可变的属性的语法有两方面的不同：1、只读属性的用 val开始代替var 2、只读属性不允许 setter\n\nval simple: Int? // 类型 Int、默认 getter、必须在构造函数中初始化\nval inferredType = 1 // 类型 Int 、默认 getter\n我们可以为属性定义自定义的访问器。如果我们定义了一个自定义的 getter，那么每次访问该属性时都会调用它 （这让我们可以实现计算出的属性）。以下是一个自定义 getter 的示例：\n\nval isEmpty: Boolean\n    get() = this.size == 0\n如果我们定义了一个自定义的 setter，那么每次给属性赋值时都会调用它。一个自定义的 setter 如下所示：\n\nvar stringRepresentation: String\n    get() = this.toString()\n    set(value) {\n        setDataFromString(value) // 解析字符串并赋值给其他属性\n    }\n按照惯例，setter 参数的名称是 value，但是如果你喜欢你可以选择一个不同的名称。\n\n自 Kotlin 1.1 起，如果可以从 getter 推断出属性类型，则可以省略它：\n\nval isEmpty get() = this.size == 0  // 具有类型 Boolean\n如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现， 你可以定义访问器而不定义其实现:\n\nvar setterVisibility: String = \"abc\"\n    private set // 此 setter 是私有的并且有默认实现\n\nvar setterWithAnnotation: Any? = null\n    @Inject set // 用 Inject 注解此 setter\n在 Kotlin 类中不能直接声明字段。然而，当一个属性需要一个幕后字段时，Kotlin 会自动提供。这个幕后字段可以使用field标识符在访问器中引用：\n\nvar counter = 0 // 注意：这个初始器直接为幕后字段赋值\n    set(value) {\n        if (value >= 0) field = value\n    }\nfield 标识符只能用在属性的访问器内。\n\n如果属性至少一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段，将会为该属性生成一个幕后字段。\n\n例如，下面的情况下， 就没有幕后字段：\n\nval isEmpty: Boolean\n    get() = this.size == 0\n如果你的需求不符合这套“隐式的幕后字段”方案，那么总可以使用 幕后属性（backing property）：\n\nprivate var _table: Map<String, Int>? = null\npublic val table: Map<String, Int>\n    get() {\n        if (_table == null) {\n            _table = HashMap() // 类型参数已推断出\n        }\n        return _table ?: throw AssertionError(\"Set to null by another thread\")\n    }\n对于 JVM 平台：通过默认 getter 和 setter 访问私有属性会被优化， 所以本例不会引入函数调用开销。\n\n如果只读属性的值在编译期是已知的，那么可以使用 const 修饰符将其标记为编译期常量。 这种属性需要满足以下要求：\n\n位于顶层或者是 object 声明 或 companion object 的一个成员\n以 String 或原生类型值初始化\n没有自定义 getter\n这些属性可以用在注解中：\n\nconst val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"\n\n@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { …… }\n一般地，属性声明为非空类型必须在构造函数中初始化。 然而，这经常不方便。例如：属性可以通过依赖注入来初始化， 或者在单元测试的 setup 方法中初始化。 这种情况下，你不能在构造函数内提供一个非空初始器。 但你仍然想在类体中引用该属性时避免空检测。\n\n为处理这种情况，你可以用 lateinit 修饰符标记该属性：\n\npublic class MyTest {\n    lateinit var subject: TestSubject\n\n    @SetUp fun setup() {\n        subject = TestSubject()\n    }\n\n    @Test fun test() {\n        subject.method()  // 直接解引用\n    }\n}\n该修饰符只能用于在类体中的属性（不是在主构造函数中声明的 var 属性，并且仅当该属性没有自定义 getter 或 setter 时），而自 Kotlin 1.2 起，也用于顶层属性与局部变量。该属性或变量必须为非空类型，并且不能是原生类型。\n\n在初始化前访问一个 lateinit 属性会抛出一个特定异常，该异常明确标识该属性被访问及它没有初始化的事实。\n\n要检测一个 lateinit var 是否已经初始化过，请在该属性的引用上使用 .isInitialized：\n\nif (foo::bar.isInitialized) {\n    println(foo.bar)\n}\n此检测仅对可词法级访问的属性可用，即声明位于同一个类型内、位于其中一个外围类型中或者位于相同文件的顶层的属性。\n\n参见覆盖属性\n\n最常见的一类属性就是简单地从幕后字段中读取（以及可能的写入）。 另一方面，使用自定义 getter 和 setter 可以实现属性的任何行为。 介于两者之间，属性如何工作有一些常见的模式。一些例子：惰性值、 通过键值从映射读取、访问数据库、访问时通知侦听器等等。\n\n这些常见行为可以通过使用委托属性实现为库。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306186755},"updatedAt":{"$$date":1597307802069},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"glRD0BT7IDjNjByo"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973272211},"updatedAt":{"$$date":1594973272211},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"gyT7qTv1AKKFmgmm"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980156160},"updatedAt":{"$$date":1594980156160},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"h01xFxflOBwzjOSd"}
{"name":"list","folderId":"IIjkbB6Kw","content":[{"label":"Fragment 1","value":"import 'dart:core';\n\nvoid main() {\n  var list = [\"黄药师\", \"郭靖\", \"小龙女\"];\n\n  void printElement(element) {\n    print(element);\n  }\n  list.forEach(printElement); \n}"},{"label":"Fragment 2","language":null,"value":null}],"tags":["e9Ui6C8xPeORK6VD"],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594709021096},"updatedAt":{"$$date":1594709290835},"_id":"hRs5arDmrjxbidwH","tagsPopulated":[{"name":"dart","_id":"e9Ui6C8xPeORK6VD","text":"dart"}],"folder":{"id":"IIjkbB6Kw","name":"dart","open":false,"defaultLanguage":"text"}}
{"name":"kotlin-返回与跳转：break 与 continue - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/returns.html\n返回与跳转：break 与 continue - Kotlin 语言中文站\n9-11 minutes\n改进翻译\nKotlin 有三种结构化跳转表达式：\n\nreturn。默认从最直接包围它的函数或者匿名函数返回。\nbreak。终止最直接包围它的循环。\ncontinue。继续下一次最直接包围它的循环。\n所有这些表达式都可以用作更大表达式的一部分：\n\nval s = person.name ?: return\n这些表达式的类型是 Nothing 类型。\n\n在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签（参见语法）。 要为一个表达式加标签，我们只要在其前加标签即可。\n\nloop@ for (i in 1..100) {\n    // ……\n}\n现在，我们可以用标签限制 break 或者continue：\n\nloop@ for (i in 1..100) {\n    for (j in 1..100) {\n        if (……) break@loop\n    }\n}\n标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。\n\nKotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：\n\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return // 非局部直接返回到 foo() 的调用者\n        print(it)\n    }\n    println(\"this point is unreachable\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。\n\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach lit@{\n        if (it == 3) return@lit // 局部返回到该 lambda 表达式的调用者，即 forEach 循环\n        print(it)\n    }\n    print(\" done with explicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。\n\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return@forEach // 局部返回到该 lambda 表达式的调用者，即 forEach 循环\n        print(it)\n    }\n    print(\" done with implicit label\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回\n\n//sampleStart\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {\n        if (value == 3) return  // 局部返回到匿名函数的调用者，即 forEach 循环\n        print(value)\n    })\n    print(\" done with anonymous function\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n请注意，前文三个示例中使用的局部返回类似于在常规循环中使用 continue。并没有 break 的直接等价形式，不过可以通过增加另一层嵌套 lambda 表达式并从其中非局部返回来模拟：\n\n//sampleStart\nfun foo() {\n    run loop@{\n        listOf(1, 2, 3, 4, 5).forEach {\n            if (it == 3) return@loop // 从传入 run 的 lambda 表达式非局部返回\n            print(it)\n        }\n    }\n    print(\" done with nested loop\")\n}\n//sampleEnd\n\nfun main() {\n    foo()\n}\n当要返一个回值的时候，解析器优先选用标签限制的 return，即\n\n意为“返回 1 到 @a”，而不是“返回一个标签标注的表达式 (@a 1)”。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306184602},"updatedAt":{"$$date":1597307740987},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"haS6Y1o1pKgqFtic"}
{"name":"kotlin-Kotlin 扩展 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-extensions.html\nKotlin 扩展 | 菜鸟教程\n4-5 minutes\nKotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。\n\n扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。\n\n扩展函数\n扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：\n\nfun receiverType.functionName(params){\n    body\n}\nreceiverType：表示函数的接收者，也就是函数扩展的对象\nfunctionName：扩展函数的名称\nparams：扩展函数的参数，可以为NULL\n以下实例扩展 User 类 ：\n\nclass User(var name:String)\n\n/**扩展函数**/\nfun User.Print(){\n    print(\"用户名 $name\")\n}\n\nfun main(arg:Array<String>){\n    var user = User(\"Runoob\")\n    user.Print()\n}\n实例执行输出结果为：\n\n用户名 Runoob\n下面代码为 MutableList 添加一个swap 函数：\n\n// 扩展函数 swap,调换不同位置的值\nfun MutableList<Int>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1]     //  this 对应该列表\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n\nfun main(args: Array<String>) {\n\n    val l = mutableListOf(1, 2, 3)\n    // 位置 0 和 2 的值做了互换\n    l.swap(0, 2) // 'swap()' 函数内的 'this' 将指向 'l' 的值\n\n    println(l.toString())\n}\n实例执行输出结果为：\n\n[3, 2, 1]\nthis关键字指代接收者对象(receiver object)(也就是调用扩展函数时, 在点号之前指定的对象实例)。\n\n扩展函数是静态解析的\n扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的:\n\nopen class C\n\nclass D: C()\n\nfun C.foo() = \"c\"   // 扩展函数 foo\n\nfun D.foo() = \"d\"   // 扩展函数 foo\n\nfun printFoo(c: C) {\n    println(c.foo())  // 类型是 C 类\n}\n\nfun main(arg:Array<String>){\n    printFoo(D())\n}\n实例执行输出结果为：\n\nc\n若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。\n\nclass C {\n    fun foo() { println(\"成员函数\") }\n}\n\nfun C.foo() { println(\"扩展函数\") }\n\nfun main(arg:Array<String>){\n    var c = C()\n    c.foo()\n}\n实例执行输出结果为：\n\n成员函数\n扩展一个空对象\n在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如:\n\nfun Any?.toString(): String {\n    if (this == null) return \"null\"\n    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()\n    // 解析为 Any 类的成员函数\n    return toString()\n}\nfun main(arg:Array<String>){\n    var t = null\n    println(t.toString())\n}\n实例执行输出结果为：\n\nnull\n扩展属性\n\n除了函数，Kotlin 也支持属性对属性进行扩展:\n\nval <T> List<T>.lastIndex: Int\n    get() = size - 1\n \n扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。\n\nval Foo.bar = 1 // 错误：扩展属性不能有初始化器\n扩展属性只能被声明为 val。\n\n伴生对象的扩展\n如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。\n\n伴生对象通过\"类名.\"形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用：\n\nclass MyClass {\n    companion object { }  // 将被称为 \"Companion\"\n}\n\nfun MyClass.Companion.foo() {\n    println(\"伴随对象的扩展函数\")\n}\n\nval MyClass.Companion.no: Int\n    get() = 10\n\nfun main(args: Array<String>) {\n    println(\"no:${MyClass.no}\")\n    MyClass.foo()\n}\n实例执行输出结果为：\n\nno:10\n伴随对象的扩展函数\n扩展的作用域\n通常扩展函数或属性定义在顶级包下:\n\npackage foo.bar\n\nfun Baz.goo() { …… } \n要使用所定义包之外的一个扩展, 通过import导入扩展的函数名进行使用:\n\npackage com.example.usage\n\nimport foo.bar.goo // 导入所有名为 goo 的扩展\n                   // 或者\nimport foo.bar.*   // 从 foo.bar 导入一切\n\nfun usage(baz: Baz) {\n    baz.goo()\n}\n扩展声明为成员\n在一个类内部你可以为另一个类声明扩展。\n\n在这个扩展中，有个多个隐含的接受者，其中扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。\n\nclass D {\n    fun bar() { println(\"D bar\") }\n}\n\nclass C {\n    fun baz() { println(\"C baz\") }\n\n    fun D.foo() {\n        bar()   // 调用 D.bar\n        baz()   // 调用 C.baz\n    }\n\n    fun caller(d: D) {\n        d.foo()   // 调用扩展函数\n    }\n}\n\nfun main(args: Array<String>) {\n    val c: C = C()\n    val d: D = D()\n    c.caller(d)\n\n}\n实例执行输出结果为：\n\nD bar\nC baz\n在 C 类内，创建了 D 类的扩展。此时，C 被成为分发接受者，而 D 为扩展接受者。从上例中，可以清楚的看到，在扩展函数中，可以调用派发接收者的成员函数。\n\n假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法。\n\nclass D {\n    fun bar() { println(\"D bar\") }\n}\n\nclass C {\n    fun bar() { println(\"C bar\") }  // 与 D 类 的 bar 同名\n\n    fun D.foo() {\n        bar()         // 调用 D.bar()，扩展接收者优先\n        this@C.bar()  // 调用 C.bar()\n    }\n\n    fun caller(d: D) {\n        d.foo()   // 调用扩展函数\n    }\n}\n\nfun main(args: Array<String>) {\n    val c: C = C()\n    val d: D = D()\n    c.caller(d)\n\n}\n实例执行输出结果为：\n\nD bar\nC bar\n以成员的形式定义的扩展函数, 可以声明为 open , 而且可以在子类中覆盖. 也就是说, 在这类扩展函数的派 发过程中, 针对分发接受者是虚拟的(virtual), 但针对扩展接受者仍然是静态的。\n\nopen class D {\n}\n\nclass D1 : D() {\n}\n\nopen class C {\n    open fun D.foo() {\n        println(\"D.foo in C\")\n    }\n\n    open fun D1.foo() {\n        println(\"D1.foo in C\")\n    }\n\n    fun caller(d: D) {\n        d.foo()   // 调用扩展函数\n    }\n}\n\nclass C1 : C() {\n    override fun D.foo() {\n        println(\"D.foo in C1\")\n    }\n\n    override fun D1.foo() {\n        println(\"D1.foo in C1\")\n    }\n}\n\n\nfun main(args: Array<String>) {\n    C().caller(D())   // 输出 \"D.foo in C\"\n    C1().caller(D())  // 输出 \"D.foo in C1\" —— 分发接收者虚拟解析\n    C().caller(D1())  // 输出 \"D.foo in C\" —— 扩展接收者静态解析\n\n}\n实例执行输出结果为：\n\nD.foo in C\nD.foo in C1\nD.foo in C"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304144146},"updatedAt":{"$$date":1597304181918},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"hk5ucGUJbeahqFeX"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241219081},"updatedAt":{"$$date":1597241219081},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"hvzY338QTHq5hxBA"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382137280},"updatedAt":{"$$date":1597382137280},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"igIKQKqIyydPXSfk"}
{"name":"py-循环","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n循环\n要计算1+2+3，我们可以直接写表达式：\n\n>>> 1 + 2 + 3\n6\n要计算1+2+3+...+10，勉强也能写出来。\n\n但是，要计算1+2+3+...+10000，直接写表达式就不可能了。\n\n为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。\n\nPython的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：\n\nnames = ['Michael', 'Bob', 'Tracy']\nfor name in names:\n    print(name)\n执行这段代码，会依次打印names的每一个元素：\n\nMichael\nBob\nTracy\n所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。\n\n再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：\n\nsum = 0\nfor x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:\n    sum = sum + x\nprint(sum)\n如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：\n\n>>> list(range(5))\n[0, 1, 2, 3, 4]\nrange(101)就可以生成0-100的整数序列，计算如下：\n\n# -*- coding: utf-8 -*-\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n\n Run\n请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。\n\n第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：\n\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。\n\n练习\n请利用循环依次对list中的每个名字打印出Hello, xxx!：\n\n# -*- coding: utf-8 -*-\nL = ['Bart', 'Lisa', 'Adam']\n\n Run\nbreak\n在循环中，break语句可以提前退出循环。例如，本来要循环打印1～100的数字：\n\nn = 1\nwhile n <= 100:\n    print(n)\n    n = n + 1\nprint('END')\n上面的代码可以打印出1~100。\n\n如果要提前结束循环，可以用break语句：\n\nn = 1\nwhile n <= 100:\n    if n > 10: # 当n = 11时，条件满足，执行break语句\n        break # break语句会结束当前循环\n    print(n)\n    n = n + 1\nprint('END')\n执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。\n\n可见break的作用是提前结束循环。\n\ncontinue\n在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。\n\nn = 0\nwhile n < 10:\n    n = n + 1\n    print(n)\n上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环：\n\nn = 0\nwhile n < 10:\n    n = n + 1\n    if n % 2 == 0: # 如果n是偶数，执行continue语句\n        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行\n    print(n)\n执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。\n\n可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。\n\n小结\n循环是让计算机做重复任务的有效的方法。\n\nbreak语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。\n\n要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。\n\n有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。\n\n请试写一个死循环程序。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973939120},"updatedAt":{"$$date":1594976980230},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ixtNFMchs9l62KRJ"}
{"name":"py- 参数小节","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\nPython的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。\n\n默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！\n\n要注意定义可变参数和关键字参数的语法：\n\n*args是可变参数，args接收的是一个tuple；\n\n**kw是关键字参数，kw接收的是一个dict。\n\n以及调用函数时如何传入可变参数和关键字参数的语法：\n\n可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；\n\n关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。\n\n使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。\n\n命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。\n\n定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977483536},"updatedAt":{"$$date":1594979596490},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"jKSFbCChvbtVp7oq"}
{"name":"kotlin-Kotlin 枚举类 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-enum-classes.html\nKotlin 枚举类 | 菜鸟教程\n2-2 minutes\n枚举类最基本的用法是实现一个类型安全的枚举。\n\n枚举常量用逗号分隔,每个枚举常量都是一个对象。\n\nenum class Color{\n    RED,BLACK,BLUE,GREEN,WHITE\n}\n枚举初始化\n每一个枚举都是枚举类的实例，它们可以被初始化：\n\nenum class Color(val rgb: Int) {\n    RED(0xFF0000),\n    GREEN(0x00FF00),\n    BLUE(0x0000FF)\n}\n默认名称为枚举字符名，值从0开始。若需要指定值，则可以使用其构造函数：\n\nenum class Shape(value:Int){\n    ovel(100),\n    rectangle(200)\n}\n枚举还支持以声明自己的匿名类及相应的方法、以及覆盖基类的方法。如：\n\nenum class ProtocolState {\n    WAITING {\n        override fun signal() = TALKING\n    },\n\n    TALKING {\n        override fun signal() = WAITING\n    };\n\n    abstract fun signal(): ProtocolState\n}\n如果枚举类定义任何成员，要使用分号将成员定义中的枚举常量定义分隔开\n\n使用枚举常量\nKotlin 中的枚举类具有合成方法，允许遍历定义的枚举常量，并通过其名称获取枚举常数。\n\nEnumClass.valueOf(value: String): EnumClass  // 转换指定 name 为枚举值，若未匹配成功，会抛出IllegalArgumentException\nEnumClass.values(): Array<EnumClass>        // 以数组的形式，返回枚举值\n获取枚举相关信息：\n\nval name: String //获取枚举名称\nval ordinal: Int //获取枚举值在所有枚举数组中定义的顺序\n实例\nenum class Color{\n    RED,BLACK,BLUE,GREEN,WHITE\n}\n\nfun main(args: Array<String>) {\n    var color:Color=Color.BLUE\n\n    println(Color.values())\n    println(Color.valueOf(\"RED\"))\n    println(color.name)\n    println(color.ordinal)\n\n}\n自 Kotlin 1.1 起，可以使用 enumValues<T>() 和 enumValueOf<T>() 函数以泛型的方式访问枚举类中的常量 ：\n\nenum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n\n\n\nfun main(args: Array<String>) {\n    printAllValues<RGB>() // 输出 RED, GREEN, BLUE\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304150593},"updatedAt":{"$$date":1597304737034},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"jv3VdBxZPFaukPg2"}
{"name":"py-条件判断","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n条件判断\n计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。\n\n比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：\n\nage = 20\nif age >= 18:\n    print('your age is', age)\n    print('adult')\n根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。\n\n也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了：\n\nage = 3\nif age >= 18:\n    print('your age is', age)\n    print('adult')\nelse:\n    print('your age is', age)\n    print('teenager')\n注意不要少写了冒号:。\n\n当然上面的判断是很粗略的，完全可以用elif做更细致的判断：\n\nage = 3\nif age >= 18:\n    print('adult')\nelif age >= 6:\n    print('teenager')\nelse:\n    print('kid')\nelif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：\n\nif <条件判断1>:\n    <执行1>\nelif <条件判断2>:\n    <执行2>\nelif <条件判断3>:\n    <执行3>\nelse:\n    <执行4>\nif语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager：\n\nage = 20\nif age >= 6:\n    print('teenager')\nelif age >= 18:\n    print('adult')\nelse:\n    print('kid')\nif判断条件还可以简写，比如写：\n\nif x:\n    print('True')\n只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。\n\n再议 input\n最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思：\n\nbirth = input('birth: ')\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n输入1982，结果报错：\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unorderable types: str() > int()\n这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：\n\ns = input('birth: ')\nbirth = int(s)\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: invalid literal for int() with base 10: 'abc'\n原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。\n\n如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973937583},"updatedAt":{"$$date":1594976922505},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"k5Ea2VJ4Exlcwtdx"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382134949},"updatedAt":{"$$date":1597382134949},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"k66dLwS1vBH30YL1"}
{"name":"kotlin-对象表达式、对象声明与伴生对象 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/object-declarations.html\n对象表达式、对象声明与伴生对象 - Kotlin 语言中文站\n11-14 minutes\n改进翻译\n有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类。 Kotlin 用对象表达式和对象声明处理这种情况。\n\n要创建一个继承自某个（或某些）类型的匿名类的对象，我们会这么写：\n\nwindow.addMouseListener(object : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { /*……*/ }\n\n    override fun mouseEntered(e: MouseEvent) { /*……*/ }\n})\n如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。 多个超类型可以由跟在冒号后面的逗号分隔的列表指定：\n\nopen class A(x: Int) {\n    public open val y: Int = x\n}\n\ninterface B { /*……*/ }\n\nval ab: A = object : A(1), B {\n    override val y = 15\n}\n任何时候，如果我们只需要“一个对象而已”，并不需要特殊超类型，那么我们可以简单地写：\n\nfun foo() {\n    val adHoc = object {\n        var x: Int = 0\n        var y: Int = 0\n    }\n    print(adHoc.x + adHoc.y)\n}\n请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象中添加的成员将无法访问。\n\nclass C {\n    // 私有函数，所以其返回类型是匿名对象类型\n    private fun foo() = object {\n        val x: String = \"x\"\n    }\n\n    // 公有函数，所以其返回类型是 Any\n    fun publicFoo() = object {\n        val x: String = \"x\"\n    }\n\n    fun bar() {\n        val x1 = foo().x        // 没问题\n        val x2 = publicFoo().x  // 错误：未能解析的引用“x”\n    }\n}\n对象表达式中的代码可以访问来自包含它的作用域的变量。\n\nfun countClicks(window: JComponent) {\n    var clickCount = 0\n    var enterCount = 0\n\n    window.addMouseListener(object : MouseAdapter() {\n        override fun mouseClicked(e: MouseEvent) {\n            clickCount++\n        }\n\n        override fun mouseEntered(e: MouseEvent) {\n            enterCount++\n        }\n    })\n    // ……\n}\n单例模式在一些场景中很有用， 而 Kotlin（继 Scala 之后）使单例声明变得很容易：\n\nobject DataProviderManager {\n    fun registerDataProvider(provider: DataProvider) {\n        // ……\n    }\n\n    val allDataProviders: Collection<DataProvider>\n        get() = // ……\n}\n这称为对象声明。并且它总是在 object 关键字后跟一个名称。 就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边。\n\n对象声明的初始化过程是线程安全的并且在首次访问时进行。\n\n如需引用该对象，我们直接使用其名称即可：\n\nDataProviderManager.registerDataProvider(……)\n这些对象可以有超类型：\n\nobject DefaultListener : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { …… }\n\n    override fun mouseEntered(e: MouseEvent) { …… }\n}\n注意：对象声明不能在局部作用域（即直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中。\n\n类内部的对象声明可以用 companion 关键字标记：\n\nclass MyClass {\n    companion object Factory {\n        fun create(): MyClass = MyClass()\n    }\n}\n该伴生对象的成员可通过只使用类名作为限定符来调用：\n\nval instance = MyClass.create()\n可以省略伴生对象的名称，在这种情况下将使用名称 Companion：\n\nclass MyClass {\n    companion object { }\n}\n\nval x = MyClass.Companion\n其自身所用的类的名称（不是另一个名称的限定符）可用作对该类的伴生对象 （无论是否具名）的引用：\n\nclass MyClass1 {\n    companion object Named { }\n}\n\nval x = MyClass1\n\nclass MyClass2 {\n    companion object { }\n}\n\nval y = MyClass2\n请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口：\n\ninterface Factory<T> {\n    fun create(): T\n}\n\nclass MyClass {\n    companion object : Factory<MyClass> {\n        override fun create(): MyClass = MyClass()\n    }\n}\n\nval f: Factory<MyClass> = MyClass\n当然，在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见Java 互操作性一节 。\n\n对象表达式和对象声明之间有一个重要的语义差别：\n\n对象表达式是在使用他们的地方立即执行（及初始化）的；\n对象声明是在第一次被访问到时延迟初始化的；\n伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307927638},"updatedAt":{"$$date":1597308130224},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kN131CDyI0iCDrnW"}
{"name":"kotlin-习惯用法 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/idioms.html\n习惯用法 - Kotlin 语言中文站\n14-17 minutes\n改进翻译\n一些在 Kotlin 中广泛使用的语法习惯，如果你有更喜欢的语法习惯或者风格，建一个 pull request 贡献给我们吧！\n\ndata class Customer(val name: String, val email: String)\n会为 Customer 类提供以下功能：\n\n所有属性的 getters （对于 var 定义的还有 setters）\nequals()\nhashCode()\ntoString()\ncopy()\n所有属性的 component1()、 component2()……等等（参见数据类）\nfun foo(a: Int = 0, b: String = \"\") { …… }\nval positives = list.filter { x -> x > 0 }\n或者可以更短:\n\nval positives = list.filter { it > 0 }\nif (\"john@example.com\" in emailsList) { …… }\n\nif (\"jane@example.com\" !in emailsList) { …… }\nwhen (x) {\n    is Foo //-> ……\n    is Bar //-> ……\n    else   //-> ……\n}\nfor ((k, v) in map) {\n    println(\"$k -> $v\")\n}\nk、v 可以改成任意名字。\n\nfor (i in 1..100) { …… }  // 闭区间：包含 100\nfor (i in 1 until 100) { …… } // 半开区间：不包含 100\nfor (x in 2..10 step 2) { …… }\nfor (x in 10 downTo 1) { …… }\nif (x in 1..10) { …… }\nval list = listOf(\"a\", \"b\", \"c\")\nval map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)\nprintln(map[\"key\"])\nmap[\"key\"] = value\nval p: String by lazy {\n    // 计算该字符串\n}\nfun String.spaceToCamelCase() { …… }\n\n\"Convert this to camelcase\".spaceToCamelCase()\nobject Resource {\n    val name = \"Name\"\n}\nval files = File(\"Test\").listFiles()\n\nprintln(files?.size)\nIf not null and else 缩写\nval files = File(\"Test\").listFiles()\n\nprintln(files?.size ?: \"empty\")\nval values = ……\nval email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\")\nval emails = …… // 可能会是空集合\nval mainEmail = emails.firstOrNull() ?: \"\"\nval value = ……\n\nvalue?.let {\n    …… // 代码会执行到此处, 假如data不为null\n}\nval value = ……\n\nval mapped = value?.let { transformValue(it) } ?: defaultValue \n// 如果该值或其转换结果为空，那么返回 defaultValue。\nfun transform(color: String): Int {\n    return when (color) {\n        \"Red\" -> 0\n        \"Green\" -> 1\n        \"Blue\" -> 2\n        else -> throw IllegalArgumentException(\"Invalid color param value\")\n    }\n}\nfun test() {\n    val result = try {\n        count()\n    } catch (e: ArithmeticException) {\n        throw IllegalStateException(e)\n    }\n\n    // 使用 result\n}\nfun foo(param: Int) {\n    val result = if (param == 1) {\n        \"one\"\n    } else if (param == 2) {\n        \"two\"\n    } else {\n        \"three\"\n    }\n}\nfun arrayOfMinusOnes(size: Int): IntArray {\n    return IntArray(size).apply { fill(-1) }\n}\n等价于\n\nfun theAnswer(): Int {\n    return 42\n}\n单表达式函数与其它惯用法一起使用能简化代码，例如和 when 表达式一起使用：\n\nfun transform(color: String): Int = when (color) {\n    \"Red\" -> 0\n    \"Green\" -> 1\n    \"Blue\" -> 2\n    else -> throw IllegalArgumentException(\"Invalid color param value\")\n}\nclass Turtle {\n    fun penDown()\n    fun penUp()\n    fun turn(degrees: Double)\n    fun forward(pixels: Double)\n}\n\nval myTurtle = Turtle()\nwith(myTurtle) { // 画一个 100 像素的正方形\n    penDown()\n    for (i in 1..4) {\n        forward(100.0)\n        turn(90.0)\n    }\n    penUp()\n}\nval myRectangle = Rectangle().apply {\n    length = 4\n    breadth = 5\n    color = 0xFAFAFA\n}\n这对于配置未出现在对象构造函数中的属性非常有用。\n\nval stream = Files.newInputStream(Paths.get(\"/some/file.txt\"))\nstream.buffered().reader().use { reader ->\n    println(reader.readText())\n}\n//  public final class Gson {\n//     ……\n//     public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n//     ……\n\ninline fun <reified T: Any> Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java)\nval b: Boolean? = ……\nif (b == true) {\n    ……\n} else {\n    // `b` 是 false 或者 null\n}\nvar a = 1\nvar b = 2\na = b.also { b = a }\nKotlin 的标准库有一个 TODO() 函数，该函数总是抛出一个 NotImplementedError。 其返回类型为 Nothing，因此无论预期类型是什么都可以使用它。 还有一个接受原因参数的重载：\n\nfun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\")\nIntelliJ IDEA 的 kotlin 插件理解 TODO() 的语言，并且会自动在 TODO 工具窗口中添加代码指示。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304158584},"updatedAt":{"$$date":1597306224262},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kWnhkNrKDW9HoWPQ"}
{"name":"py-定义函数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n\n\n如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。\n\n\n\n\n\n空函数\n如果想定义一个什么事也不做的空函数，可以用pass语句：\n\ndef nop():\n    pass\n\n\n\n    pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。\n\npass还可以用在其他语句里，比如：\n\nif age >= 18:\n    pass\n缺少了pass，代码运行就会有语法错误。\n\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973947094},"updatedAt":{"$$date":1594977376708},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"kXPsRnxiSBdx275n"}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244759182},"updatedAt":{"$$date":1597244759182},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"lKZZOn1nLRvLQuEF"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980161374},"updatedAt":{"$$date":1594980161374},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"lSL0yhwJp0jsww3m"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977492065},"updatedAt":{"$$date":1594977492065},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"mWslsYzOUdDNtGza"}
{"name":"py-参数组合","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n\n比如定义一个函数，包含上述若干种参数：\n\ndef f1(a, b, c=0, *args, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)\n\ndef f2(a, b, c=0, *, d, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)\n在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。\n\n>>> f1(1, 2)\na = 1 b = 2 c = 0 args = () kw = {}\n>>> f1(1, 2, c=3)\na = 1 b = 2 c = 3 args = () kw = {}\n>>> f1(1, 2, 3, 'a', 'b')\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {}\n>>> f1(1, 2, 3, 'a', 'b', x=99)\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}\n>>> f2(1, 2, d=99, ext=None)\na = 1 b = 2 c = 0 d = 99 kw = {'ext': None}\n最神奇的是通过一个tuple和dict，你也可以调用上述函数：\n\n>>> args = (1, 2, 3, 4)\n>>> kw = {'d': 99, 'x': '#'}\n>>> f1(*args, **kw)\na = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}\n>>> args = (1, 2, 3)\n>>> kw = {'d': 88, 'x': '#'}\n>>> f2(*args, **kw)\na = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}\n所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\n\n 虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977482517},"updatedAt":{"$$date":1594979486402},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"mkzk64xLn6ACNVl5"}
{"name":"kotlin-集合概述 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collections-overview.html\n集合概述 - Kotlin 语言中文站\n20-25 minutes\n改进翻译\nKotlin 标准库提供了一整套用于管理集合的工具，集合是可变数量（可能为零）的一组条目，各种集合对于解决问题都具有重要意义，并且经常用到。\n\n集合是大多数编程语言的常见概念，因此如果熟悉像 Java 或者 Python 语言的集合，那么可以跳过这一介绍转到详细部分。\n\n集合通常包含相同类型的一些（数目也可以为零）对象。集合中的对象称为元素或条目。例如，一个系的所有学生组成一个集合，可以用于计算他们的平均年龄。 以下是 Kotlin 相关的集合类型：\n\nList 是一个有序集合，可通过索引（反映元素位置的整数）访问元素。元素可以在 list 中出现多次。列表的一个示例是一句话：有一组字、这些字的顺序很重要并且字可以重复。\nSet 是唯一元素的集合。它反映了集合（set）的数学抽象：一组无重复的对象。一般来说 set 中元素的顺序并不重要。例如，字母表是字母的集合（set）。\nMap（或者字典）是一组键值对。键是唯一的，每个键都刚好映射到一个值。值可以重复。map 对于存储对象之间的逻辑连接非常有用，例如，员工的 ID 与员工的位置。\nKotlin 让你可以独立于所存储对象的确切类型来操作集合。换句话说，将 String 添加到 String list 中的方式与添加 Int 或者用户自定义类的到相应 list 中的方式相同。 因此，Kotlin 标准库为创建、填充、管理任何类型的集合提供了泛型的（通用的，双关）接口、类与函数。\n\n这些集合接口与相关函数位于 kotlin.collections 包中。我们来大致了解下其内容。\n\nKotlin 标准库提供了基本集合类型的实现： set、list 以及 map。 一对接口代表每种集合类型：\n\n一个 只读 接口，提供访问集合元素的操作。\n一个 可变 接口，通过写操作扩展相应的只读接口：添加、删除和更新其元素。\n请注意，更改可变集合不需要它是以 var 定义的变量：写操作修改同一个可变集合对象，因此引用不会改变。 但是，如果尝试对 val 集合重新赋值，你将收到编译错误。\n\nTarget platform: JVMRunning on kotlin v. 1.3.72\n\n只读集合类型是型变的。 这意味着，如果类 Rectangle 继承自 Shape，则可以在需要 List <Shape> 的任何地方使用 List <Rectangle>。 换句话说，集合类型与元素类型具有相同的子类型关系。 map 在值（value）类型上是型变的，但在键（key）类型上不是。\n\n反之，可变集合不是型变的；否则将导致运行时故障。 如果 MutableList <Rectangle> 是 MutableList <Shape> 的子类型，你可以在其中插入其他 Shape 的继承者（例如，Circle），从而违反了它的 Rectangle 类型参数。\n\n下面是 Kotlin 集合接口的图表：\n\nCollection interfaces hierarchy\n\n让我们来看看接口及其实现。\n\nCollection<T> 是集合层次结构的根。此接口表示一个只读集合的共同行为：检索大小、检测是否为成员等等。 Collection 继承自 Iterable <T> 接口，它定义了迭代元素的操作。可以使用 Collection 作为适用于不同集合类型的函数的参数。对于更具体的情况，请使用 Collection 的继承者： List 与 Set。\n\nfun printAll(strings: Collection<String>) {\n        for(s in strings) print(\"$s \")\n        println()\n    }\n    \nfun main() {\n    val stringList = listOf(\"one\", \"two\", \"one\")\n    printAll(stringList)\n    \n    val stringSet = setOf(\"one\", \"two\", \"three\")\n    printAll(stringSet)\n}\nMutableCollection 是一个具有写操作的 Collection 接口，例如 add 以及 remove。\n\nfun List<String>.getShortWordsTo(shortWords: MutableList<String>, maxLength: Int) {\n    this.filterTo(shortWords) { it.length <= maxLength }\n    // throwing away the articles\n    val articles = setOf(\"a\", \"A\", \"an\", \"An\", \"the\", \"The\")\n    shortWords -= articles\n}\n\nfun main() {\n    val words = \"A long time ago in a galaxy far far away\".split(\" \")\n    val shortWords = mutableListOf<String>()\n    words.getShortWordsTo(shortWords, 3)\n    println(shortWords)\n}\n\nList<T> 以指定的顺序存储元素，并提供使用索引访问元素的方法。索引从 0 开始 – 第一个元素的索引 – 直到 最后一个元素的索引 即 (list.size - 1)。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Number of elements: ${numbers.size}\")\n    println(\"Third element: ${numbers.get(2)}\")\n    println(\"Fourth element: ${numbers[3]}\")\n    println(\"Index of element \\\"two\\\" ${numbers.indexOf(\"two\")}\")\n//sampleEnd\n}\nList 元素（包括空值）可以重复：List 可以包含任意数量的相同对象或单个对象的出现。 如果两个 List 在相同的位置具有相同大小和相同结构的元素，则认为它们是相等的。\n\ndata class Person(var name: String, var age: Int)\n\nfun main() {\n//sampleStart\n    val bob = Person(\"Bob\", 31)\n    val people = listOf(Person(\"Adam\", 20), bob, bob)\n    val people2 = listOf(Person(\"Adam\", 20), Person(\"Bob\", 31), bob)\n    println(people == people2)\n    bob.age = 32\n    println(people == people2)\n//sampleEnd\n}\nMutableList<T> 是可以进行写操作的 List，例如用于在特定位置添加或删除元素。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    numbers.removeAt(1)\n    numbers[0] = 0\n    numbers.shuffle()\n    println(numbers)\n//sampleEnd\n}\n如你所见，在某些方面，List 与数组（Array）非常相似。 但是，有一个重要的区别：数组的大小是在初始化时定义的，永远不会改变; 反之，List 没有预定义的大小；作为写操作的结果，可以更改 List 的大小：添加，更新或删除元素。\n\n在 Kotlin 中，List 的默认实现是 ArrayList，可以将其视为可调整大小的数组。\n\nSet<T> 存储唯一的元素；它们的顺序通常是未定义的。null 元素也是唯一的：一个 Set 只能包含一个 null。当两个 set 具有相同的大小并且对于一个 set 中的每个元素都能在另一个 set 中存在相同元素，则两个 set 相等。\n\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)\n    println(\"Number of elements: ${numbers.size}\")\n    if (numbers.contains(1)) println(\"1 is in the set\")\n\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    println(\"The sets are equal: ${numbers == numbersBackwards}\")\n//sampleEnd\n}\nMutableSet 是一个带有来自 MutableCollection 的写操作接口的 Set。\n\nSet的默认实现 - LinkedHashSet – 保留元素插入的顺序。 因此，依赖于顺序的函数，例如 first() 或 last()，会在这些 set 上返回可预测的结果。\n\nfun main() {\n//sampleStart\n    val numbers = setOf(1, 2, 3, 4)  // LinkedHashSet is the default implementation\n    val numbersBackwards = setOf(4, 3, 2, 1)\n    \n    println(numbers.first() == numbersBackwards.first())\n    println(numbers.first() == numbersBackwards.last())\n//sampleEnd\n}\n另一种实现方式 – HashSet – 不声明元素的顺序，所以在它上面调用这些函数会返回不可预测的结果。但是，HashSet 只需要较少的内存来存储相同数量的元素。\n\nMap<K, V> 不是 Collection 接口的继承者；但是它也是 Kotlin 的一种集合类型。 Map 存储 键-值 对（或 条目）；键是唯一的，但是不同的键可以与相同的值配对。Map 接口提供特定的函数进行通过键访问值、搜索键和值等操作。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n    \n    println(\"All keys: ${numbersMap.keys}\")\n    println(\"All values: ${numbersMap.values}\")\n    if (\"key2\" in numbersMap) println(\"Value by key \\\"key2\\\": ${numbersMap[\"key2\"]}\")    \n    if (1 in numbersMap.values) println(\"The value 1 is in the map\")\n    if (numbersMap.containsValue(1)) println(\"The value 1 is in the map\") // 同上\n//sampleEnd\n}\n无论键值对的顺序如何，包含相同键值对的两个 Map 是相等的。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)    \n    val anotherMap = mapOf(\"key2\" to 2, \"key1\" to 1, \"key4\" to 1, \"key3\" to 3)\n    \n    println(\"The maps are equal: ${numbersMap == anotherMap}\")\n//sampleEnd\n}\nMutableMap 是一个具有写操作的 Map 接口，可以使用该接口添加一个新的键值对或更新给定键的值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    numbersMap[\"one\"] = 11\n\n    println(numbersMap)\n//sampleEnd\n}\nMap 的默认实现 – LinkedHashMap – 迭代 Map 时保留元素插入的顺序。 反之，另一种实现 – HashMap – 不声明元素的顺序。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308428714},"updatedAt":{"$$date":1597313874945},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"n9MiJr2HmNm0uIVh"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973281648},"updatedAt":{"$$date":1594973281648},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"nhPtihhOx0jffTp2"}
{"name":"kotlin-接口 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/interfaces.html\n接口 - Kotlin 语言中文站\n6-8 minutes\n改进翻译\nKotlin 的接口可以既包含抽象方法的声明也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。\n\n使用关键字 interface 来定义接口\n\n一个类或者对象可以实现一个或多个接口。\n\nclass Child : MyInterface {\n    override fun bar() {\n        // 方法体\n    }\n}\n你可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。\n\ninterface MyInterface {\n    val prop: Int // 抽象的\n\n    val propertyWithImplementation: String\n        get() = \"foo\"\n\n    fun foo() {\n        print(prop)\n    }\n}\n\nclass Child : MyInterface {\n    override val prop: Int = 29\n}\n一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现：\n\ninterface Named {\n    val name: String\n}\n\ninterface Person : Named {\n    val firstName: String\n    val lastName: String\n    \n    override val name: String get() = \"$firstName $lastName\"\n}\n\ndata class Employee(\n    // 不必实现“name”\n    override val firstName: String,\n    override val lastName: String,\n    val position: Position\n) : Person\n实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如\n\ninterface A {\n    fun foo() { print(\"A\") }\n    fun bar()\n}\n\ninterface B {\n    fun foo() { print(\"B\") }\n    fun bar() { print(\"bar\") }\n}\n\nclass C : A {\n    override fun bar() { print(\"bar\") }\n}\n\nclass D : A, B {\n    override fun foo() {\n        super<A>.foo()\n        super<B>.foo()\n    }\n\n    override fun bar() {\n        super<B>.bar()\n    }\n}\n上例中，接口 A 和 B 都定义了方法 foo() 和 bar()。 两者都实现了 foo(), 但是只有 B 实现了 bar() (bar() 在 A 中没有标记为抽象， 因为没有方法体时默认为抽象）。因为 C 是一个实现了 A 的具体类，所以必须要重写 bar() 并实现这个抽象方法。\n\n然而，如果我们从 A 和 B 派生 D，我们需要实现我们从多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306187990},"updatedAt":{"$$date":1597307907724},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"okyR70l78sf8VqLi"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973273709},"updatedAt":{"$$date":1594973273709},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"pt4ptmd2BgnvAGP3"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977495490},"updatedAt":{"$$date":1594977495490},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"pzcJji0MzjtSRx7P"}
{"name":"py-set","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\nset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n\n要创建一个set，需要提供一个list作为输入集合：\n\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。\n\n重复元素在set中自动被过滤：\n\n>>> s = set([1, 1, 2, 2, 3, 3])\n>>> s\n{1, 2, 3}\n通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：\n\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n通过remove(key)方法可以删除元素：\n\n>>> s.remove(4)\n>>> s\n{1, 2, 3}\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n\n>>> s1 = set([1, 2, 3])\n>>> s2 = set([2, 3, 4])\n>>> s1 & s2\n{2, 3}\n>>> s1 | s2\n{1, 2, 3, 4}\nset和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973941643},"updatedAt":{"$$date":1594977107218},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"q3ZnuWnRxMvVwA7U"}
{"name":"java-使用线程池","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                    60L, TimeUnit.SECONDS,\n                                    new SynchronousQueue<Runnable>());\n}\n因此，想创建指定动态范围的线程池，可以这么写：\n\nint min = 4;\nint max = 10;\nExecutorService es = new ThreadPoolExecutor(min, max,\n        60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());\nScheduledThreadPool\n还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用ScheduledThreadPool。放入ScheduledThreadPool的任务可以定期反复执行。\n\n创建一个ScheduledThreadPool仍然是通过Executors类：\n\nScheduledExecutorService ses = Executors.newScheduledThreadPool(4);\n我们可以提交一次性任务，它会在指定延迟后只执行一次：\n\n// 1秒后执行一次性任务:\nses.schedule(new Task(\"one-time\"), 1, TimeUnit.SECONDS);\n如果任务以固定的每3秒执行，我们可以这样写：\n\n// 2秒后开始执行定时任务，每3秒执行:\nses.scheduleAtFixedRate(new Task(\"fixed-rate\"), 2, 3, TimeUnit.SECONDS);\n如果任务以固定的3秒为间隔执行，我们可以这样写：\n\n// 2秒后开始执行定时任务，以3秒为间隔执行:\nses.scheduleWithFixedDelay(new Task(\"fixed-delay\"), 2, 3, TimeUnit.SECONDS);\n注意FixedRate和FixedDelay的区别。FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间：\n\n│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  \n├───────┼───────┼───────┼───────┼────>\n│<─────>│<─────>│<─────>│<─────>│\n而FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：\n\n│░░░│       │░░░░░│       │░░│       │░\n└───┼───────┼─────┼───────┼──┼───────┼──>\n    │<─────>│     │<─────>│  │<─────>│\n因此，使用ScheduledThreadPool时，我们要根据需要选择执行一次、FixedRate执行还是FixedDelay执行。\n\n细心的童鞋还可以思考下面的问题：\n\n在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？\n\n如果任务抛出了异常，后续任务是否继续执行？\n\nJava标准库还提供了一个java.util.Timer类，这个类也可以定期执行任务，但是，一个Timer会对应一个Thread，所以，一个Timer只能定期执行一个任务，多个定时任务必须启动多个Timer，而一个ScheduledThreadPool就可以调度多个定时任务，所以，我们完全可以用ScheduledThreadPool取代旧的Timer。\n\n练习\n从下载练习：使用线程池 （推荐使用IDE练习插件快速下载）\n\n小结\nJDK提供了ExecutorService实现了线程池功能：\n\n线程池内部维护一组线程，可以高效执行大量小任务；\n\nExecutors提供了静态方法创建不同类型的ExecutorService；\n\n必须调用shutdown()关闭ExecutorService；\n\nScheduledThreadPool可以定期调度多个任务。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826929589},"updatedAt":{"$$date":1594968084143},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qQDYRGHkEQkPQz7h"}
{"name":"py-要计算str包含多少个字符，可以用len()函数：","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n>> len('ABC')\n3\n>>> len('中文')\n2\nlen()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：\n\n>>> len(b'ABC')\n3\n>>> len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')\n6\n>>> len('中文'.encode('utf-8'))\n6"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973932390},"updatedAt":{"$$date":1594974680304},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qR1Zq5H4BvK9tAui"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241221886},"updatedAt":{"$$date":1597241221886},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"qg46RdjfmyfoxJEM"}
{"name":"andr-Kotlin-Java 互操作指南","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /kotlin/interop\nKotlin-Java 互操作指南  |  Android 开发者  |  Android Developers\n7-9 minutes\n本文档提供了关于用 Java 和 Kotlin 编写公共 API 的一系列规则，目的是让您从另一种语言使用代码时感觉其符合语言习惯。\n\n上次更新日期：2018 年 5 月 18 日\n\nJava（供 Kotlin 使用）\n不得使用硬关键字\n请勿将 Kotlin 的任何硬关键字用作方法或字段的名称。从 Kotlin 调用时，这些硬关键字需要使用反引号进行转义。允许使用软关键字、修饰符关键字和特殊标识符。\n\n例如，从 Kotlin 使用时，Mockito 的 when 函数需要使用反引号：\n\nval callable = Mockito.mock(Callable::class.java)\nMockito.`when`(callable.call()).thenReturn(/* … */)\n避免使用 Any 的扩展函数或属性的名称\n除非绝对必要，否则应避免对方法使用 Any 的扩展函数的名称或对字段使用 Any 的扩展属性的名称。虽然成员方法和字段始终优先于 Any 的扩展函数或属性，但读取代码时可能很难知道调用的是哪个。\n\n可为 null 性注释\n公共 API 中的每个非基元参数类型、返回类型和字段类型都应具有可为 null 性注释。不带注释的类型会被解释为“平台”类型，而后者的可为 null 性不明确。\n\nJSR 305 软件包注释可用于设置合理的默认值，但目前不建议这样做。这类注释要求编译器遵循一个选择启用标志，而这与 Java 9 的模块系统存在冲突。\n\nLambda 参数位于最后\n符合 SAM 转换条件的参数类型应位于最后。\n\n例如，RxJava 2’s Flowable.create() 方法签名定义为：\n\npublic static  Flowable create(\n    FlowableOnSubscribe source,\n    BackpressureStrategy mode) { /* … */ }\n由于 FlowableOnSubscribe 符合 SAM 转换条件，因此从 Kotlin 对此方法进行的函数调用如下所示：\n\nFlowable.create({ /* … */ }, BackpressureStrategy.LATEST)\n不过，如果该方法签名中的参数颠倒顺序，则函数调用可以使用尾随 lambda 语法：\n\nFlowable.create(BackpressureStrategy.LATEST) { /* … */ }\n属性前缀\n要使方法在 Kotlin 中表示为属性，必须使用严格的“bean”样式的前缀。\n\n访问器方法需要“get”前缀，而对于布尔值返回方法，可以使用“is”前缀。\n\npublic final class User {\n  public String getName() { /* … */ }\n  public boolean isActive() { /* … */ }\n}\nval name = user.name // Invokes user.getName()\nval active = user.active // Invokes user.isActive()\n关联的更改器方法需要“set”前缀。\n\npublic final class User {\n  public String getName() { /* … */ }\n  public void setName(String name) { /* … */ }\n}\nuser.name = \"Bob\" // Invokes user.setName(String)\n如果要将方法作为属性提供，请勿使用“has”/“set”之类的非标准前缀或不带“get”前缀的访问器。带有非标准前缀的方法仍可作为函数进行调用，这种情况或许可以接受，具体取决于方法的行为。\n\n运算符过载\n请注意在 Kotlin 中允许使用特殊调用点语法（即运算符过载）的方法名称。确保这样的方法名称可以有效地与缩短的语法一起使用。\n\npublic final class IntBox {\n  private final int value;\n  public IntBox(int value) {\n    this.value = value;\n  }\n  public IntBox plus(IntBox other) {\n    return new IntBox(value + other.value);\n  }\n}\nval one = IntBox(1)\nval two = IntBox(2)\nval three = one + two // Invokes one.plus(two)\nKotlin（供 Java 使用）\n文件名\n当文件包含顶级函数或属性时，应始终使用 @file:JvmName(\"Foo\") 对其进行注释，以提供一个合适的名称。\n\n默认情况下，MyClass.kt 文件中的顶级成员最终会进入一个名为 MyClassKt 的类中，此名称没有吸引力，并且会泄露作为实现细节的语言。\n\n不妨考虑添加 @file:JvmMultifileClass，以将多个文件中的顶级成员组合到一个类中。\n\nLambda 参数\n需要从 Java 中使用的函数类型应避免返回类型 Unit。这样做要求指定明确的 return Unit.INSTANCE; 语句，但该语句不符合语言习惯。\n\nfun sayHi(callback: (String) -> Unit) = /* … */\n// Kotlin caller:\ngreeter.sayHi { Log.d(\"Greeting\", \"Hello, $it!\") }\n// Java caller:\ngreeter.sayHi(name -> {\n    Log.d(\"Greeting\", \"Hello, \" + name + \"!\");\n    return Unit.INSTANCE;\n});\n此语法也不允许提供从语义上命名的类型以便在其他类型上实现。\n\n在 Kotlin 中为 lambda 类型定义命名的单一抽象方法 (SAM) 接口可以为 Java 更正此问题，但这样就无法在 Kotlin 中使用 lambda 语法。\n\ninterface GreeterCallback {\n    fun greetName(name: String): Unit\n}fun sayHi(callback: GreeterCallback) = /* … */\n// Kotlin caller:\ngreeter.sayHi(object : GreeterCallback {\n    override fun greetName(name: String) {\n        Log.d(\"Greeting\", \"Hello, $name!\")\n    }\n})\n// Java caller:\ngreeter.sayHi(name -> Log.d(\"Greeting\", \"Hello, \" + name + \"!\"))\n在 Java 中定义命名的 SAM 接口就可以使用稍低版本的 Kotlin lambda 语法，其中必须明确指定接口类型。\n\n// Defined in Java:\ninterface GreeterCallback {\n    void greetName(String name);\n}\nfun sayHi(greeter: GreeterCallback) = /* … */\n// Kotlin caller:\ngreeter.sayHi(GreeterCallback { Log.d(\"Greeting\", \"Hello, $it!\") })\n// Java caller:\ngreeter.sayHi(name -> Log.d(\"Greeter\", \"Hello, \" + name + \"!\"));\n要定义一个在 Java 和 Kotlin 中用作 lambda 的参数类型，又要求在这两种语言中使用时都感觉其符合语言习惯，这在目前还无法做到。当前的建议是优先选用函数类型，虽然当返回类型为 Unit 时在 Java 中的体验会受到影响。\n\n避免使用 Nothing 类属\n类属参数为 Nothing 的类型会作为原始类型提供给 Java。原始类型在 Java 中很少使用，应避免使用。\n\n记录异常\n会抛出受检异常的函数应使用 @Throws 记录这些异常。运行时异常应记录在 KDoc 中。\n\n请注意函数委托给的 API，因为它们可能会抛出 Kotlin 本来会以静默方式允许传播的受检异常。\n\n防御性复制\n从公共 API 返回共享或无主的只读集合时，应将其封装在不可修改的容器中或执行防御性复制。虽然 Kotlin 强制要求它们具备只读属性，但在 Java 端没有这样的强制性要求。如果没有封装容器或不执行防御性复制，可能会因返回长期存在的集合引用而违反不变量。\n\n伴生函数\n伴生对象中的公共函数必须带有 @JvmStatic 注释才能作为静态方法公开。\n\n如果没有该注释，则这些函数只能作为静态 Companion 字段中的实例方法使用。\n\n不正确：没有注释\n\nclass KotlinClass {\n    companion object {\n        fun doWork() {\n            /* … */\n        }\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        KotlinClass.Companion.doWork();\n    }\n}\n正确：@JvmStatic 注释\n\nclass KotlinClass {\n    companion object {\n        @JvmStatic fun doWork() {\n            /* … */\n        }\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        KotlinClass.doWork();\n    }\n}\n伴生常量\n在 companion object 中作为有效常量的公共非 const 属性必须带有 @JvmField 注释才能作为静态字段公开。\n\n如果没有该注释，则这些属性只能作为静态 Companion 字段中命名奇怪的“getter”实例使用。使用 @JvmStatic 而不是 @JvmField 可将命名奇怪的“getter”移至类的静态方法，但这样仍然不正确。\n\n不正确：没有注释\n\nclass KotlinClass {\n    companion object {\n        const val INTEGER_ONE = 1\n        val BIG_INTEGER_ONE = BigInteger.ONE\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        System.out.println(KotlinClass.INTEGER_ONE);\n        System.out.println(KotlinClass.Companion.getBIG_INTEGER_ONE());\n    }\n}\n不正确：@JvmStatic 注释\n\nclass KotlinClass {\n    companion object {\n        const val INTEGER_ONE = 1\n        @JvmStatic val BIG_INTEGER_ONE = BigInteger.ONE\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        System.out.println(KotlinClass.INTEGER_ONE);\n        System.out.println(KotlinClass.getBIG_INTEGER_ONE());\n    }\n}\n正确：@JvmField 注释\n\nclass KotlinClass {\n    companion object {\n        const val INTEGER_ONE = 1\n        @JvmField val BIG_INTEGER_ONE = BigInteger.ONE\n    }\n}\npublic final class JavaClass {\n    public static void main(String... args) {\n        System.out.println(KotlinClass.INTEGER_ONE);\n        System.out.println(KotlinClass.BIG_INTEGER_ONE);\n    }\n}\n符合语言习惯的命名\nKotlin 的调用规范与 Java 不同，这可能会改变您为函数命名的方式。请使用 @JvmName 设计名称，使其符合这两种语言的规范或与各自的标准库命名保持一致。\n\n扩展函数和扩展属性最常出现这种情况，因为接收器类型的位置不同。\n\nsealed class Optional\ndata class Some(val value: T): Optional()\nobject None : Optional()@JvmName(\"ofNullable\")\nfun  T?.asOptional() = if (this == null) None else Some(this)\n// FROM KOTLIN:\nfun main(vararg args: String) {\n    val nullableString: String? = \"foo\"\n    val optionalString = nullableString.asOptional()\n}\n// FROM JAVA:\npublic static void main(String... args) {\n    String nullableString = \"Foo\";\n    Optional optionalString =\n          Optionals.ofNullable(nullableString);\n}\n默认值的函数过载\n参数具有默认值的函数必须使用 @JvmOverloads。如果没有此注释，则无法使用任何默认值来调用函数。\n\n使用 @JvmOverloads 时，应检查生成的方法，以确保它们每个都有意义。如果它们没有意义，请执行以下一种或两种重构，直到满意为止：\n\n更改参数顺序，使具有默认值的参数尽量接近末尾。\n将默认值移至手动函数过载。\n不正确：没有 @JvmOverloads\n\nclass Greeting {\n    fun sayHello(prefix: String = \"Mr.\", name: String) {\n        println(\"Hello, $prefix $name\")\n    }\n}\npublic class JavaClass {\n    public static void main(String... args) {\n        Greeting greeting = new Greeting();\n        greeting.sayHello(\"Mr.\", \"Bob\");\n    }\n}\n正确：@JvmOverloads 注释\n\nclass Greeting {\n    @JvmOverloads\n    fun sayHello(prefix: String = \"Mr.\", name: String) {\n        println(\"Hello, $prefix $name\")\n    }\n}\npublic class JavaClass {\n    public static void main(String... args) {\n        Greeting greeting = new Greeting();\n        greeting.sayHello(\"Bob\");\n    }\n}\nLint 检查\n要求\nAndroid Studio 版本：3.2 Canary 10 或更高版本\nAndroid Gradle 插件版本：3.2 或更高版本\n支持的检查\n现在有一些 Android Lint 检查可帮助您检测并标记上述某些互操作性问题。目前只检测到了 Java（供 Kotlin 使用）中的问题。具体来说，支持的检查包括：\n\n未知 Null 性\n属性访问\n不得使用 Kotlin 硬关键字\nLambda 参数位于最后\nAndroid Studio\n要启用这些检查，请依次转到 File > Preferences > Editor > Inspections，然后在“Kotlin Interoperability”下勾选要启用的规则：\n\n\n\n图 1.Android Studio 中的 Kotlin 互操作性设置。\n\n勾选要启用的规则后，当您运行代码检查（依次转到 Analyze > Inspect Code…）时，将运行新的检查。\n\n命令行 build\n要通过命令行 build 启用这些检查，请在 build.gradle 文件中添加以下代码行：\n\nandroid {...\n    lintOptions \n\n{\n        enable 'Interoperability'\n    }\n}\n如需了解 lintOptions 内支持的全部配置，请参阅 Android Gradle DSL 参考。\n\n然后，从命令行运行 ./gradlew lint。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244740351},"updatedAt":{"$$date":1597245341438},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"r2G2IlUjtfTnbqX7"}
{"name":"kotlin-Kotlin 基础语法 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-basic-syntax.html\nKotlin 基础语法 | 菜鸟教程\n4-5 minutes\nKotlin 文件以 .kt 为后缀。\n\n包声明\n代码文件的开头一般为包的声明：\n\npackage com.runoob.main\n\nimport java.util.*\n\nfun test() {}\nclass Runoob {}\nkotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。\n\n以上例中 test() 的全名是 com.runoob.main.test、Runoob 的全名是 com.runoob.main.Runoob。\n\n如果没有指定包，默认为 default 包。\n\n默认导入\n有多个包会默认导入到每个 Kotlin 文件中：\n\nkotlin.*\nkotlin.annotation.*\nkotlin.collections.*\nkotlin.comparisons.*\nkotlin.io.*\nkotlin.ranges.*\nkotlin.sequences.*\nkotlin.text.*\n函数定义\n函数定义使用关键字 fun，参数格式为：参数 : 类型\n\nfun sum(a: Int, b: Int): Int {   // Int 参数，返回值 Int\n    return a + b\n}\n表达式作为函数体，返回类型自动推断：\n\nfun sum(a: Int, b: Int) = a + b\n\npublic fun sum(a: Int, b: Int): Int = a + b   // public 方法则必须明确写出返回类型\n无返回值的函数(类似Java中的void)：\n\nfun printSum(a: Int, b: Int): Unit { \n    print(a + b)\n}\n\n\n// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：\npublic fun printSum(a: Int, b: Int) { \n    print(a + b)\n}\n可变长参数函数\n函数的变长参数可以用 vararg 关键字进行标识：\n\nfun vars(vararg v:Int){\n    for(vt in v){\n        print(vt)\n    }\n}\n\n// 测试\nfun main(args: Array<String>) {\n    vars(1,2,3,4,5)  // 输出12345\n}\nlambda(匿名函数)\nlambda表达式使用实例：\n\n// 测试\nfun main(args: Array<String>) {\n    val sumLambda: (Int, Int) -> Int = {x,y -> x+y}\n    println(sumLambda(1,2))  // 输出 3\n}\n定义常量与变量\n可变变量定义：var 关键字\n\nvar <标识符> : <类型> = <初始化值>\n不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)\n\nval <标识符> : <类型> = <初始化值>\n常量与变量都可以没有初始化值,但是在引用前必须初始化\n\n编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。\n\nval a: Int = 1\nval b = 1       // 系统自动推断变量类型为Int\nval c: Int      // 如果不在声明时初始化则必须提供变量类型\nc = 1           // 明确赋值\n\n\nvar x = 5        // 系统自动推断变量类型为Int\nx += 1           // 变量可修改\n注释\nKotlin 支持单行和多行注释，实例如下：\n\n// 这是一个单行注释\n\n/* 这是一个多行的\n   块注释。 */\n与 Java 不同, Kotlin 中的块注释允许嵌套。\n\n字符串模板\n$ 表示一个变量名或者变量值\n\n$varName 表示变量值\n\n${varName.fun()} 表示变量的方法返回值:\n\nvar a = 1\n// 模板中的简单名称：\nval s1 = \"a is $a\" \n\na = 2\n// 模板中的任意表达式：\nval s2 = \"${s1.replace(\"is\", \"was\")}, but now is $a\"\nNULL检查机制\nKotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理\n\n//类型后面加?表示可为空\nvar age: String? = \"23\" \n//抛出空指针异常\nval ages = age!!.toInt()\n//不做处理返回 null\nval ages1 = age?.toInt()\n//age为空返回-1\nval ages2 = age?.toInt() ?: -1\n当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。\n\n当 str 中的字符串内容不是一个整数时, 返回 null:\n\nfun parseInt(str: String): Int? {\n  // ...\n}\n以下实例演示如何使用一个返回值可为 null 的函数:\n\nfun main(args: Array<String>) {\n  if (args.size < 2) {\n    print(\"Two integers expected\")\n    return\n  }\n  val x = parseInt(args[0])\n  val y = parseInt(args[1])\n  // 直接使用 `x * y` 会导致错误, 因为它们可能为 null.\n  if (x != null && y != null) {\n    // 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量\n    print(x * y)\n  }\n}\n类型检测及自动类型转换\n我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。\n\nfun getStringLength(obj: Any): Int? {\n  if (obj is String) {\n    // 做过类型判断以后，obj会被系统自动转换为String类型\n    return obj.length \n  }\n\n  //在这里还有一种方法，与Java中instanceof不同，使用!is\n  // if (obj !is String){\n  //   // XXX\n  // }\n\n  // 这里的obj仍然是Any类型的引用\n  return null\n}\n或者\n\nfun getStringLength(obj: Any): Int? {\n  if (obj !is String)\n    return null\n  // 在这个分支中, `obj` 的类型会被自动转换为 `String`\n  return obj.length\n}\n甚至还可以\n\nfun getStringLength(obj: Any): Int? {\n  // 在 `&&` 运算符的右侧, `obj` 的类型会被自动转换为 `String`\n  if (obj is String && obj.length > 0)\n    return obj.length\n  return null\n}\n区间\n区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。\n\n区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例:\n\nfor (i in 1..4) print(i) // 输出“1234”\n\nfor (i in 4..1) print(i) // 什么都不输出\n\nif (i in 1..10) { // 等同于 1 <= i && i <= 10\n    println(i)\n}\n\n// 使用 step 指定步长\nfor (i in 1..4 step 2) print(i) // 输出“13”\n\nfor (i in 4 downTo 1 step 2) print(i) // 输出“42”\n\n\n// 使用 until 函数排除结束元素\nfor (i in 1 until 10) {   // i in [1, 10) 排除了 10\n     println(i)\n}\n实例测试\nfun main(args: Array<String>) {\n    print(\"循环输出：\")\n    for (i in 1..4) print(i) // 输出“1234”\n    println(\"\\n----------------\")\n    print(\"设置步长：\")\n    for (i in 1..4 step 2) print(i) // 输出“13”\n    println(\"\\n----------------\")\n    print(\"使用 downTo：\")\n    for (i in 4 downTo 1 step 2) print(i) // 输出“42”\n    println(\"\\n----------------\")\n    print(\"使用 until：\")\n    // 使用 until 函数排除结束元素\n    for (i in 1 until 4) {   // i in [1, 4) 排除了 4\n        print(i)\n    }\n    println(\"\\n----------------\")\n}\n输出结果：\n\n循环输出：1234\n----------------\n设置步长：13\n----------------\n使用 downTo：42\n----------------\n使用 until：123\n----------------"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303687029},"updatedAt":{"$$date":1597303781660},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"r58qMvy8EO8g46MN"}
{"name":"java-使用ThreadLocal","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"多线程是Java实现多任务的基础，Thread对象代表一个线程，我们可以在代码中调用Thread.currentThread()获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字：\n\n// Thread\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        log(\"start main...\");\n        new Thread(() -> {\n            log(\"run task...\");\n        }).start();\n        new Thread(() -> {\n            log(\"print...\");\n        }).start();\n        log(\"end main.\");\n    }\n\n    static void log(String s) {\n        System.out.println(Thread.currentThread().getName() + \": \" + s);\n    }\n}\n\n Run\n对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：\n\npublic void process(User user) {\n    checkPermission();\n    doWork();\n    saveStatus();\n    sendResponse();\n}\n然后，通过线程池去执行这些任务。\n\n观察process()方法，它内部需要调用若干其他方法，同时，我们遇到一个问题：如何在一个线程内传递状态？\n\nprocess()方法需要传递的状态就是User实例。有的童鞋会想，简单地传入User就可以了：\n\npublic void process(User user) {\n    checkPermission(user);\n    doWork(user);\n    saveStatus(user);\n    sendResponse(user);\n}\n但是往往一个方法又会调用其他很多方法，这样会导致User传递到所有地方：\n\nvoid doWork(User user) {\n    queryStatus(user);\n    checkStatus();\n    setNewStatus(user);\n    log();\n}\n这种在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。\n\n给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，User对象就传不进去了。\n\nJava标准库提供了一个特殊的ThreadLocal，它可以在一个线程中传递同一个对象。\n\nThreadLocal实例通常总是以静态字段初始化如下：\n\nstatic ThreadLocal<User> threadLocalUser = new ThreadLocal<>();\n它的典型使用方式如下：\n\nvoid processUser(user) {\n    try {\n        threadLocalUser.set(user);\n        step1();\n        step2();\n    } finally {\n        threadLocalUser.remove();\n    }\n}\n通过设置一个User实例关联到ThreadLocal中，在移除之前，所有方法都可以随时获取到该User实例：\n\nvoid step1() {\n    User u = threadLocalUser.get();\n    log();\n    printUser();\n}\n\nvoid log() {\n    User u = threadLocalUser.get();\n    println(u.name);\n}\n\nvoid step2() {\n    User u = threadLocalUser.get();\n    checkUser(u.id);\n}\n注意到普通的方法调用一定是同一个线程执行的，所以，step1()、step2()以及log()方法内，threadLocalUser.get()获取的User对象是同一个实例。\n\n实际上，可以把ThreadLocal看成一个全局Map<Thread, Object>：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key：\n\nObject threadLocalValue = threadLocalMap.get(Thread.currentThread());\n因此，ThreadLocal相当于给每个线程都开辟了一个独立的存储空间，各个线程的ThreadLocal关联的实例互不干扰。\n\n最后，特别注意ThreadLocal一定要在finally中清除：\n\ntry {\n    threadLocalUser.set(user);\n    ...\n} finally {\n    threadLocalUser.remove();\n}\n这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。\n\n为了保证能释放ThreadLocal关联的实例，我们可以通过AutoCloseable接口配合try (resource) {...}结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的ThreadLocal可以封装为一个UserContext对象：\n\npublic class UserContext implements AutoCloseable {\n\n    static final ThreadLocal<String> ctx = new ThreadLocal<>();\n\n    public UserContext(String user) {\n        ctx.set(user);\n    }\n\n    public static String currentUser() {\n        return ctx.get();\n    }\n\n    @Override\n    public void close() {\n        ctx.remove();\n    }\n}\n使用的时候，我们借助try (resource) {...}结构，可以这么写：\n\ntry (var ctx = new UserContext(\"Bob\")) {\n    // 可任意调用UserContext.currentUser():\n    String currentUser = UserContext.currentUser();\n} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象\n这样就在UserContext中完全封装了ThreadLocal，外部代码在try (resource) {...}内部可以随时调用UserContext.currentUser()获取当前线程绑定的用户名。\n\n练习\n从下载练习：ThreadLocal练习 （推荐使用IDE练习插件快速下载）\n\n小结\nThreadLocal表示线程的“局部变量”，它确保每个线程的ThreadLocal变量都是各自独立的；\n\nThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；\n\n使用ThreadLocal要用try ... finally结构，并在finally中清除。\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826932040},"updatedAt":{"$$date":1594973551028},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"rUCGLq25zuOwlDvT"}
{"name":"andr-字符串","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/resources/string-resource\n字符串资源  |  Android 开发者  |  Android Developers\n18-23 minutes\n字符串资源为您的应用提供具有可选文本样式和格式设置的文本字符串。共有三种类型的资源可为您的应用提供字符串：\n\nString\n提供单个字符串的 XML 资源。\nString Array\n提供字符串数组的 XML 资源。\nQuantity Strings (Plurals)\n带有用于多元化的不同字符串的 XML 资源。\n所有字符串都能应用某些样式设置标记和格式设置参数。如需了解有关样式和格式设置字符串的信息，请参阅格式和样式设置部分。\n\nString\n可从应用或其他资源文件（如 XML 布局）引用的单个字符串。\n\n请注意：字符串是一种简单资源，您可以使用 name 属性（并非 XML 文件的名称）中提供的值对其进行引用。因此，您可以在一个 <resources> 元素下，将字符串资源与其他简单资源合并到一个 XML 文件中。\n\n文件位置：\nres/values/filename.xml\nfilename 是任意值。<string> 元素的 name 用作资源 ID。\n编译资源的数据类型：\n指向 String 的资源指针。\n资源引用：\n在 Java 中：R.string.string_name\n在 XML 中：@string/string_name\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string\n        name=\"string_name\"\n        >text_string</string>\n</resources>\n元素：\n<resources>\n必备。此元素必须是根节点。\n无属性。\n\n<string>\n字符串，可包含样式设置标记。请注意，您必须对撇号和引号进行转义。如需了解有关如何正确设置字符串样式和格式的详细信息，请参阅下文的格式和样式设置。\n属性：\n\nname\nString。字符串的名称。此名称用作资源 ID。\n示例：\n保存在 res/values/strings.xml 的 XML 文件：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string name=\"hello\">Hello!</string>\n</resources>\n该布局 XML 会对视图应用一个字符串：\n\n<TextView\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"@string/hello\" />\n以下应用代码用于检索字符串：\n\n您可以使用 getString(int) 或 getText(int) 检索字符串。getText(int) 会保留所有应用于字符串的富文本样式。\n\nString Array\n可从应用引用的字符串数组。\n\n请注意：字符串数组是一种简单资源，您可以使用 name 属性（并非 XML 文件的名称）中提供的值对其进行引用。因此，您可以在一个 <resources> 元素下，将字符串数组资源与其他简单资源合并到一个 XML 文件中。\n\n文件位置：\nres/values/filename.xml\nfilename 是任意值。<string-array> 元素的 name 用作资源 ID。\n编译资源的数据类型：\n指向 String 数组的资源指针。\n资源引用：\n在 Java 中：R.array.string_array_name\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string-array\n        name=\"string_array_name\">\n        <item\n            >text_string</item>\n    </string-array>\n</resources>\n元素：\n<resources>\n必备。此元素必须是根节点。\n无属性。\n\n<string-array>\n定义一个字符串数组。包含一个或多个 <item> 元素。\n属性：\n\nname\nString。数组的名称。此名称用作引用数组的资源 ID。\n<item>\n字符串，可包含样式设置标记。其值可以是对另一字符串资源的引用。必须为 <string-array> 元素的子项。请注意，您必须对撇号和引号进行转义。如需了解有关如何正确设置字符串样式和格式的信息，请参阅下文的格式和样式设置。\n无属性。\n\n示例：\n保存在 res/values/strings.xml 的 XML 文件：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string-array name=\"planets_array\">\n        <item>Mercury</item>\n        <item>Venus</item>\n        <item>Earth</item>\n        <item>Mars</item>\n    </string-array>\n</resources>\n以下应用代码用于检索字符串数组：\n\nQuantity Strings (Plurals)\n针对语法数量的一致性，不同语言有不同规则。例如，在英语中，数量 1 是一种特殊情况。我们会写成“1 book”，但如果是任何其他数量，则会写成“n books”。这种对单复数的区分很常见，但其他语言拥有更细致的区分。Android 支持以下完整集合：zero、one、two、few、many 和 other。\n\n决定为给定语言和数量使用哪种情况的规则可能非常复杂，因此 Android 为您提供 getQuantityString() 等方法来选择合适资源。\n\n虽然 Quantity Strings 过去称作“Quantity Strings”（并且 API 中仍采用此名称），但其只应用于表示复数。例如，类似使用 Quantity Strings 实现 Gmail 的“Inbox”这类情况便属于错误行为，正确的做法是用其实现“Inbox (12)”这种存在未读邮件的情况。使用 Quantity Strings 来替代 if 语句似乎很方便，但必须注意的是，某些语言（如中文）根本不做这些语法区分，因此您获取的始终是 other 字符串。\n\n选择使用哪一个字符串完全取决于语法上的必要性。在英语中，即使数量为 0，表示 zero 的字符串也会被忽略，因为在语法上，0 与 2 或除 1 以外的任何其他数字并无区别（“zero books”、“one book”、“two books”等）。相反，韩语中仅使用过 other 字符串。\n\n请勿被某些事实误导，例如 two 听起来仅适用于数量 2：某种语言可能规定，对 2、12、102（依此类推）等数量进行相同处理，但对其他数量进行特殊处理。您可以依靠翻译人员来了解其语言的实际区分要求。\n\n通常，您可以利用“Books: 1”等无需考虑数量的表示，从而避免使用 Quantity Strings。如果您的应用可接受此样式，则您和翻译人员的工作都会更轻松。\n\n请注意：Plurals 集合是一种简单资源，您可以使用 name 属性（并非 XML 文件的名称）中提供的值对其进行引用。因此，您可以在一个 <resources> 元素下，将 plurals 资源与其他简单资源合并到一个 XML 文件中。\n\n文件位置：\nres/values/filename.xml\nfilename 是任意值。<plurals> 元素的 name 用作资源 ID。\n资源引用：\n在 Java 中：R.plurals.plural_name\n语法：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <plurals\n        name=\"plural_name\">\n        <item\n            quantity=[\"zero\" | \"one\" | \"two\" | \"few\" | \"many\" | \"other\"]\n            >text_string</item>\n    </plurals>\n</resources>\n元素：\n<resources>\n必备。此元素必须是根节点。\n无属性。\n\n<plurals>\n字符串集合，根据事物数量提供其中的一个字符串。包含一个或多个 <item> 元素。\n属性：\n\nname\nString。字符串对的名称。此名称用作资源 ID。\n<item>\n一个复数或单数字符串。其值可以是对另一字符串资源的引用。必须为 <plurals> 元素的子项。请注意，您必须对撇号和引号进行转义。如需了解有关如何正确设置字符串样式和格式的信息，请参阅下文的格式和样式设置。\n属性：\n\nquantity\n关键字。表示应在何时使用该字符串的值。以下是该关键字的有效值（括号内仅为部分示例）：\nValue\t描述\nzero\t当某种语言要求对数字 0（如阿拉伯语中的 0）进行特殊处理时。\none\t当某种语言要求对 1 这类数字（如英语和大多数其他语言中的数字 1；在俄语中，任何末尾为 1 但非 11 的数字均属此类）进行特殊处理时。\ntwo\t当某种语言要求对 2 这类数字（如威尔士语中的 2，或斯洛文尼亚语中的 102）进行特殊处理时。\nfew\t当某种语言要求对“小”数字（如捷克语中的 2、3 和 4；或波兰语中末尾为 2、3 或 4，但非 12、13 或 14 的数字）进行特殊处理时。\nmany\t当某种语言要求对“大”数字（如马耳他语中末尾为 11 至 99 的数字）进行特殊处理时。\nother\t当某种语言未要求对给定数量（如中文中的所有数字，或英语中的 42）进行特殊处理时。\n示例：\n保存在 res/values/strings.xml 的 XML 文件：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <plurals name=\"numberOfSongsAvailable\">\n        <!--\n             As a developer, you should always supply \"one\" and \"other\"\n             strings. Your translators will know which strings are actually\n             needed for their language. Always include %d in \"one\" because\n             translators will need to use %d for languages where \"one\"\n             doesn't mean 1 (as explained above).\n          -->\n        <item quantity=\"one\">%d song found.</item>\n        <item quantity=\"other\">%d songs found.</item>\n    </plurals>\n</resources>\n保存在 res/values-pl/strings.xml 中的 XML 文件：\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <plurals name=\"numberOfSongsAvailable\">\n        <item quantity=\"one\">Znaleziono %d piosenkę.</item>\n        <item quantity=\"few\">Znaleziono %d piosenki.</item>\n        <item quantity=\"other\">Znaleziono %d piosenek.</item>\n    </plurals>\n</resources>\n用法：\n\nval count = getNumberOfSongsAvailable()\nval songsFound = resources.\ngetQuantityString\n(R.plurals.numberOfSongsAvailable, count, count)\nint count = getNumberOfSongsAvailable();\nResources res = \ngetResources()\n;\nString songsFound = res.\ngetQuantityString\n(R.plurals.numberOfSongsAvailable, count, count);\n使用 getQuantityString() 方法时，如果您的字符串包含带有数字的字符串格式设置，则您需要传递两次 count。例如，对于字符串 %d songs found，第一个 count 参数会选择相应的复数字符串，第二个 count 参数会被插入 %d 占位符内。如果您的复数字符串没有字符串格式设置，则无需向 getQuantityString 传递第三个参数。\n\n格式和样式\n关于如何正确设置字符串资源的格式和样式，您应了解以下几个要点。\n\n处理特殊字符\n如果 XML 或 Android 中的字符串包含有特殊用法的字符，则必须转义这些字符。您可以使用前导反斜杠转义某些字符，但其他字符需使用 XML 转义。您也可以通过在双引号中包括整个字符串，处理撇号和单引号。以下为部分示例：\n\n字符\t转义形式\n@\t\\@\n?\t\\?\n<\t&lt;\n&\t&amp;\n单引号 (')\t\n以下任意字符：\n\n&apos;\n\\'\n在双引号中包括整个字符串（例如，\"This'll work\"）\n双引号 (\")\t\n以下任意字符：\n\n&quot;\n\\\"\n请注意，您必须转义双引号。在单引号中包括字符串没有任何作用。\n\n设置字符串格式\n如需设置字符串的格式，您可以在字符串资源中放入格式参数（如以下示例资源所示）。\n\n<string name=\"welcome_messages\">Hello, %1$s! You have %2$d new messages.</string>\n在本例中，格式字符串有两个参数：%1$s 为字符串，而 %2$d 为十进制数字。然后，您可通过调用 getString(int, Object...) 来设置字符串格式。例如：\n\nvar text = getString(R.string.welcome_messages, username, mailCount)\nString text = getString(R.string.welcome_messages, username, mailCount);\n使用 HTML 标记设置样式\n您可以使用 HTML 标记为字符串添加样式设置。例如：\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string name=\"welcome\">Welcome to <b>Android</b>!</string>\n</resources>\n支持以下 HTML 元素：\n\n粗体：<b>、<em>\n斜体：<i>、<cite>、<dfn>\n文本放大 25%：<big>\n文本缩小 20%：<small>\n设置字体属性：<font face=”font_family“ color=”hex_color”>。可能的字体系列示例包括 monospace、serif 和 sans_serif。\n设置等宽字体系列：<tt>\n删除线：<s>、<strike>、<del>\n下划线：<u>\n上标：<sup>\n下标：<sub>\n列表标记：<ul>、<li>\n换行符：<br>\n区隔标记：<div>\nCSS 样式：<span style=”color|background_color|text-decoration”>\n段落：<p dir=”rtl | ltr” style=”…”>\n如果您没有应用格式设置，则可通过调用 setText(java.lang.CharSequence) 直接设置 TextView 文本。但在某些情况下，您可能想创建带样式的文本资源，并将其用作格式字符串。您通常无法实现此目标，因为 format(String, Object...) 和 getString(int, Object...) 方法会删除字符串中的所有样式信息。解决方法是编写带转义实体的 HTML 标记，并在完成格式设置后通过 fromHtml(String) 恢复这些实体。例如：\n\n将您带样式的文本资源存储为 HTML 转义字符串：\n<resources>\n  <string name=\"welcome_messages\">Hello, %1$s! You have &lt;b>%2$d new messages&lt;/b>.</string>\n</resources>\n如上所示，带格式的字符串中添加了 <b> 元素。请注意，开括号使用 &lt; 符号实现了 HTML 转义。\n\n然后照常设置字符串格式，但还需调用 fromHtml(String)，以将 HTML 文本转换成带样式的文本：\nval text: String = getString(R.string.welcome_messages, username, mailCount)\nval styledText: Spanned = Html.fromHtml(text, FROM_HTML_MODE_LEGACY)\nString text = getString(R.string.welcome_messages, username, mailCount);\nSpanned styledText = Html.fromHtml(text, FROM_HTML_MODE_LEGACY);\n由于 fromHtml(String) 方法会设置所有 HTML 实体的格式，因此请务必使用 htmlEncode(String) 转义带格式文本的字符串中任何可能存在的 HTML 字符。例如，如果您打算对包含“<”或“&”等字符的字符串进行格式设置，则在设置格式前必须先转义这类字符。如此一来，当通过 fromHtml(String) 传递带格式的字符串时，字符才会以最初的编写形式显示。例如：\n\nval escapedUsername: String = TextUtils.\nhtmlEncode\n(username)val text: String = getString(R.string.welcome_messages, escapedUsername, mailCount)\nval styledText: Spanned = Html.fromHtml(text, FROM_HTML_MODE_LEGACY)\nString escapedUsername = TextUtils.\nhtmlEncode\n(username);String text = getString(R.string.welcome_messages, escapedUsername, mailCount);\nSpanned styledText = Html.fromHtml(text);\n使用 Spannable 设置样式\nSpannable 是一种文本对象，您可使用颜色和字体粗细等字体属性对其进行样式设置。您可以使用 SpannableStringBuilder 生成文本，然后对文本应用 android.text.style 软件包中定义的样式。\n\n您可以使用以下辅助方法设置创建 spannable 文本的大量工作：\n\n/**\n * Returns a CharSequence that concatenates the specified array of CharSequence\n * objects and then applies a list of zero or more tags to the entire range.\n *\n * @param content an array of character sequences to apply a style to\n * @param tags the styled span objects to apply to the content\n *        such as android.text.style.StyleSpan\n */\nprivate fun apply(content: Array<out CharSequence>, vararg tags: Any): CharSequence {\n    return SpannableStringBuilder().apply {\n        openTags(tags)\n        content.forEach { charSequence ->\n            append(charSequence)\n        }\n        closeTags(tags)\n    }\n}/**\n * Iterates over an array of tags and applies them to the beginning of the specified\n * Spannable object so that future text appended to the text will have the styling\n * applied to it. Do not call this method directly.\n */\nprivate fun Spannable.openTags(tags: Array<out Any>) {\n    tags.forEach { tag ->\n        setSpan(tag, 0, 0, Spannable.SPAN_MARK_MARK)\n    }\n}/**\n * \"Closes\" the specified tags on a Spannable by updating the spans to be\n * endpoint-exclusive so that future text appended to the end will not take\n * on the same styling. Do not call this method directly.\n */\nprivate fun Spannable.closeTags(tags: Array<out Any>) {\n    tags.forEach { tag ->\n    if (length > 0) {\n            setSpan(tag, 0, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)\n        } else {\n            removeSpan(tag)\n        }\n    }\n}\n/**\n * Returns a CharSequence that concatenates the specified array of CharSequence\n * objects and then applies a list of zero or more tags to the entire range.\n *\n * @param content an array of character sequences to apply a style to\n * @param tags the styled span objects to apply to the content\n *        such as android.text.style.StyleSpan\n *\n */\nprivate static CharSequence applyStyles(CharSequence[] content, Object[] tags) {\n    SpannableStringBuilder text = new SpannableStringBuilder();\n    openTags(text, tags);\n    for (CharSequence item : content) {\n        text.append(item);\n    }\n    closeTags(text, tags);\n    return text;\n}/**\n * Iterates over an array of tags and applies them to the beginning of the specified\n * Spannable object so that future text appended to the text will have the styling\n * applied to it. Do not call this method directly.\n */\nprivate static void openTags(Spannable text, Object[] tags) {\n    for (Object tag : tags) {\n        text.setSpan(tag, 0, 0, Spannable.SPAN_MARK_MARK);\n    }\n}/**\n * \"Closes\" the specified tags on a Spannable by updating the spans to be\n * endpoint-exclusive so that future text appended to the end will not take\n * on the same styling. Do not call this method directly.\n */\nprivate static void closeTags(Spannable text, Object[] tags) {\n    int len = text.length();\n    for (Object tag : tags) {\n        if (len > 0) {\n            text.setSpan(tag, 0, len, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n        } else {\n            text.removeSpan(tag);\n        }\n    }\n}\n以下 bold、italic 和 color 方法包含上述辅助方法，并展示应用 android.text.style 软件包中所定义样式的具体示例。通过创建类似的方法，您也可对其他类型的文本进行样式设置。\n\n/**\n * Returns a CharSequence that applies boldface to the concatenation\n * of the specified CharSequence objects.\n */\nfun bold(vararg content: CharSequence): CharSequence = apply(content, StyleSpan(Typeface.BOLD))/**\n * Returns a CharSequence that applies italics to the concatenation\n * of the specified CharSequence objects.\n */\nfun italic(vararg content: CharSequence): CharSequence = apply(content, StyleSpan(Typeface.ITALIC))/**\n * Returns a CharSequence that applies a foreground color to the\n * concatenation of the specified CharSequence objects.\n */\nfun color(color: Int, vararg content: CharSequence): CharSequence =\n        apply(content, ForegroundColorSpan(color))\n/**\n * Returns a CharSequence that applies boldface to the concatenation\n * of the specified CharSequence objects.\n */\npublic static CharSequence bold(CharSequence... content) {\n    return apply(content, new StyleSpan(Typeface.BOLD));\n}/**\n * Returns a CharSequence that applies italics to the concatenation\n * of the specified CharSequence objects.\n */\npublic static CharSequence italic(CharSequence... content) {\n    return apply(content, new StyleSpan(Typeface.ITALIC));\n}/**\n * Returns a CharSequence that applies a foreground color to the\n * concatenation of the specified CharSequence objects.\n */\npublic static CharSequence color(int color, CharSequence... content) {\n    return apply(content, new ForegroundColorSpan(color));\n}\n以下示例展示如何通过结合这些方法，向短语中的单个字词应用各种样式：\n\n// Create an italic \"hello, \" a red \"world\",\n// and bold the entire sequence.\nval text: CharSequence = bold(italic(getString(R.string.hello)),\n        color(Color.RED, getString(R.string.world)))\n// Create an italic \"hello, \" a red \"world\",\n// and bold the entire sequence.\nvar text = bold(italic(getString(R.string.hello)),\n  color(Color.RED, getString(R.string.world)))\n</pre>\n</section><section><h3 id=\"java\">Java</h3>\n<pre class=\"prettyprint lang-java\">\n// Create an italic \"hello, \" a red \"world\",\n// and bold the entire sequence.\nCharSequence text = bold(italic(getString(R.string.hello)),\n    color(Color.RED, getString(R.string.world)));\ncore-ktx Kotlin 模块还包含扩展函数，便于您更轻松地使用 span。您可以前往 GitHub 查看 android.text 软件包文档，了解详情。\n\n如需了解有关使用 span 的更多信息，请访问以下链接：\n\n使用 Span 设置样式的文本\n了解 span\n使用注解设置样式\n您可以通过使用 strings.xml 资源文件中的 Annotation 类和 <annotation> 标记，应用复杂样式或自定义样式。借助注解标记，您可以通过在 XML 文件中定义自定义键值对来标记自定义样式的部分字符串，框架随后会将该 XML 文件转换成 Annotation span。然后，您便可检索这些注解，并使用键和值来应用样式。\n\n创建注解时，请务必为 strings.xml 文件中的所有字符串翻译添加 <annotation> 标记。\n\n\n在所有语言中向“text”一词应用自定义字体\n\n示例 - 添加自定义字体\n添加 <annotation> 标记并定义键值对。在此情况下，键为 font，而值是我们要使用的字体类型：title_emphasis\n\n// values/strings.xml\n<string name=\"title\">Best practices for <annotation font=\"title_emphasis\">text</annotation> on Android</string>\n// values-es/strings.xml\n\n<string name=\"title\"><annotation font=\"title_emphasis\">Texto</annotation> en Android: mejores prácticas</string>\n加载字符串资源并找到包含 font 键的注解。然后，创建一个自定义 span，并用其替换现有 span。\n\n// get the text as SpannedString so we can get the spans attached to the text\nval titleText = getText(R.string.title) as SpannedString// get all the annotation spans from the text\nval annotations = titleText.getSpans(0, titleText.length, Annotation::class.java)// create a copy of the title text as a SpannableString.\n// the constructor copies both the text and the spans. so we can add and remove spans\nval spannableString = SpannableString(titleText)// iterate through all the annotation spans\nfor (annotation in annotations) {\n   // look for the span with the key font\n   if (annotation.key == \"font\") {\n      val fontName = annotation.value\n      // check the value associated to the annotation key\n      if (fontName == \"title_emphasis\") {\n         // create the typeface\n         val typeface = getFontCompat(R.font.permanent_marker)\n         // set the span at the same indices as the annotation\n         spannableString.setSpan(CustomTypefaceSpan(typeface),\n            titleText.getSpanStart(annotation),\n            titleText.getSpanEnd(annotation),\n            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)\n      }\n   }\n}// now, the spannableString contains both the annotation spans and the CustomTypefaceSpan\nstyledText.text = spannableString\n// get the text as SpannedString so we can get the spans attached to the text\nSpannedString titleText = (SpannedString) getText(R.string.title_about);// get all the annotation spans from the text\nAnnotation[] annotations = titleText.getSpans(0, titleText.length(), Annotation.class);// create a copy of the title text as a SpannableString.\n// the constructor copies both the text and the spans. so we can add and remove spans\nSpannableString spannableString = new SpannableString(titleText);// iterate through all the annotation spans\nfor (Annotation annotation: annotations) {\n  // look for the span with the key font\n  if (annotation.getKey().equals(\"font\")) {\n    String fontName = annotation.getValue();\n    // check the value associated to the annotation key\n    if (fontName.equals(\"title_emphasis\")) {\n    // create the typeface\n    Typeface typeface = ResourcesCompat.getFont(this, R.font.roboto_mono);\n    // set the span at the same indices as the annotation\n    spannableString.setSpan(new CustomTypefaceSpan(typeface),\n      titleText.getSpanStart(annotation),\n      titleText.getSpanEnd(annotation),\n      Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n    }\n  }\n}// now, the spannableString contains both the annotation spans and the CustomTypefaceSpan\nstyledText.text = spannableString;\n如果您多次使用相同文本，则应构建一次 SpannableString 对象并根据需要重复使用该对象，以避免出现潜在的性能和内存问题。\n\n如需了解注解用法的更多示例，请参阅在 Android 中设置国际化文本的样式\n\n注解 span 和文本打包\nAnnotation span 也是 ParcelableSpans，因此需对键值对进行打包和拆包。只要包的接收方了解如何解释注解，您便可使用 Annotation span 向打包文本应用自定义样式。\n\n如要在向 Intent Bundle 传递文本时保留自定义样式，您首先需在文本中添加 Annotation span。您可以使用 <annotation> 标记在 XML 资源中执行此操作（如上例所示），或通过创建新的 Annotation 并将其设置为 span，在代码中执行此操作（如下所示）：\n\nval spannableString = SpannableString(\"My spantastic text\")\nval annotation = Annotation(\"font\", \"title_emphasis\")\nspannableString.setSpan(annotation, 3, 7, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)// start Activity with text with spans\nval intent = Intent(this, MainActivity::class.java)\nintent.putExtra(TEXT_EXTRA, spannableString)\nstartActivity(intent)\nSpannableString spannableString = new SpannableString(\"My spantastic text\");\nAnnotation annotation = new Annotation(\"font\", \"title_emphasis\");\nspannableString.setSpan(annotation, 3, 7, 33);// start Activity with text with spans\nIntent intent = new Intent(this, MainActivity.class);\nintent.putExtra(TEXT_EXTRA, spannableString);\nthis.startActivity(intent);\n以 SpannableString 的形式从 Bundle 中检索文本，然后解析附加的注解（如上例所示）。\n\n// read text with Spans\nval intentCharSequence = intent.getCharSequenceExtra(TEXT_EXTRA) as SpannableString\n// read text with Spans\nSpannableString intentCharSequence = (SpannableString)intent.getCharSequenceExtra(TEXT_EXTRA);\n如需了解有关文本样式设置的更多信息，请访问以下链接：\n\nGoogle I/O 2018 大会 - Android 文本最佳实践\n了解 span"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242642948},"updatedAt":{"$$date":1597242792820},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ra9Ro72uTD8vrIwa"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980160299},"updatedAt":{"$$date":1594980160299},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"roiJaWxOJH0EH19y"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382138364},"updatedAt":{"$$date":1597382138364},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"rpPIdpzRu5HAzx0g"}
{"name":"java-使用Condition","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"使用ReentrantLock比直接使用synchronized更安全，可以替代synchronized进行线程同步。\n\n但是，synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock我们怎么编写wait和notify的功能呢？\n\n答案是使用Condition对象来实现wait和notify的功能。\n\n我们仍然以TaskQueue为例，把前面用synchronized实现的功能通过ReentrantLock和Condition来实现：\n\nclass TaskQueue {\n    private final Lock lock = new ReentrantLock();\n    private final Condition condition = lock.newCondition();\n    private Queue<String> queue = new LinkedList<>();\n\n    public void addTask(String s) {\n        lock.lock();\n        try {\n            queue.add(s);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public String getTask() {\n        lock.lock();\n        try {\n            while (queue.isEmpty()) {\n                condition.await();\n            }\n            return queue.remove();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n可见，使用Condition时，引用的Condition对象必须从Lock实例的newCondition()返回，这样才能获得一个绑定了Lock实例的Condition实例。\n\nCondition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：\n\nawait()会释放当前锁，进入等待状态；\n\nsignal()会唤醒某个等待线程；\n\nsignalAll()会唤醒所有等待线程；\n\n唤醒线程从await()返回后需要重新获得锁。\n\n此外，和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：\n\nif (condition.await(1, TimeUnit.SECOND)) {\n    // 被其他线程唤醒\n} else {\n    // 指定时间内没有被其他线程唤醒\n}\n可见，使用Condition配合Lock，我们可以实现更灵活的线程同步。\n\n小结\nCondition可以替代wait和notify；\n\nCondition对象必须从Lock对象获取。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594826925022},"updatedAt":{"$$date":1594967598256},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"sBKoG8Rbd1J6AsPX"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594973931290},"updatedAt":{"$$date":1594973931290},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"sfHyqeU6rNij316P"}
{"name":"kotlin-函数：infix、vararg、tailrec - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/functions.html\n函数：infix、vararg、tailrec - Kotlin 语言中文站\n20-25 minutes\n改进翻译\nKotlin 中的函数使用 fun 关键字声明：\n\n调用函数使用传统的方法：\n\n调用成员函数使用点表示法：\n\nStream().read() // 创建类 Stream 实例并调用 read()\n函数参数使用 Pascal 表示法定义，即 name: type。参数用逗号隔开。每个参数必须有显式类型：\n\nfun powerOf(number: Int, exponent: Int) { /*……*/ }\n函数参数可以有默认值，当省略相应的参数时使用默认值。与其他语言相比，这可以减少重载数量：\n\nfun read(b: Array<Byte>, off: Int = 0, len: Int = b.size) { /*……*/ }\n默认值通过类型后面的 = 及给出的值来定义。\n\n覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：\n\nopen class A {\n    open fun foo(i: Int = 10) { /*……*/ }\n}\n\nclass B : A() {\n    override fun foo(i: Int) { /*……*/ }  // 不能有默认值\n}\n如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用具名参数调用该函数来使用：\n\nfun foo(bar: Int = 0, baz: Int) { /*……*/ }\n\nfoo(baz = 1) // 使用默认值 bar = 0\n如果在默认参数之后的最后一个参数是 lambda 表达式，那么它既可以作为具名参数在括号内传入，也可以在括号外传入：\n\nfun foo(bar: Int = 0, baz: Int = 1, qux: () -> Unit) { /*……*/ }\n\nfoo(1) { println(\"hello\") }     // 使用默认值 baz = 1\nfoo(qux = { println(\"hello\") }) // 使用两个默认值 bar = 0 与 baz = 1\nfoo { println(\"hello\") }        // 使用两个默认值 bar = 0 与 baz = 1\n可以在调用函数时使用具名的函数参数。当一个函数有大量的参数或默认参数时这会非常方便。\n\n给定以下函数：\n\nfun reformat(str: String,\n             normalizeCase: Boolean = true,\n             upperCaseFirstLetter: Boolean = true,\n             divideByCamelHumps: Boolean = false,\n             wordSeparator: Char = ' ') {\n/*……*/\n}\n我们可以使用默认参数来调用它：\n\n然而，当使用非默认参数调用它时，该调用看起来就像：\n\nreformat(str, true, true, false, '_')\n使用具名参数我们可以使代码更具有可读性：\n\nreformat(str,\n    normalizeCase = true,\n    upperCaseFirstLetter = true,\n    divideByCamelHumps = false,\n    wordSeparator = '_'\n)\n并且如果我们不需要所有的参数：\n\nreformat(str, wordSeparator = '_')\n当一个函数调用混用位置参数与具名参数时，所有位置参数都要放在第一个具名参数之前。例如，允许调用 f(1, y = 2) 但不允许 f(x = 1, 2)。\n\n可以通过使用星号操作符将可变数量参数（vararg） 以具名形式传入：\n\nfun foo(vararg strings: String) { /*……*/ }\n\nfoo(strings = *arrayOf(\"a\", \"b\", \"c\"))\n对于 JVM 平台：在调用 Java 函数时不能使用具名参数语法，因为 Java 字节码并不总是保留函数参数的名称。\n\n如果一个函数不返回任何有用的值，它的返回类型是 Unit。Unit 是一种只有一个值——Unit 的类型。这个值不需要显式返回：\n\nfun printHello(name: String?): Unit {\n    if (name != null)\n        println(\"Hello $name\")\n    else\n        println(\"Hi there!\")\n    // `return Unit` 或者 `return` 是可选的\n}\nUnit 返回类型声明也是可选的。上面的代码等同于：\n\nfun printHello(name: String?) { …… }\n当函数返回单个表达式时，可以省略花括号并且在 = 符号之后指定代码体即可：\n\nfun double(x: Int): Int = x * 2\n当返回值类型可由编译器推断时，显式声明返回类型是可选的：\n\nfun double(x: Int) = x * 2\n具有块代码体的函数必须始终显式指定返回类型，除非他们旨在返回 Unit，在这种情况下它是可选的。 Kotlin 不推断具有块代码体的函数的返回类型，因为这样的函数在代码体中可能有复杂的控制流，并且返回类型对于读者（有时甚至对于编译器）是不明显的。\n\n函数的参数（通常是最后一个）可以用 vararg 修饰符标记：\n\nfun <T> asList(vararg ts: T): List<T> {\n    val result = ArrayList<T>()\n    for (t in ts) // ts is an Array\n        result.add(t)\n    return result\n}\n允许将可变数量的参数传递给函数：\n\nval list = asList(1, 2, 3)\n在函数内部，类型 T 的 vararg 参数的可见方式是作为 T 数组，即上例中的 ts 变量具有类型 Array <out T>。\n\n只有一个参数可以标注为 vararg。如果 vararg 参数不是列表中的最后一个参数， 可以使用具名参数语法传递其后的参数的值，或者，如果参数具有函数类型，则通过在括号外部传一个 lambda。\n\n当我们调用 vararg-函数时，我们可以一个接一个地传参，例如 asList(1, 2, 3)，或者，如果我们已经有一个数组并希望将其内容传给该函数，我们使用伸展（spread）操作符（在数组前面加 *）：\n\nval a = arrayOf(1, 2, 3)\nval list = asList(-1, 0, *a, 4)\n标有 infix 关键字的函数也可以使用中缀表示法（忽略该调用的点与圆括号）调用。中缀函数必须满足以下要求：\n\n它们必须是成员函数或扩展函数；\n它们必须只有一个参数；\n其参数不得接受可变数量的参数且不能有默认值。\ninfix fun Int.shl(x: Int): Int { …… }\n\n// 用中缀表示法调用该函数\n1 shl 2\n\n// 等同于这样\n1.shl(2)\n中缀函数调用的优先级低于算术操作符、类型转换以及 rangeTo 操作符。 以下表达式是等价的：\n\n1 shl 2 + 3 等价于 1 shl (2 + 3)\n0 until n * 2 等价于 0 until (n * 2)\nxs union ys as Set<*> 等价于 xs union (ys as Set<*>)\n另一方面，中缀函数调用的优先级高于布尔操作符 && 与 ||、is- 与 in- 检测以及其他一些操作符。这些表达式也是等价的：\n\na && b xor c 等价于 a && (b xor c)\na xor b in c 等价于 (a xor b) in c\n完整的优先级层次结构请参见其语法参考。\n\n请注意，中缀函数总是要求指定接收者与参数。当使用中缀表示法在当前接收者上调用方法时，需要显式使用 this；不能像常规方法调用那样省略。这是确保非模糊解析所必需的。\n\nclass MyStringCollection {\n    infix fun add(s: String) { /*……*/ }\n    \n    fun build() {\n        this add \"abc\"   // 正确\n        add(\"abc\")       // 正确\n        //add \"abc\"        // 错误：必须指定接收者\n    }\n}\n在 Kotlin 中函数可以在文件顶层声明，这意味着你不需要像一些语言如 Java、C# 或 Scala 那样需要创建一个类来保存一个函数。此外除了顶层函数，Kotlin 中函数也可以声明在局部作用域、作为成员函数以及扩展函数。\n\nKotlin 支持局部函数，即一个函数在另一个函数内部：\n\nfun dfs(graph: Graph) {\n    fun dfs(current: Vertex, visited: MutableSet<Vertex>) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v, visited)\n    }\n\n    dfs(graph.vertices[0], HashSet())\n}\n局部函数可以访问外部函数（即闭包）的局部变量，所以在上例中，visited 可以是局部变量：\n\nfun dfs(graph: Graph) {\n    val visited = HashSet<Vertex>()\n    fun dfs(current: Vertex) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v)\n    }\n\n    dfs(graph.vertices[0])\n}\n成员函数是在类或对象内部定义的函数：\n\nclass Sample {\n    fun foo() { print(\"Foo\") }\n}\n成员函数以点表示法调用：\n\nSample().foo() // 创建类 Sample 实例并调用 foo\n关于类和覆盖成员的更多信息参见类和继承。\n\n函数可以有泛型参数，通过在函数名前使用尖括号指定：\n\nfun <T> singletonList(item: T): List<T> { /*……*/ }\n关于泛型函数的更多信息参见泛型。\n\n内联函数在这里讲述。\n\n扩展函数在其自有章节讲述。\n\n高阶函数和 Lambda 表达式在其自有章节讲述。\n\nKotlin 支持一种称为尾递归的函数式编程风格。 这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 tailrec 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本：\n\nval eps = 1E-10 // \"good enough\", could be 10^-15\n\ntailrec fun findFixPoint(x: Double = 1.0): Double\n        = if (Math.abs(x - Math.cos(x)) < eps) x else findFixPoint(Math.cos(x))\n这段代码计算余弦的不动点（fixpoint of cosine），这是一个数学常数。 它只是重复地从 1.0 开始调用 Math.cos，直到结果不再改变，对于这里指定的 eps 精度会产生 0.7390851332151611 的结果。最终代码相当于这种更传统风格的代码：\n\nval eps = 1E-10 // \"good enough\", could be 10^-15\n\nprivate fun findFixPoint(): Double {\n    var x = 1.0\n    while (true) {\n        val y = Math.cos(x)\n        if (Math.abs(x - y) < eps) return x\n        x = Math.cos(x)\n    }\n}\n要符合 tailrec 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前在 Kotlin for JVM 与 Kotlin/Native 中支持尾递归。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308426153},"updatedAt":{"$$date":1597308634040},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"shI082KPsB0QkH9b"}
{"name":"andr-LiveData 概览  ","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/architecture/livedata\nLiveData 概览  |  Android 开发者  |  Android Developers\n15-18 minutes\nLiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。\n\n如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。LiveData 只会将更新通知给活跃的观察者。为观察 LiveData 对象而注册的非活跃观察者不会收到更改通知。\n\n您可以注册与实现 LifecycleOwner 接口的对象配对的观察者。有了这种关系，当相应的 Lifecycle 对象的状态变为 DESTROYED 时，便可移除此观察者。 这对于 Activity 和 Fragment 特别有用，因为它们可以放心地观察 LiveData 对象而不必担心泄露（当 Activity 和 Fragment 的生命周期被销毁时，系统会立即退订它们）。\n\n要详细了解如何使用 LiveData，请参阅使用 LiveData 对象。\n\n使用 LiveData 的优势\n使用 LiveData 具有以下优势：\n\n确保界面符合数据状态\nLiveData 遵循观察者模式。当生命周期状态发生变化时，LiveData 会通知 Observer 对象。您可以整合代码以在这些 Observer 对象中更新界面。观察者可以在每次发生更改时更新界面，而不是在每次应用数据发生更改时更新界面。\n不会发生内存泄漏\n观察者会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。\n不会因 Activity 停止而导致崩溃\n如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。\n不再需要手动处理生命周期\n界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。\n数据始终保持最新状态\n如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。\n适当的配置更改\n如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。\n共享资源\n您可以使用单一实例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。如需了解详情，请参阅扩展 LiveData。\n使用 LiveData 对象\n请按照以下步骤使用 LiveData 对象：\n\n创建 LiveData 实例以存储某种类型的数据。这通常在 ViewModel 类中完成。\n创建可定义 onChanged() 方法的 Observer 对象，该方法可以控制当 LiveData 对象存储的数据更改时会发生什么。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中创建 Observer 对象。\n使用 observe() 方法将 Observer 对象附加到 LiveData 对象。observe() 方法会采用 LifecycleOwner 对象。这样会使 Observer 对象订阅 LiveData 对象，以使其收到有关更改的通知。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中附加 Observer 对象。\n\n当您更新存储在 LiveData 对象中的值时，它会触发所有已注册的观察者（只要附加的 LifecycleOwner 处于活跃状态）。\n\nLiveData 允许界面控制器观察者订阅更新。当 LiveData 对象存储的数据发生更改时，界面会自动更新以做出响应。\n\n创建 LiveData 对象\nLiveData 是一种可用于任何数据的封装容器，其中包括可实现 Collections 的对象，如 List。LiveData 对象通常存储在 ViewModel 对象中，并可通过 getter 方法进行访问，如以下示例中所示：\n\n    class NameViewModel : ViewModel() {// Create a LiveData with a String\n        val currentName: MutableLiveData<String> by lazy {\n            MutableLiveData<String>()\n        }// Rest of the ViewModel...\n    }\n    \n    public class NameViewModel extends ViewModel {// Create a LiveData with a String\n    private MutableLiveData<String> currentName;public MutableLiveData<String> getCurrentName() {\n            if (currentName == null) {\n                currentName = new MutableLiveData<String>();\n            }\n            return currentName;\n        }// Rest of the ViewModel...\n    }\n    \n最初，LiveData 对象中的数据并未经过设置。\n\n您可以在 ViewModel 指南中详细了解 ViewModel 类的好处和用法。\n\n观察 LiveData 对象\n在大多数情况下，应用组件的 onCreate() 方法是开始观察 LiveData 对象的正确着手点，原因如下：\n\n确保系统不会从 Activity 或 Fragment 的 onResume() 方法进行冗余调用。\n确保 Activity 或 Fragment 变为活跃状态后具有可以立即显示的数据。一旦应用组件处于 STARTED 状态，就会从它正在观察的 LiveData 对象接收最新值。只有在设置了要观察的 LiveData 对象时，才会发生这种情况。\n通常，LiveData 仅在数据发生更改时才发送更新，并且仅发送给活跃观察者。此行为的一种例外情况是，观察者从非活跃状态更改为活跃状态时也会收到更新。此外，如果观察者第二次从非活跃状态更改为活跃状态，则只有在自上次变为活跃状态以来值发生了更改时，它才会收到更新。\n\n以下示例代码说明了如何开始观察 LiveData 对象：\n\n    class NameActivity : AppCompatActivity() {// Use the 'by viewModels()' Kotlin property delegate\n        // from the activity-ktx artifact\n        private val model: NameViewModel by viewModels()override fun onCreate(savedInstanceState: Bundle?) {\n            super.onCreate(savedInstanceState)// Other code to setup the activity...// Create the observer which updates the UI.\n            val nameObserver = Observer<String> { newName ->\n                // Update the UI, in this case, a TextView.\n                nameTextView.text = newName\n            }// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.\n            model.currentName.observe(this, nameObserver)\n        }\n    }\n    \n    public class NameActivity extends AppCompatActivity {private NameViewModel model;@Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);// Other code to setup the activity...// Get the ViewModel.\n            model = new ViewModelProvider(this).get(NameViewModel.class);// Create the observer which updates the UI.\n            final Observer<String> nameObserver = new Observer<String>() {\n                @Override\n                public void onChanged(@Nullable final String newName) {\n                    // Update the UI, in this case, a TextView.\n                    nameTextView.setText(newName);\n                }\n            };// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.\n            model.getCurrentName().observe(this, nameObserver);\n        }\n    }\n    \n在传递 nameObserver 参数的情况下调用 observe() 后，系统会立即调用 onChanged()，从而提供 mCurrentName 中存储的最新值。如果 LiveData 对象尚未在 mCurrentName 中设置值，则不会调用 onChanged()。\n\n更新 LiveData 对象\nLiveData 没有公开可用的方法来更新存储的数据。MutableLiveData 类将公开 setValue(T) 和 postValue(T) 方法，如果您需要修改存储在 LiveData 对象中的值，则必须使用这些方法。通常情况下会在 ViewModel 中使用 MutableLiveData，然后 ViewModel 只会向观察者公开不可变的 LiveData 对象。\n\n设置观察者关系后，您可以更新 LiveData 对象的值（如以下示例中所示），这样当用户点按某个按钮时会触发所有观察者：\n\n    button.setOnClickListener {\n        val anotherName = \"John Doe\"\n        model.currentName.setValue(anotherName)\n    }\n    \n    button.setOnClickListener(new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            String anotherName = \"John Doe\";\n            model.getCurrentName().setValue(anotherName);\n        }\n    });\n    \n在本例中调用 setValue(T) 导致观察者使用值 John Doe 调用其 onChanged() 方法。本例中演示的是按下按钮的方法，但也可以出于各种各样的原因调用 setValue() 或 postValue() 来更新 mName，这些原因包括响应网络请求或数据库加载完成。在所有情况下，调用 setValue() 或 postValue() 都会触发观察者并更新界面。\n\n将 LiveData 与 Room 一起使用\nRoom 持久性库支持返回 LiveData 对象的可观察查询。可观察查询属于数据库访问对象 (DAO) 的一部分。\n\n当数据库更新时，Room 会生成更新 LiveData 对象所需的所有代码。在需要时，生成的代码会在后台线程上异步运行查询。此模式有助于使界面中显示的数据与存储在数据库中的数据保持同步。您可以在 Room 持久性库指南中详细了解 Room 和 DAO。\n\n将协程与 LiveData 一起使用\nLiveData 支持 Kotlin 协程。如需了解详情，请参阅将 Kotlin 协程与 Android 架构组件一起使用。\n\n扩展 LiveData\n如果观察者的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。以下示例代码说明了如何扩展 LiveData 类：\n\n    class StockLiveData(symbol: String) : LiveData<BigDecimal>() {\n        private val stockManager = StockManager(symbol)private val listener = { price: BigDecimal ->\n            value = price\n        }override fun onActive() {\n            stockManager.requestPriceUpdates(listener)\n        }override fun onInactive() {\n            stockManager.removeUpdates(listener)\n        }\n    }\n    \n    public class StockLiveData extends LiveData<BigDecimal> {\n        private StockManager stockManager;private SimplePriceListener listener = new SimplePriceListener() {\n            @Override\n            public void onPriceChanged(BigDecimal price) {\n                setValue(price);\n            }\n        };public StockLiveData(String symbol) {\n            stockManager = new StockManager(symbol);\n        }@Override\n        protected void onActive() {\n            stockManager.requestPriceUpdates(listener);\n        }@Override\n        protected void onInactive() {\n            stockManager.removeUpdates(listener);\n        }\n    }\n    \n本例中的价格监听器实现包括以下重要方法：\n\n当 LiveData 对象具有活跃观察者时，会调用 onActive() 方法。这意味着，您需要从此方法开始观察股价更新。\n当 LiveData 对象没有任何活跃观察者时，会调用 onInactive() 方法。由于没有观察者在监听，因此没有理由与 StockManager 服务保持连接。\nsetValue(T) 方法将更新 LiveData 实例的值，并将更改通知给任何活跃观察者。\n您可以使用 StockLiveData 类，如下所示：\n\n    public class MyFragment : Fragment() {\n        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            val myPriceListener: LiveData<BigDecimal> = ...\n            myPriceListener.observe(viewLifecycleOwner, Observer<BigDecimal> { price: BigDecimal? ->\n                // Update the UI.\n            })\n        }\n    }\n    \n    public class MyFragment extends Fragment {\n        @Override\n        public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n            super.onViewCreated(view, savedInstanceState);\n            LiveData<BigDecimal> myPriceListener = ...;\n            myPriceListener.observe(getViewLifeycleOwner(), price -> {\n                // Update the UI.\n            });\n        }\n    }\n    \nobserve() 方法将与 Fragment 视图关联的 LifecycleOwner 作为第一个参数传递。这样做表示此观察者已绑定到与所有者关联的 Lifecycle 对象，这意味着：\n\n如果 Lifecycle 对象未处于活跃状态，那么即使值发生更改，也不会调用观察者。\n销毁 Lifecycle 对象后，会自动移除观察者。\nLiveData 对象具有生命周期感知能力，这一事实意味着您可以在多个 Activity、Fragment 和 Service 之间共享这些对象。为使示例保持简单，您可以将 LiveData 类实现为单一实例，如下所示：\n\n    class StockLiveData(symbol: String) : LiveData<BigDecimal>() {\n        private val stockManager: StockManager = StockManager(symbol)private val listener = { price: BigDecimal ->\n            value = price\n        }override fun onActive() {\n            stockManager.requestPriceUpdates(listener)\n        }override fun onInactive() {\n            stockManager.removeUpdates(listener)\n        }companion object {\n            private lateinit var sInstance: StockLiveData@MainThread\n            fun get(symbol: String): StockLiveData {\n                sInstance = if (::sInstance.isInitialized) sInstance else StockLiveData(symbol)\n                return sInstance\n            }\n        }\n    }\n    \n    public class StockLiveData extends LiveData<BigDecimal> {\n        private static StockLiveData sInstance;\n        private StockManager stockManager;private SimplePriceListener listener = new SimplePriceListener() {\n            @Override\n            public void onPriceChanged(BigDecimal price) {\n                setValue(price);\n            }\n        };@MainThread\n        public static StockLiveData get(String symbol) {\n            if (sInstance == null) {\n                sInstance = new StockLiveData(symbol);\n            }\n            return sInstance;\n        }private StockLiveData(String symbol) {\n            stockManager = new StockManager(symbol);\n        }@Override\n        protected void onActive() {\n            stockManager.requestPriceUpdates(listener);\n        }@Override\n        protected void onInactive() {\n            stockManager.removeUpdates(listener);\n        }\n    }\n    \n并且您可以在 Fragment 中使用它，如下所示：\n\n    class MyFragment : Fragment() {override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            super.onViewCreated(view, savedInstanceState)\n            StockLiveData.get(symbol).observe(viewLifecycleOwner, Observer<BigDecimal> { price: BigDecimal? ->\n                // Update the UI.\n            })}\n    \n    public class MyFragment extends Fragment {\n        @Override\n        public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n            super.onViewCreated(view, savedInstanceState);\n            StockLiveData.get(symbol).observe(getViewLifecycleOwner(), price -> {\n                // Update the UI.\n            });\n        }\n    }\n    \n多个 Fragment 和 Activity 可以观察 MyPriceListener 实例。仅当一个或多个系统服务可见且处于活跃状态时，LiveData 才会连接到该服务。\n\n转换 LiveData\n您可能希望在将 LiveData 对象分派给观察者之前对存储在其中的值进行更改，或者您可能需要根据另一个实例的值返回不同的 LiveData 实例。Lifecycle 软件包会提供 Transformations 类，该类包括可应对这些情况的辅助程序方法。\n\nTransformations.map()\n对存储在 LiveData 对象中的值应用函数，并将结果传播到下游。\n    val userLiveData: LiveData<User> = UserLiveData()\n    val userName: LiveData<String> = Transformations.map(userLiveData) {\n        user -> \"${user.name} ${user.lastName}\"\n    }\n    \n    LiveData<User> userLiveData = ...;\n    LiveData<String> userName = Transformations.map(userLiveData, user -> {\n        user.name + \" \" + user.lastName\n    });\n    \nTransformations.switchMap()\n与 map() 类似，对存储在 LiveData 对象中的值应用函数，并将结果解封和分派到下游。传递给 switchMap() 的函数必须返回 LiveData 对象，如以下示例中所示：\n    private fun getUser(id: String): LiveData<User> {\n      ...\n    }\n    val userId: LiveData<String> = ...\n    val user = Transformations.switchMap(userId) { id -> getUser(id) }\n    \n    private LiveData<User> getUser(String id) {\n      ...;\n    }LiveData<String> userId = ...;\n    LiveData<User> user = Transformations.switchMap(userId, id -> getUser(id) );\n    \n您可以使用转换方法在观察者的生命周期内传送信息。除非观察者正在观察返回的 LiveData 对象，否则不会计算转换。因为转换是以延迟的方式计算，所以与生命周期相关的行为会隐式传递下去，而不需要额外的显式调用或依赖项。\n\n如果您认为 ViewModel 对象中需要有 Lifecycle 对象，那么进行转换或许是更好的解决方案。例如，假设您有一个界面组件，该组件接受地址并返回该地址的邮政编码。您可以为此组件实现简单的 ViewModel，如以下示例代码所示：\n\n    class MyViewModel(private val repository: PostalCodeRepository) : ViewModel() {private fun getPostalCode(address: String): LiveData<String> {\n            // DON'T DO THIS\n            return repository.getPostCode(address)\n        }\n    }\n    \n    class MyViewModel extends ViewModel {\n        private final PostalCodeRepository repository;\n        public MyViewModel(PostalCodeRepository repository) {\n           this.repository = repository;\n        }private LiveData<String> getPostalCode(String address) {\n           // DON'T DO THIS\n           return repository.getPostCode(address);\n        }\n    }\n    \n然后，该界面组件需要取消注册先前的 LiveData 对象，并在每次调用 getPostalCode() 时注册到新的实例。此外，如果重新创建了该界面组件，它会再触发一次对 repository.getPostCode() 方法的调用，而不是使用先前调用所得的结果。\n\n您也可以将邮政编码查询实现为地址输入的转换，如以下示例中所示：\n\n    class MyViewModel(private val repository: PostalCodeRepository) : ViewModel() {\n        private val addressInput = MutableLiveData<String>()\n        val postalCode: LiveData<String> = Transformations.switchMap(addressInput) {\n                address -> repository.getPostCode(address) }private fun setInput(address: String) {\n            addressInput.value = address\n        }\n    }\n    \n    class MyViewModel extends ViewModel {\n        private final PostalCodeRepository repository;\n        private final MutableLiveData<String> addressInput = new MutableLiveData();\n        public final LiveData<String> postalCode =\n                Transformations.switchMap(addressInput, (address) -> {\n                    return repository.getPostCode(address);\n                 });public MyViewModel(PostalCodeRepository repository) {\n          this.repository = repository\n      }private void setInput(String address) {\n          addressInput.setValue(address);\n      }\n    }\n    \n在这种情况下，postalCode 字段定义为 addressInput 的转换。只要您的应用具有与 postalCode 字段关联的活跃观察者，就会在 addressInput 发生更改时重新计算并检索该字段的值。\n\n此机制允许较低级别的应用创建以延迟的方式按需计算的 LiveData 对象。ViewModel 对象可以轻松获取对 LiveData 对象的引用，然后在其基础之上定义转换规则。\n\n创建新的转换\n有十几种不同的特定转换在您的应用中可能很有用，但默认情况下不提供它们。要实现您自己的转换，您可以使用 MediatorLiveData 类，该类可以监听其他 LiveData 对象并处理它们发出的事件。MediatorLiveData 正确地将其状态传播到源 LiveData 对象。要详细了解此模式，请参阅 Transformations 类的参考文档。\n\n合并多个 LiveData 源\nMediatorLiveData 是 LiveData 的子类，允许您合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。\n\n例如，如果界面中有可以从本地数据库或网络更新的 LiveData 对象，则可以向 MediatorLiveData 对象添加以下源：\n\n与存储在数据库中的数据关联的 LiveData 对象。\n与从网络访问的数据关联的 LiveData 对象。\n您的 Activity 只需观察 MediatorLiveData 对象即可从这两个源接收更新。有关详细示例，请参阅应用架构指南的附录：公开网络状态部分。\n\n其他资源\n如需详细了解 LiveData 类，请参阅以下资源。\n\n示例\nSunflower，这是一个演示应用，演示架构组件的最佳做法\nAndroid 架构组件基本示例\nCodelab\n带 View 的 Android Room (Java) (Kotlin)\n博客\nViewModel 和 LiveData：模式 + 反模式\nViewModel  之外的 LiveData - 使用 Transformations 和 MediatorLiveData 的响应模式\nLiveData 与信息提示控件、导航和其他事件（SingleLiveEvent 情景）\n视频\nJetpack LiveData\nLiveData 其乐无穷（2018 年 Android 开发者峰会）"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243906536},"updatedAt":{"$$date":1597244257477},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"t3GuTCZmPgo2yB1l"}
{"name":"kotlin-类与继承 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/classes.html\n类与继承 - Kotlin 语言中文站\n25-31 minutes\n改进翻译\nKotlin 中使用关键字 class 声明类\n\n类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。\n\n在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。\n\nclass Person constructor(firstName: String) { /*……*/ }\n如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。\n\nclass Person(firstName: String) { /*……*/ }\n主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。\n\n在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：\n\n//sampleStart\nclass InitOrderDemo(name: String) {\n    val firstProperty = \"First property: $name\".also(::println)\n    \n    init {\n        println(\"First initializer block that prints ${name}\")\n    }\n    \n    val secondProperty = \"Second property: ${name.length}\".also(::println)\n    \n    init {\n        println(\"Second initializer block that prints ${name.length}\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    InitOrderDemo(\"hello\")\n}\n请注意，主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用：\n\nclass Customer(name: String) {\n    val customerKey = name.toUpperCase()\n}\n事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：\n\nclass Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }\n与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。\n\n如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：\n\nclass Customer public @Inject constructor(name: String) { /*……*/ }\n更多详情，参见可见性修饰符\n\n类也可以声明前缀有 constructor的次构造函数：\n\nclass Person {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(parent: Person) {\n        parent.children.add(this)\n    }\n}\n如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：\n\nclass Person(val name: String) {\n    var children: MutableList<Person> = mutableListOf<>()\n    constructor(name: String, parent: Person) : this(name) {\n        parent.children.add(this)\n    }\n}\n请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：\n\n//sampleStart\nclass Constructors {\n    init {\n        println(\"Init block\")\n    }\n\n    constructor(i: Int) {\n        println(\"Constructor\")\n    }\n}\n//sampleEnd\n\nfun main() {\n    Constructors(1)\n}\n如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：\n\nclass DontCreateMe private constructor () { /*……*/ }\n注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。\n\nclass Customer(val customerName: String = \"\")\n要创建一个类的实例，我们就像普通函数一样调用构造函数：\n\nval invoice = Invoice()\n\nval customer = Customer(\"Joe Smith\")\n注意 Kotlin 并没有 new 关键字。\n\n创建嵌套类、内部类与匿名内部类的类实例在嵌套类中有述。\n\n类可以包含：\n\n构造函数与初始化块\n函数\n属性\n嵌套类与内部类\n对象声明\n在 Kotlin 中所有类都有一个共同的超类 Any，这对于没有超类型声明的类是默认超类：\n\nclass Example // 从 Any 隐式继承\nAny 有三个方法：equals()、 hashCode() 与 toString()。因此，为所有 Kotlin 类都定义了这些方法。\n\n默认情况下，Kotlin 类是最终（final）的：它们不能被继承。 要使一个类可继承，请用 open 关键字标记它。\n\nopen class Base // 该类开放继承\n\n如需声明一个显式的超类型，请在类头中把超类型放到冒号之后：\n\nopen class Base(p: Int)\n\nclass Derived(p: Int) : Base(p)\n如果派生类有一个主构造函数，其基类可以（并且必须） 用派生类主构造函数的参数就地初始化。\n\n如果派生类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：\n\nclass MyView : View {\n    constructor(ctx: Context) : super(ctx)\n\n    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)\n}\n我们之前提到过，Kotlin 力求清晰显式。因此，Kotlin 对于可覆盖的成员（我们称之为开放）以及覆盖后的成员需要显式修饰符：\n\nopen class Shape {\n    open fun draw() { /*……*/ }\n    fun fill() { /*……*/ }\n}\n\nclass Circle() : Shape() {\n    override fun draw() { /*……*/ }\n}\nCircle.draw() 函数上必须加上 override 修饰符。如果没写，编译器将会报错。 如果函数没有标注 open 如 Shape.fill()，那么子类中不允许定义相同签名的函数， 不论加不加 override。将 open 修饰符添加到 final 类（即没有 open 的类）的成员上不起作用。\n\n标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：\n\nopen class Rectangle() : Shape() {\n    final override fun draw() { /*……*/ }\n}\n属性覆盖与方法覆盖类似；在超类中声明然后在派生类中重新声明的属性必须以 override 开头，并且它们必须具有兼容的类型。 每个声明的属性可以由具有初始化器的属性或者具有 get 方法的属性覆盖。\n\nopen class Shape {\n    open val vertexCount: Int = 0\n}\n\nclass Rectangle : Shape() {\n    override val vertexCount = 4\n}\n你也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。 这是允许的，因为一个 val 属性本质上声明了一个 get 方法， 而将其覆盖为 var 只是在子类中额外声明一个 set 方法。\n\n请注意，你可以在主构造函数中使用 override 关键字作为属性声明的一部分。\n\ninterface Shape {\n    val vertexCount: Int\n}\n\nclass Rectangle(override val vertexCount: Int = 4) : Shape // 总是有 4 个顶点\n\nclass Polygon : Shape {\n    override var vertexCount: Int = 0  // 以后可以设置为任何数\n}\n在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。\n\n//sampleStart\nopen class Base(val name: String) {\n\n    init { println(\"Initializing Base\") }\n\n    open val size: Int = \n        name.length.also { println(\"Initializing size in Base: $it\") }\n}\n\nclass Derived(\n    name: String,\n    val lastName: String\n) : Base(name.capitalize().also { println(\"Argument for Base: $it\") }) {\n\n    init { println(\"Initializing Derived\") }\n\n    override val size: Int =\n        (super.size + lastName.length).also { println(\"Initializing size in Derived: $it\") }\n}\n//sampleEnd\n\nfun main() {\n    println(\"Constructing Derived(\\\"hello\\\", \\\"world\\\")\")\n    val d = Derived(\"hello\", \"world\")\n}\n这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化。如果在基类初始化逻辑中（直接或通过另一个覆盖的 open 成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或运行时故障。设计一个基类时，应该避免在构造函数、属性初始化器以及 init 块中使用 open 成员。\n\n派生类中的代码可以使用 super 关键字调用其超类的函数与属性访问器的实现：\n\nopen class Rectangle {\n    open fun draw() { println(\"Drawing a rectangle\") }\n    val borderColor: String get() = \"black\"\n}\n\nclass FilledRectangle : Rectangle() {\n    override fun draw() {\n        super.draw()\n        println(\"Filling the rectangle\")\n    }\n\n    val fillColor: String get() = super.borderColor\n}\n在一个内部类中访问外部类的超类，可以通过由外部类名限定的 super 关键字来实现：super@Outer：\n\nclass FilledRectangle: Rectangle() {\n    fun draw() { /* …… */ }\n    val borderColor: String get() = \"black\"\n    \n    inner class Filler {\n        fun fill() { /* …… */ }\n        fun drawAndFill() {\n            super@FilledRectangle.draw() // 调用 Rectangle 的 draw() 实现\n            fill()\n            println(\"Drawn a filled rectangle with color ${super@FilledRectangle.borderColor}\") // 使用 Rectangle 所实现的 borderColor 的 get()\n        }\n    }\n}\n在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super<Base>：\n\nopen class Rectangle {\n    open fun draw() { /* …… */ }\n}\n\ninterface Polygon {\n    fun draw() { /* …… */ } // 接口成员默认就是“open”的\n}\n\nclass Square() : Rectangle(), Polygon {\n    // 编译器要求覆盖 draw()：\n    override fun draw() {\n        super<Rectangle>.draw() // 调用 Rectangle.draw()\n        super<Polygon>.draw() // 调用 Polygon.draw()\n    }\n}\n可以同时继承 Rectangle 与 Polygon， 但是二者都有各自的 draw() 实现，所以我们必须在 Square 中覆盖 draw()， 并提供其自身的实现以消除歧义。\n\n类以及其中的某些成员可以声明为 abstract。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。\n\n我们可以用一个抽象成员覆盖一个非抽象的开放成员\n\nopen class Polygon {\n    open fun draw() {}\n}\n\nabstract class Rectangle : Polygon() {\n    abstract override fun draw()\n}\n如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂方法），你可以把它写成该类内对象声明中的一员。\n\n更具体地讲，如果在你的类内声明了一个伴生对象， 你就可以访问其成员，只是以类名作为限定符。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597306185686},"updatedAt":{"$$date":1597307786437},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"tCgut1eqc9TFudaE"}
{"name":"py-布尔值","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：\n\n>>> True\nTrue\n>>> False\nFalse\n>>> 3 > 2\nTrue\n>>> 3 > 5\nFalse\n布尔值可以用and、or和not运算。\n\nand运算是与运算，只有所有都为True，and运算结果才是True：\n\n>>> True and True\nTrue\n>>> True and False\nFalse\n>>> False and False\nFalse\n>>> 5 > 3 and 3 > 1\nTrue\nor运算是或运算，只要其中有一个为True，or运算结果就是True：\n\n>>> True or True\nTrue\n>>> True or False\nTrue\n>>> False or False\nFalse\n>>> 5 > 3 or 1 > 3\nTrue\nnot运算是非运算，它是一个单目运算符，把True变成False，False变成True：\n\n>>> not True\nFalse\n>>> not False\nTrue\n>>> not 1 > 2\nTrue\n布尔值经常用在条件判断中，比如：\n\nif age >= 18:\n    print('adult')\nelse:\n    print('teenager')"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973925643},"updatedAt":{"$$date":1594974102005},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"tSrhoxH59Kxw0xdE"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973263497},"updatedAt":{"$$date":1594973263497},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"taGSpoVdFPCaRnIn"}
{"name":"py-命名关键字参数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。\n\n仍以person()函数为例，我们希望检查是否有city和job参数：\n\ndef person(name, age, **kw):\n    if 'city' in kw:\n        # 有city参数\n        pass\n    if 'job' in kw:\n        # 有job参数\n        pass\n    print('name:', name, 'age:', age, 'other:', kw)\n但是调用者仍可以传入不受限制的关键字参数：\n\n>>> person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)\n如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：\n\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\n和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\n\n调用方式如下：\n\n>>> person('Jack', 24, city='Beijing', job='Engineer')\nJack 24 Beijing Engineer\n如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n\ndef person(name, age, *args, city, job):\n    print(name, age, args, city, job)\n命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：\n\n>>> person('Jack', 24, 'Beijing', 'Engineer')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: person() takes 2 positional arguments but 4 were given\n由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。\n\n命名关键字参数可以有缺省值，从而简化调用：\n\ndef person(name, age, *, city='Beijing', job):\n    print(name, age, city, job)\n由于命名关键字参数city具有默认值，调用时，可不传入city参数：\n\n>>> person('Jack', 24, job='Engineer')\nJack 24 Beijing Engineer\n使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：\n\ndef person(name, age, city, job):\n    # 缺少 *，city和job被视为位置参数\n    pass\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977481006},"updatedAt":{"$$date":1594979296907},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"tsBA6zrF1g6JdEWb"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382133880},"updatedAt":{"$$date":1597382133880},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uVUfBjuYBql1DWTa"}
{"name":"kotlin-kotlin入门中文教程（1）","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\njuejin.im /post/6844904017408032781\nkotlin入门中文教程（1） - 掘金\n叶志陈 2019年12月10日 阅读 4422 已关注\n36-46 minutes\n本文已收录至学习笔记大全：JavaKotlinAndroidGuide\n\n作者：leavesC\n\n[TOC]\n\n一、Hello World\n按照国际惯例，学习一门新的语言通常都是从 Hello World 开始的，在这里也不例外\n\npackage main\n\nfun main(args: Array<String>) {\n    println(\"Hello World\")\n}\n复制代码\n从这个简单的函数就可以列出 kotlin 和 Java 的几点不同\n\n函数可以定义在文件的最外层，不需要把它放在类中\n用关键字 fun 来声明一个函数\n参数类型写在变量名之后，这有助于在类型自动推导时省略类型声明\n数组就是类。和 Java 不同，kotlin 没有声明数组类型的特殊语法\n使用 println 代替了 System.out.println ，这是 kotlin 标准库提供的对 Java 标准库函数的封装\n可以省略代码结尾的分号\n此外，kotlin 的最新版本已经可以省略 main 方法的参数了\n\n二、Package\nkotlin 文件都以一条 package 语句开头，文件中定义的所有声明（类、函数和属性）都会被放到这个包中。如果其他文件中定义的声明也有相同的包，这个文件可以直接使用它们，如果包不相同则需要导入它们\n\n包的声明应处于源文件顶部，import 语句紧随其后\n\npackage base\n\nimport java.text.SimpleDateFormat\nimport java.util.*\n复制代码\nkotlin 不区分导入的是类还是函数，允许使用 import 关键字导入任何种类的声明。此外，也可以在包名称后加上 .* 来导入特定包中定义的所有声明，这不仅会让包中定义的类可见，也会让顶层函数和属性可见\n\npackage learn.package2\n\nval index = 10\n\nfun Test(status: Boolean) = println(status)\n\nclass Point(val x: Int, val y: Int) {\n\n    val isEquals1: Boolean\n        get() {\n            return x == y\n        }\n\n    val isEquals2\n        get() = x == y\n\n    var isEquals3 = false\n        get() = x > y\n        set(value) {\n            field = !value\n        }\n\n}\n复制代码\npackage learn.package1\n\nimport learn.package2.Point\nimport learn.package2.Test\nimport learn.package2.index\n\nfun main() {\n    val point = Point(10, index)\n    Test(true)\n}\n复制代码\nJava 语言规定类要放到和包结构匹配的文件夹目录结构中，而 kotlin 允许把多个类放到同一个文件中，文件名也可以任意选择。kotlin 也没有对磁盘上源文件的布局强加任何限制，包层级结构不需要遵循目录层级结构 ,但最好还是遵循 Java 的目录布局并根据包结构把源码文件放到相应的目录中\n\n如果包名出现命名冲突，可以使用 as 关键字在本地重命名冲突项来消歧义\n\nimport learn.package1.Point\nimport learn.package2.Point as PointTemp \n复制代码\nkotlin 中也有一个类似的概念可以用来重命名现有类型，叫做类型别名。类型别名用于为现有类型提供一个替代名称，如果类型名称比较长，就可以通过引入一个较短或者更为简略的名称来方便记忆\n\n类型别名不会引入新的类型，依然相应其底层类型，所以在下述代码中输出的 class 类型是一致的\n\nclass Base {\n\n    class InnerClass\n\n}\n\ntypealias BaseInner = Base.InnerClass\n\nfun main() {\n    val baseInner1 = Base.InnerClass()\n    val baseInner2 = BaseInner()\n    println(baseInner1.javaClass) \n    println(baseInner2.javaClass) \n}\n复制代码\n三、变量与数据类型\n在 Java 中，大部分的变量是可变的（非 final 的），意味着任何可以访问到这个变量的代码都可以去修改它。而在 kotlin 中，变量可以分为 可变变量(var) 和 不可变变量(val) 两类\n\n声明变量的关键字有两个：\n\nval（value / varible+final）——不可变引用。使用 val 声明的变量不能在初始化之后再次赋值，对应的是 Java 中的 final 变量\nvar（variable）——可变引用。var 变量的值可以被改变，对应的是 Java 中的非 final 变量\n不可变变量在赋值之后就不能再去改变它的状态了，因此不可变变量可以说是线程安全的，因为它们无法改变，所有线程访问到的对象都是同一个，因此也不需要去做访问控制。开发者应当尽可能地使用不可变变量，这样可以让代码更加接近函数式编程风格\n\n编程领域中也推崇一种开发原则：尽可能使用 val，不可变对象及纯函数来设计程序。这样可以尽量避免副作用带来的影响\n\nfun main() {\n    \n    \n    val intValue: Int = 100\n\n    \n    var doubleValue: Double = 100.0\n}\n复制代码\n在声明变量时我们通常不需要显式指明变量的类型，这可以由编译器根据上下文自动推导出来。如果只读变量在声明时没有初始值，则必须指明变量类型，且在使用前必须确保在各个分支条件下变量可以被初始化，否则编译期会报异常\n\nfun main() {\n    val intValue = 1002222222222\n    val doubleValue = 100.0\n    val longValue = 100L\n\n    \n    val intValue2: Int\n    if (false) {\n        intValue2 = 10\n    }\n    println(intValue2) \n}\n复制代码\n3.1、基本数据类型\n与 Java 不同，kotlin 并不区分基本数据类型和它的包装类，在 kotlin 中一切都是对象，可以在任何变量上调用其成员函数和属性。kotlin 没有像 Java 中那样的原始基本类型，但 byte、char、integer、float 或者 boolean 等类型仍然有保留，但是全部都作为对象存在\n\n对于基本类型，kotlin 相比 Java 有几点特殊的地方\n\n数字、字符和布尔值可以在运行时表示为原生类型值，但对开发者来说，它们看起来就像普通的类\n对于数字没有隐式拓宽转换，而在 Java 中 int 可以隐式转换为 long\n所有未超出 Int 最⼤值的整型值初始化的变量都会自动推断为 Int 类型，如果初始值超过了其最⼤值，则会推断为 Long 类型， 如需显式指定 Long 类型值可在该值后追加 L 后缀\n字符不能视为数字\n不支持八进制\n    \n\n    val intIndex: Int = 100\n    \n    val intIndex = 100\n\n    \n    val doubleIndex: Double = intIndex.toDouble()\n    \n    \n\n    val intValue: Int = 1\n    val longValue: Long = 1\n    \n    \n\n    \n    val ch: Char = 'c'\n    val charValue: Int = ch.toInt()\n    \n    \n\n    \n    val value1 = 0b00101\n    \n    val value2 = 0x123\n复制代码\n此外，kotlin 的可空类型不能用 Java 的基本数据类型表示，因为 null 只能被存储在 Java 的引用类型的变量中，这意味着只要使用了基本数据类型的可空版本，它就会被编译成对应的包装类型\n\n    \n    val intValue_1: Int = 200\n    \n    val intValue_2: Int? = intValue_1\n    val intValue_3: Int? = intValue_1\n    \n    println(intValue_2 == intValue_3)\n    \n    println(intValue_2 === intValue_3)\n复制代码\n如果 intValue_1 的值是100，就会发现 intValue_2 === intValue_3 的比较结果是 true，这就涉及到 Java 对包装类对象的重复使用问题了\n\n3.2、字符串\nkotlin 与 Java 一样用 String 类型来表示字符串，字符串是不可变的，可以使用索引运算符访问[] 来访问包含的单个字符，也可以用 for 循环来迭代字符串，此外也可以用 + 来连接字符串\n\n    val str = \"leavesC\"\n    println(str[1])\n    for (c in str) {\n        println(c)\n    }\n    val str1 = str + \" hello\"\n复制代码\nkotlin 支持在字符串字面值中引用局部变量，只需要在变量名前加上字符 $ 即可，此外还可以包含用花括号括起来的表达式，此时会自动求值并把结果合并到字符串中\n\n    val intValue = 100\n    \n    println(\"intValue value is $intValue\") \n    \n    println(\"(intValue + 100) value is ${intValue + 100}\")   \n复制代码\n如果你需要在原始字符串中表示字面值（$）字符（它不支持反斜杠转义），可以用下列语法：\n\n    val price = \"${'\n   \n  \n  \n  \n\n\n}100.99\"\n    println(price)  \n复制代码\n3.3、数组\nkotlin 中的数组是带有类型参数的类，其元素类型被指定为相应的类型参数，使用 Array 类来表示， Array 类定义了 get 与 set 函数（按照运算符重载约定这会转变为 [ ] ）以及 size 属性等\n\n创建数组的方法有以下几种：\n\n用 arrayOf 函数创建一个数组，包含的元素是指定为该函数的实参\n用 arrayOfNulls 创建一个给定大小的数组，包含的元素均为 null，只能用来创建包含元素类型可空的数组\n调用 Array 类的构造方法，传递数组的大小和一个 lambda 表达式，调用 lambda 表达式来创建每一个数组元素\n    \n    val array1 = arrayOf(\"leavesC\", \"叶\", \"https://github.com/leavesC\")\n\n    array1[0] = \"leavesC\"\n    println(array1[1])\n    println(array1.size)\n\n    \n    val array2 = arrayOfNulls<String>(10)\n\n    \n    val array3 = Array(26) { i -> ('a' + i).toString() }\n复制代码\n需要注意的是，数组类型的类型参数始终会变成对象类型，因此声明 Array< Int > 将是一个包含装箱类型（java.lang.Integer）的数组。如果想要创建没有装箱的基本数据类型的数组，必须使用一个基本数据类型数组的特殊类\n\n为了表示基本数据类型的数组，kotlin 为每一种基本数据类型都提供了若干相应的类并做了特殊的优化。例如，有 IntArray、ByteArray、BooleanArray 等类型，这些类型都会被编译成普通的 Java 基本数据类型数组，比如 int[]、byte[]、boolean[] 等，这些数组中的值存储时没有进行装箱，而是使用了可能的最高效的方式。需要注意，IntArray 等并不是 Array 的子类\n\n要创建一个基本数据类型的数组，有以下几种方式：\n\n向对应类型的类（如 IntArray）的构造函数传递数组大小，这将返回一个使用对应基本数据类型默认值初始化好的数组\n向对应类型的类（如 IntArray）的构造函数传递数组大小以及用来初始化每个元素的 lambda\n向工厂函数（如 charArrayOf）传递变长参数的值，从而得到指定元素值的数组\n    \n    val intArray = IntArray(5)\n    \n    val doubleArray = DoubleArray(5) { Random().nextDouble() }\n    \n    val charArray = charArrayOf('H', 'e', 'l', 'l', 'o')\n复制代码\n3.4、Any 和 Any?\nAny 类型是 kotlin 所有非空类型的超类型，包括像 Int 这样的基本数据类型\n\n如果把基本数据类型的值赋给 Any 类型的变量，则会自动装箱\n\nval any: Any = 100\nprintln(any.javaClass) \n复制代码\n如果想要使变量可以存储包括 null 在内的所有可能的值，则需要使用 Any?\n\nval any: Any? = null\n复制代码\n3.5、Unit\nkotlin 中的 Unit 类型类似于 Java 中的 void，可以用于函数没有返回值时的情况\n\nfun check(): Unit {\n\n}\n\n\nfun check() {\n\n}\n复制代码\nUnit 是一个完备的类型，可以作为类型参数，但 void 不行\n\ninterface Test<T> {\n    fun test(): T\n}\n\nclass NoResultClass : Test<Unit> {\n    \n    \n    override fun test() {\n\n    }\n\n}\n复制代码\n3.6、Nothing\nNothing 类型没有任何值，只有被当做函数返回值使用，或者被当做泛型函数返回值的类型参数使用时才会有意义，可以用 Nothing 来表示一个函数不会被正常终止，从而帮助编译器对代码进行诊断\n\n编译器知道返回值为 Nothing 类型的函数从不正常终止，所以编译器会把 name1 的类型推断为非空，因为 name1 在为 null 时的分支处理会始终抛出异常\n\ndata class User(val name: String?)\n\nfun fail(message: String): Nothing {\n    throw IllegalStateException(message)\n}\n\nfun main() {\n    val user = User(\"leavesC\")\n    val name = user.name ?: fail(\"no name\")\n    println(name) \n\n    val user1 = User(null)\n    val name1 = user1.name ?: fail(\"no name\")\n    println(name1.length) \n}\n复制代码\n四、函数\nkotlin 中的函数以关键字 fun 作为开头，函数名称紧随其后，再之后是用括号包裹起来的参数列表，如果函数有返回值，则再加上返回值类型，用一个冒号与参数列表隔开\n\n        \n        \n        fun getNameLastChar(): Char {\n            return name.get(name.length - 1)\n        }\n复制代码\n        \n        \n        fun test1(str: String, int: Int): Int {\n            return str.length + int\n        }\n复制代码\n此外，表达式函数体的返回值类型可以省略，返回值类型可以自动推断，这种用单行表达式与等号定义的函数叫做表达式函数体。但对于一般情况下的有返回值的代码块函数体，必须显式地写出返回类型和 return 语句\n\n        \n        \n        \n        fun getNameLastChar() = name.get(name.length - 1)\n复制代码\n如果函数没有有意义的返回值，则可以声明为 Unit ，也可以省略 Unit\n\n以下三种写法都是等价的\n\n        fun test(str: String, int: Int): Unit {\n            println(str.length + int)\n        }\n\n        fun test(str: String, int: Int) {\n            println(str.length + int)\n        }\n\n        fun test(str: String, int: Int) = println(str.length + int)\n复制代码\n4.1、命名参数\n为了增强代码的可读性，kotlin 允许我们使用命名参数，即在调用某函数的时候，可以将函数参数名一起标明，从而明确地表达该参数的含义与作用，但是在指定了一个参数的名称后，之后的所有参数都需要标明名称\n\nfun main() {\n    \n    \n    compute(index = 120, value = \"leavesC\")\n    compute(130, value = \"leavesC\")\n}\n\nfun compute(index: Int, value: String) {\n\n}\n复制代码\n4.2、默认参数值\n可以在声明函数的时候指定参数的默认值，从而避免创建重载的函数\n\nfun main() {\n    compute(24)\n    compute(24, \"leavesC\")\n}\n\nfun compute(age: Int, name: String = \"leavesC\") {\n\n}\n复制代码\n对于以上这个例子，如果按照常规的调用语法时，必须按照函数声明定义的参数顺序来给定参数，可以省略的只有排在末尾的参数\n\nfun main() {\n    \n    \n    \n    \n    compute(\"leavesC\", 24)\n}\n\nfun compute(name: String = \"leavesC\", age: Int, value: Int = 100) {}\n复制代码\n如果使用命名参数，可以省略任何有默认值的参数，而且也可以按照任意顺序传入需要的参数\n\nfun main() {\n    compute(age = 24)\n    compute(age = 24, name = \"leavesC\")\n    compute(age = 24, value = 90, name = \"leavesC\")\n    compute(value = 90, age = 24, name = \"leavesC\")\n}\n\nfun compute(name: String = \"leavesC\", age: Int, value: Int = 100) {\n\n}\n复制代码\n4.3、可变参数\n可变参数可以让我们把任意个数的参数打包到数组中传给函数，kotlin 的语法相比 Java 有所不同，改为通过使用 varage 关键字声明可变参数\n\n例如，以下的几种函数调用方式都是正确的\n\nfun main() {\n    compute()\n    compute(\"leavesC\")\n    compute(\"leavesC\", \"叶应是叶\")\n    compute(\"leavesC\", \"叶应是叶\", \"叶\")\n}\n\nfun compute(vararg name: String) {\n    name.forEach { println(it) }\n}\n复制代码\n在 Java 中，可以直接将数组传递给可变参数，而 kotlin 要求显式地解包数组，以便每个数组元素在函数中能够作为单独的参数来调用，这个功能被称为展开运算符，使用方式就是在数组参数前加一个 *\n\nfun main() {\n    val names = arrayOf(\"leavesC\", \"叶应是叶\", \"叶\")\n    compute(* names)\n}\n\nfun compute(vararg name: String) {\n    name.forEach { println(it) }\n}\n复制代码\n4.4、局部函数\nkotlin 支持在函数中嵌套函数，被嵌套的函数称为局部函数\n\nfun main() {\n    compute(\"leavesC\", \"country\")\n}\n\nfun compute(name: String, country: String) {\n    fun check(string: String) {\n        if (string.isEmpty()) {\n            throw IllegalArgumentException(\"参数错误\")\n        }\n    }\n    check(name)\n    check(country)\n}\n复制代码\n五、表达式和条件循环\n5.1、语句和表达式\n这里需要先区分“语句”和“表达式”这两个概念。语句是可以单独执行，能够产生实际效果的代码，表现为赋值逻辑、打印操作、流程控制等形式，Java 中的流程控制（if，while，for）等都是语句。表达式可以是一个值、变量、常量、操作符、或它们之间的组合，表达式可以看做是包含返回值的语句\n\n例如，以下的赋值操作、流程控制、打印输出都是语句，其是作为一个整体存在的，且不包含返回值\n\n    val a = 10\n    for (i in 0..a step 2) {\n        println(i)\n    }\n复制代码\n再看几个表达式的例子\n\n1       \n++1     \n\nfun getLength(str: String?): Int {\n    return if (str.isNullOrBlank()) 0 else str.length\n}\n复制代码\n5.2、If 表达式\nif 的分支可以是代码块，最后的表达式作为该块的返回值\n\n    val maxValue = if (20 > 10) {\n        println(\"maxValue is 20\")\n        20\n    } else {\n        println(\"maxValue is 10\")\n        10\n    }\n    println(maxValue) \n复制代码\n以下代码可以显示地看出 if 的返回值，完全可以用来替代 Java 中的三元运算符，因此 kotlin 并没有三元运算符\n\n    val list = listOf(1, 4, 10, 4, 10, 30)\n    val value = if (list.size > 0) list.size else null\n    println(value)  \n复制代码\n如果 if 表达式分支是用于执行某个命令，那么此时的返回值类型就是 Unit ，此时的 if 语句就看起来和 Java 的一样了\n\n    val value1 = if (list.size > 0) println(\"1\") else println(\"2\")\n    println(value1.javaClass)   \n复制代码\n如果将 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支\n\n5.3、when 表达式\nwhen 表达式与 Java 中的 switch/case 类似，但是要强大得多。when 既可以被当做表达式使用也可以被当做语句使用，when 将参数和所有的分支条件顺序比较直到某个分支满足条件，然后它会运行右边的表达式。如果 when 被当做表达式来使用，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。与 Java 的 switch/case 不同之处是 When 表达式的参数可以是任何类型，并且分支也可以是一个条件\n\n和 if 一样，when 表达式每一个分支可以是一个代码块，它的值是代码块中最后的表达式的值，如果其它分支都不满足条件将会求值于 else 分支\n\n如果 when 作为一个表达式使用，则必须有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了。如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔\n\n    val value = 2\n    when (value) {\n        in 4..9 -> println(\"in 4..9\") \n        3 -> println(\"value is 3\")    \n        2, 6 -> println(\"value is 2 or 6\")    \n        is Int -> println(\"is Int\")   \n        else -> println(\"else\")       \n    }\n复制代码\nfun main() {\n    \n    fun parser(obj: Any): String =\n            when (obj) {\n                1 -> \"value is 1\"\n                \"4\" -> \"value is string 4\"\n                is Long -> \"value type is long\"\n                else -> \"unknown\"\n            }\n    println(parser(1))\n    println(parser(1L))\n    println(parser(\"4\"))\n    println(parser(100L))\n    println(parser(100.0))\n}\n\nvalue is 1\nvalue type is long\nvalue is string 4\nvalue type is long\nunknown\n复制代码\n此外，When 循环也可以不带参数\n\n    when {\n        1 > 5 -> println(\"1 > 5\")\n        3 > 1 -> println(\"3 > 1\")\n    }\n复制代码\n5.4、for 循环\n和 Java 中的 for 循环最为类似的形式是\n\n    val list = listOf(1, 4, 10, 34, 10)\n    for (value in list) {\n        println(value)\n    }\n复制代码\n通过索引来遍历\n\n    val items = listOf(\"H\", \"e\", \"l\", \"l\", \"o\")\n    \n    for (index in items.indices) {\n        println(\"${index}对应的值是：${items[index]}\")\n    }\n复制代码\n也可以在每次循环中获取当前索引和相应的值\n\n    val list = listOf(1, 4, 10, 34, 10)\n    for ((index, value) in list.withIndex()) {\n        println(\"index : $index , value :$value\")\n    }\n复制代码\n也可以自定义循环区间\n\n    for (index in 2..10) {\n        println(index)\n    }\n复制代码\n5.5、while 和 do/while 循环\nwhile 和 do/while 与 Java 中的区别不大\n\n    val list = listOf(1, 4, 15, 2, 4, 10, 0, 9)\n    var index = 0\n    while (index < list.size) {\n        println(list[index])\n        index++\n    }\n复制代码\n    val list = listOf(1, 4, 15, 2, 4, 10, 0, 9)\n    var index = 0\n    do {\n        println(list[index])\n        index++\n    } while (index < list.size)\n复制代码\n5.6、返回和跳转\nkotlin 有三种结构化跳转表达式：\n\nreturn 默认从最直接包围它的函数或者匿名函数返回\nbreak 终止最直接包围它的循环\ncontinue 继续下一次最直接包围它的循环\n在 kotlin 中任何表达式都可以用标签（label）来标记，标签的格式为标识符后跟 @ 符号，例如：abc@ 、fooBar@ 都是有效的标签\n\nfun main() {\n    fun1()\n}\n\nfun fun1() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    loop@ for (it in list) {\n        if (it == 8) {\n            continue\n        }\n        if (it == 23) {\n            break@loop\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n}\n复制代码\nvalue is 1\nvalue is 4\nvalue is 6\nvalue is 12\nfunction end\n复制代码\nkotlin 有函数字面量、局部函数和对象表达式。因此 kotlin 的函数可以被嵌套\n\n标签限制的 return 允许我们从外层函数返回，最重要的一个用途就是从 lambda 表达式中返回。通常情况下使用隐式标签更方便，该标签与接受该 lambda 的函数同名\n\nfun main() {\n    fun1()\n    fun2()\n    fun3()\n    fun4()\n    fun5()\n}\n\nfun fun1() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    list.forEach {\n        if (it == 8) {\n            return\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n\n\n\n\n}\n\nfun fun2() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    list.forEach {\n        if (it == 8) {\n            return@fun2\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n\n\n\n\n}\n\n\nfun fun3() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    list.forEach {\n        if (it == 8) {\n            return@forEach\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n    \n\n\n\n\n\n\n\n}\n\nfun fun4() {\n    val list = listOf(1, 4, 6, 8, 12, 23, 40)\n    list.forEach loop@{\n        if (it == 8) {\n            return@loop\n        }\n        println(\"value is $it\")\n    }\n    println(\"function end\")\n\n\n\n\n\n\n\n\n}\n\nfun fun5() {\n    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {\n        if (value == 3) {\n            \n            return\n        }\n        println(\"value is $value\")\n    })\n    println(\"function end\")\n}\n复制代码\n六、区间\nRanges 表达式使用一个 .. 操作符来声明一个闭区间，它被用于定义实现了一个 RangTo 方法\n\n以下三种声明形式是等价的\n\n    var index = 5\n    \n    if (index >= 0 && index <= 10) {\n\n    }\n\n    if (index in 0..10) {\n\n    }\n\n    if (index in 0.rangeTo(10)) {\n        \n    }\n复制代码\n数字类型的 ranges 在被迭代时，编译器会将它们转换为与 Java 中使用 index 的 for 循环的相同字节码的方式来进行优化\n\nRanges 默认会自增长，所以如果像以下的代码就不会被执行\n\n    for (index in 10..0) {\n        println(index)\n    }\n复制代码\n可以改用 downTo 函数来将之改为递减\n\n    for (index in 10 downTo 0) {\n        println(index)\n    }\n复制代码\n可以在 ranges 中使用 step 来定义每次循环递增或递增的长度：\n\n    for (index in 1..8 step 2){\n        println(index)\n    }\n    for (index in 8 downTo 1 step 2) {\n        println(index)\n    }\n复制代码\n以上声明的都是闭区间，如果想声明的是开区间，可以使用 until 函数：\n\n    for (index in 0 until 4){\n        println(index)\n    }\n复制代码\n扩展函数 reversed() 可用于返回将区间反转后的序列\n\n    val rangeTo = 1.rangeTo(3)\n    for (i in rangeTo) {\n        println(i) \n    }\n    for (i in rangeTo.reversed()) {\n        println(i) \n    }\n复制代码\n七、修饰符\n7.1、final 和 oepn\nkotlin 中的类和方法默认都是 final 的，即不可继承的，如果想允许创建一个类的子类，需要使用 open 修饰符来标识这个类，此外，也需要为每一个希望被重写的属性和方法添加 open 修饰符\n\nopen class View {\n    open fun click() {\n\n    }\n\t\n    fun longClick() {\n\n    }\n}\n\nclass Button : View() {\n    override fun click() {\n        super.click()\n    }\n}\n复制代码\n如果重写了一个基类或者接口的成员，重写了的成员同样默认是 open 的。例如，如果 Button 类是 open 的，则其子类也可以重写其 click() 方法\n\nopen class Button : View() {\n    override fun click() {\n        super.click()\n    }\n}\n\nclass CompatButton : Button() {\n    override fun click() {\n        super.click()\n    }\n}\n复制代码\n如果不想要类的子类重写该方法的实现，可以显式地将重写的成员标记为 final\n\nopen class Button : View() {\n    override final fun click() {\n        super.click()\n    }\n}\n复制代码\n7.2、public\npublic 修饰符是限制级最低的修饰符，是默认的修饰符。如果一个定义为 public 的成员被包含在一个 private 修饰的类中，那么这个成员在这个类以外也是不可见的\n\n7.3、protected\nprotected 修饰符只能被用在类或者接口中的成员上。在 Java 中，可以从同一个包中访问一个 protected 的成员，但对于 kotlin 来说，protected 成员只在该类和它的子类中可见。此外，protected 不适用于顶层声明\n\n7.4、internal\n一个定义为 internal 的包成员，对其所在的整个 module 可见。如果它是一个其它领域的成员，它就需要依赖那个领域的可见性了。比如，如果我们写了一个 private 类，那么它的 internal 修饰的函数的可见性就会限制于它所在的这个类的可见性\n\n我们可以访问同一个 module 中的 internal 修饰的类，但是其它 module 是访问不到该 internal 类的，该修饰符可用于对外发布的开源库，将开源库中不希望被外部引用的代码设为 internal 权限，可避免对外部引用库造成混淆\n\n根据 Jetbrains 的定义，一个 module 应该是一个单独的功能性的单位，可以看做是一起编译的 kotlin 文件的集合，它应该是可以被单独编译、运行、测试、debug 的。相当于在 Android Studio 中主工程引用的 module，Eclipse 中在一个 workspace 中的不同的 project\n\n7.5、private\nprivate 修饰符是限制级最高的修饰符，kotlin 允许在顶层声明中使用 private 可见性，包括类、函数和属性，这表示只在自己所在的文件中可见，所以如果将一个类声明为 private，就不能在定义这个类之外的地方中使用它。此外，如果在一个类里面使用了 private 修饰符，那访问权限就被限制在这个类里面，继承这个类的子类也不能使用它。所以如果类、对象、接口等被定义为 private，那么它们只对被定义所在的文件可见。如果被定义在了类或者接口中，那它们只对这个类或者接口可见\n\n7.6、总结\n修饰符\t类成员\t顶层声明\npublic（默认）\t所有地方可见\t所有地方可见\ninternal\t模块中可见\t模块中可见\nprotected\t子类中可见\t\nprivate\t类中可见\t文件中可见\n八、空安全\n8.1、可空性\n在 kotlin 中，类型系统将一个引用分为可以容纳 null （可空引用）或者不能容纳 null（非空引用）两种类型。 例如，String 类型的常规变量不能指向 null\n\n    var name: String = \"leavesC\"\n    \n    \n复制代码\n如果希望一个变量可以储存 null 引用，需要显式地在类型名称后面加上问号\n\n    var name: String? = \"leavesC\"\n    name = null\n复制代码\n问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用：Int?、Doubld? 、Long? 等\n\nkotlin 对可空类型的显式支持有助于防止 NullPointerException 导致的异常问题，编译器不允许不对可空变量做 null 检查就直接调用其属性。这个强制规定使得开发者必须在编码初期就考虑好变量的可赋值范围并为其各个情况做好分支处理\n\nfun check(name: String?): Boolean {\n    \n    return name.isNotEmpty()\n}\n复制代码\n正确的做法事显式地进行 null 检查\n\nfun check(name: String?): Boolean {\n    if (name != null) {\n        return name.isNotEmpty()\n    }\n    return false\n}\n复制代码\n8.2、安全调用运算符：?.\n安全调用运算符：?. 允许把一次 null 检查和一次方法调用合并为一个操作，如果变量值非空，则方法或属性会被调用，否则直接返回 null\n\n例如，以下两种写法是完全等同的：\n\nfun check(name: String?) {\n    if (name != null) {\n        println(name.toUpperCase())\n    } else {\n        println(null)\n    }\n}\n\nfun check(name: String?) {\n    println(name?.toUpperCase())\n}\n复制代码\n8.3、Elvis 运算符：?:\nElvis 运算符：?: 用于替代 ?. 直接返回默认值 null 的情况，Elvis 运算符接收两个运算数，如果第一个运算数不为 null ，运算结果就是其运算结果值，如果第一个运算数为 null ，运算结果就是第二个运算数\n\n例如，以下两种写法是完全等同的：\n\nfun check(name: String?) {\n    if (name != null) {\n        println(name)\n    } else {\n        println(\"default\")\n    }\n}\n\nfun check(name: String?) {\n    println(name ?: \"default\")\n}\n复制代码\n8.4、安全转换运算符：as?\n安全转换运算符：as? 用于把值转换为指定的类型，如果值不适合该类型则返回 null\n\nfun check(any: Any?) {\n    val result = any as? String\n    println(result ?: println(\"is not String\"))\n}\n复制代码\n8.5、非空断言：!!\n非空断言用于把任何值转换为非空类型，如果对 null 值做非空断言，则会抛出异常\n\nfun main() {\n    var name: String? = \"leavesC\"\n    check(name) \n\n    name = null\n    check(name) \n}\n\nfun check(name: String?) {\n    println(name!!.length)\n}\n复制代码\n8.6、可空类型的扩展\n为可空类型定义扩展函数是一种更强大的处理 null 值的方式，可以允许接收者为 null 的调用，并在该函数中处理 null ，而不是在确保变量不为 null 之后再调用它的方法\n\n例如，如下方法可以被正常调用而不会发生空指针异常\n\n    val name: String? = null\n    println(name.isNullOrEmpty()) \n复制代码\nisNullOrEmpty() 的方法签名如下所示，可以看到这是为可空类型 CharSequence? 定义的扩展函数，方法中已经处理了方法调用者为 null 的情况\n\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n    return this == null || this.length == 0\n}\n复制代码\n8.7、平台类型\n平台类型是 kotlin 对 java 所作的一种平衡性设计。kotlin 将对象的类型分为了可空类型和不可空类型两种，但 java 平台的一切对象类型均为可空的，当在 kotlin 中引用 java 变量时，如果将所有变量均归为可空类型，最终将多出许多 null 检查；如果均看成不可空类型，那么就很容易就写出忽略了NPE 风险的代码。为了平衡两者，kotlin 引入了平台类型，即当在 kotlin 中引用 java 变量值时，既可以将之看成可空类型，也可以将之看成不可空类型，由开发者自己来决定是否进行 null 检查\n\n九、类型的检查与转换\n9.1、类型检查\nis 与 !is 操作符用于在运行时检查对象是否符合给定类型：\n\nfun main() {\n    val strValue = \"leavesC\"\n    parserType(strValue) \n    val intValue = 100\n    parserType(intValue) \n    val doubleValue = 100.22\n    parserType(doubleValue) \n    val longValue = 200L\n    parserType(longValue) \n}\n\nfun parserType(value: Any) {\n    when (value) {\n        is String -> println(\"value is String , length : ${value.length}\")\n        is Int -> println(\"value is Int , toLong : ${value.toLong()}\")\n        !is Long -> println(\"value !is Long\")\n        else -> println(\"unknown\")\n    }\n}\n复制代码\n9.2、智能转换\n在许多情况下，不需要在 kotlin 中使用显式转换操作符，因为编译器跟踪不可变值的 is 检查以及显式转换，并在需要时自动插入安全的转换\n\n例如，对于以下例子来说，当判断 value 为 String 类型通过时，就可以直接将 value 当做 String 类型变量并调用其内部属性\n\nfun main() {\n    val strValue = \"leavesC\"\n    parserType(strValue) \n\n    val intValue = 100\n    parserType(intValue) \n\n    val doubleValue = 100.22\n    parserType(doubleValue) \n\n    val longValue = 200L\n    parserType(longValue) \n}\n\nfun parserType(value: Any) {\n    when (value) {\n        is String -> println(\"value is String , length : ${value.length}\")\n        is Int -> println(\"value is Int , toLong : ${value.toLong()}\")\n        !is Long -> println(\"value !is Long\")\n        else -> println(\"unknown\")\n    }\n}\n复制代码\n编译器会指定根据上下文环境，将变量智能转换为合适的类型\n\n    if (value !is String) return\n    \n    println(value.length)\n\n    \n    if (value !is String || value.length > 0) {\n\n    }\n\n    \n    if (value is String && value.length > 0) {\n\n    }\n复制代码\n9.3、不安全的转换操作符\n如果转换是不可能的，转换操作符 as 会抛出一个异常。因此，我们称之为不安全的转换操作符\n\nfun main() {\n    parserType(\"leavesC\") \n    parserType(10) \n}\n\nfun parserType(value: Any) {\n    val tempValue = value as String\n    println(\"value is String , length is ${tempValue.length}\")\n}\n复制代码\n需要注意的是，null 不能转换为 String 变量，因为该类型不是可空的\n\n因此如下转换会抛出异常\n\n    val x = null\n    val y: String = x as String \n复制代码\n为了匹配安全，可以转换的类型声明为可空类型\n\n    val x = null\n    val y: String? = x as String?\n复制代码\n9.4、安全的转换操作符\n可以使用安全转换操作符 as? 来避免在转换时抛出异常，它在失败时返回 null\n\n    val x = null\n    val y: String? = x as? String\n复制代码\n尽管以上例子 as? 的右边是一个非空类型的 String，但是其转换的结果是可空的\n\n十、类\n10.1、基本概念\n类的概念就是把数据和处理数据的代码封装成一个单一的实体。在 Java 中，数据存储在一个私有字段中，通过提供访问器方法：getter 和 setter 来访问或者修改数据\n\n在 Java 中以下的示例代码是很常见的，Point 类包含很多重复的代码：通过构造函数把参数赋值给有着相同名称的字段，通过 getter 来获取属性值\n\npublic final class Point {\n\n   private final int x;\n   \n   private final int y;\n   \n   public Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n   }\n\n   public final int getX() {\n      return this.x;\n   }\n\n   public final int getY() {\n      return this.y;\n   }\n   \n}\n复制代码\n使用 kotlin 来声明 Point 类则只需要一行代码，两者完全等同\n\nclass Point(val x: Int, val y: Int)\n复制代码\nkotlin 也使用关键字 class 来声明类，类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成，类头与类体都是可选的，如果一个类没有类体，可以省略花括号。此外，kotlin 中类默认是 publish（公有的） 且 final （不可继承）的\n\nkotlin 区分了主构造方法（在类体外部声明）和次构造方法（在类体内部声明），一个类可以有一个主构造函数和多个次构造函数，此外也允许在初始化代码块中 init 添加额外的初始化逻辑\n\n10.2、主构造函数\n主构造函数是类头的一部分，跟在类名（和可选的类型参数）后，主构造函数的参数可以是可变的（var）或只读的（val）\n\nclass Point constructor(val x: Int, val y: Int) {\n\n}\n复制代码\n如果主构造函数没有任何注解或者可见性修饰符，可以省略 constructor 关键字\n\nclass Point(val x: Int, val y: Int) {\n\n}\n\n\nclass Point(val x: Int, val y: Int)\n复制代码\n如果构造函数有注解或可见性修饰符，则 constructor 关键字是必需的，并且这些修饰符在它前面\n\nclass Point public @Inject constructor(val x: Int, val y: Int) {\n\n}\n复制代码\n主构造函数不能包含任何的代码，初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中，初始化块包含了在类被创建时执行的代码，主构造函数的参数可以在初始化块中使用。如果需要的话，也可以在一个类中声明多个初始化语句块。需要注意的是，构造函数的参数如果用 val/var 进行修饰，则相当于在类内部声明了一个同名的全局属性。如果不加 val/var 进行修饰，则构造函数只能在 init 函数块和全局属性初始化时进行引用\n\n此外，要创建一个类的实例不需要使用 Java 中的 new 关键字，像普通函数一样调用构造函数即可\n\nclass Point(val x: Int, val y: Int) {\n\n    init {\n        println(\"initializer blocks , x value is: $x , y value is: $y\")\n    }\n\n}\n\nfun main() {\n    Point(1, 2) \n}\n复制代码\n主构造函数的参数也可以在类体内声明的属性初始化器中使用\n\nclass Point(val x: Int, val y: Int) {\n\n    private val localX = x + 1\n\n    private val localY = y + 1\n\n    init {\n        println(\"initializer blocks , x value is: $x , y value is: $y\")\n        println(\"initializer blocks , localX value is: $localX , localY value is: $localY\")\n    }\n\n}\n\nfun main() {\n    Point(1, 2)\n    \n    \n}\n复制代码\n10.3、次构造函数\n类也可以声明包含前缀 constructor 的次构造函数。如果类有一个主构造函数，每个次构造函数都需要直接委托给主构造函数或者委托给另一个次构造函数以此进行间接委托，用 this 关键字来进行指定即可\n\nclass Point(val x: Int, val y: Int) {\n\n    private val localX = x + 1\n\n    private val localY = y + 1\n\n    init {\n        println(\"initializer blocks , x value is: $x , y value is: $y\")\n        println(\"initializer blocks , localX value is: $localX , localY value is: $localY\")\n    }\n\n    constructor(base: Int) : this(base + 1, base + 1) {\n        println(\"constructor(base: Int)\")\n    }\n\n    constructor(base: Long) : this(base.toInt()) {\n        println(\"constructor(base: Long)\")\n    }\n\n}\n\nfun main() {\n    Point(100)\n    \n    \n    \n    Point(100L)\n    \n    \n    \n    \n}\n复制代码\n初始化块中的代码实际上会成为主构造函数的一部分，委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块。如果一个非抽象类没有声明任何（主或次）构造函数，会默认生成一个不带参数的公有主构造函数\n\n10.4、属性\n在 Java 中，字段和其访问器的组合被称作属性。在 kotlin 中，属性是头等的语言特性，完全替代了字段和访问器方法。在类中声明一个属性和声明一个变量一样是使用 val 和 var 关键字。val 变量只有一个 getter ，var 变量既有 getter 也有 setter\n\nfun main() {\n    val user = User()\n    println(user.name)\n    user.age = 200\n}\n\nclass User() {\n\n    val name: String = \"leavesC\"\n\n    var age: Int = 25\n\n}\n复制代码\n10.5、自定义访问器\n访问器的默认实现逻辑很简单：创建一个存储值的字段，以及返回属性值的 getter 和更新属性值的 setter。如果需要的话，也可以自定义访问器\n\n例如，以下就声明了三个带自定义访问器的属性\n\nclass Point(val x: Int, val y: Int) {\n\n    val isEquals1: Boolean\n        get() {\n            return x == y\n        }\n\n    val isEquals2\n        get() = x == y\n\n    var isEquals3 = false\n        get() = x > y\n        set(value) {\n            field = !value\n        }\n\n}\n复制代码\n如果仅需要改变一个访问器的可见性或者为其添加注解，那么可以定义访问器而不定义其实现\n\nfun main() {\n    val point = Point(10, 10)\n    println(point.isEquals1)\n    \n    \n}\n\nclass Point(val x: Int, val y: Int) {\n\n    var isEquals1: Boolean = false\n        get() {\n            return x == y\n        }\n        private set\n    \n}\n复制代码\n10.6、延迟初始化\n一般地，非空类型的属性必须在构造函数中初始化，但像使用了 Dagger2 这种依赖注入框架的项目来说就十分的不方便了，为了应对这种情况，可以用 lateinit 修饰符来标记该属性，用于告诉编译器该属性会在稍后的时间被初始化\n\n用 lateinit 修饰的属性或变量必须为非空类型，并且不能是原生类型\n\nclass Point(val x: Int, val y: Int)\n\nclass Example {\n\n    lateinit var point: Point\n\n    var point2: Point\n\n    constructor() {\n        point2 = Point(10, 20)\n    }\n    \n}\n复制代码\n如果访问了一个未经过初始化的 lateinit 变量，则会抛出一个包含具体原因（该变量未初始化）的异常信息\n\nException in thread \"main\" kotlin.UninitializedPropertyAccessException: lateinit property point has not been initialized\n复制代码\n十一、类的分类\n11.1、抽象类\n声明为 abstract 的类内部可以包含没有实现体的成员方法，且该成员方法也用 abstract 标记，这种类称为抽象类，包含的没有实现体的方法称为抽象方法\n\n此外，我们并不需要用 open 标注一个抽象类或者抽象方法，因为这是默认声明的\n\nabstract class BaseClass {\n    abstract fun fun1()\n}\n\nclass Derived : BaseClass() {\n    override fun fun1() {\n        \n    }\n}\n复制代码\n11.2、数据类\n数据类是一种非常强大的类，可以避免重复创建 Java 中的用于保存状态但又操作非常简单的 POJO 的模版代码，它们通常只提供了用于访问它们属性的简单的 getter 和 setter\n\n定义一个新的数据类非常简单，例如\n\ndata class Point(val x: Int, val y: Int)\n复制代码\n数据类默认地为主构造函数中声明的所有属性生成了如下几个方法\n\ngetter、setter（需要是 var）\ncomponentN()。按主构造函数的属性声明顺序进行对应\ncopy()\ntoString()\nhashCode()\nequals()\n为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：\n\n主构造函数需要包含一个参数\n主构造函数的所有参数需要标记为 val 或 var\n数据类不能是抽象、开放、密封或者内部的\n可以利用 IDEA 来反编译查看 Point 类的 Java 实现，了解其内部实现\n\npublic final class Point {\n   private final int x;\n   private final int y;\n\n   public final int getX() {\n      return this.x;\n   }\n\n   public final int getY() {\n      return this.y;\n   }\n\n   public Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n   }\n\n   public final int component1() {\n      return this.x;\n   }\n\n   public final int component2() {\n      return this.y;\n   }\n\n   @NotNull\n   public final Point copy(int x, int y) {\n      return new Point(x, y);\n   }\n\n   \n   \n   @NotNull\n   public static Point copy$default(Point var0, int var1, int var2, int var3, Object var4) {\n      if ((var3 & 1) != 0) {\n         var1 = var0.x;\n      }\n\n      if ((var3 & 2) != 0) {\n         var2 = var0.y;\n      }\n\n      return var0.copy(var1, var2);\n   }\n\n   public String toString() {\n      return \"Point(x=\" + this.x + \", y=\" + this.y + \")\";\n   }\n\n   public int hashCode() {\n      return this.x * 31 + this.y;\n   }\n\n   public boolean equals(Object var1) {\n      if (this != var1) {\n         if (var1 instanceof Point) {\n            Point var2 = (Point)var1;\n            if (this.x == var2.x && this.y == var2.y) {\n               return true;\n            }\n         }\n\n         return false;\n      } else {\n         return true;\n      }\n   }\n}\n复制代码\n通过数据类可以简化很多的通用操作，可以很方便地进行：格式化输出变量值、映射对象到变量、对比变量之间的相等性、复制变量等操作\n\nfun main() {\n    val point1 = Point(10, 20)\n    val point2 = Point(10, 20)\n    println(\"point1 toString() : $point1\") \n    println(\"point2 toString() : $point2\") \n\n    val (x, y) = point1\n    println(\"point1 x is $x,point1 y is $y\") \n\n    \n    \n    println(\"point1 == point2 : ${point1 == point2}\") \n    println(\"point1 === point2 : ${point1 === point2}\") \n\n    val point3 = point1.copy(y = 30)\n    println(\"point3 toString() : $point3\") \n}\n复制代码\n需要注意的是，数据类的 toString()、equals()、hashCode()、copy() 等方法只考虑主构造函数中声明的属性，因此在比较两个数据类对象的时候可能会有一些意想不到的结果\n\ndata class Point(val x: Int) {\n\n    var y: Int = 0\n\n}\n\nfun main() {\n    val point1 = Point(10)\n    point1.y = 10\n\n    val point2 = Point(10)\n    point2.y = 20\n\n    println(\"point1 == point2 : ${point1 == point2}\") \n    println(\"point1 === point2 : ${point1 === point2}\") \n}\n复制代码\n11.3、密封类\nSealed 类（密封类）用于对类可能创建的子类进行限制，用 Sealed 修饰的类的直接子类只允许被定义在 Sealed 类所在的文件中（密封类的间接继承者可以定义在其他文件中），这有助于帮助开发者掌握父类与子类之间的变动关系，避免由于代码更迭导致的潜在 bug，且密封类的构造函数只能是 private 的\n\n例如，对于 View 类，其子类只能定义在与之同一个文件里，Sealed 修饰符修饰的类也隐含表示该类为 open 类，因此无需再显式地添加 open 修饰符\n\nsealed class View {\n\n    fun click() {\n\n    }\n\n}\n\nclass Button : View() {\n\n}\n\nclass TextView : View() {\n\n}\n复制代码\n因为 Sealed 类的子类对于编译器来说是可控的，所以如果在 when 表达式中处理了所有 Sealed 类的子类，那就不需要再提供 else 默认分支。即使以后由于业务变动又新增了 View 子类，编译器也会检测到 check 方法缺少分支检查后报错，所以说 check 方法是类型安全的\n\nfun check(view: View): Boolean {\n    when (view) {\n        is Button -> {\n            println(\"is Button\")\n            return true\n        }\n        is TextView -> {\n            println(\"is TextView\")\n            return true\n        }\n    }\n}\n复制代码\n11.4、枚举类\nkotlin 也提供了枚举的实现，相比 Java 需要多使用 class 关键字来声明枚举\n\nenum class Day {\n    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY\n}\n复制代码\n枚举可以声明一些参数\n\nenum class Day(val index: Int) {\n    SUNDAY(0), MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6)\n}\n复制代码\n此外，枚举也可以实现接口\n\ninterface OnChangedListener {\n\n    fun onChanged()\n\n}\n\nenum class Day(val index: Int) : OnChangedListener {\n    SUNDAY(0) {\n        override fun onChanged() {\n\n        }\n    },\n    MONDAY(1) {\n        override fun onChanged() {\n            \n        }\n    }\n}\n复制代码\n枚举也包含有一些共有函数\n\nfun main() {\n    val day = Day.FRIDAY\n    \n    val value = day.index  \n    \n    val value1 = Day.valueOf(\"SUNDAY\") \n    \n    val value2 = Day.values()\n    \n    val value3 = Day.SUNDAY.name \n    \n    val value4 = Day.TUESDAY.ordinal \n}\n复制代码\n11.5、匿名内部类\n使用对象表达式来创建匿名内部类实例\n\ninterface OnClickListener {\n\n    fun onClick()\n\n}\n\nclass View {\n\n    fun setClickListener(clickListener: OnClickListener) {\n\n    }\n\n}\n\nfun main() {\n    val view = View()\n    view.setClickListener(object : OnClickListener {\n        override fun onClick() {\n\n        }\n\n    })\n}\n复制代码\n11.6、嵌套类\n在 kotlin 中在类里面再定义的类默认是嵌套类，此时嵌套类不会包含对外部类的隐式引用\n\nclass Outer {\n\n    private val bar = 1\n\n    class Nested {\n        fun foo1() = 2\n        \n        \n    }\n}\n\nfun main() {\n    val demo = Outer.Nested().foo1()\n}\n复制代码\n以上代码通过 IDEA 反编译后可以看到其内部的 Java 实现方式\n\n可以看到 Nested 其实就是一个静态类，因此 foo2() 不能访问外部类的非静态成员，也不用先声明 Outer 变量再指向 Nested 类，而是直接通过 Outer 类指向 Nested 类\n\npublic final class Outer {\n   private final int bar = 1;\n\n   public static final class Nested {\n      public final int foo1() {\n         return 2;\n      }\n   }\n}\n\npublic final class MainkotlinKt {\n   public static final void main(@NotNull String[] args) {\n      Intrinsics.checkParameterIsNotNull(args, \"args\");\n      int demo = (new Outer.Nested()).foo1();\n   }\n}\n复制代码\n11.7、内部类\n如果需要去访问外部类的成员，需要用 inner 修饰符来标注被嵌套的类，这称为内部类。内部类会隐式持有对外部类的引用\n\nclass Outer {\n\n    private val bar = 1\n\n    inner class Nested {\n        fun foo1() = 2\n        fun foo2() = bar\n    }\n}\n\nfun main() {\n    val demo = Outer().Nested().foo2()\n}\n复制代码\n再来看其内部的 Java 实现方式\n\n使用 inner 来声明 Nested 类后，就相当于将之声明为非静态内部类，因此 foo2() 能访问其外部类的非静态成员，在声明 Nested 变量前也需要通过 Outer 变量来指向其内部的 Nested 类\n\npublic final class Outer {\n   private final int bar = 1;\n\n   public final class Nested {\n      public final int foo1() {\n         return 2;\n      }\n\n      public final int foo2() {\n         return Outer.this.bar;\n      }\n   }\n}\n\npublic final class MainkotlinKt {\n   public static final void main(@NotNull String[] args) {\n      Intrinsics.checkParameterIsNotNull(args, \"args\");\n      int demo = (new Outer().new Nested()).foo2();\n   }\n}\n复制代码\n类A在类B中声明\t在Java中\t在kotlin中\n嵌套类（不存储外部类的引用）\tstatic class A\tclass A\n内部类（存储外部类的引用）\tclass A\tinner class A\n十二、接口\n12.1、抽象方法与默认方法\nkotlin 中的接口与 Java 8 中的类似，可以包含抽象方法的定义以及非抽象方法的实现，不需要使用 default 关键字来标注有默认实现的非抽象方法，但在实现接口的抽象方法时需要使用 override 进行标注\n\nfun main() {\n    val view = View()\n    view.click()\n    view.longClick()\n}\n\nclass View : Clickable {\n    \n    override fun click() {\n        println(\"clicked\")\n    }\n\n}\n\ninterface Clickable {\n    fun click()\n    fun longClick() = println(\"longClicked\")\n}\n复制代码\n如果一个类实现了多个接口，而接口包含带有默认实现且签名相同的方法，此时编译器就会要求开发者必须显式地实现该方法，可以选择在该方法中调用不同接口的相应实现\n\nclass View : Clickable, Clickable2 {\n\n    override fun click() {\n        println(\"clicked\")\n    }\n\n    override fun longClick() {\n        super<Clickable>.longClick()\n        super<Clickable2>.longClick()\n    }\n}\n\ninterface Clickable {\n    fun click()\n    fun longClick() = println(\"longClicked\")\n}\n\ninterface Clickable2 {\n    fun click()\n    fun longClick() = println(\"longClicked2\")\n}\n复制代码\n12.2、抽象属性\n接口中可以包含抽象属性声明，接口不定义该抽象属性是应该存储到一个支持字段还是通过 getter 来获取，接口本身并不包含任何状态，因此只有实现这个接口的类在需要的情况下会存储这个值\n\n看以下例子，Button 类和 TextView 类都实现了 Clickable 接口，并都提供了取得 statusValue 值的方式\n\nButton 类提供了一个自定义的 getter 用于在每次访问时重新获取 statusValue 值，因此在多次获取属性值时其值可能都会不一致，因为每次 getRandom() 方法都会被调用\n\nTextView 类中的 statusValue 属性有一个支持字段来存储在类初始化时得到的数据，因此其值在初始化后是不会再次获取值，即 TextView 类中的 getRandom() 只会被调用一次\n\nfun main() {\n    val button = Button()\n    println(button.statusValue)\n    val textView = TextView()\n    println(textView.statusValue)\n}\n\nclass Button : Clickable {\n\n    override val statusValue: Int\n        get() = getRandom()\n\n    private fun getRandom() = Random().nextInt(10)\n\n}\n\nclass TextView : Clickable {\n\n    override val statusValue: Int = getRandom()\n\n    private fun getRandom() = Random().nextInt(10)\n\n}\n\ninterface Clickable {\n\n    val statusValue: Int\n\n}\n复制代码\n除了可以声明抽象属性外，接口还可以包含具有 getter 和 setter 的属性，只要它们没有引用一个支持字段（支持字段需要在接口中存储状态，而这是不允许的）\n\ninterface Clickable {\n\n    val statusValue: Int\n\n    val check: Boolean\n        get() = statusValue > 10\n    \n}\n复制代码\n十三、继承\n在 kotlin 中所有类都有一个共同的超类 Any ，对于没有超类声明的类来说它就是默认超类。需要注意的是， Any 并不是 java.lang.Object ，它除了 equals() 、 hashCode() 与 toString() 外没有其他属性或者函数\n\n要声明一个显式的超类，需要把父类名放到类头的冒号之后\n\nopen class Base()\n\nclass SubClass() : Base()\n复制代码\n当中，类上的 open 标注与 Java 中的 final 含义相反，用于允许其它类从这个类继承。默认情况下，kotlin 中所有的类都是 final\n\n如果派生类有一个主构造函数，其基类型必须直接或间接调用基类的主构造函数\n\nopen class Base(val str: String)\n\nclass SubClass(val strValue: String) : Base(strValue)\n\nclass SubClass2 : Base {\n\n    constructor(strValue: String) : super(strValue)\n\n    constructor(intValue: Int) : super(intValue.toString())\n\n    constructor(doubValue: Double) : this(doubValue.toString())\n\n}\n复制代码\n13.1、覆盖方法\n与 Java 不同，kotlin 需要显式标注可覆盖的成员和覆盖后的成员：\n\nopen class Base() {\n    open fun fun1() {\n\n    }\n\n    fun fun2() {\n        \n    }\n}\n\nclass SubClass() : Base() {\n    override fun fun1() {\n        super.fun1()\n    }\n}\n复制代码\n用 open 标注的函数才可以被子类重载，子类用 override 表示该函数是要对父类的同签名函数进行覆盖。标记为 override 的成员本身也是开放的，也就是说，它可以被子类覆盖。如果想禁止再次覆盖，可以使用 final 关键字标记 如果父类没有使用 open 对函数进行标注，则子类不允许定义相同签名的函数。对于一个 final 类（没有用 open 标注的类）来说，使用 open 标记属性和方法是无意义的\n\n13.2、属性覆盖\n属性覆盖与方法覆盖类似。在超类中声明为 open 的属性，如果要进行覆盖则必须在派生类中重新声明且以 override 开头，并且它们必须具有兼容的类型\n\n每个声明的属性可以由具有初始化器的属性或者具有 getter 方法的属性覆盖\n\nopen class Base {\n    open val x = 10\n\n    open val y: Int\n        get() {\n            return 100\n        }\n}\n\nclass SubClass : Base() {\n    override val x = 100\n\n    override var y = 200\n}\n\nfun main() {\n    val base = Base()\n    println(base.x) \n    println(base.y) \n\n    val base1: Base = SubClass()\n    println(base1.x) \n    println(base1.y) \n\n    val subClass = SubClass()\n    println(subClass.x) \n    println(subClass.y) \n}\n复制代码\n此外，也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。因为一个 val 属性本质上声明了一个 getter 方法，而将其覆盖为 var 只是在子类中额外声明一个 setter 方法\n\n可以在主构造函数中使用 override 关键字作为属性声明的一部分\n\nopen class Base {\n    open val str: String = \"Base\"\n}\n\nclass SubClass(override val str: String) : Base()\n\nfun main() {\n    val base = Base()\n    println(base.str) \n\n    val subClass = SubClass(\"leavesC\")\n    println(subClass.str) \n}\n复制代码\n13.3、调用超类实现\n派生类可以通过 super 关键字调用其超类的函数与属性访问器的实现\n\nopen class BaseClass {\n    open fun fun1() {\n        println(\"BaseClass fun1\")\n    }\n}\n\nclass SubClass : BaseClass() {\n\n    override fun fun1() {\n        super.fun1()\n    }\n\n}\n复制代码\n对于内部类来说，其本身就可以直接调用调用外部类的函数\n\nopen class BaseClass2 {\n    private fun fun1() {\n        println(\"BaseClass fun1\")\n    }\n\n    inner class InnerClass {\n        fun fun2() {\n            fun1()\n        }\n    }\n\n}\n复制代码\n但如果想要在一个内部类中访问外部类的超类，则需要通过由外部类名限定的 super 关键字来实现\n\nopen class BaseClass {\n    open fun fun1() {\n        println(\"BaseClass fun1\")\n    }\n}\n\nclass SubClass : BaseClass() {\n\n    override fun fun1() {\n        println(\"SubClass fun1\")\n    }\n\n    inner class InnerClass {\n\n        fun fun2() {\n            super@SubClass.fun1()\n        }\n\n    }\n\n}\n\nfun main() {\n    val subClass = SubClass()\n    val innerClass = subClass.InnerClass()\n    \n    innerClass.fun2()\n}\n复制代码\n如果一个类从它的直接超类和实现的接口中继承了相同成员的多个实现， 则必须覆盖这个成员并提供其自己的实现来消除歧义\n\n为了表示采用从哪个超类型继承的实现，使用由尖括号中超类型名限定的 super 来指定，如 super< BaseClass >\n\nopen class BaseClass {\n    open fun fun1() {\n        println(\"BaseClass fun1\")\n    }\n}\n\ninterface BaseInterface {\n    \n    fun fun1() {\n        println(\"BaseInterface fun1\")\n    }\n}\n\nclass SubClass() : BaseClass(), BaseInterface {\n    override fun fun1() {\n        \n        super<BaseClass>.fun1()\n        \n        super<BaseInterface>.fun1()\n    }\n}\n复制代码\n十四、集合\n14.1、只读集合与可变集合\nkotlin 的集合设计和 Java 不同的另一项特性是：kotlin 把访问数据的接口和修改集合数据的接口分开了，kotlin.collections.Collection 接口提供了遍历集合元素、获取集合大小、判断集合是否包含某元素等操作，但这个接口没有提供添加和移除元素的方法。kotlin.collections.MutableCollection 接口继承于 kotlin.collections.Collection 接口，扩展出了用于添加、移除、清空元素的方法\n\n就像 kotlin 对 val 和 var 的区分一样，只读集合接口与可变集合接口的分离能提高对代码的可控性，如果函数接收 Collection 作为形参，那么就可以知道该函数不会修改集合，而只是对数据进行读取\n\n以下是用来创建不同类型集合的函数\n\n集合元素\t只读\t可变\nList\tlistOf\tmutableListOf、arrayListOf\nSet\tsetOf\tmutableSetOf、hashSetOf、linkedSetOf、sortedSetOf\nMap\tmapOf\tmutableMapOf、hashMapOf、linkedMapOf、sortedMapOf\n    val list = listOf(10, 20, 30, 40)\n    \n    \n    println(list.size)\n    println(list.contains(20))\n\n    val mutableList = mutableListOf(\"leavesC\", \"叶应是叶\", \"叶\")\n    mutableList.add(\"Ye\")\n    println(mutableList.size)\n    println(mutableList.contains(\"leavesC\"))\n复制代码\n14.2、集合与 Java\n因为 Java 并不会区分只读集合与可变集合，即使 kotlin 中把集合声明为只读的， Java 代码也可以修改这个集合，而 Java 代码中的集合对 kotlin 来说也是可变性未知的，kotlin 代码可以将之视为只读的或者可变的，包含的元素也是可以为 null 或者不为 null 的\n\n例如，在 Java 代码中 names 这么一个 List< String > 类型的变量\n\npublic class JavaMain {\n\n    public static List<String> names = new ArrayList<>();\n\n    static {\n        names.add(\"leavesC\");\n        names.add(\"Ye\");\n    }\n\n}\n复制代码\n在 kotlin 中可以用以下四种方式来引用变量 names\n\n    val list1: List<String?> = JavaMain.names\n\n    val list2: List<String> = JavaMain.names\n\n    val list3: MutableList<String> = JavaMain.names\n\n    val list4: MutableList<String?> = JavaMain.names\n复制代码\n14.3、只读集合的可变性\n只读集合不一定就是不可变的。例如，假设存在一个拥有只读类型接口的对象，该对象存在两个不同的引用，一个只读，一个可变，当可变引用修改了该对象后，这对只读引用来说就相当于“只读集合被修改了”，因此只读集合并不总是线程安全的。如果需要在多线程环境下处理数据，需要保证正确地同步了对数据的访问，或者使用支持并发访问的数据结构\n\n例如，list1 和 list1 引用到同一个集合对象， list3 对集合的修改同时会影响到 list1\n\n    val list1: List<String> = JavaMain.names\n    val list3: MutableList<String> = JavaMain.names\n    list1.forEach { it -> println(it) } \n    list3.forEach { it -> println(it) } \n    for (index in list3.indices) {\n        list3[index] = list3[index].toUpperCase()\n    }\n    list1.forEach { it -> println(it) } \n复制代码\n14.4、集合与可空性\n集合的可空性可以分为三种：\n\n可以包含为 null 的集合元素\n集合本身可以为 null\n集合本身可以为 null，且可以包含为 null 的集合元素\n例如，intList1 可以包含为 null 的集合元素，但集合本身不能指向 null；intList2 不可以包含为 null 的集合元素，但集合本身可以指向 null；intList3 可以包含为 null 的集合元素，且集合本身能指向 null\n\n    \n    val intList1: List<Int?> = listOf(10, 20, 30, 40, null)\n    \n    var intList2: List<Int>? = listOf(10, 20, 30, 40)\n    intList2 = null\n    \n    var intList3: List<Int?>? = listOf(10, 20, 30, 40, null)\n    intList3 = null\n复制代码"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304154049},"updatedAt":{"$$date":1597305351662},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ucpammJ89ZaGKx2m"}
{"name":"py-关键字参数","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：\n\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：\n\n>>> person('Michael', 30)\nname: Michael age: 30 other: {}\n也可以传入任意个数的关键字参数：\n\n>>> person('Bob', 35, city='Beijing')\nname: Bob age: 35 other: {'city': 'Beijing'}\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。\n\n和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\n\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, city=extra['city'], job=extra['job'])\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n当然，上面复杂的调用可以用简化的写法：\n\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, **extra)\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977480015},"updatedAt":{"$$date":1594977798453},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uqhi3nZkJoZuCpSx"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977500875},"updatedAt":{"$$date":1594977500875},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"vB8S8cojs8ZzQ4Y6"}
{"name":"py-数据类型转换","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n数据类型转换\nPython内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：\n\n>>> int('123')\n123\n>>> int(12.34)\n12\n>>> float('12.34')\n12.34\n>>> str(1.23)\n'1.23'\n>>> str(100)\n'100'\n>>> bool(1)\nTrue\n>>> bool('')\nFalse\n函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：\n\n>>> a = abs # 变量a指向abs函数\n>>> a(-1) # 所以也可以通过a调用abs函数\n1"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973944732},"updatedAt":{"$$date":1594977269087},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"w2Mk0Qh6yDfObMK1"}
{"name":"kotlin-嵌套类与内部类 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/nested-classes.html\n嵌套类与内部类 - Kotlin 语言中文站\n3-3 minutes\n改进翻译\n类可以嵌套在其他类中：\n\n标记为 inner 的嵌套类能够访问其外部类的成员。内部类会带有一个对外部类的对象的引用：\n\nclass Outer {\n    private val bar: Int = 1\n    inner class Inner {\n        fun foo() = bar\n    }\n}\n\nval demo = Outer().Inner().foo() // == 1\n参见限定的 this 表达式以了解内部类中的 this 的消歧义用法。\n\n使用对象表达式创建匿名内部类实例：\n\nwindow.addMouseListener(object : MouseAdapter() {\n\n    override fun mouseClicked(e: MouseEvent) { …… }\n\n    override fun mouseEntered(e: MouseEvent) { …… }\n})\n注：对于 JVM 平台, 如果对象是函数式 Java 接口（即具有单个抽象方法的 Java 接口）的实例， 你可以使用带接口类型前缀的lambda表达式创建它：\n\nval listener = ActionListener { println(\"clicked\") }"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307925492},"updatedAt":{"$$date":1597308079613},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"w2ijnfaFv4BaAG2K"}
{"name":"kotlin-枚举类 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/enum-classes.html\n枚举类 - Kotlin 语言中文站\n7-9 minutes\n改进翻译\n枚举类的最基本的用法是实现类型安全的枚举：\n\nenum class Direction {\n    NORTH, SOUTH, WEST, EAST\n}\n每个枚举常量都是一个对象。枚举常量用逗号分隔。\n\n因为每一个枚举都是枚举类的实例，所以他们可以是这样初始化过的：\n\nenum class Color(val rgb: Int) {\n        RED(0xFF0000),\n        GREEN(0x00FF00),\n        BLUE(0x0000FF)\n}\n枚举常量还可以声明其带有相应方法以及覆盖了基类方法的匿名类。\n\nenum class ProtocolState {\n    WAITING {\n        override fun signal() = TALKING\n    },\n\n    TALKING {\n        override fun signal() = WAITING\n    };\n\n    abstract fun signal(): ProtocolState\n}\n如果枚举类定义任何成员，那么使用分号将成员定义中的枚举常量定义分隔开。\n\n枚举条目不能包含内部类以外的嵌套类型（已在 Kotlin 1.2 中弃用）。\n\n一个枚举类可以实现接口（但不能从类继承），可以为所有条目提供统一的接口成员实现，也可以在相应匿名类中为每个条目提供各自的实现。只需将接口添加到枚举类声明中即可，如下所示：\n\nimport java.util.function.BinaryOperator\nimport java.util.function.IntBinaryOperator\n\n//sampleStart\nenum class IntArithmetics : BinaryOperator<Int>, IntBinaryOperator {\n    PLUS {\n        override fun apply(t: Int, u: Int): Int = t + u\n    },\n    TIMES {\n        override fun apply(t: Int, u: Int): Int = t * u\n    };\n    \n    override fun applyAsInt(t: Int, u: Int) = apply(t, u)\n}\n//sampleEnd\n\nfun main() {\n    val a = 13\n    val b = 31\n    for (f in IntArithmetics.values()) {\n        println(\"$f($a, $b) = ${f.apply(a, b)}\")\n    }\n}\nKotlin 中的枚举类也有合成方法允许列出定义的枚举常量以及通过名称获取枚举常量。这些方法的签名如下（假设枚举类的名称是 EnumClass）：\n\nEnumClass.valueOf(value: String): EnumClass\nEnumClass.values(): Array<EnumClass>\n如果指定的名称与类中定义的任何枚举常量均不匹配，valueOf() 方法将抛出 IllegalArgumentException 异常。\n\n自 Kotlin 1.1 起，可以使用 enumValues<T>() 与 enumValueOf<T>() 函数以泛型的方式访问枚举类中的常量 ：\n\nenum class RGB { RED, GREEN, BLUE }\n\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n\nprintAllValues<RGB>() // 输出 RED, GREEN, BLUE\n每个枚举常量都具有在枚举类声明中获取其名称与位置的属性：\n\nval name: String\nval ordinal: Int\n枚举常量还实现了 Comparable 接口， 其中自然顺序是它们在枚举类中定义的顺序。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597307926558},"updatedAt":{"$$date":1597308098756},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"wLTBHce1Wi9gB7k3"}
{"name":"andr-","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597244749992},"updatedAt":{"$$date":1597244749992},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"x0fq7v9pwrjzldKL"}
{"name":"kotlin-Kotlin 继承 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-extend.html\nKotlin 继承 | 菜鸟教程\n3-4 minutes\nKotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：\n\nclass Example // 从 Any 隐式继承\nAny 默认提供了三个函数：\n\nequals()\n\nhashCode()\n\ntoString()\n注意：Any 不是 java.lang.Object。\n\n如果一个类要被继承，可以使用 open 关键字进行修饰。\n\nopen class Base(p: Int)           // 定义基类\n\nclass Derived(p: Int) : Base(p)\n构造函数\n子类有主构造函数\n如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。\n\nopen class Person(var name : String, var age : Int){// 基类\n\n}\n\nclass Student(name : String, age : Int, var no : String, var score : Int) : Person(name, age) {\n\n}\n\n// 测试\nfun main(args: Array<String>) {\n    val s =  Student(\"Runoob\", 18, \"S12346\", 89)\n    println(\"学生名： ${s.name}\")\n    println(\"年龄： ${s.age}\")\n    println(\"学生号： ${s.no}\")\n    println(\"成绩： ${s.score}\")\n}\n输出结果：\n\n学生名： Runoob\n年龄： 18\n学生号： S12346\n成绩： 89\n子类没有主构造函数\n如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。\n\nclass Student : Person {\n\n    constructor(ctx: Context) : super(ctx) {\n    } \n\n    constructor(ctx: Context, attrs: AttributeSet) : super(ctx,attrs) {\n    }\n}\n实例\n/**用户基类**/\nopen class Person(name:String){\n    /**次级构造函数**/\n    constructor(name:String,age:Int):this(name){\n        //初始化\n        println(\"-------基类次级构造函数---------\")\n    }\n}\n\n/**子类继承 Person 类**/\nclass Student:Person{\n\n    /**次级构造函数**/\n    constructor(name:String,age:Int,no:String,score:Int):super(name,age){\n        println(\"-------继承类次级构造函数---------\")\n        println(\"学生名： ${name}\")\n        println(\"年龄： ${age}\")\n        println(\"学生号： ${no}\")\n        println(\"成绩： ${score}\")\n    }\n}\n\nfun main(args: Array<String>) {\n    var s =  Student(\"Runoob\", 18, \"S12345\", 89)\n}\n输出结果：\n\n-------基类次级构造函数---------\n-------继承类次级构造函数---------\n学生名： Runoob\n年龄： 18\n学生号： S12345\n成绩： 89\n重写\n在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：\n\n/**用户基类**/\nopen class Person{\n    open fun study(){       // 允许子类重写\n        println(\"我毕业了\")\n    }\n}\n\n/**子类继承 Person 类**/\nclass Student : Person() {\n\n    override fun study(){    // 重写方法\n        println(\"我在读大学\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val s =  Student()\n    s.study();\n\n}\n输出结果为:\n\n我在读大学\n如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。\n\nopen class A {\n    open fun f () { print(\"A\") }\n    fun a() { print(\"a\") }\n}\n\ninterface B {\n    fun f() { print(\"B\") } //接口的成员变量默认是 open 的\n    fun b() { print(\"b\") }\n}\n\nclass C() : A() , B{\n    override fun f() {\n        super<A>.f()//调用 A.f()\n        super<B>.f()//调用 B.f()\n    }\n}\n\nfun main(args: Array<String>) {\n    val c =  C()\n    c.f();\n\n}\nC 继承自 a() 或 b(), C 不仅可以从 A 或则 B 中继承函数，而且 C 可以继承 A()、B() 中共有的函数。此时该函数在中只有一个实现，为了消除歧义，该函数必须调用A()和B()中该函数的实现，并提供自己的实现。\n\n输出结果为:\n\nAB\n属性重写\n属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写：\n\nopen class Foo {\n    open val x: Int get { …… }\n}\n\nclass Bar1 : Foo() {\n    override val x: Int = ……\n}\n你可以用一个var属性重写一个val属性，但是反过来不行。因为val属性本身定义了getter方法，重写为var属性会在衍生类中额外声明一个setter方法\n\n你可以在主构造函数中使用 override 关键字作为属性声明的一部分:\n\ninterface Foo {\n    val count: Int\n}\n\nclass Bar1(override val count: Int) : Foo\n\nclass Bar2 : Foo {\n    override var count: Int = 0\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597303693203},"updatedAt":{"$$date":1597304084161},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xLI8nLZJLNfG7OV1"}
{"name":"kotlin-区间与数列 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/ranges.html\n区间与数列 - Kotlin 语言中文站\n9-11 minutes\n改进翻译\nKotlin 可通过调用 kotlin.ranges 包中的 rangeTo() 函数及其操作符形式的 .. 轻松地创建两个值的区间。 通常，rangeTo() 会辅以 in 或 !in 函数。\n\n整数类型区间（IntRange、LongRange、CharRange）还有一个拓展特性：可以对其进行迭代。 这些区间也是相应整数类型的等差数列。 这种区间通常用于 for 循环中的迭代。\n\nfun main() {\n//sampleStart\n    for (i in 1..4) print(i)\n//sampleEnd\n}\n\n要反向迭代数字，请使用 downTo 函数而不是 .. 。\n\nfun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n也可以通过任意步长（不一定为 1 ）迭代数字。 这是通过 step 函数完成的。\n\nfun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n    println()\n    for (i in 8 downTo 1 step 2) print(i)\n//sampleEnd\n}\n\n要迭代不包含其结束元素的数字区间，请使用 until 函数：\n\nfun main() {\n//sampleStart\n    for (i in 1 until 10) {       // i in [1, 10), 10被排除\n        print(i)\n    }\n//sampleEnd\n}\n\n区间从数学意义上定义了一个封闭的间隔：它由两个端点值定义，这两个端点值都包含在该区间内。 区间是为可比较类型定义的：具有顺序，可以定义任意实例是否在两个给定实例之间的区间内。 区间的主要操作是 contains，通常以 in 与 !in 操作符的形式使用。\n\n要为类创建一个区间，请在区间起始值上调用 rangeTo() 函数，并提供结束值作为参数。 rangeTo() 通常以操作符 .. 形式调用。\n\nclass Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        }\n        return this.minor - other.minor\n    }\n}\n\nfun main() {\n//sampleStart\n    val versionRange = Version(1, 11)..Version(1, 30)\n    println(Version(0, 9) in versionRange)\n    println(Version(1, 20) in versionRange)\n//sampleEnd\n}\n\n如上个示例所示，整数类型的区间（例如 Int、Long 与 Char）可视为等差数列。 在 Kotlin 中，这些数列由特殊类型定义：IntProgression、LongProgression 与 CharProgression。\n\n数列具有三个基本属性：first 元素、last 元素和一个非零的 step。 首个元素为 first，后续元素是前一个元素加上一个 step。 以确定的步长在数列上进行迭代等效于 Java/JavaScript 中基于索引的 for 循环。\n\nfor (int i = first; i <= last; i += step) {\n  // ……\n}\n通过迭代数列隐式创建区间时，此数列的 first 与 last 元素是区间的端点，step 为 1 。\n\nfun main() {\n//sampleStart\n    for (i in 1..10) print(i)\n//sampleEnd\n}\n\n要指定数列步长，请在区间上使用 step 函数。\n\nfun main() {\n//sampleStart\n    for (i in 1..8 step 2) print(i)\n//sampleEnd\n}\n\n数列的 last 元素是这样计算的：\n\n对于正步长：不大于结束值且满足 (last - first) % step == 0 的最大值。\n对于负步长：不小于结束值且满足 (last - first) % step == 0 的最小值。\n因此，last 元素并非总与指定的结束值相同。\n\nfun main() {\n//sampleStart\n    for (i in 1..9 step 3) print(i) // 最后一个元素是 7\n//sampleEnd\n}\n\n要创建反向迭代的数列，请在定义其区间时使用 downTo 而不是 ..。\n\nfun main() {\n//sampleStart\n    for (i in 4 downTo 1) print(i)\n//sampleEnd\n}\n\n数列实现 Iterable<N>，其中 N 分别是 Int、Long 或 Char，因此可以在各种集合函数（如 map、filter 与其他）中使用它们。\n\nfun main() {\n//sampleStart\n    println((1..10).filter { it % 2 == 0 })\n//sampleEnd\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597308431957},"updatedAt":{"$$date":1597376998359},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xdzfG4zB8oiDTpBN"}
{"name":"py-","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594977494373},"updatedAt":{"$$date":1594977494373},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xf9wLlmLfQfadLvf"}
{"name":"kotlin-Kotlin 对象表达式和对象声明 | 菜鸟教程","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.runoob.com /kotlin/kotlin-object-declarations.html\nKotlin 对象表达式和对象声明 | 菜鸟教程\n4-5 minutes\nKotlin 用对象表达式和对象声明来实现创建一个对某个类做了轻微改动的类的对象，且不需要去声明一个新的子类。\n\n对象表达式\n通过对象表达式实现一个匿名内部类的对象用于方法的参数中：\n\nwindow.addMouseListener(object : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) {\n        // ...\n    }\n    override fun mouseEntered(e: MouseEvent) {\n        // ...\n    }\n})\n对象可以继承于某个基类，或者实现其他接口:\n\nopen class A(x: Int) {\n    public open val y: Int = x\n}\n\ninterface B {……}\n\nval ab: A = object : A(1), B {\n    override val y = 15\n}\n如果超类型有一个构造函数，则必须传递参数给它。多个超类型和接口可以用逗号分隔。\n\n通过对象表达式可以越过类的定义直接得到一个对象：\n\nfun main(args: Array<String>) {\n    val site = object {\n        var name: String = \"菜鸟教程\"\n        var url: String = \"www.runoob.com\"\n    }\n    println(site.name)\n    println(site.url)\n}\n请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。\n\nclass C {\n    // 私有函数，所以其返回类型是匿名对象类型\n    private fun foo() = object {\n        val x: String = \"x\"\n    }\n\n    // 公有函数，所以其返回类型是 Any\n    fun publicFoo() = object {\n        val x: String = \"x\"\n    }\n\n    fun bar() {\n        val x1 = foo().x        // 没问题\n        val x2 = publicFoo().x  // 错误：未能解析的引用“x”\n    }\n}\n在对象表达中可以方便的访问到作用域中的其他变量:\n\nfun countClicks(window: JComponent) {\n    var clickCount = 0\n    var enterCount = 0\n\n    window.addMouseListener(object : MouseAdapter() {\n        override fun mouseClicked(e: MouseEvent) {\n            clickCount++\n        }\n\n        override fun mouseEntered(e: MouseEvent) {\n            enterCount++\n        }\n    })\n    // ……\n}\n对象声明\nKotlin 使用 object 关键字来声明一个对象。\n\nKotlin 中我们可以方便的通过对象声明来获得一个单例。\n\nobject DataProviderManager {\n    fun registerDataProvider(provider: DataProvider) {\n        // ……\n    }\n\n    val allDataProviders: Collection<DataProvider>\n        get() = // ……\n}\n引用该对象，我们直接使用其名称即可：\n\nDataProviderManager.registerDataProvider(……)\n当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个单例。\n\nvar data1 = DataProviderManager\nvar data2 = DataProviderManager\ndata1.name = \"test\"\nprint(\"data1 name = ${data2.name}\")  \n实例\n以下实例中，两个对象都输出了同一个 url 地址：\n\nobject Site {\n    var url:String = \"\"\n    val name: String = \"菜鸟教程\"\n}\nfun main(args: Array<String>) {\n    var s1 =  Site\n    var s2 = Site\n    s1.url = \"www.runoob.com\"\n    println(s1.url)\n    println(s2.url)\n}\n输出结果为:\n\nwww.runoob.com\nwww.runoob.com\n对象可以有超类型：\n\nobject DefaultListener : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) {\n        // ……\n    }\n\n    override fun mouseEntered(e: MouseEvent) {\n        // ……\n    }\n}\n与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。\n\nclass Site {\n    var name = \"菜鸟教程\"\n    object DeskTop{\n        var url = \"www.runoob.com\"\n        fun showName(){\n            print{\"desk legs $name\"} // 错误，不能访问到外部类的方法和变量\n        }\n    }\n}\nfun main(args: Array<String>) {\n    var site = Site()\n    site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象\n    Site.DeskTop.url // 正确\n}\n伴生对象\n类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。\n\nclass MyClass {\n    companion object Factory {\n        fun create(): MyClass = MyClass()\n    }\n}\n\nval instance = MyClass.create()   // 访问到对象的内部元素\n我们可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名：\n\nclass MyClass {\n    companion object {\n    }\n}\n\nval x = MyClass.Companion\n注意：一个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次。\n\n请伴生对象的成员看起来像其他语言的静态成员，但在运行时他们仍然是真实对象的实例成员。例如还可以实现接口：\n\ninterface Factory<T> {\n    fun create(): T\n}\n\n\nclass MyClass {\n    companion object : Factory<MyClass> {\n        override fun create(): MyClass = MyClass()\n    }\n}\n对象表达式和对象声明之间的语义差异\n对象表达式和对象声明之间有一个重要的语义差别：\n\n对象表达式是在使用他们的地方立即执行的\n\n对象声明是在第一次被访问到时延迟初始化的\n\n伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597304151760},"updatedAt":{"$$date":1597305002861},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xfPUB9MMJmWc3vL8"}
{"name":"java-","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973264611},"updatedAt":{"$$date":1594973264611},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"xwlWtJcH1itE8Pil"}
{"name":"java-使用CompletableFuture","folderId":"I2PM_U4RG","content":[{"label":"Fragment 1","language":"java","value":"使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。\n\n从Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。\n\n我们以获取股票价格为例，看看如何使用CompletableFuture：\n\n// CompletableFuture\nimport java.util.concurrent.CompletableFuture;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 创建异步执行任务:\n        CompletableFuture<Double> cf = CompletableFuture.supplyAsync(Main::fetchPrice);\n        // 如果执行成功:\n        cf.thenAccept((result) -> {\n            System.out.println(\"price: \" + result);\n        });\n        // 如果执行异常:\n        cf.exceptionally((e) -> {\n            e.printStackTrace();\n            return null;\n        });\n        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:\n        Thread.sleep(200);\n    }\n\n    static Double fetchPrice() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        if (Math.random() < 0.3) {\n            throw new RuntimeException(\"fetch price failed!\");\n        }\n        return 5 + Math.random() * 20;\n    }\n}\n\n Run\n创建一个CompletableFuture是通过CompletableFuture.supplyAsync()实现的，它需要一个实现了Supplier接口的对象：\n\npublic interface Supplier<T> {\n    T get();\n}\n这里我们用lambda语法简化了一下，直接传入Main::fetchPrice，因为Main.fetchPrice()静态方法的签名符合Supplier接口的定义（除了方法名外）。\n\n紧接着，CompletableFuture已经被提交给默认的线程池执行了，我们需要定义的是CompletableFuture完成时和异常时需要回调的实例。完成时，CompletableFuture会调用Consumer对象：\n\npublic interface Consumer<T> {\n    void accept(T t);\n}\n异常时，CompletableFuture会调用Function对象：\n\npublic interface Function<T, R> {\n    R apply(T t);\n}\n这里我们都用lambda语法简化了代码。\n\n可见CompletableFuture的优点是：\n\n异步任务结束时，会自动回调某个对象的方法；\n异步任务出错时，会自动回调某个对象的方法；\n主线程设置好回调后，不再关心异步任务的执行。\n如果只是实现了异步回调机制，我们还看不出CompletableFuture相比Future的优势。CompletableFuture更强大的功能是，多个CompletableFuture可以串行执行，例如，定义两个CompletableFuture，第一个CompletableFuture根据证券名称查询证券代码，第二个CompletableFuture根据证券代码查询证券价格，这两个CompletableFuture实现串行操作如下：\n\n// CompletableFuture\nimport java.util.concurrent.CompletableFuture;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 第一个任务:\n        CompletableFuture<String> cfQuery = CompletableFuture.supplyAsync(() -> {\n            return queryCode(\"中国石油\");\n        });\n        // cfQuery成功后继续执行下一个任务:\n        CompletableFuture<Double> cfFetch = cfQuery.thenApplyAsync((code) -> {\n            return fetchPrice(code);\n        });\n        // cfFetch成功后打印结果:\n        cfFetch.thenAccept((result) -> {\n            System.out.println(\"price: \" + result);\n        });\n        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:\n        Thread.sleep(2000);\n    }\n\n    static String queryCode(String name) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        return \"601857\";\n    }\n\n    static Double fetchPrice(String code) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        return 5 + Math.random() * 20;\n    }\n}\n\n Run\n除了串行执行外，多个CompletableFuture还可以并行执行。例如，我们考虑这样的场景：\n\n同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：\n\n// CompletableFuture\nimport java.util.concurrent.CompletableFuture;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 两个CompletableFuture执行异步查询:\n        CompletableFuture<String> cfQueryFromSina = CompletableFuture.supplyAsync(() -> {\n            return queryCode(\"中国石油\", \"https://finance.sina.com.cn/code/\");\n        });\n        CompletableFuture<String> cfQueryFrom163 = CompletableFuture.supplyAsync(() -> {\n            return queryCode(\"中国石油\", \"https://money.163.com/code/\");\n        });\n\n        // 用anyOf合并为一个新的CompletableFuture:\n        CompletableFuture<Object> cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);\n\n        // 两个CompletableFuture执行异步查询:\n        CompletableFuture<Double> cfFetchFromSina = cfQuery.thenApplyAsync((code) -> {\n            return fetchPrice((String) code, \"https://finance.sina.com.cn/price/\");\n        });\n        CompletableFuture<Double> cfFetchFrom163 = cfQuery.thenApplyAsync((code) -> {\n            return fetchPrice((String) code, \"https://money.163.com/price/\");\n        });\n\n        // 用anyOf合并为一个新的CompletableFuture:\n        CompletableFuture<Object> cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);\n\n        // 最终结果:\n        cfFetch.thenAccept((result) -> {\n            System.out.println(\"price: \" + result);\n        });\n        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:\n        Thread.sleep(200);\n    }\n\n    static String queryCode(String name, String url) {\n        System.out.println(\"query code from \" + url + \"...\");\n        try {\n            Thread.sleep((long) (Math.random() * 100));\n        } catch (InterruptedException e) {\n        }\n        return \"601857\";\n    }\n\n    static Double fetchPrice(String code, String url) {\n        System.out.println(\"query price from \" + url + \"...\");\n        try {\n            Thread.sleep((long) (Math.random() * 100));\n        } catch (InterruptedException e) {\n        }\n        return 5 + Math.random() * 20;\n    }\n}\n\n Run\n上述逻辑实现的异步查询规则实际上是：\n\n┌─────────────┐ ┌─────────────┐\n│ Query Code  │ │ Query Code  │\n│  from sina  │ │  from 163   │\n└─────────────┘ └─────────────┘\n       │               │\n       └───────┬───────┘\n               ▼\n        ┌─────────────┐\n        │    anyOf    │\n        └─────────────┘\n               │\n       ┌───────┴────────┐\n       ▼                ▼\n┌─────────────┐  ┌─────────────┐\n│ Query Price │  │ Query Price │\n│  from sina  │  │  from 163   │\n└─────────────┘  └─────────────┘\n       │                │\n       └────────┬───────┘\n                ▼\n         ┌─────────────┐\n         │    anyOf    │\n         └─────────────┘\n                │\n                ▼\n         ┌─────────────┐\n         │Display Price│\n         └─────────────┘\n除了anyOf()可以实现“任意个CompletableFuture只要一个成功”，allOf()可以实现“所有CompletableFuture都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。\n\n最后我们注意CompletableFuture的命名规则：\n\nxxx()：表示该方法将继续在已有的线程中执行；\nxxxAsync()：表示将异步在线程池中执行。\n练习\n从下载练习：使用CompletableFuture （推荐使用IDE练习插件快速下载）\n\n小结\nCompletableFuture可以指定异步处理流程：\n\nthenAccept()处理正常结果；\nexceptional()处理异常结果；\nthenApplyAsync()用于串行化另一个CompletableFuture；\nanyOf()和allOf()用于并行化多个CompletableFuture。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973284814},"updatedAt":{"$$date":1594973370741},"folder":{"id":"I2PM_U4RG","name":"java","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"y6PWECdpdNWzibw1"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"java","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1594980166135},"updatedAt":{"$$date":1594980166135},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yXP4hKbqlHKLe0EB"}
{"name":"andr-使用生命周期感知型组件处理生命周期","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /topic/libraries/architecture/lifecycle\n使用生命周期感知型组件处理生命周期  |  Android 开发者  |  Android Developers\n12-15 minutes\n生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您写出更有条理且往往更精简的代码，这样的代码更易于维护。\n\n一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。\n\nandroidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。\n\n在 Android 框架中定义的大多数应用组件都存在生命周期。生命周期由操作系统或进程中运行的框架代码管理。它们是 Android 运作方式的核心，应用必须遵循它们。如果不这样做，可能会引发内存泄露甚至应用崩溃。\n\n假设我们有一个在屏幕上显示设备位置的 Activity。常见的实现可能如下所示：\n\n    internal class MyLocationListener(\n            private val context: Context,\n            private val callback: (Location) -> Unit\n    ) {fun start() {\n            // connect to system location service\n        }fun stop() {\n            // disconnect from system location service\n        }\n    }class MyActivity : AppCompatActivity() {\n        private lateinit var myLocationListener: MyLocationListeneroverride fun onCreate(...) {\n            myLocationListener = MyLocationListener(this) { location ->\n                // update UI\n            }\n        }public override fun onStart() {\n            super.onStart()\n            myLocationListener.start()\n            // manage other components that need to respond\n            // to the activity lifecycle\n        }public override fun onStop() {\n            super.onStop()\n            myLocationListener.stop()\n            // manage other components that need to respond\n            // to the activity lifecycle\n        }\n    }\n    \n    class MyLocationListener {\n        public MyLocationListener(Context context, Callback callback) {\n            // ...\n        }void start() {\n            // connect to system location service\n        }void stop() {\n            // disconnect from system location service\n        }\n    }class MyActivity extends AppCompatActivity {\n        private MyLocationListener myLocationListener;@Override\n        public void onCreate(...) {\n            myLocationListener = new MyLocationListener(this, (location) -> {\n                // update UI\n            });\n        }@Override\n        public void onStart() {\n            super.onStart();\n            myLocationListener.start();\n            // manage other components that need to respond\n            // to the activity lifecycle\n        }@Override\n        public void onStop() {\n            super.onStop();\n            myLocationListener.stop();\n            // manage other components that need to respond\n            // to the activity lifecycle\n        }\n    }\n    \n虽然此示例看起来没问题，但在真实的应用中，最终会有太多管理界面和其他组件的调用，以响应生命周期的当前状态。管理多个组件会在生命周期方法（如 onStart() 和 onStop()）中放置大量的代码，这使得它们难以维护。\n\n此外，无法保证组件会在 Activity 或 Fragment 停止之前启动。在我们需要执行长时间运行的操作（如 onStart() 中的某种配置检查）时尤其如此。这可能会导致出现一种竞争条件，在这种条件下，onStop() 方法会在 onStart() 之前结束，这使得组件留存的时间比所需的时间要长。\n\n    class MyActivity : AppCompatActivity() {\n        private lateinit var myLocationListener: MyLocationListeneroverride fun onCreate(...) {\n            myLocationListener = MyLocationListener(this) { location ->\n                // update UI\n            }\n        }public override fun onStart() {\n            super.onStart()\n            Util.checkUserStatus { result ->\n                // what if this callback is invoked AFTER activity is stopped?\n                if (result) {\n                    myLocationListener.start()\n                }\n            }\n        }public override fun onStop() {\n            super.onStop()\n            myLocationListener.stop()\n        }}\n    \n    class MyActivity extends AppCompatActivity {\n        private MyLocationListener myLocationListener;public void onCreate(...) {\n            myLocationListener = new MyLocationListener(this, location -> {\n                // update UI\n            });\n        }@Override\n        public void onStart() {\n            super.onStart();\n            Util.checkUserStatus(result -> {\n                // what if this callback is invoked AFTER activity is stopped?\n                if (result) {\n                    myLocationListener.start();\n                }\n            });\n        }@Override\n        public void onStop() {\n            super.onStop();\n            myLocationListener.stop();\n        }\n    }\n    \nandroidx.lifecycle 软件包提供的类和接口可帮助您以弹性和隔离的方式解决这些问题。\n\n生命周期\nLifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。\n\nLifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：\n\n事件\n从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。\n状态\n由 Lifecycle 对象跟踪的组件的当前状态。\n生命周期状态示意图\n图 1. 构成 Android Activity 生命周期的状态和事件\n您可以将状态看作图中的节点，将事件看作这些节点之间的边。\n\n类可以通过向其方法添加注解来监控组件的生命周期状态。然后，您可以通过调用 Lifecycle 类的 addObserver() 方法并传递观察者的实例来添加观察者，如以下示例中所示：\n\n    class MyObserver : LifecycleObserver {@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n        fun connectListener() {\n            ...\n        }@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n        fun disconnectListener() {\n            ...\n        }\n    }\n    myLifecycleOwner\n\n.getLifecycle().addObserver(MyObserver())\n    \n    public class MyObserver implements LifecycleObserver {\n        @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n        public void connectListener() {\n            ...\n        }@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n        public void disconnectListener() {\n            ...\n        }\n    }\n    myLifecycleOwner\n\n.getLifecycle().addObserver(new MyObserver());\n    \n在上面的示例中，myLifecycleOwner 对象实现了 LifecycleOwner 接口，我们将在接下来的部分中对该接口进行说明。\n\nLifecycleOwner\nLifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。\n\n此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。\n\n实现 LifecycleObserver 的组件可与实现 LifecycleOwner 的组件无缝协同工作，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。\n\n对于位置跟踪示例，我们可以让 MyLocationListener 类实现 LifecycleObserver，然后在 onCreate() 方法中使用 Activity 的 Lifecycle 对其进行初始化。这样，MyLocationListener 类便可以“自给自足”，这意味着，对生命周期状态的变化做出响应的逻辑会在 MyLocationListener（而不是在 Activity）中进行声明。让各个组件存储自己的逻辑，可使 Activity 和 Fragment 逻辑更易于管理。\n\n    class MyActivity : AppCompatActivity() {\n        private lateinit var myLocationListener: MyLocationListeneroverride fun onCreate(...) {\n            myLocationListener = MyLocationListener(this, lifecycle) { location ->\n                // update UI\n            }\n            Util.checkUserStatus { result ->\n                if (result) {\n                    myLocationListener.enable()\n                }\n            }\n        }\n    }\n    \n    class MyActivity extends AppCompatActivity {\n        private MyLocationListener myLocationListener;public void onCreate(...) {\n            myLocationListener = new MyLocationListener(this, getLifecycle(), location -> {\n                // update UI\n            });\n            Util.checkUserStatus(result -> {\n                if (result) {\n                    myLocationListener.enable();\n                }\n            });\n      }\n    }\n    \n一个常见的用例是，如果 Lifecycle 现在未处于良好的状态，则应避免调用某些回调。例如，如果回调在 Activity 状态保存后运行 Fragment 事务，就会引发崩溃，因此我们绝不能调用该回调。\n\n为简化此用例，Lifecycle 类允许其他对象查询当前状态。\n\n    internal class MyLocationListener(\n            private val context: Context,\n            private val lifecycle: Lifecycle,\n            private val callback: (Location) -> Unit\n    ) {private var enabled = false@OnLifecycleEvent(Lifecycle.Event.ON_START)\n        fun start() {\n            if (enabled) {\n                // connect\n            }\n        }fun enable() {\n            enabled = true\n            if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) {\n                // connect if not connected\n            }\n        }@OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n        fun stop() {\n            // disconnect if connected\n        }\n    }\n    \n    class MyLocationListener implements LifecycleObserver {\n        private boolean enabled = false;\n        public MyLocationListener(Context context, Lifecycle lifecycle, Callback callback) {\n           ...\n        }@OnLifecycleEvent(Lifecycle.Event.ON_START)\n        void start() {\n            if (enabled) {\n               // connect\n            }\n        }public void enable() {\n            enabled = true;\n            if (lifecycle.getCurrentState().isAtLeast(STARTED)) {\n                // connect if not connected\n            }\n        }@OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n        void stop() {\n            // disconnect if connected\n        }\n    }\n    \n对于此实现，LocationListener 类可以完全感知生命周期。如果我们需要从另一个 Activity 或 Fragment 使用 LocationListener，只需对其进行初始化。所有设置和拆解操作都由类本身管理。\n\n如果库提供了需要使用 Android 生命周期的类，我们建议您使用生命周期感知型组件。库客户端可以轻松集成这些组件，而无需在客户端进行手动生命周期管理。\n\n实现自定义 LifecycleOwner\nSupport Library 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 LifecycleOwner 接口。\n\n如果您有一个自定义类并希望使其成为 LifecycleOwner，您可以使用 LifecycleRegistry 类，但需要将事件转发到该类，如以下代码示例中所示：\n\n    class MyActivity : Activity(), LifecycleOwner {private lateinit var lifecycleRegistry: LifecycleRegistryoverride fun onCreate(savedInstanceState: Bundle?) {\n            super.onCreate(savedInstanceState)\n            lifecycleRegistry \n\n= LifecycleRegistry(this)\n            lifecycleRegistry.markState(Lifecycle.State.CREATED)\n        }public override fun onStart() {\n            super.onStart()\n            lifecycleRegistry.markState(Lifecycle.State.STARTED)\n        }override fun getLifecycle(): Lifecycle {\n            return lifecycleRegistry\n        }\n    }\n    \n    public class MyActivity extends Activity implements LifecycleOwner {\n        private LifecycleRegistry lifecycleRegistry;@Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            lifecycleRegistry \n\n= new LifecycleRegistry(this);\n            lifecycleRegistry.markState(Lifecycle.State.CREATED);\n        }@Override\n        public void onStart() {\n            super.onStart();\n            lifecycleRegistry.markState(Lifecycle.State.STARTED);\n        }@NonNull\n        @Override\n        public Lifecycle getLifecycle() {\n            return lifecycleRegistry;\n        }\n    }\n    \n生命周期感知型组件的最佳做法\n使界面控制器（Activity 和 Fragment）尽可能保持精简。它们不应试图获取自己的数据，而应使用 ViewModel 执行此操作，并观察 LiveData 对象以将更改体现到视图中。\n设法编写数据驱动型界面，对于此类界面，界面控制器的责任是随着数据更改而更新视图，或者将用户操作通知给 ViewModel。\n将数据逻辑放在 ViewModel 类中。ViewModel 应充当界面控制器与应用其余部分之间的连接器。不过要注意，ViewModel 不负责获取数据（例如，从网络获取）。ViewModel 应调用相应的组件来获取数据，然后将结果提供给界面控制器。\n使用 Data Binding 在视图与界面控制器之间维持干净的接口。这样一来，您可以使视图更具声明性，并尽量减少需要在 Activity 和 Fragment 中编写的更新代码。如果您更愿意使用 Java 编程语言执行此操作，请使用诸如 Butter Knife 之类的库，以避免样板代码并实现更好的抽象化。\n如果界面很复杂，不妨考虑创建 presenter 类来处理界面的修改。这可能是一项艰巨的任务，但这样做可使界面组件更易于测试。\n避免在 ViewModel 中引用 View 或 Activity 上下文。如果 ViewModel 存在的时间比 Activity 更长（在配置更改的情况下），Activity 将泄露并且不会由垃圾回收器妥善处置。\n使用 Kotlin 协程管理长时间运行的任务和其他可以异步运行的操作。\n生命周期感知型组件的用例\n生命周期感知型组件可使您在各种情况下更轻松地管理生命周期。下面列举几个例子：\n\n在粗粒度和细粒度位置更新之间切换。使用生命周期感知型组件可在位置应用可见时启用细粒度位置更新，并在应用位于后台时切换到粗粒度更新。借助生命周期感知型组件 LiveData，应用可以在用户使用位置发生变化时自动更新界面。\n停止和开始视频缓冲。使用生命周期感知型组件可尽快开始视频缓冲，但会推迟播放，直到应用完全启动。此外，应用销毁后，您还可以使用生命周期感知型组件终止缓冲。\n开始和停止网络连接。借助生命周期感知型组件，可在应用位于前台时启用网络数据的实时更新（流式传输），并在应用进入后台时自动暂停。\n暂停和恢复动画可绘制资源。借助生命周期感知型组件，可在应用位于后台时暂停动画可绘制资源，并在应用位于前台后恢复可绘制资源。\n处理 ON_STOP 事件\n如果 Lifecycle 属于 AppCompatActivity 或 Fragment，那么调用 AppCompatActivity 或 Fragment 的 onSaveInstanceState() 时，Lifecycle 的状态会更改为 CREATED 并且会分派 ON_STOP 事件。\n\n通过 onSaveInstanceState() 保存 Fragment 或 AppCompatActivity 的状态后，其界面被视为不可变，直到调用 ON_START。如果在保存状态后尝试修改界面，很可能会导致应用的导航状态不一致，因此应用在保存状态后运行 FragmentTransaction 时，FragmentManager 会抛出异常。如需了解详情，请参阅 commit()。\n\nLiveData 本身可防止出现这种极端情况，方法是在其观察者的关联 Lifecycle 还没有至少处于 STARTED 状态时避免调用其观察者。在后台，它会在决定调用其观察者之前调用 isAtLeast()。\n\n遗憾的是，AppCompatActivity 的 onStop() 方法会在 onSaveInstanceState() 之后调用，这样就会留下一个缺口，即不允许界面状态发生变化，但 Lifecycle 尚未移至 CREATED 状态。\n\n为防止出现这个问题，beta2 及更低版本中的 Lifecycle 类会将状态标记为 CREATED 而不分派事件，这样一来，即使未分派事件（直到系统调用 onStop()），检查当前状态的任何代码也会获得实际值。\n\n遗憾的是，此解决方案有两个主要问题：\n\n在 API 23 及更低级别，Android 系统实际上会保存 Activity 的状态，即使它的一部分被另一个 Activity 覆盖。换句话说，Android 系统会调用 onSaveInstanceState()，但不一定会调用 onStop()。这样可能会产生很长的时间间隔，在此时间间隔内，观察者仍认为生命周期处于活动状态，虽然无法修改其界面状态。\n要向 LiveData 类公开类似行为的任何类都必须实现由 Lifecycle 版本 beta 2 及更低版本提供的解决方案。\n其他资源\n要详细了解如何使用生命周期感知型组件处理生命周期，请参阅下面列出的其他资源：\n\n示例\nAndroid 架构组件基本示例\nSunflower，这是一个演示应用，演示架构组件的最佳做法\nCodelab\nAndroid 生命周期感知型组件\n博客\nAndroid Sunflower 简介"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597243905343},"updatedAt":{"$$date":1597244236715},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yjgwCjJu6lyzbGB3"}
{"name":"ad-","folderId":"gPNVEhZ6m","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597241225995},"updatedAt":{"$$date":1597241225995},"folder":{"id":"gPNVEhZ6m","name":"android","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"zBSTXFEEpiXzrXmX"}
{"name":"py-变量","folderId":"BIksInDe9","content":[{"label":"Fragment 1","language":"python","value":"变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。\n\n变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：\n\na = 1\n变量a是一个整数。\n\nt_007 = 'T007'\n变量t_007是一个字符串。\n\nAnswer = True\n变量Answer是一个布尔值True。\n\n在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：\n\n# -*- coding: utf-8 -*-\na = 123 # a是整数\nprint(a)\na = 'ABC' # a变为字符串\nprint(a)\n\n\n\n\n\n\n\n\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1594973928011},"updatedAt":{"$$date":1594974272529},"folder":{"id":"BIksInDe9","name":"python","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"zHNZcljbPaFidrDm"}
{"name":"andr-权限","folderId":"fdfoMAS2Z","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\ndeveloper.android.google.cn /guide/topics/permissions/overview\n权限概览  |  Android 开发者  |  Android Developers\n8-10 minutes\n权限的作用是保护 Android 用户的隐私。Android 应用必须请求权限才能访问敏感的用户数据（例如联系人和短信）以及某些系统功能（例如相机和互联网）。系统可能会自动授予权限，也可能会提示用户批准请求，具体取决于访问的功能。\n\nAndroid 安全架构的设计主旨是：在默认情况下，任何应用都没有权限执行会对其他应用、操作系统或用户带来不利影响的任何操作。这包括读取或写入用户的私有数据（例如联系人或电子邮件）、读取或写入其他应用的文件、执行网络访问、使设备保持唤醒状态等。\n\n本页概述了 Android 权限的工作原理，包括：如何向用户提供权限、安装时权限请求和运行时权限请求之间的区别、如何强制执行权限，以及权限类型和权限组。如果您只需要关于如何使用应用权限的方法指南，请参阅请求应用权限。\n\n权限审批\n应用必须通过在应用清单中添加 <uses-permission> 标记来公开所需的权限。例如，需要发送短信的应用会在清单中添加以下代码行：\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n          package=\"com.example.snazzyapp\"><uses-permission android:name=\"android.permission.SEND_SMS\"/><application ...>\n        ...\n    </application>\n</manifest>\n如果您的应用在清单中列出普通权限（即不会给用户隐私或设备操作带来太大风险的权限），系统会自动将这些权限授予应用。\n\n如果您的应用在清单中列出危险权限（即可能影响用户隐私或设备正常操作的权限），如上面的 SEND_SMS 权限，必须由用户明确同意授予这些权限。\n\n如需详细了解普通权限和危险权限，请参阅保护级别。\n\n危险权限的请求提示\n仅危险权限需要用户同意。Android 请求用户授予危险权限的方式取决于用户设备上搭载的 Android 版本和应用的目标系统版本。\n\n运行时请求（Android 6.0 及更高版本）\n如果设备搭载的是 Android 6.0（API 级别 23）或更高版本，并且应用的 targetSdkVersion 是 23 或更高版本，用户在安装时不会收到任何应用权限的通知。您的应用必须在运行时请求用户授予危险权限。当应用请求权限时，用户会看到一个系统对话框（如图 1 左图所示），告知用户应用正在尝试访问的权限组。该对话框包括拒绝和允许按钮。\n\n如果用户拒绝权限请求，当应用下次请求该权限时，该对话框将包含一个复选框，选中它即表示用户不想再收到权限提示（请参阅图 1 右图）。\n\n\n\n图 1. 初始权限对话框（左）和包含关闭进一步请求的选项的二次权限请求（右）\n\n如果用户选中不再询问复选框并点按拒绝，当您以后尝试请求相同权限时，系统不会再提示用户。\n\n即使用户授予应用所请求的权限，您也不能指望始终拥有该权限。用户也可以选择在系统设置中逐一启用和停用权限。您应始终在运行时检查并请求权限，以防发生运行时错误 (SecurityException)。\n\n如需详细了解如何处理运行时权限请求，请参阅请求应用权限。\n\n安装时请求（Android 5.1.1 及更低版本）\n如果设备搭载的是 Android 5.1.1（API 级别 22）或更低版本，或者应用在任何版本的 Android 上运行时其 targetSdkVersion 是 22 或更低版本，系统将在安装时自动请求用户向应用授予所有危险权限（请参见图 2）。\n\n\n\n图 2. 安装时权限对话框\n\n如果用户点击接受，系统将授予应用请求的所有权限。如果用户拒绝权限请求，系统将取消安装应用。\n\n如果应用更新包括额外权限需求，系统会在更新应用之前提示用户接受这些新权限。\n\n有关请求权限的建议用户体验模式概览，请参阅应用权限最佳做法。\n\n如需了解如何检查并向用户请求权限，请参阅请求应用权限。\n\n访问敏感用户信息的请求提示\n有些应用依赖于访问与通话记录和短信有关的敏感用户信息。如果您想请求特定于通话记录和短信的权限，并将应用发布到 Play 商店，您必须在请求这些运行时权限之前，提示用户将应用设置为核心系统功能的默认处理程序。\n\n如需详细了解默认处理程序，包括有关如何向用户显示默认处理程序提示的指南，请参阅有关仅在默认处理程序中使用的权限的指南。\n\n可选硬件功能的权限\n访问某些硬件功能（如蓝牙或相机）需要应用权限。但是，实际上并非所有 Android 设备都具备这些硬件功能。因此，如果您的应用请求 CAMERA 权限，请务必还要在清单中添加 <uses-feature> 标记，用于声明是否确实需要此功能。例如：\n\n<uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n如果您对该功能声明 android:required=\"false\"，那么 Google Play 就会允许将您的应用安装在没有该功能的设备上。然后，您必须在运行时通过调用 PackageManager.hasSystemFeature() 检查当前设备是否具备该功能，并在没有该功能的情况下将其妥善停用。\n\n如果您未提供 <uses-feature> 标记，那么当 Google Play 发现您的应用请求相应权限时，就会假定您的应用需要此功能。因此，它会从没有该功能的设备中过滤掉您的应用，就像您在 <uses-feature> 标记中声明了 android:required=\"true\" 一样。\n\n如需了解详情，请参阅 Google Play 和根据功能进行过滤\n\n权限强制执行\n权限不仅仅用于请求系统功能。应用提供的服务可强制执行自定义权限以限制谁能使用它们。如需详细了解如何声明自定义权限，请参阅定义自定义应用权限。\n\nActivity 权限强制执行\n使用 android:permission 属性应用于清单中 <activity> 标记的权限可限制谁能启动该 Activity。系统会在 Context.startActivity() 和 Activity.startActivityForResult() 期间检查权限。如果调用方没有所需的权限，则调用会抛出 SecurityException。\n\n服务权限强制执行\n使用 android:permission 属性应用于清单中 <service> 标记的权限可限制谁能启动或绑定到关联的 Service。系统会在 Context.startService()、Context.stopService() 和 Context.bindService() 期间检查权限。如果调用方没有所需的权限，则调用会抛出 SecurityException。\n\n广播权限强制执行\n使用 android:permission 属性应用于 <receiver> 标记的权限可限制谁能向关联的 BroadcastReceiver 发送广播。系统会在 Context.sendBroadcast() 返回后检查权限，因为系统会尝试将提交的广播传递到指定的接收器。因此，权限失效不会导致向调用方抛回异常；只是不会传递该 Intent。\n\n同样，可以向 Context.registerReceiver() 提供权限，用于控制谁能向以编程方式注册的接收器发送广播。另一方面，可以在调用 Context.sendBroadcast() 时提供权限来限制允许哪些广播接收器接收广播。\n\n请注意，接收器和广播者可能都需要权限。发生这种情况时，两项权限检查都必须通过后方可将 intent 传递到关联的目标。如需了解详情，请参阅通过权限限制广播。\n\n内容提供程序权限强制执行\n使用 android:permission 属性应用于 <provider> 标记的权限可限制谁能访问 ContentProvider 中的数据。（内容提供程序有重要的附加安全工具可供其使用，称为 URI 权限，将在后面介绍。）与其他组件不同，您可以设置两个单独的权限属性：android:readPermission 限制谁可以读取提供程序，android:writePermission 限制谁可以写入提供程序。请注意，如果提供程序有读取和写入权限保护，仅拥有写入权限并不表示您可以读取提供程序。\n\n第一次检索提供程序时将会检查权限（如果没有任何权限，将会抛出 SecurityException），对提供程序执行操作时也会检查权限。使用 ContentResolver.query() 需要拥有读取权限；使用 ContentResolver.insert()、ContentResolver.update()、ContentResolver.delete() 需要写入权限。在所有这些情况下，没有所需的权限将导致调用抛出 SecurityException。\n\nURI 权限\n内容提供程序仅仅使用到目前为止介绍的标准权限系统往往是不够的。内容提供程序可能需要通过读取和写入权限保护自己，而其直接客户端也需要将特定 URI 传给其他应用以便于它们运行。\n\n电子邮件应用中的附件就是一个典型的示例。对电子邮件的访问应通过权限加以保护，因为这是敏感的用户数据。但是，如果将图像附件的 URI 提供给图像查看器，该图像查看器就不再有打开附件的权限，因为它没有理由拥有访问所有电子邮件的权限。\n\n此问题的解决方法是采用按 URI 的权限机制：在启动 Activity 或返回结果给 Activity 时，调用方可以设置 Intent.FLAG_GRANT_READ_URI_PERMISSION 和/或 Intent.FLAG_GRANT_WRITE_URI_PERMISSION。这将向接收 Activity 授予访问 intent 中特定数据 URI 的权限，而不管它是否具有任何权限可访问 intent 对应的内容提供程序中的数据。\n\n此机制支持常见的能力式模型，其中用户互动（如打开附件、从列表中选择联系人等）推动临时授予细化的权限。这是一项关键功能，可将应用所需的权限缩小至只与其行为直接相关的权限。\n\n如需构建最安全的实现，使其他应用对其在您的应用中的操作负责，您应该以这种方式使用细化的权限，并使用 android:grantUriPermissions 属性或 <grant-uri-permissions> 标记声明您的应用对它的支持。\n\n如需了解详情，请参阅 Context.grantUriPermission()、Context.revokeUriPermission() 和 Context.checkUriPermission() 方法。\n\n其他权限强制执行\n您可对任何服务调用强制执行任意细化的权限。这可通过 Context.checkCallingPermission() 方法完成。使用所需的权限字符串调用，它将返回一个整数，表示是否已向当前的调用进程授予权限。请注意，仅在执行从另一个进程传入的调用（通常是通过从服务发布的 IDL 接口或者指定给另一进程的某种其他方式完成）时才可使用此方法。\n\n检查权限还有许多其他有用的方法。如果您有另一个进程的进程 ID (PID)，您可以使用 Context.checkPermission() 方法检查针对该 PID 的权限。如果您有另一个应用的软件包名称，您可以使用 PackageManager.checkPermission() 方法了解是否已为该软件包授予特定权限。\n\n自动权限调整\n随着时间的推移，平台中可能会加入新的限制，以致您的应用为了使用特定 API，必须请求之前不需要的权限。因为现有应用假设可随意获取这些 API 的访问权限，所以 Android 可能会将新的权限请求应用到应用清单，以免在新平台版本上中断应用（从而将应用包括在“祖父豁免原则”中以获取权限）。Android 将根据为 targetSdkVersion 属性提供的值决定应用是否需要权限。如果该值低于在其中添加权限的版本，Android 就会添加该权限。\n\n例如，READ_EXTERNAL_STORAGE 权限从 API 级别 19 开始强制执行，用于限制对共享存储空间的访问。如果您的 targetSdkVersion 为 18 或更低版本，系统就会向更高版本的 Android 中运行的应用添加此权限。\n\n警告：如果某权限自动添加到应用，即使您的应用可能实际并不需要这些附加权限，Google Play 上的应用详情也会列出它们。为避免这种情况并移除您不需要的默认权限，请始终将 targetSdkVersion 尽可能更新至最高版本。您可在 Build.VERSION_CODES 文档中查看各版本添加的权限。\n\n保护级别\n权限分为几个保护级别。保护级别影响着是否需要运行时权限请求。\n\n有三种保护级别会影响第三方应用：普通、签名和危险权限。如需查看特定权限所拥有的保护级别，请访问权限 API 参考页面。\n\n普通权限\n普通权限涵盖以下情况：应用需要访问其沙盒外部的数据或资源，但对用户隐私或其他应用的操作带来的风险很小。例如，设置时区的权限就是普通权限。\n\n如果应用在清单中声明需要普通权限，系统会在安装时自动向应用授予该权限。系统不会提示用户授予普通权限，用户也无法撤消这些权限。\n\n签名权限\n系统在安装时授予这些应用权限，但仅会在尝试使用某权限的应用签名证书为定义该权限的同一证书时才会授予。\n\n危险权限\n危险权限涵盖以下情况：应用需要的数据或资源涉及用户隐私信息，或者可能对用户存储的数据或其他应用的操作产生影响。例如，能够读取用户的联系人属于危险权限。如果应用声明其需要危险权限，必须由用户向应用明确授予该权限。在用户批准该权限之前，应用无法提供依赖于该权限的功能。\n\n为了使用危险权限，应用必须在运行时提示用户授予权限。如需详细了解如何提示用户，请参阅危险权限的请求提示。\n\n特殊权限\n有几项权限的行为与普通权限及危险权限都不同。SYSTEM_ALERT_WINDOW 和 WRITE_SETTINGS 特别敏感，因此大多数应用不应该使用它们。如果应用需要其中一种权限，必须在清单中声明该权限，并发送请求用户授权的 intent。系统将向用户显示详细管理屏幕，以响应该 intent。\n\n如需详细了解如何请求这些权限，请参阅 SYSTEM_ALERT_WINDOW 和 WRITE_SETTINGS 参考条目。\n\n如需了解 Android 系统提供的所有权限，请参阅 Manifest.permission。\n\n权限组\n权限根据设备的功能或特性分为多个组。在这一体系中，权限请求在组级别进行处理，一个权限组对应于应用清单中的多个权限声明。例如，短信组同时包括 READ_SMS 和 RECEIVE_SMS 声明。通过这种方式对权限分组，用户就能做出更有意义和明智的选择，而不会对复杂和技术性权限请求感到无所适从。\n\n\n\n所有危险的 Android 权限都属于权限组。任何权限都可以属于某个权限组，不管保护级别如何。但是，权限组仅当权限危险时才影响用户体验。\n\n如果设备搭载的是 Android 6.0（API 级别 23），并且应用的 targetSdkVersion 是 23 或更高版本，系统会在应用请求危险权限时发生以下行为：\n\n如果应用当前在权限组中没有任何权限，系统会向用户显示权限请求对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只会说明应用需要访问设备的联系人。如果用户批准，系统只会向应用授予其请求的权限。\n如果应用已在相同权限组中被授予另一危险权限，系统将立即授予该权限，不会与用户进行任何互动。例如，如果某应用之前已请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限，不向用户显示权限对话框。\n注意：将来版本的 Android SDK 可能可以将特定权限从一个组移到另一个组。因此，不要根据这些权限组的结构设置应用的逻辑。\n\n例如，自 Android 8.1（API 级别 27）起，READ_CONTACTS 位于与 WRITE_CONTACTS 相同的权限组中。如果您的应用请求 READ_CONTACTS 权限，然后请求 WRITE_CONTACTS 权限，不要假定系统可以自动授予 WRITE_CONTACTS 权限。\n\n如果设备搭载的是 Android 5.1（API 级别 22）或更低版本，或者应用的 targetSdkVersion 是 22 或更低版本，系统会在安装时要求用户授予权限。再次强调，系统只会向用户告知应用需要的权限组，而不告知具体权限。例如，当应用请求 READ_CONTACTS 时，安装对话框会列出“联系人”组。当用户接受后，系统仅向应用授予 READ_CONTACTS 权限。\n\n注意：您的应用仍需要明确请求其需要的每项权限，即使用户已授予同一组中的其他权限。此外，权限分组在将来的 Android 版本中可能会发生变化。代码的逻辑不应依赖于同一组中的一组特定权限。\n\n查看应用的权限\n您可以使用“设置”应用和 shell 命令 adb shell pm list permissions 查看系统中当前定义的所有权限。如需使用“设置”应用，请依次转至设置 > 应用。选择一个应用并向下滚动查看该应用使用的权限。对于开发者，adb '-s' 选项以类似于用户所见内容的形式显示权限：\n\n$ adb shell pm list permissions -s\nAll Permissions:\n\nNetwork communication: view Wi-Fi state, create Bluetooth connections, full\ninternet access, view network state\n\nYour location: access extra location provider commands, fine (GPS) location,\nmock location sources for testing, coarse (network-based) location\n\nServices that cost you money: send SMS messages, directly call phone numbers\n\n...\n在模拟器中或测试设备上安装应用时，您也可以使用 adb -g 选项自动授予所有权限：\n\n$ adb shell install -g MyApp.apk\n其他资源\n请求应用权限：有关请求应用权限的方法指南。\n隐含功能要求的权限：介绍请求某些权限如何隐式将您的应用限制于包含相应硬件或软件功能的设备。\n<uses-permission>：声明应用所需权限的清单标记的 API 参考文档。\n设备兼容性：介绍 Android 如何在不同类型的设备上工作，以及如何针对各种设备优化您的应用，或如何限制您的应用在不同设备上的可用性。\nAndroid 安全性概览：详细介绍 Android 平台的安全模型。\n“妈妈，我可以吗？”请求权限：2015 年 Android 开发者峰会上的这个视频介绍了请求权限的最佳做法。\nAndroid M 权限：2015 年 Google I/O 大会上的这个视频说明了 Android 6.0 中对权限模型进行的更改。"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1597242655321},"updatedAt":{"$$date":1597243183631},"folder":{"id":"fdfoMAS2Z","name":"androidV2","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ziPrZqte7Kqasfcw"}
{"name":"kotlin-取单个元素 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382132706},"updatedAt":{"$$date":1597384371204},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"M2GufjtgNH0MywFo"}
{"name":"kotlin-取单个元素 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-elements.html\n取单个元素 - Kotlin 语言中文站\n12-15 minutes\n改进翻译\nKotlin 集合提供了一套从集合中检索单个元素的函数。 此页面描述的函数适用于 list 和 set。\n\n正如 list 的定义所言，list 是有序集合。 因此，list 中的每个元素都有其位置可供你引用。 除了此页面上描述的函数外，list 还提供了更广泛的一套方法去按索引检索和搜索元素。 有关更多详细信息，请参见 List 相关操作。\n\n反过来，从定义来看，set 并不是有序集合。 但是，Kotlin 中的 Set 按某些顺序存储元素。 这些可以是插入顺序（在 LinkedHashSet 中）、自然排序顺序（在 SortedSet 中）或者其他顺序。 一组元素的顺序也可以是未知的。 在这种情况下，元素仍会以某种顺序排序，因此，依赖元素位置的函数仍会返回其结果。 但是，除非调用者知道所使用的 Set 的具体实现，否则这些结果对于调用者是不可预测的。\n\n为了检索特定位置的元素，有一个函数 elementAt()。 用一个整数作为参数来调用它，你会得到给定位置的集合元素。 第一个元素的位置是 0，最后一个元素的位置是 (size - 1)。\n\nelementAt() 对于不提供索引访问或非静态已知提供索引访问的集合很有用。 在使用 List 的情况下，使用索引访问操作符 （get() 或 []）更为习惯。\n\nfun main() {\n//sampleStart\n    val numbers = linkedSetOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    println(numbers.elementAt(3))    \n\n    val numbersSortedSet = sortedSetOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbersSortedSet.elementAt(0)) // 元素以升序存储\n//sampleEnd\n}\n还有一些有用的别名来检索集合的第一个和最后一个元素：first() 和 last()。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    println(numbers.first())    \n    println(numbers.last())    \n//sampleEnd\n}\n为了避免在检索位置不存在的元素时出现异常，请使用 elementAt() 的安全变体：\n\n当指定位置超出集合范围时，elementAtOrNull() 返回 null。\nelementAtOrElse() 还接受一个 lambda 表达式，该表达式能将一个 Int 参数映射为一个集合元素类型的实例。 当使用一个越界位置来调用时，elementAtOrElse() 返回对给定值调用该 lambda 表达式的结果。\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    println(numbers.elementAtOrNull(5))\n    println(numbers.elementAtOrElse(5) { index -> \"The value for index $index is undefined\"})\n//sampleEnd\n}\n函数 first() 和 last() 还可以让你在集合中搜索与给定谓词匹配的元素。 当你使用测试集合元素的谓词调用 first() 时，你会得到对其调用谓词产生 true 的第一个元素。 反过来，带有一个谓词的 last() 返回与其匹配的最后一个元素。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.first { it.length > 3 })\n    println(numbers.last { it.startsWith(\"f\") })\n//sampleEnd\n}\n如果没有元素与谓词匹配，两个函数都会抛异常。 为了避免它们，请改用 firstOrNull() 和 lastOrNull()：如果找不到匹配的元素，它们将返回 null。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.firstOrNull { it.length > 6 })\n//sampleEnd\n}\n或者，如果别名更适合你的情况，那么可以使用别名：\n\n使用 find() 代替 firstOrNull()\n使用 findLast() 代替 lastOrNull()\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3, 4)\n    println(numbers.find { it % 2 == 0 })\n    println(numbers.findLast { it % 2 == 0 })\n//sampleEnd\n}\n如果需要检索集合的一个随机元素，那么请调用 random() 函数。 你可以不带参数或者使用一个 Random 对象作为随机源来调用它。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3, 4)\n    println(numbers.random())\n//sampleEnd\n}\n如需检查集合中某个元素的存在，可以使用 contains() 函数。 如果存在一个集合元素等于（equals()）函数参数，那么它返回 true。 你可以使用 in 关键字以操作符的形式调用 contains()。\n\n如需一次检查多个实例的存在，可以使用这些实例的集合作为参数调用 containsAll()。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.contains(\"four\"))\n    println(\"zero\" in numbers)\n    \n    println(numbers.containsAll(listOf(\"four\", \"two\")))\n    println(numbers.containsAll(listOf(\"one\", \"zero\")))\n//sampleEnd\n}\n此外，你可以通过调用 isEmpty() 和 isNotEmpty() 来检查集合中是否包含任何元素。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\n    println(numbers.isEmpty())\n    println(numbers.isNotEmpty())\n    \n    val empty = emptyList<String>()\n    println(empty.isEmpty())\n    println(empty.isNotEmpty())\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382132706},"updatedAt":{"$$date":1597384375652},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"M2GufjtgNH0MywFo"}
{"name":"kotlin-排序 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382133880},"updatedAt":{"$$date":1597384382011},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uVUfBjuYBql1DWTa"}
{"name":"kotlin-排序 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-ordering.html\n排序 - Kotlin 语言中文站\n14-18 minutes\n改进翻译\n元素的顺序是某些集合类型的一个重要方面。 例如，如果拥有相同元素的两个列表的元素顺序不同，那么这两个列表也不相等。\n\n在 Kotlin 中，可以通过多种方式定义对象的顺序。\n\n首先，有 自然 顺序。它是为 Comparable 接口的继承者定义的。 当没有指定其他顺序时，使用自然顺序为它们排序。\n\n大多数内置类型是可比较的：\n\n数值类型使用传统的数值顺序：1 大于 0； -3.4f 大于 -5f，以此类推。\nChar 和 String 使用字典顺序： b 大于 a； world 大于 hello。\n如需为用户定义的类型定义一个自然顺序，可以让这个类型继承 Comparable。 这需要实现 compareTo() 函数。 compareTo() 必须将另一个具有相同类型的对象作为参数并返回一个整数值来显示哪个对象更大：\n\n正值表明接收者对象更大。\n负值表明它小于参数。\n0 说明对象相等。\n下面是一个类，可用于排序由主版本号和次版本号两部分组成的版本。\n\nclass Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version): Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        } else if (this.minor != other.minor) {\n            return this.minor - other.minor\n        } else return 0\n    }\n}\n\nfun main() {    \n    println(Version(1, 2) > Version(1, 3))\n    println(Version(2, 0) > Version(1, 5))\n}\n自定义 顺序让你可以按自己喜欢的方式对任何类型的实例进行排序。 特别是，你可以为不可比较类型定义顺序，或者为可比较类型定义非自然顺序。 如需为类型定义自定义顺序，可以为其创建一个 Comparator。 Comparator 包含 compare() 函数：它接受一个类的两个实例并返回它们之间比较的整数结果。 如上所述，对结果的解释与 compareTo() 的结果相同。\n\nfun main() {\n//sampleStart\n    val lengthComparator = Comparator { str1: String, str2: String -> str1.length - str2.length }\n    println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(lengthComparator))\n//sampleEnd\n}\n\n有了 lengthComparator，你可以按照字符串的长度而不是默认的字典顺序来排列字符串。\n\n定义一个 Comparator 的一种比较简短的方式是标准库中的 compareBy() 函数。 compareBy() 接受一个 lambda 表达式，该表达式从一个实例产生一个 Comparable 值，并将自定义顺序定义为生成值的自然顺序。 使用 compareBy()，上面示例中的长度比较器如下所示：\n\nfun main() {\n//sampleStart    \nprintln(listOf(\"aaa\", \"bb\", \"c\").sortedWith(compareBy { it.length }))\n//sampleEnd\n}\n\nKotlin 集合包提供了用于按照自然顺序、自定义顺序甚至随机顺序对集合排序的函数。 在此页面上，我们将介绍适用于只读集合的排序函数。 这些函数将它们的结果作为一个新集合返回，集合里包含了按照请求顺序排序的来自原始集合的元素。 如果想学习就地对可变集合排序的函数，请参见 List 相关操作。\n\n基本的函数 sorted() 和 sortedDescending() 返回集合的元素，这些元素按照其自然顺序升序和降序排序。 这些函数适用于 Comparable 元素的集合。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    println(\"Sorted ascending: ${numbers.sorted()}\")\n    println(\"Sorted descending: ${numbers.sortedDescending()}\")\n//sampleEnd\n}\n\n为了按照自定义顺序排序或者对不可比较对象排序，可以使用函数 sortedBy() 和 sortedByDescending()。 它们接受一个将集合元素映射为 Comparable 值的选择器函数，并以该值的自然顺序对集合排序。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n\n    val sortedNumbers = numbers.sortedBy { it.length }\n    println(\"Sorted by length ascending: $sortedNumbers\")\n    val sortedByLast = numbers.sortedByDescending { it.last() }\n    println(\"Sorted by the last letter descending: $sortedByLast\")\n//sampleEnd\n}\n\n如需为集合排序定义自定义顺序，可以提供自己的 Comparator。 为此，调用传入 Comparator 的 sortedWith() 函数。 使用此函数，按照字符串长度排序如下所示：\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(\"Sorted by length ascending: ${numbers.sortedWith(compareBy { it.length })}\")\n//sampleEnd\n}\n\n你可以使用 reversed() 函数以相反的顺序检索集合。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    println(numbers.reversed())\n//sampleEnd\n}\n\nreversed() 返回带有元素副本的新集合。 因此，如果你之后改变了原始集合，这并不会影响先前获得的 reversed() 的结果。\n\n另一个反向函数——asReversed()——返回相同集合实例的一个反向视图，因此，如果原始列表不会发生变化，那么它会比 reversed() 更轻量，更合适。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n//sampleEnd\n}\n\n如果原始列表是可变的，那么其所有更改都会反映在其反向视图中，反之亦然。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    val reversedNumbers = numbers.asReversed()\n    println(reversedNumbers)\n    numbers.add(\"five\")\n    println(reversedNumbers)\n//sampleEnd\n}\n\n但是，如果列表的可变性未知或者源根本不是一个列表，那么 reversed() 更合适，因为其结果是一个未来不会更改的副本。\n\n最后，shuffled() 函数返回一个包含了以随机顺序排序的集合元素的新的 List。 你可以不带参数或者使用 Random 对象来调用它。\n\nfun main() {\n//sampleStart\n     val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n     println(numbers.shuffled())\n//sampleEnd\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382133880},"updatedAt":{"$$date":1597384948720},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uVUfBjuYBql1DWTa"}
{"name":"kotlin-聚合操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382134949},"updatedAt":{"$$date":1597384951414},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"k66dLwS1vBH30YL1"}
{"name":"kotlin-聚合操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-aggregate.html\n聚合操作 - Kotlin 语言中文站\n10-13 minutes\n改进翻译\nKotlin 集合包含用于常用的 聚合操作 （基于集合内容返回单个值的操作）的函数 。 其中大多数是众所周知的，并且其工作方式与在其他语言中相同。\n\nmin() 与 max() 分别返回最小和最大的元素；\naverage() 返回数字集合中元素的平均值；\nsum() 返回数字集合中元素的总和；\ncount() 返回集合中元素的数量；\nfun main() {\n//sampleStart\n    val numbers = listOf(6, 42, 10, 4)\n\n    println(\"Count: ${numbers.count()}\")\n    println(\"Max: ${numbers.max()}\")\n    println(\"Min: ${numbers.min()}\")\n    println(\"Average: ${numbers.average()}\")\n    println(\"Sum: ${numbers.sum()}\")\n//sampleEnd\n}\n还有一些通过某些选择器函数或自定义 Comparator 来检索最小和最大元素的函数。\n\nmaxBy()/minBy() 接受一个选择器函数并返回使选择器返回最大或最小值的元素。\nmaxWith()/minWith() 接受一个 Comparator 对象并且根据此 Comparator 对象返回最大或最小元素。\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 42, 10, 4)\n    val min3Remainder = numbers.minBy { it % 3 }\n    println(min3Remainder)\n\n    val strings = listOf(\"one\", \"two\", \"three\", \"four\")\n    val longestString = strings.maxWith(compareBy { it.length })\n    println(longestString)\n//sampleEnd\n}\n此外，有一些高级的求和函数，它们接受一个函数并返回对所有元素调用此函数的返回值的总和：\n\nsumBy() 使用对集合元素调用返回 Int 值的函数。\nsumByDouble() 与返回 Double 的函数一起使用。\nfun main() {\n//sampleStart    \n    val numbers = listOf(5, 42, 10, 4)\n    println(numbers.sumBy { it * 2 })\n    println(numbers.sumByDouble { it.toDouble() / 2 })\n//sampleEnd\n}\n对于更特定的情况，有函数 reduce() 和 fold()，它们依次将所提供的操作应用于集合元素并返回累积的结果。 操作有两个参数：先前的累积值和集合元素。\n\n这两个函数的区别在于：fold() 接受一个初始值并将其用作第一步的累积值，而 reduce() 的第一步则将第一个和第二个元素作为第一步的操作参数。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n\n    val sum = numbers.reduce { sum, element -> sum + element }\n    println(sum)\n    val sumDoubled = numbers.fold(0) { sum, element -> sum + element * 2 }\n    println(sumDoubled)\n\n    //val sumDoubledReduce = numbers.reduce { sum, element -> sum + element * 2 } //错误：第一个元素在结果中没有加倍\n    //println(sumDoubledReduce)\n//sampleEnd\n}\n上面的实例展示了区别：fold() 用于计算加倍的元素之和。 如果将相同的函数传给 reduce()，那么它会返回另一个结果，因为在第一步中它将列表的第一个和第二个元素作为参数，所以第一个元素不会被加倍。\n\n如需将函数以相反的顺序应用于元素，可以使用函数 reduceRight() 和 foldRight() 它们的工作方式类似于 fold() 和 reduce()，但从最后一个元素开始，然后再继续到前一个元素。 记住，在使用 foldRight 或 reduceRight 时，操作参数会更改其顺序：第一个参数变为元素，然后第二个参数变为累积值。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumDoubledRight = numbers.foldRight(0) { element, sum -> sum + element * 2 }\n    println(sumDoubledRight)\n//sampleEnd\n}\n你还可以使用将元素索引作为参数的操作。 为此，使用函数 reduceIndexed() 和 foldIndexed() 传递元素索引作为操作的第一个参数。\n\n最后，还有将这些操作从右到左应用于集合元素的函数——reduceRightIndexed() 与 foldRightIndexed()。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(5, 2, 10, 4)\n    val sumEven = numbers.foldIndexed(0) { idx, sum, element -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEven)\n\n    val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -> if (idx % 2 == 0) sum + element else sum }\n    println(sumEvenRight)\n//sampleEnd\n}"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382134949},"updatedAt":{"$$date":1597385236648},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"k66dLwS1vBH30YL1"}
{"name":"kotlin-集合写操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382136115},"updatedAt":{"$$date":1597385446930},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cnO122tqe2FtXBH7"}
{"name":"kotlin-集合写操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n集合写操作 - Kotlin 语言中文站\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382136115},"updatedAt":{"$$date":1597385751845},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cnO122tqe2FtXBH7"}
{"name":"kotlin-集合写操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382136115},"updatedAt":{"$$date":1597385754001},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cnO122tqe2FtXBH7"}
{"name":"kotlin-集合写操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/collection-write.html\n集合写操作 - Kotlin 语言中文站\n9-11 minutes\n改进翻译\n可变集合支持更改集合内容的操作，例如添加或删除元素。 在此页面上，我们将描述实现 MutableCollection 的所有写操作。 有关 List 与 Map 可用的更多特定操作，请分别参见 List 相关操作与 Map 相关操作。\n\n要将单个元素添加到列表或集合，请使用 add() 函数。指定的对象将添加到集合的末尾。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.add(5)\n    println(numbers)\n//sampleEnd\n}\naddAll() 将参数对象的每个元素添加到列表或集合中。参数可以是 Iterable、Sequence 或 Array。 接收者的类型和参数可能不同，例如，你可以将所有内容从 Set 添加到 List。\n\n当在列表上调用时，addAll() 会按照在参数中出现的顺序添加各个新元素。 你也可以调用 addAll() 时指定一个元素位置作为第一参数。 参数集合的第一个元素会被插入到这个位置。 其他元素将跟随在它后面，将接收者元素移到末尾。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 5, 6)\n    numbers.addAll(arrayOf(7, 8))\n    println(numbers)\n    numbers.addAll(2, setOf(3, 4))\n    println(numbers)\n//sampleEnd\n}\n你还可以使用 plus 运算符 - plusAssign (+=) 添加元素。 当应用于可变集合时，+= 将第二个操作数(一个元素或另一个集合)追加到集合的末尾。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\")\n    numbers += \"three\"\n    println(numbers)\n    numbers += listOf(\"four\", \"five\")    \n    println(numbers)\n//sampleEnd\n}\n若要从可变集合中移除元素，请使用 remove() 函数。 remove() 接受元素值，并删除该值的一个匹配项。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4, 3)\n    numbers.remove(3)                    // 删除了第一个 `3`\n    println(numbers)\n    numbers.remove(5)                    // 什么都没删除\n    println(numbers)\n//sampleEnd\n}\n要一次删除多个元素，有以下函数：\n\nremoveAll() 移除参数集合中存在的所有元素。 或者，你可以用谓词作为参数来调用它；在这种情况下，函数移除谓词产生 true 的所有元素。\nretainAll() 与 removeAll() 相反：它移除除参数集合中的元素之外的所有元素。 当与谓词一起使用时，它只留下与之匹配的元素。\nclear() 从列表中移除所有元素并将其置空。\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    println(numbers)\n    numbers.retainAll { it >= 3 }\n    println(numbers)\n    numbers.clear()\n    println(numbers)\n\n    val numbersSet = mutableSetOf(\"one\", \"two\", \"three\", \"four\")\n    numbersSet.removeAll(setOf(\"one\", \"two\"))\n    println(numbersSet)\n//sampleEnd\n}\n从集合中移除元素的另一种方法是使用 minusAssign (-=) ——原地修改版的 minus 操作符。 minus 操作符。 第二个参数可以是元素类型的单个实例或另一个集合。 右边是单个元素时，-= 会移除它的第一个匹配项。 反过来，如果它是一个集合，那么它的所有元素的每次出现都会删除。 例如，如果列表包含重复的元素，它们将被同时删除。 第二个操作数可以包含集合中不存在的元素。这些元素不会影响操作的执行。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"three\", \"four\")\n    numbers -= \"three\"\n    println(numbers)\n    numbers -= listOf(\"four\", \"five\")    \n    //numbers -= listOf(\"four\")    // 与上述相同\n    println(numbers)    \n//sampleEnd\n}\nlist 和 map 还提供更新元素的操作。 它们在 List 相关操作与 Map 相关操作中有所描述。 对于 set 来说，更新没有意义，因为它实际上是移除一个元素并添加另一个元素。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382136115},"updatedAt":{"$$date":1597385754756},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"cnO122tqe2FtXBH7"}
{"name":"kotlin-List 相关操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382137280},"updatedAt":{"$$date":1597385760863},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"igIKQKqIyydPXSfk"}
{"name":"kotlin-List 相关操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/list-operations.html\nList 相关操作 - Kotlin 语言中文站\n19-23 minutes\n改进翻译\nList 是 Kotlin 标准库中最受欢迎的集合类型。对列表元素的索引访问为 List 提供了一组强大的操作。\n\nList 支持按索引取元素的所有常用操作： elementAt() 、 first() 、 last() 与取单个元素中列出的其他操作。 List 的特点是能通过索引访问特定元素，因此读取元素的最简单方法是按索引检索它。 这是通过 get() 函数或简写语法 [index] 来传递索引参数完成的。\n\n如果 List 长度小于指定的索引，则抛出异常。 另外，还有两个函数能避免此类异常：\n\ngetOrElse() 提供用于计算默认值的函数，如果集合中不存在索引，则返回默认值。\ngetOrNull() 返回 null 作为默认值。\nTarget platform: JVMRunning on kotlin v. 1.3.72\n\n除了取集合的一部分中常用的操作， List 还提供 subList() 该函数将指定元素范围的视图作为列表返回。 因此，如果原始集合的元素发生变化，则它在先前创建的子列表中也会发生变化，反之亦然。\n\nfun main() {\n//sampleStart\n    val numbers = (0..13).toList()\n    println(numbers.subList(3, 6))\n//sampleEnd\n}\n\n在任何列表中，都可以使用 indexOf() 或 lastIndexOf() 函数找到元素的位置。 它们返回与列表中给定参数相等的元素的第一个或最后一个位置。 如果没有这样的元素，则两个函数均返回 -1。\n\nfun main() {\n//sampleStart\n    val numbers = listOf(1, 2, 3, 4, 2, 5)\n    println(numbers.indexOf(2))\n    println(numbers.lastIndexOf(2))\n//sampleEnd\n}\n\n还有一对函数接受谓词并搜索与之匹配的元素：\n\nindexOfFirst() 返回与谓词匹配的第一个元素的索引，如果没有此类元素，则返回 -1。\nindexOfLast() 返回与谓词匹配的最后一个元素的索引，如果没有此类元素，则返回 -1。\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    println(numbers.indexOfFirst { it > 2})\n    println(numbers.indexOfLast { it % 2 == 1})\n//sampleEnd\n}\n\n还有另一种搜索列表中元素的方法——二分查找算法。 它的工作速度明显快于其他内置搜索功能，但要求该列表按照一定的顺序（自然排序或函数参数中提供的另一种排序）按升序排序过。 否则，结果是不确定的。\n\n要搜索已排序列表中的元素，请调用 binarySearch() 函数，并将该值作为参数传递。 如果存在这样的元素，则函数返回其索引；否则，将返回 (-insertionPoint - 1)，其中 insertionPoint 为应插入此元素的索引，以便列表保持排序。 如果有多个具有给定值的元素，搜索则可以返回其任何索引。\n\n还可以指定要搜索的索引区间：在这种情况下，该函数仅在两个提供的索引之间搜索。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n    numbers.sort()\n    println(numbers)\n    println(numbers.binarySearch(\"two\"))  // 3\n    println(numbers.binarySearch(\"z\")) // -5\n    println(numbers.binarySearch(\"two\", 0, 2))  // -3\n//sampleEnd\n}\n\n如果列表元素不是 Comparable，则应提供一个用于二分搜索的 Comparator。 该列表必须根据此 Comparator 以升序排序。来看一个例子：\n\ndata class Product(val name: String, val price: Double)\n\nfun main() {\n//sampleStart\n    val productList = listOf(\n        Product(\"WebStorm\", 49.0),\n        Product(\"AppCode\", 99.0),\n        Product(\"DotTrace\", 129.0),\n        Product(\"ReSharper\", 149.0))\n\n    println(productList.binarySearch(Product(\"AppCode\", 99.0), compareBy<Product> { it.price }.thenBy { it.name }))\n//sampleEnd\n}\n\n这是一个不可排序的 Product 实例列表，以及一个定义排序的 Comparator：如果 p1 的价格小于 p2 的价格，则产品 p1 在产品 p2 之前。 因此，按照此顺序对列表进行升序排序后，使用 binarySearch() 查找指定的 Product的索引。\n\n当列表使用与自然排序不同的顺序时（例如，对 String 元素不区分大小写的顺序），自定义 Comparator 也很方便。\n\nfun main() {\n//sampleStart\n    val colors = listOf(\"Blue\", \"green\", \"ORANGE\", \"Red\", \"yellow\")\n    println(colors.binarySearch(\"RED\", String.CASE_INSENSITIVE_ORDER)) // 3\n//sampleEnd\n}\n\n使用 比较 函数的二分搜索无需提供明确的搜索值即可查找元素。 取而代之的是，它使用一个比较函数将元素映射到 Int 值，并搜索函数返回 0 的元素。 该列表必须根据提供的函数以升序排序；换句话说，比较的返回值必须从一个列表元素增长到下一个列表元素。\n\nimport kotlin.math.sign\n//sampleStart\ndata class Product(val name: String, val price: Double)\n\nfun priceComparison(product: Product, price: Double) = sign(product.price - price).toInt()\n\nfun main() {\n    val productList = listOf(\n        Product(\"WebStorm\", 49.0),\n        Product(\"AppCode\", 99.0),\n        Product(\"DotTrace\", 129.0),\n        Product(\"ReSharper\", 149.0))\n\n    println(productList.binarySearch { priceComparison(it, 99.0) })\n}\n//sampleEnd\nComparator 与比较函数二分搜索都可以针对列表区间执行。\n\n除了集合写操作中描述的集合修改操作之外，可变列表还支持特定的写操作。 这些操作使用索引来访问元素以扩展列表修改功能。\n\n要将元素添加到列表中的特定位置，请使用 add() 或 addAll() 并提供元素插入的位置作为附加参数。 位置之后的所有元素都将向右移动。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"five\", \"six\")\n    numbers.add(1, \"two\")\n    numbers.addAll(2, listOf(\"three\", \"four\"))\n    println(numbers)\n//sampleEnd\n}\n\n列表还提供了在指定位置替换元素的函数——set() 及其操作符形式 []。set() 不会更改其他元素的索引。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"five\", \"three\")\n    numbers[1] =  \"two\"\n    println(numbers)\n//sampleEnd\n}\n\nfill() 简单地将所有集合元素的值替换为指定值。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4)\n    numbers.fill(3)\n    println(numbers)\n//sampleEnd\n}\n\n要从列表中删除指定位置的元素，请使用 removeAt() 函数，并将位置作为参数。 在元素被删除之后出现的所有元素索引将减 1。\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(1, 2, 3, 4, 3)    \n    numbers.removeAt(1)\n    println(numbers)\n//sampleEnd\n}\n\n在集合排序中，描述了按特定顺序检索集合元素的操作。 对于可变列表，标准库中提供了类似的扩展函数，这些扩展函数可以执行相同的排序操作。 将此类操作应用于列表实例时，它将更改指定实例中元素的顺序。\n\n就地排序函数的名称与应用于只读列表的函数的名称相似，但没有 ed/d 后缀：\n\nsort* 在所有排序函数的名称中代替 sorted*：sort()、sortDescending()、sortBy() 等等。\nshuffle() 代替 shuffled()。\nreverse() 代替 reversed()。\nasReversed() 在可变列表上调用会返回另一个可变列表，该列表是原始列表的反向视图。在该视图中的更改将反映在原始列表中。 以下示例展示了可变列表的排序函数：\n\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n\n    numbers.sort()\n    println(\"Sort into ascending: $numbers\")\n    numbers.sortDescending()\n    println(\"Sort into descending: $numbers\")\n\n    numbers.sortBy { it.length }\n    println(\"Sort into ascending by length: $numbers\")\n    numbers.sortByDescending { it.last() }\n    println(\"Sort into descending by the last letter: $numbers\")\n    \n    numbers.sortWith(compareBy<String> { it.length }.thenBy { it })\n    println(\"Sort by Comparator: $numbers\")\n\n    numbers.shuffle()\n    println(\"Shuffle: $numbers\")\n\n    numbers.reverse()\n    println(\"Reverse: $numbers\")\n//sampleEnd\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382137280},"updatedAt":{"$$date":1597386008841},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"igIKQKqIyydPXSfk"}
{"name":"kotlin-Set 相关操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382138364},"updatedAt":{"$$date":1597386013058},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"rpPIdpzRu5HAzx0g"}
{"name":"kotlin-Set 相关操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/set-operations.html\nSet 相关操作 - Kotlin 语言中文站\n3-4 minutes\n改进翻译\nKotlin 集合包中包含 set 常用操作的扩展函数：查找交集、并集或差集。\n\n要将两个集合合并为一个（并集），可使用 union() 函数。也能以中缀形式使用 a union b。 注意，对于有序集合，操作数的顺序很重要：在结果集合中，左侧操作数在前。\n\n要查找两个集合中都存在的元素（交集），请使用 intersect() 。 要查找另一个集合中不存在的集合元素（差集），请使用 subtract() 。 这两个函数也能以中缀形式调用，例如， a intersect b 。\n\nfun main() {\n//sampleStart\n    val numbers = setOf(\"one\", \"two\", \"three\")\n\n    println(numbers union setOf(\"four\", \"five\"))\n    println(setOf(\"four\", \"five\") union numbers)\n\n    println(numbers intersect setOf(\"two\", \"one\"))\n    println(numbers subtract setOf(\"three\", \"four\"))\n    println(numbers subtract setOf(\"four\", \"three\")) // 相同的输出\n//sampleEnd\n}\n注意， List 也支持 Set 操作。 但是，对 List 进行 Set 操作的结果仍然是 Set ，因此将删除所有重复的元素。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382138364},"updatedAt":{"$$date":1597386028019},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"rpPIdpzRu5HAzx0g"}
{"name":"kotlin-Map 相关操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382139474},"updatedAt":{"$$date":1597386031486},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Yjach19u2aDqDEVt"}
{"name":"kotlin-Map 相关操作 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/map-operations.html\nMap 相关操作 - Kotlin 语言中文站\n18-22 minutes\n改进翻译\n在 map 中，键和值的类型都是用户定义的。 对基于键的访问启用了各种特定于 map 的处理函数，从键获取值到对键和值进行单独过滤。 在此页面上，我们提供了来自标准库的 map 处理功能的描述。\n\n要从 Map 中检索值，必须提供其键作为 get() 函数的参数。 还支持简写 [key] 语法。 如果找不到给定的键，则返回 null 。 还有一个函数 getValue() ，它的行为略有不同：如果在 Map 中找不到键，则抛出异常。 此外，还有两个选项可以解决键缺失的问题：\n\ngetOrElse() 与 list 的工作方式相同：对于不存在的键，其值由给定的 lambda 表达式返回。\ngetOrDefault() 如果找不到键，则返回指定的默认值。\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.get(\"one\"))\n    println(numbersMap[\"one\"])\n    println(numbersMap.getOrDefault(\"four\", 10))\n    println(numbersMap[\"five\"])               // null\n    //numbersMap.getValue(\"six\")      // exception!\n//sampleEnd\n}\n\n要对 map 的所有键或所有值执行操作，可以从属性 keys 和 values 中相应地检索它们。 keys 是 Map 中所有键的集合， values 是 Map 中所有值的集合。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap.keys)\n    println(numbersMap.values)\n//sampleEnd\n}\n\n可以使用 filter() 函数来过滤 map 或其他集合。 对 map 使用 filter() 函数时， Pair 将作为参数的谓词传递给它。 它将使用谓词同时过滤其中的键和值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\n    println(filteredMap)\n//sampleEnd\n}\n\n还有两种用于过滤 map 的特定函数：按键或按值。 这两种方式，都有对应的函数： filterKeys() 和 filterValues() 。 两者都将返回一个新 Map ，其中包含与给定谓词相匹配的条目。 filterKeys() 的谓词仅检查元素键， filterValues() 的谓词仅检查值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\n    val filteredKeysMap = numbersMap.filterKeys { it.endsWith(\"1\") }\n    val filteredValuesMap = numbersMap.filterValues { it < 10 }\n\n    println(filteredKeysMap)\n    println(filteredValuesMap)\n//sampleEnd\n}\n\n由于需要访问元素的键，plus（+）与 minus（-）运算符对 map 的作用与其他集合不同。 plus 返回包含两个操作数元素的 Map ：左侧的 Map 与右侧的 Pair 或另一个 Map 。 当右侧操作数中有左侧 Map 中已存在的键时，该条目将使用右侧的值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap + Pair(\"four\", 4))\n    println(numbersMap + Pair(\"one\", 10))\n    println(numbersMap + mapOf(\"five\" to 5, \"one\" to 11))\n//sampleEnd\n}\n\nminus 将根据左侧 Map 条目创建一个新 Map ，右侧操作数带有键的条目将被剔除。 因此，右侧操作数可以是单个键或键的集合： list 、 set 等。\n\nfun main() {\n//sampleStart\n    val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    println(numbersMap - \"one\")\n    println(numbersMap - listOf(\"two\", \"four\"))\n//sampleEnd\n}\n\n关于在可变 Map 中使用 plusAssign（+=）与 minusAssign（-=）运算符的详细信息，请参见 Map 写操作 。\n\nMutable Map （可变 Map ）提供特定的 Map 写操作。 这些操作使你可以使用键来访问或更改 Map 值。\n\nMap 写操作的一些规则：\n\n值可以更新。 反过来，键也永远不会改变：添加条目后，键是不变的。\n每个键都有一个与之关联的值。也可以添加和删除整个条目。\n下面是对可变 Map 中可用写操作的标准库函数的描述。\n\n要将新的键值对添加到可变 Map ，请使用 put() 。 将新条目放入 LinkedHashMap （Map的默认实现）后，会添加该条目，以便在 Map 迭代时排在最后。 在 Map 类中，新元素的位置由其键顺序定义。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap.put(\"three\", 3)\n    println(numbersMap)\n//sampleEnd\n}\n\n要一次添加多个条目，请使用 putAll() 。它的参数可以是 Map 或一组 Pair ： Iterable 、 Sequence 或 Array 。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.putAll(setOf(\"four\" to 4, \"five\" to 5))\n    println(numbersMap)\n//sampleEnd\n}\n\n如果给定键已存在于 Map 中，则 put() 与 putAll() 都将覆盖值。 因此，可以使用它们来更新 Map 条目的值。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    val previousValue = numbersMap.put(\"one\", 11)\n    println(\"value associated with 'one', before: $previousValue, after: ${numbersMap[\"one\"]}\")\n    println(numbersMap)\n//sampleEnd\n}\n\n还可以使用快速操作符将新条目添加到 Map 。 有两种方式：\n\nplusAssign （+=） 操作符。\n[] 操作符为 put() 的别名。\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\n    numbersMap[\"three\"] = 3     // 调用 numbersMap.put(\"three\", 3)\n    numbersMap += mapOf(\"four\" to 4, \"five\" to 5)\n    println(numbersMap)\n//sampleEnd\n}\n\n使用 Map 中存在的键进行操作时，将覆盖相应条目的值。\n\n要从可变 Map 中删除条目，请使用 remove() 函数。 调用 remove() 时，可以传递键或整个键值对。 如果同时指定键和值，则仅当键值都匹配时，才会删除此的元素。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap.remove(\"one\")\n    println(numbersMap)\n    numbersMap.remove(\"three\", 4)            //不会删除任何条目\n    println(numbersMap)\n//sampleEnd\n}\n\n还可以通过键或值从可变 Map 中删除条目。 在 Map 的 .keys 或 .values 中调用 remove() 并提供键或值来删除条目。 在 .values 中调用时， remove() 仅删除给定值匹配到的的第一个条目。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"threeAgain\" to 3)\n    numbersMap.keys.remove(\"one\")\n    println(numbersMap)\n    numbersMap.values.remove(3)\n    println(numbersMap)\n//sampleEnd\n}\n\nminusAssign （-=） 操作符也可用于可变 Map 。\n\nfun main() {\n//sampleStart\n    val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\n    numbersMap -= \"two\"\n    println(numbersMap)\n    numbersMap -= \"five\"             //不会删除任何条目\n    println(numbersMap)\n//sampleEnd\n}\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382139474},"updatedAt":{"$$date":1597386351907},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Yjach19u2aDqDEVt"}
{"name":"kotlin-基础 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382140847},"updatedAt":{"$$date":1597386552951},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9zC8KjRNRbTjr529"}
{"name":"kotlin-基础 - Kotlin 语言中文站","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\nwww.kotlincn.net /docs/reference/coroutines/basics.html\n基础 - Kotlin 语言中文站\n19-24 minutes\n改进翻译\n目录\n\n协程基础\n第一个协程程序\n桥接阻塞与非阻塞的世界\n等待一个作业\n结构化的并发\n作用域构建器\n提取函数重构\n协程很轻量\n全局协程像守护线程\n这一部分包括基础的协程概念。\n\n运行以下代码：\n\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // 在后台启动一个新的协程并继续\n        delay(1000L) // 非阻塞的等待 1 秒钟（默认时间单位是毫秒）\n        println(\"World!\") // 在延迟后打印输出\n    }\n    println(\"Hello,\") // 协程已在等待时主线程还在继续\n    Thread.sleep(2000L) // 阻塞主线程 2 秒钟来保证 JVM 存活\n}\n可以在这里获取完整代码。\n\n代码运行的结果：\n\nHello,\nWorld!\n本质上，协程是轻量级的线程。 它们在某些 CoroutineScope 上下文中与 launch 协程构建器 一起启动。 这里我们在 GlobalScope 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制。\n\n可以将 GlobalScope.launch { …… } 替换为 thread { …… }，并将 delay(……) 替换为 Thread.sleep(……) 达到同样目的。 试试看（不要忘记导入 kotlin.concurrent.thread）。\n\n如果你首先将 GlobalScope.launch 替换为 thread，编译器会报以下错误：\n\nError: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function\n这是因为 delay 是一个特殊的 挂起函数 ，它不会造成线程阻塞，但是会 挂起 协程，并且只能在协程中使用。\n\n第一个示例在同一段代码中混用了 非阻塞的 delay(……) 与 阻塞的 Thread.sleep(……)。 这容易让我们记混哪个是阻塞的、哪个是非阻塞的。 让我们显式使用 runBlocking 协程构建器来阻塞：\n\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // 在后台启动一个新的协程并继续\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // 主线程中的代码会立即执行\n    runBlocking {     // 但是这个表达式阻塞了主线程\n        delay(2000L)  // ……我们延迟 2 秒来保证 JVM 的存活\n    } \n}\n可以在这里获取完整代码。\n\n结果是相似的，但是这些代码只使用了非阻塞的函数 delay。 调用了 runBlocking 的主线程会一直 阻塞 直到 runBlocking 内部的协程执行完毕。\n\n这个示例可以使用更合乎惯用法的方式重写，使用 runBlocking 来包装 main 函数的执行：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // 开始执行主协程\n    GlobalScope.launch { // 在后台启动一个新的协程并继续\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // 主协程在这里会立即执行\n    delay(2000L)      // 延迟 2 秒来保证 JVM 存活\n}\n可以在这里获取完整代码。\n\n这里的 runBlocking<Unit> { …… } 作为用来启动顶层主协程的适配器。 我们显式指定了其返回类型 Unit，因为在 Kotlin 中 main 函数必须返回 Unit 类型。\n\n这也是为挂起函数编写单元测试的一种方式：\n\nclass MyTest {\n    @Test\n    fun testMySuspendingFunction() = runBlocking<Unit> {\n        // 这里我们可以使用任何喜欢的断言风格来使用挂起函数\n    }\n}\n延迟一段时间来等待另一个协程运行并不是一个好的选择。让我们显式（以非阻塞方式）等待所启动的后台 Job 执行结束：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    val job = GlobalScope.launch { // 启动一个新协程并保持对这个作业的引用\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    job.join() // 等待直到子协程执行结束\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n现在，结果仍然相同，但是主协程与后台作业的持续时间没有任何关系了。好多了。\n\n协程的实际使用还有一些需要改进的地方。 当我们使用 GlobalScope.launch 时，我们会创建一个顶层协程。虽然它很轻量，但它运行时仍会消耗一些内存资源。如果我们忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样（例如，我们错误地延迟了太长时间），如果我们启动了太多的协程并导致内存不足会怎么样？ 必须手动保持对所有已启动协程的引用并 join 之很容易出错。\n\n有一个更好的解决办法。我们可以在代码中使用结构化并发。 我们可以在执行操作所在的指定作用域内启动协程， 而不是像通常使用线程（线程总是全局的）那样在 GlobalScope 中启动。\n\n在我们的示例中，我们使用 runBlocking 协程构建器将 main 函数转换为协程。 包括 runBlocking 在内的每个协程构建器都将 CoroutineScope 的实例添加到其代码块所在的作用域中。 我们可以在这个作用域中启动协程而无需显式 join 之，因为外部协程（示例中的 runBlocking）直到在其作用域中启动的所有协程都执行完毕后才会结束。因此，可以将我们的示例简化为：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { // 在 runBlocking 作用域中启动一个新协程\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n}\n可以在这里获取完整代码。\n\n除了由不同的构建器提供协程作用域之外，还可以使用 coroutineScope 构建器声明自己的作用域。它会创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束。\n\nrunBlocking 与 coroutineScope 可能看起来很类似，因为它们都会等待其协程体以及所有子协程结束。 主要区别在于，runBlocking 方法会阻塞当前线程来等待， 而 coroutineScope 只是挂起，会释放底层线程用于其他用途。 由于存在这点差异，runBlocking 是常规函数，而 coroutineScope 是挂起函数。\n\n可以通过以下示例来演示：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking { // this: CoroutineScope\n    launch { \n        delay(200L)\n        println(\"Task from runBlocking\")\n    }\n    \n    coroutineScope { // 创建一个协程作用域\n        launch {\n            delay(500L) \n            println(\"Task from nested launch\")\n        }\n    \n        delay(100L)\n        println(\"Task from coroutine scope\") // 这一行会在内嵌 launch 之前输出\n    }\n    \n    println(\"Coroutine scope is over\") // 这一行在内嵌 launch 执行完毕后才输出\n}\n可以在这里获取完整代码。\n\n请注意，（当等待内嵌 launch 时）紧挨“Task from coroutine scope”消息之后， 就会执行并输出“Task from runBlocking”——尽管 coroutineScope 尚未结束。\n\n我们来将 launch { …… } 内部的代码块提取到独立的函数中。当你对这段代码执行“提取函数”重构时，你会得到一个带有 suspend 修饰符的新函数。 这是你的第一个挂起函数。在协程内部可以像普通函数一样使用挂起函数， 不过其额外特性是，同样可以使用其他挂起函数（如本例中的 delay）来挂起协程的执行。\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    launch { doWorld() }\n    println(\"Hello,\")\n}\n\n// 这是你的第一个挂起函数\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"World!\")\n}\n可以在这里获取完整代码。\n\n但是如果提取出的函数包含一个在当前作用域中调用的协程构建器的话，该怎么办？ 在这种情况下，所提取函数上只有 suspend 修饰符是不够的。为 CoroutineScope 写一个 doWorld 扩展方法是其中一种解决方案，但这可能并非总是适用，因为它并没有使 API 更加清晰。 惯用的解决方案是要么显式将 CoroutineScope 作为包含该函数的类的一个字段， 要么当外部类实现了 CoroutineScope 时隐式取得。 作为最后的手段，可以使用 CoroutineScope(coroutineContext)，不过这种方法结构上不安全， 因为你不能再控制该方法执行的作用域。只有私有 API 才能使用这个构建器。\n\n运行以下代码：\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    repeat(100_000) { // 启动大量的协程\n        launch {\n            delay(5000L)\n            print(\".\")\n        }\n    }\n}\n可以在这里获取完整代码。\n\n它启动了 10 万个协程，并且在 5 秒钟后，每个协程都输出一个点。\n\n现在，尝试使用线程来实现。会发生什么？（很可能你的代码会产生某种内存不足的错误）\n\n以下代码在 GlobalScope 中启动了一个长期运行的协程，该协程每秒输出“I'm sleeping”两次，之后在主函数中延迟一段时间后返回。\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n//sampleStart\n    GlobalScope.launch {\n        repeat(1000) { i ->\n            println(\"I'm sleeping $i ...\")\n            delay(500L)\n        }\n    }\n    delay(1300L) // 在延迟后退出\n//sampleEnd\n}\n可以在这里获取完整代码。\n\n你可以运行这个程序并看到它输出了以下三行后终止：\n\nI'm sleeping 0 ...\nI'm sleeping 1 ...\nI'm sleeping 2 ...\n在 GlobalScope 中启动的活动协程并不会使进程保活。它们就像守护线程。"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597382140847},"updatedAt":{"$$date":1597386554165},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"9zC8KjRNRbTjr529"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386561179},"updatedAt":{"$$date":1597386561179},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"odJnFbbCvjFJc8DS"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386565710},"updatedAt":{"$$date":1597386565710},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"OSsh3kvshTbEPD4N"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386566872},"updatedAt":{"$$date":1597386566872},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"y6VOxodbzwTS0M3G"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386568106},"updatedAt":{"$$date":1597386568106},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"g3O79pwZYOgLfoso"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386569165},"updatedAt":{"$$date":1597386569165},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"yGyKHm3oOK7Nzi0j"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386570255},"updatedAt":{"$$date":1597386570255},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"aiNfT1TMoDowHJyL"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":true,"createdAt":{"$$date":1597386565710},"updatedAt":{"$$date":1597386565710},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"OSsh3kvshTbEPD4N"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386572806},"updatedAt":{"$$date":1597386572806},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0LJsCj3dSGGPzqxZ"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386573893},"updatedAt":{"$$date":1597386573893},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"eb9g4bcCzLv56HFI"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386574905},"updatedAt":{"$$date":1597386574905},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"777IdC3ljwasjxGS"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386576954},"updatedAt":{"$$date":1597386576954},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"fvXEjHZ3wLg5qKRv"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386578104},"updatedAt":{"$$date":1597386578104},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"wqmc0l3faAlmCmKe"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386579211},"updatedAt":{"$$date":1597386579211},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"uom79z59VxzEZtkS"}
{"name":"kotlin-","folderId":"IcRu3rfX8","content":[{"label":"Fragment 1","language":"kotlin","value":"\n\n\n"}],"tags":[],"isFavorites":true,"isDeleted":false,"createdAt":{"$$date":1597386580281},"updatedAt":{"$$date":1597386580281},"folder":{"id":"IcRu3rfX8","name":"kotlin","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"ceb6CSKV01UMQlkq"}
